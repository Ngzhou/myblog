{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hueman/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hueman/source/images/qidai.png","path":"images/qidai.png","modified":0,"renderable":1},{"_id":"themes/hueman/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/css/images/opacity-10.png","path":"css/images/opacity-10.png","modified":0,"renderable":1},{"_id":"themes/hueman/source/css/images/s-left.png","path":"css/images/s-left.png","modified":0,"renderable":1},{"_id":"themes/hueman/source/css/images/logo-header.png","path":"css/images/logo-header.png","modified":0,"renderable":1},{"_id":"themes/hueman/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":0,"renderable":1},{"_id":"themes/hueman/source/css/images/thumb-default.png","path":"css/images/thumb-default.png","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/justified-gallery/jquery.justifiedGallery.min.js","path":"libs/justified-gallery/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/justified-gallery/justifiedGallery.min.css","path":"libs/justified-gallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/styles.css","path":"libs/titillium-web/styles.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/source-code-pro/styles.css","path":"libs/source-code-pro/styles.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/css/font-awesome.css","path":"libs/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/css/font-awesome.min.css","path":"libs/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/img/loading.gif","path":"libs/lightgallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/img/vimeo-play.png","path":"libs/lightgallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/img/video-play.png","path":"libs/lightgallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/img/youtube-play.png","path":"libs/lightgallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.css","path":"libs/lightgallery/css/lg-fb-comment-box.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.css.map","path":"libs/lightgallery/css/lg-fb-comment-box.css.map","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.min.css","path":"libs/lightgallery/css/lg-fb-comment-box.min.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.css","path":"libs/lightgallery/css/lg-transitions.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.css.map","path":"libs/lightgallery/css/lg-transitions.css.map","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.css","path":"libs/lightgallery/css/lightgallery.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.min.css","path":"libs/lightgallery/css/lg-transitions.min.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.css.map","path":"libs/lightgallery/css/lightgallery.css.map","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.min.css","path":"libs/lightgallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.svg","path":"libs/lightgallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.ttf","path":"libs/lightgallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.woff","path":"libs/lightgallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-autoplay.js","path":"libs/lightgallery/js/lg-autoplay.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-autoplay.min.js","path":"libs/lightgallery/js/lg-autoplay.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-fullscreen.js","path":"libs/lightgallery/js/lg-fullscreen.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-fullscreen.min.js","path":"libs/lightgallery/js/lg-fullscreen.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-hash.js","path":"libs/lightgallery/js/lg-hash.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.eot","path":"libs/lightgallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-pager.js","path":"libs/lightgallery/js/lg-pager.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-pager.min.js","path":"libs/lightgallery/js/lg-pager.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-hash.min.js","path":"libs/lightgallery/js/lg-hash.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-share.js","path":"libs/lightgallery/js/lg-share.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-share.min.js","path":"libs/lightgallery/js/lg-share.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-thumbnail.js","path":"libs/lightgallery/js/lg-thumbnail.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-thumbnail.min.js","path":"libs/lightgallery/js/lg-thumbnail.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-video.js","path":"libs/lightgallery/js/lg-video.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-video.min.js","path":"libs/lightgallery/js/lg-video.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-zoom.js","path":"libs/lightgallery/js/lg-zoom.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-zoom.min.js","path":"libs/lightgallery/js/lg-zoom.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcSo_WB_cotcEMUw1LsIE8mM.woff2","path":"libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcSo_WB_cotcEMUw1LsIE8mM.woff2","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcZSnX671uNZIV63UdXh3Mg0.woff2","path":"libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcZSnX671uNZIV63UdXh3Mg0.woff2","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lightgallery.js","path":"libs/lightgallery/js/lightgallery.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/lightgallery/js/lightgallery.min.js","path":"libs/lightgallery/js/lightgallery.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr4-67659ICLY8bMrYhtePPA.woff2","path":"libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr4-67659ICLY8bMrYhtePPA.woff2","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr46gJz9aNFrmnwBdd69aqzY.woff2","path":"libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr46gJz9aNFrmnwBdd69aqzY.woff2","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr9INifKjd1RJ3NxxEi9Cy2w.woff2","path":"libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr9INifKjd1RJ3NxxEi9Cy2w.woff2","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr_SNRT0fZ5CX-AqRkMYgJJo.woff2","path":"libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr_SNRT0fZ5CX-AqRkMYgJJo.woff2","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.eot","path":"libs/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/FontAwesome.otf","path":"libs/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","path":"libs/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.woff","path":"libs/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/jquery/3.3.1/jquery.min.js","path":"libs/jquery/3.3.1/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","path":"libs/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.svg","path":"libs/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"10f23fc44d9a04d72f0f4835bd75bbafe4ec48e2","modified":1591760155919},{"_id":"themes/hueman/LICENSE","hash":"3975b7883caeb33f61fada7c0ef4add7ab189849","modified":1561702756514},{"_id":"themes/hueman/README.md","hash":"defb1f667677e1fd13b3a4799a6c70eae621f796","modified":1561702756514},{"_id":"themes/hueman/_config.yml","hash":"f71b48faa0416f4686b96f56c5e58e37e596d7be","modified":1561702756514},{"_id":"themes/hueman/package.json","hash":"363dccd465022c6a692cd3fb212d0d9a4ed4b7e0","modified":1561702756527},{"_id":"source/_posts/.DS_Store","hash":"a8b67e9b408a7a5617dd079eb098e9e2ca8d63d6","modified":1566537017692},{"_id":"source/_posts/2019-06-11-hexo-course-1.md","hash":"6028faa060a19fa05193f2f878ec2c5b691897ff","modified":1591768927413},{"_id":"source/_posts/2019-06-20-activiti-flow.md","hash":"aa11ba991f90c380c57fa56116929e17df52fa15","modified":1591768925625},{"_id":"source/_posts/2019-06-20-基于svg的流程图展示实现.md","hash":"8d4808201011a3af41fa1e171114ae2eb238cdf4","modified":1591768922483},{"_id":"source/_posts/2019-06-20-asterisk-share.md","hash":"204b1a3f878daadd5397f9053d9999232ac5d734","modified":1591768923477},{"_id":"source/_posts/2019-06-26-pdm系统框架介绍及开发总结.md","hash":"45fbce44f9d593572467b67733984c454207ef04","modified":1561702756513},{"_id":"source/_posts/2019-06-25-markdown-introduction.md","hash":"02f6955cc85e16155ded64756092de768a296b21","modified":1591768921527},{"_id":"source/_posts/2019-06-28-pdm系统开发遇到的相关问题.md","hash":"f608207cc385ba1003c6b38605f2e506bb65fa06","modified":1591768918795},{"_id":"source/_posts/2019-06-28-csstrick.md","hash":"92228f90684afe27b8ebc765409dfeacd6b31b56","modified":1591768919713},{"_id":"source/about/index.md","hash":"9aa34bd89f4680691f120ade96e50b2646374383","modified":1586341102006},{"_id":"themes/hueman/layout/archive.ejs","hash":"8785477232088e09a75da88a0cdcb32fedf4f81f","modified":1561702756517},{"_id":"themes/hueman/layout/author.ejs","hash":"5096d3f019098d9940429152295f6d6161d887ba","modified":1561702756518},{"_id":"themes/hueman/layout/category.ejs","hash":"5096d3f019098d9940429152295f6d6161d887ba","modified":1561702756518},{"_id":"themes/hueman/layout/index.ejs","hash":"8785477232088e09a75da88a0cdcb32fedf4f81f","modified":1561702756522},{"_id":"themes/hueman/layout/layout.ejs","hash":"35fd7fe6d4e2d313246a0a31446a597714facdea","modified":1561702756522},{"_id":"themes/hueman/layout/page.ejs","hash":"5afddd6a45fa72beacec8d760487dfe8a667e622","modified":1561702756523},{"_id":"themes/hueman/layout/post.ejs","hash":"5afddd6a45fa72beacec8d760487dfe8a667e622","modified":1561702756523},{"_id":"themes/hueman/layout/tag.ejs","hash":"8785477232088e09a75da88a0cdcb32fedf4f81f","modified":1561702756525},{"_id":"themes/hueman/languages/ca.yml","hash":"d082e6f9e7615556b8f6c5f1286f0db8a0db195e","modified":1561702756515},{"_id":"themes/hueman/languages/en.yml","hash":"f903e8e52c75f8bcbb654977c6f8538ad47a9d8f","modified":1561702756515},{"_id":"themes/hueman/languages/es.yml","hash":"97191c8ab7ce5334369d96f6e53a6d365a2057b1","modified":1561702756515},{"_id":"themes/hueman/languages/fr.yml","hash":"5c19a745b42b11b062cfbc4dcefd4847a0156bdc","modified":1561702756515},{"_id":"themes/hueman/languages/hu.yml","hash":"5dd987ad5f33748bcba1d9a7eb78c1800b7c8bed","modified":1561702756515},{"_id":"themes/hueman/languages/id.yml","hash":"03e45cf88b69e657a340362e18668e443ddaae47","modified":1561702756516},{"_id":"themes/hueman/languages/ja.yml","hash":"56f3af0bf5cc56f9f7bf24fe5cb881a6a1b34e7b","modified":1561702756516},{"_id":"themes/hueman/languages/ko.yml","hash":"81ea44ecda87a4398bb6d88a3b02f6b73c9a1637","modified":1561702756516},{"_id":"themes/hueman/languages/pt-BR.yml","hash":"6f9539673e08d66866bb210b78863ef68023f991","modified":1561702756516},{"_id":"themes/hueman/languages/tr.yml","hash":"003cb50200eba865d57e5c53925636f1a5ec0a70","modified":1561702756517},{"_id":"themes/hueman/languages/ru.yml","hash":"99f111b39f867d421ff4cb859dd1deb26caa382e","modified":1561702756516},{"_id":"themes/hueman/languages/vi.yml","hash":"edeb4492a08af458fe958dc4d48101c96750b159","modified":1561702756517},{"_id":"themes/hueman/scripts/excerpt.js","hash":"630f17f2647b2ba5b207dba36fb3c6587a3aa04f","modified":1561702756527},{"_id":"themes/hueman/scripts/md5.js","hash":"7712232a328daf1797a3dd313bfce124f7df67ff","modified":1561702756527},{"_id":"themes/hueman/scripts/meta.js","hash":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1561702756527},{"_id":"themes/hueman/languages/zh-CN.yml","hash":"cd4f34f66618c48d761db519bf7506d223113cdf","modified":1561702756517},{"_id":"themes/hueman/languages/zh-TW.yml","hash":"fd9cc3ab5e00cc2cd650b9871f694769a8068f4a","modified":1561702756517},{"_id":"themes/hueman/scripts/thumbnail.js","hash":"e78b1b978fa1acad5409afc685d13f669e80b24f","modified":1561702756527},{"_id":"themes/hueman/layout/comment/changyan.ejs","hash":"4dbfefe8c9ed9b824a6bc4952d2a0a72e9166b61","modified":1561702756518},{"_id":"themes/hueman/layout/comment/counter.ejs","hash":"237fe2f89c128fe4f7c1edb9187f504f42cb5e74","modified":1561702756518},{"_id":"themes/hueman/layout/comment/disqus.ejs","hash":"83158f5b00f95acf847524fd7ffeb5aab25add78","modified":1561702756518},{"_id":"themes/hueman/layout/comment/duoshuo.ejs","hash":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1561702756518},{"_id":"themes/hueman/layout/comment/gitalk.ejs","hash":"915124de9806cf92bbe1af1b77e6580d0eaa8ac3","modified":1561702756519},{"_id":"themes/hueman/layout/comment/facebook.ejs","hash":"5ee16430a4435c2fead0275ff83fc98092d73d4c","modified":1561702756518},{"_id":"themes/hueman/layout/comment/index.ejs","hash":"058f7dc27f700d083841e3d7a251e57ccbc4706e","modified":1561702756519},{"_id":"themes/hueman/layout/comment/isso.ejs","hash":"c196dbd522a3969d75ce5e61bc7ce7cec52d462f","modified":1561702756519},{"_id":"themes/hueman/layout/comment/livere.ejs","hash":"792e4f0e93b2bdc5abd85d447d804a5c608a9c5c","modified":1561702756519},{"_id":"themes/hueman/layout/comment/scripts.ejs","hash":"48212bc99b046a67a1027024efecda8c79eb7fa9","modified":1561702756519},{"_id":"themes/hueman/layout/comment/valine.ejs","hash":"8db3c09f00e496ff5eb0d104c865770924e2a0d0","modified":1561702756519},{"_id":"themes/hueman/layout/comment/youyan.ejs","hash":"ef6c37f535d4897679823143ce37c25d556cd729","modified":1561702756519},{"_id":"themes/hueman/layout/common/archive.ejs","hash":"bf909e4d6798374daf114cf41540f2bd300408d9","modified":1561702756520},{"_id":"themes/hueman/layout/common/article.ejs","hash":"c9121df26b0140f7e00ae7a5292d62845d2ce077","modified":1561702756520},{"_id":"themes/hueman/layout/common/footer.ejs","hash":"8ce0499440874599fc03ebf6fd4b025e7762fb00","modified":1586341326940},{"_id":"themes/hueman/layout/common/content-title.ejs","hash":"4e1a92448207b8e3d1695df855f6be7c70576248","modified":1561702756520},{"_id":"themes/hueman/layout/common/head.ejs","hash":"2af341e500d562531de1c833b699378eb31ed67b","modified":1561702756520},{"_id":"themes/hueman/layout/common/header.ejs","hash":"6ee79d3dd2749d2881d45d4d568ea5fa3a4032ae","modified":1586341345310},{"_id":"themes/hueman/layout/common/scripts.ejs","hash":"db677ab336d31292bffc071b2115e25e9c6f198d","modified":1561702756522},{"_id":"themes/hueman/layout/common/summary.ejs","hash":"0a76e4541529009ac91e4ed28a57ef63e9e1a4c6","modified":1561702756522},{"_id":"themes/hueman/layout/common/thumbnail.ejs","hash":"c5fba5d5287f49e02040c530cd92312b2221a2c1","modified":1561702756522},{"_id":"themes/hueman/layout/common/sidebar.ejs","hash":"f582cd96ce6fa3b0340a1642695fec1632391e25","modified":1561702756522},{"_id":"themes/hueman/layout/plugin/baidu-analytics.ejs","hash":"d99089976258050666208f29000f84496fe1029c","modified":1561702756523},{"_id":"themes/hueman/layout/plugin/google-analytics.ejs","hash":"9ae10a0ff00a5bfe2bb6ad2ce2f882ae9074ad2b","modified":1561702756523},{"_id":"themes/hueman/layout/plugin/scripts.ejs","hash":"b8ec9a495f87567ddae9573d6188e1e73890da5a","modified":1561702756523},{"_id":"themes/hueman/layout/plugin/statcounter.ejs","hash":"7773a7ef15dbaf4ead2485eb7e5c394d20789438","modified":1561702756523},{"_id":"themes/hueman/layout/pwa/index.ejs","hash":"7a8856b91c3cca416af662da53caf7e9cf8a877f","modified":1561702756524},{"_id":"themes/hueman/layout/search/baidu.ejs","hash":"bcffa60f2d1750ac7499e928f538176e3804393b","modified":1561702756524},{"_id":"themes/hueman/layout/search/index.ejs","hash":"1a6a742727018567f60f8815be0bff5a45294ce5","modified":1561702756524},{"_id":"themes/hueman/layout/search/insight.ejs","hash":"130fe3d33ac71da0b50f7fee6a87979f30938a1b","modified":1561702756524},{"_id":"themes/hueman/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1561702756524},{"_id":"themes/hueman/layout/share/addtoany.ejs","hash":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1561702756524},{"_id":"themes/hueman/layout/share/bdshare.ejs","hash":"5fd8c82a40d957e9481540a0b7d3ffca874e14a7","modified":1561702756525},{"_id":"themes/hueman/layout/share/default.ejs","hash":"7492f5b375a56c67a1a1a4f6b893e37f49dc86dc","modified":1561702756525},{"_id":"themes/hueman/layout/share/index.ejs","hash":"029e91aace5a4c0d8387fc7744c477ccc6865c30","modified":1561702756525},{"_id":"themes/hueman/layout/share/jiathis.ejs","hash":"b80332a1e0c8d230fabcf5e696edae349925ae17","modified":1561702756525},{"_id":"themes/hueman/layout/widget/archive.ejs","hash":"c4d303eaaa23768e52ead324c422a8900b1fe448","modified":1561702756525},{"_id":"themes/hueman/layout/widget/catalog.ejs","hash":"b95f91c7b3b26236ea675482b173b29fecf3e7f4","modified":1561702756526},{"_id":"themes/hueman/layout/widget/category.ejs","hash":"2d705df76f2eef7d695a971266fc104e89ca6bcd","modified":1561702756526},{"_id":"themes/hueman/layout/widget/links.ejs","hash":"97dab84d6336a4c926ddc288d5a6c264f54c50c3","modified":1561702756526},{"_id":"themes/hueman/layout/widget/recent_posts.ejs","hash":"16a2bd28bdf520616202670a18c6cc93d1dd3f54","modified":1561702756526},{"_id":"themes/hueman/layout/widget/sticky_posts.ejs","hash":"6bad4126bed652f5f9e93027cbe3ee03b67b034a","modified":1561702756526},{"_id":"themes/hueman/layout/widget/tag.ejs","hash":"bfbc63e675439dcdc35e07dce6948e41500b649c","modified":1561702756526},{"_id":"themes/hueman/layout/widget/tagcloud.ejs","hash":"3ecb048d6098bc3953043a4c25f1f7c4b23397cf","modified":1561702756526},{"_id":"themes/hueman/source/css/_extend.styl","hash":"c2160499dc89c524ff17cd2e3fcbb8df83ebca1a","modified":1561702756527},{"_id":"themes/hueman/source/css/_responsive.styl","hash":"4addaf2f203563accf0479850eda1ab4f4a4c34b","modified":1561702756543},{"_id":"themes/hueman/source/css/_variables.styl","hash":"ce03de3658b55b5f90bb4dd18679be18ec38acaa","modified":1561702756544},{"_id":"themes/hueman/source/css/style.styl","hash":"b76d43839bda01ee791e71093f009ad2c8b093b2","modified":1561702756547},{"_id":"themes/hueman/source/images/qidai.png","hash":"e5851bf12c41821e4d624914e4e5bf025b57418f","modified":1561702756548},{"_id":"themes/hueman/source/js/insight.js","hash":"6ee84c42c2b230ff9e9bf605a444bd671d44f9e3","modified":1561702756549},{"_id":"themes/hueman/source/js/main.js","hash":"2ef5449478816096cdd0e9dde4d1fc1c2f33ab87","modified":1561702756549},{"_id":"themes/hueman/layout/common/post/author.ejs","hash":"a87d77d6465548178a8461dd4b3f021826df5466","modified":1561702756521},{"_id":"themes/hueman/layout/common/post/date.ejs","hash":"198f75157a776b3e05eeb5da85b14a42027bd524","modified":1561702756521},{"_id":"themes/hueman/layout/common/post/gallery.ejs","hash":"659f019761116313169148ec61773e7b84abb739","modified":1561702756521},{"_id":"themes/hueman/layout/common/post/ld_json.ejs","hash":"99f85dc71d8184e10560321360464548cc4792af","modified":1561702756521},{"_id":"themes/hueman/layout/common/post/nav.ejs","hash":"c5f41ebf451cff39eaf116096604ce706a175767","modified":1561702756521},{"_id":"themes/hueman/layout/common/post/tag.ejs","hash":"2e966216256321aa0c76fe1b9be689601c76ef31","modified":1561702756521},{"_id":"themes/hueman/layout/common/post/title.ejs","hash":"6d19c61afb1f5f71c483be2ce37c6820ac2cd8b5","modified":1561702756522},{"_id":"themes/hueman/layout/common/post/tj.ejs","hash":"217e61a53fe2b0e783307ec21966d0ad23eb8985","modified":1561702756522},{"_id":"themes/hueman/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1561702756528},{"_id":"themes/hueman/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1561702756528},{"_id":"themes/hueman/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1561702756528},{"_id":"themes/hueman/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1561702756528},{"_id":"themes/hueman/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1561702756529},{"_id":"themes/hueman/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1561702756528},{"_id":"themes/hueman/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1561702756529},{"_id":"themes/hueman/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1561702756529},{"_id":"themes/hueman/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1561702756529},{"_id":"themes/hueman/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1561702756529},{"_id":"themes/hueman/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1561702756529},{"_id":"themes/hueman/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1561702756530},{"_id":"themes/hueman/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1561702756529},{"_id":"themes/hueman/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1561702756530},{"_id":"themes/hueman/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1561702756530},{"_id":"themes/hueman/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1561702756530},{"_id":"themes/hueman/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1561702756530},{"_id":"themes/hueman/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1561702756530},{"_id":"themes/hueman/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1561702756531},{"_id":"themes/hueman/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1561702756531},{"_id":"themes/hueman/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1561702756531},{"_id":"themes/hueman/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1561702756531},{"_id":"themes/hueman/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1561702756531},{"_id":"themes/hueman/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1561702756531},{"_id":"themes/hueman/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1561702756531},{"_id":"themes/hueman/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1561702756532},{"_id":"themes/hueman/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1561702756532},{"_id":"themes/hueman/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1561702756532},{"_id":"themes/hueman/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1561702756532},{"_id":"themes/hueman/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1561702756532},{"_id":"themes/hueman/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1561702756532},{"_id":"themes/hueman/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1561702756533},{"_id":"themes/hueman/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1561702756533},{"_id":"themes/hueman/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1561702756533},{"_id":"themes/hueman/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1561702756533},{"_id":"themes/hueman/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1561702756533},{"_id":"themes/hueman/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1561702756533},{"_id":"themes/hueman/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1561702756534},{"_id":"themes/hueman/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1561702756534},{"_id":"themes/hueman/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1561702756533},{"_id":"themes/hueman/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1561702756534},{"_id":"themes/hueman/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1561702756534},{"_id":"themes/hueman/source/css/_highlight/index.styl","hash":"d421ed06c84f7a561b293f662a670bf132d41c63","modified":1561702756534},{"_id":"themes/hueman/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1561702756534},{"_id":"themes/hueman/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1561702756535},{"_id":"themes/hueman/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1561702756535},{"_id":"themes/hueman/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1561702756535},{"_id":"themes/hueman/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1561702756535},{"_id":"themes/hueman/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1561702756535},{"_id":"themes/hueman/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1561702756535},{"_id":"themes/hueman/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1561702756535},{"_id":"themes/hueman/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1561702756536},{"_id":"themes/hueman/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1561702756536},{"_id":"themes/hueman/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1561702756536},{"_id":"themes/hueman/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1561702756536},{"_id":"themes/hueman/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1561702756536},{"_id":"themes/hueman/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1561702756536},{"_id":"themes/hueman/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1561702756536},{"_id":"themes/hueman/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1561702756537},{"_id":"themes/hueman/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1561702756537},{"_id":"themes/hueman/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1561702756537},{"_id":"themes/hueman/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1561702756538},{"_id":"themes/hueman/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1561702756538},{"_id":"themes/hueman/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1561702756538},{"_id":"themes/hueman/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1561702756538},{"_id":"themes/hueman/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1561702756539},{"_id":"themes/hueman/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1561702756539},{"_id":"themes/hueman/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1561702756539},{"_id":"themes/hueman/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1561702756539},{"_id":"themes/hueman/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1561702756539},{"_id":"themes/hueman/source/css/_partial/archive.styl","hash":"5e5fb791ab54f0acf33850f586f7aa8cb2782f3a","modified":1561702756540},{"_id":"themes/hueman/source/css/_partial/article.styl","hash":"5f93edada8ba08100e1fee6a9f6f5cf4a35b6c7f","modified":1561702756540},{"_id":"themes/hueman/source/css/_partial/assets.styl","hash":"3d95417663c5a737f064a31ab4ef52bac7fda8df","modified":1561702756542},{"_id":"themes/hueman/source/css/_partial/comment.styl","hash":"d2de8f2c1cf6236ead0800c2a1566e01e7ae0b44","modified":1561702756542},{"_id":"themes/hueman/source/css/_partial/footer.styl","hash":"219f881c937735869ac4a1af1259e0d234aea9f3","modified":1561702756542},{"_id":"themes/hueman/source/css/_partial/header.styl","hash":"f94fcb4e2cbda45c8dc910ddb8ff4f19ff0644bf","modified":1561702756542},{"_id":"themes/hueman/source/css/_partial/insight.styl","hash":"3d66323e7b75ad197e80d7189a8d9216e1e1ef2f","modified":1561702756542},{"_id":"themes/hueman/source/css/_partial/nav.styl","hash":"587a9c9d304ed83eb0331a1d16693461805311c3","modified":1561702756543},{"_id":"themes/hueman/source/css/_partial/sidebar.styl","hash":"2217aa9c746107426d4830058aa67ea73f69f449","modified":1561702756543},{"_id":"themes/hueman/source/css/images/opacity-10.png","hash":"bbc979866c5b50e8adb348419154b28b1ff44d78","modified":1561702756545},{"_id":"themes/hueman/source/css/images/s-left.png","hash":"c8cac4f4e3492606fab93196364bd0f87d93bb98","modified":1561702756546},{"_id":"themes/hueman/source/css/images/logo-header.png","hash":"1fb55625877a9cbee8276307b8c6a5cd7b67cef1","modified":1561702756545},{"_id":"themes/hueman/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1561702756547},{"_id":"themes/hueman/source/css/images/thumb-default.png","hash":"2d0ba175d958d342494241c616a74d37f48059fb","modified":1561702756547},{"_id":"themes/hueman/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1561702756567},{"_id":"themes/hueman/source/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1561702756567},{"_id":"themes/hueman/source/libs/titillium-web/styles.css","hash":"d98f0c50aae4c922cd0b663fa820fd7dff2dd9b1","modified":1561702756584},{"_id":"themes/hueman/source/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1561702756581},{"_id":"themes/hueman/source/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1561702756550},{"_id":"themes/hueman/source/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1561702756551},{"_id":"themes/hueman/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1561702756572},{"_id":"themes/hueman/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1561702756573},{"_id":"themes/hueman/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1561702756572},{"_id":"themes/hueman/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1561702756573},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1561702756567},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1561702756568},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1561702756568},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1561702756568},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1561702756569},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1561702756570},{"_id":"themes/hueman/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1561702756569},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1561702756570},{"_id":"themes/hueman/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1561702756570},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1561702756571},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1561702756572},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1561702756572},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1561702756573},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1561702756574},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1561702756575},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1561702756575},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1561702756575},{"_id":"themes/hueman/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1561702756571},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1561702756576},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1561702756576},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1561702756576},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1561702756576},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1561702756577},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1561702756577},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1561702756577},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1561702756578},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1561702756578},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1561702756578},{"_id":"themes/hueman/source/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1561702756579},{"_id":"themes/hueman/source/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcSo_WB_cotcEMUw1LsIE8mM.woff2","hash":"6d17eac7fcc2866f10d1f2725a08ab749a6e978d","modified":1561702756581},{"_id":"themes/hueman/source/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcZSnX671uNZIV63UdXh3Mg0.woff2","hash":"78029561e4c2ec565ea11c3f5bbd052b018af8a6","modified":1561702756581},{"_id":"themes/hueman/source/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1561702756579},{"_id":"themes/hueman/source/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1561702756579},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr4-67659ICLY8bMrYhtePPA.woff2","hash":"4e5557954ec161edc03b6f971ddefee6179c1305","modified":1561702756582},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr46gJz9aNFrmnwBdd69aqzY.woff2","hash":"1454a4753468b607c23deac9f5438cd0ed5cb35d","modified":1561702756582},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr9INifKjd1RJ3NxxEi9Cy2w.woff2","hash":"1758c64c8acec4497735ccb5336b1a518d24024c","modified":1561702756583},{"_id":"themes/hueman/source/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr_SNRT0fZ5CX-AqRkMYgJJo.woff2","hash":"e2e2993940fc54ed41f26e39257fdbd824c05e81","modified":1561702756583},{"_id":"themes/hueman/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1561702756580},{"_id":"themes/hueman/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1561702756580},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1561702756554},{"_id":"themes/hueman/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1561702756553},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1561702756565},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1561702756564},{"_id":"themes/hueman/source/libs/jquery/3.3.1/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1561702756566},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1561702756563},{"_id":"themes/hueman/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1561702756559},{"_id":"source/_posts/2019-08-01-sass+compass.md","hash":"41adf8792757f7881b548c2e149fea55c18c26aa","modified":1591768913290},{"_id":"source/_posts/2019-06-26-pdm-react-admin.md","hash":"cd2cd857e2f00f2795f819f505d1158727917163","modified":1591768920590},{"_id":"source/_posts/2019-07-10-verdaccio-course.md","hash":"3c0d190fd44f2d51b109a0b1bf0fd4486147d2b1","modified":1591768917945},{"_id":"source/_posts/2019-07-12-generator.md","hash":"3eccd99c35cede4fa8d23b3f3766cbef799377f5","modified":1591768917015},{"_id":"source/_posts/2019-07-18-flutter-introduction.md","hash":"feca4775cac90ce9aa89fa952478659aa4f0d67e","modified":1591768916095},{"_id":"source/_posts/2019-07-26-svg-course.md","hash":"18dd18587147a4e67e07f6958c28739906b4dfea","modified":1591768915180},{"_id":"source/_posts/2019-07-26-编码问题.md","hash":"b0708424091fafdec3ebb5afffc211f179e011d0","modified":1591768914269},{"_id":"source/_posts/2019-08-05-javascript-regexp.md","hash":"0291ecd78e70da5aadc8a0bce877715f990cf212","modified":1591768912327},{"_id":"source/_posts/2019-08-09-Promise实现.md","hash":"793086a83c0448d105ed1e1fd0f4b1fd2006ad18","modified":1591768911401},{"_id":"source/_posts/2019-08-30-jsdoc-course.md","hash":"239d9ed47641876499228f93e8c29e8e0850839f","modified":1591768910380},{"_id":"source/_posts/2019-09-09-Async-await原理.md","hash":"3d5faeb3230755f84ea0bd46015f253a4e0de7dc","modified":1591768908445},{"_id":"source/_posts/2019-09-18-koa2.md","hash":"a8f81d921e95da5af8ba6ca678846e703b7c89b4","modified":1591768907365},{"_id":"source/_posts/2019-09-29-webcomponent.md","hash":"a46a5edffcb571a5701073c847ad4a853ff45b07","modified":1591768905618},{"_id":"source/_posts/2019-10-17-mongodb-basic-one.md","hash":"58d3e4e9db2f1408680f3a2ac87d82c32a82a0be","modified":1591768904493},{"_id":"source/_posts/2019-10-22-vue-element-admin.md","hash":"28f95276695e49ab7ed90300b9dd0b9c20929f64","modified":1591768903566},{"_id":"source/_posts/2019-11-15-React-hook.md","hash":"6817bb45e14ff2989d890cb4abf625b3976a55c7","modified":1591768902323},{"_id":"source/_posts/2019-12-13-Vuex使用.md","hash":"f9408cd8faaea902f1337d5222293eeaa0cd9472","modified":1591768895895},{"_id":"source/_posts/2019-11-21-nginx-rtmp-module-course.md","hash":"baa192f4c9ba2627135809420b3e585b15b4638e","modified":1591768900705},{"_id":"source/_posts/2019-11-26-redux原理.md","hash":"e328e4fe0b25a178e9eca8cd3b0ba2a80bdacefc","modified":1591768899562},{"_id":"source/_posts/2019-11-27-websocket.md","hash":"dcfec8f1808e5a22f02e0c7fdc97ab8441ffcfb2","modified":1591768897657},{"_id":"source/_posts/2019-12-26-js-inheritance.md","hash":"082fb5409573a9c604cbd943c281bcfff464ad71","modified":1591768892410},{"_id":"source/_posts/2019-12-20-react-hoc.md","hash":"904f1fd9fd2e881411ad004e83d129d729731844","modified":1591768893958},{"_id":"source/_posts/2019-12-30-webrtc本地测试配置.md","hash":"13c693dd56e7c1daa9aecbfd13c1403f19eb91d0","modified":1591768890172},{"_id":"source/_posts/2020-01-08-Vue-cli脚手架.md","hash":"5c265f0be1b7b370373480f2ac159de8ad57984d","modified":1591768879019},{"_id":"source/_posts/2020-01-08-Vue-router路由.md","hash":"a9164d14f6faa6a9506bab1bde443b7fce7c9176","modified":1591768875236},{"_id":"public/content.json","hash":"c695b003e668befd19ed7c2790fe1395fcc253fa","modified":1591768947525},{"_id":"public/about/index.html","hash":"49ffc9c7f74bfc13e229641d1b6a010cf7f2dc54","modified":1591768950590},{"_id":"public/2020/01/08/Vue-router路由/index.html","hash":"be6af6423b17d4992d5aa20a8cb83cc25e5a6a90","modified":1591768950590},{"_id":"public/2020/01/08/Vue-cli脚手架/index.html","hash":"8c016a2914e52284140171fd1f41030696c3bca2","modified":1591768950590},{"_id":"public/2019/12/30/webrtc本地测试配置/index.html","hash":"b67acfb7bfc64f93b4680c903b2d52ed5b9545ba","modified":1591768950590},{"_id":"public/2019/12/26/js-inheritance/index.html","hash":"348ffa42bb9edc7427740a43a628e186e80b4a20","modified":1591768950590},{"_id":"public/2019/12/20/react-hoc/index.html","hash":"87f63a7483fa78821bc7989733516a5fd3830509","modified":1591768950590},{"_id":"public/2019/12/13/Vuex使用/index.html","hash":"741d3eb498061e980939e56722fc57ab48c9a9b7","modified":1591768950590},{"_id":"public/2019/11/27/websocket/index.html","hash":"bbb23a677d5f90a34e6be974cc7c4f06b4b8e186","modified":1591768950591},{"_id":"public/2019/11/26/redux原理/index.html","hash":"43ed2e7fb36a77d19c285f451267f11f9842bcdf","modified":1591768950591},{"_id":"public/2019/11/21/nginx-rtmp-module-course/index.html","hash":"a717a4880d23240411df9a0d0f38392de71460b2","modified":1591768950591},{"_id":"public/2019/11/15/React-hook/index.html","hash":"158c19b474a90fc8a01c115b1439cea8b6ab4ca9","modified":1591768950591},{"_id":"public/2019/10/22/vue-element-admin/index.html","hash":"b3e6fbed41a111eda03287d5a5de230cdd97236d","modified":1591768950591},{"_id":"public/2019/10/17/mongodb-basic-one/index.html","hash":"dcbc7d15331272d408ce6dea4290cb48c0f480a8","modified":1591768950591},{"_id":"public/2019/09/18/koa2/index.html","hash":"13e1ce759d808f000f7e3794cf3af447a0941d28","modified":1591768950592},{"_id":"public/2019/09/09/Async-await原理/index.html","hash":"213acad6e17450a5c855f4778e6667bd976fa7c2","modified":1591768950592},{"_id":"public/2019/08/30/jsdoc-course/index.html","hash":"44a7803ea1cd098407e7b6b7b46043bb018296a8","modified":1591768950592},{"_id":"public/2019/08/09/Promise实现/index.html","hash":"c25e9e4291b8aa2dd0d481f00603d6a41171ad81","modified":1591768950592},{"_id":"public/2019/08/09/webcomponent/index.html","hash":"d5d7916a951cdc9007c4ec28cc40e8b53a488348","modified":1591768950592},{"_id":"public/2019/08/05/javascript-regexp/index.html","hash":"e0cb7b53b9ed5c84b4b688e0d7a2111723d6f60a","modified":1591768950592},{"_id":"public/2019/08/01/sass+compass/index.html","hash":"2b8a022f2ca4501a9abc2f59f040c828f833c564","modified":1591768950592},{"_id":"public/2019/07/26/svg-course/index.html","hash":"a5503008d1e19ee259f096992237d4f321b06b66","modified":1591768950593},{"_id":"public/2019/07/26/编码问题/index.html","hash":"3aad0a796d0822598f9a951787b01b9b3326d09e","modified":1591768950593},{"_id":"public/2019/07/18/flutter-introduction/index.html","hash":"13dabaf247569b6a539c54a7f67257ba5ebc4f72","modified":1591768950593},{"_id":"public/2019/07/12/generator/index.html","hash":"dcf97934f622f95139c90fc0ccb648660f3207f9","modified":1591768950593},{"_id":"public/2019/07/10/verdaccio-course/index.html","hash":"d95a47478edafe812fa4a1e7d222448c6da1f2c8","modified":1591768950593},{"_id":"public/2019/06/28/pdm系统开发遇到的相关问题/index.html","hash":"491c45c774466b162e159715ade0665cdf5a9beb","modified":1591768950593},{"_id":"public/2019/06/28/csstrick/index.html","hash":"96166fcf196a041e9a1c06e8a3f126da09cc6c23","modified":1591768950593},{"_id":"public/2019/06/26/pdm-react-admin/index.html","hash":"9e680312fd5160f863cca321b697f9ba8db7ecb6","modified":1591768950593},{"_id":"public/2019/06/25/markdown-introduction/index.html","hash":"637272d84f6144748ddd1543dbe7f92d318a96a7","modified":1591768950593},{"_id":"public/2019/06/20/asterisk-share/index.html","hash":"c27e0f4889b0bbda5267a4abbc0829f22422988e","modified":1591768950595},{"_id":"public/2019/06/20/activiti-flow/index.html","hash":"1257399726df8e7798f4a52634fe1c4c321debfb","modified":1591768950595},{"_id":"public/2019/06/20/基于svg的流程图展示实现/index.html","hash":"fa194bb5d42a835f639c0ffe3e79d9f4268fd67e","modified":1591768950595},{"_id":"public/2019/06/11/hexo-course-1/index.html","hash":"2238f5cdaeda9d5daff0f818e3ee1da25077f32a","modified":1591768950595},{"_id":"public/archives/index.html","hash":"cdb45d788398f619b8f38f7c2183bbd9c280eabb","modified":1591768950596},{"_id":"public/archives/page/2/index.html","hash":"9d2bc345fa4d291c0b1b12879a199e5c43d9c6d5","modified":1591768950596},{"_id":"public/archives/page/3/index.html","hash":"4b7e844c5f230ae4619fc63823423c7babd4b2c2","modified":1591768950596},{"_id":"public/archives/page/4/index.html","hash":"b39b71d689e5d55d6c50d344a6174bb8ac8d3d74","modified":1591768950596},{"_id":"public/archives/2019/index.html","hash":"bbf4c1b78955012f1d4d94728fdfd8676ded8cbc","modified":1591768950596},{"_id":"public/archives/2019/page/2/index.html","hash":"1ce7d385cdbdbb7c7287cfcb9cf4fe6790070820","modified":1591768950596},{"_id":"public/archives/2019/page/3/index.html","hash":"3fe900e4afcbf60258c4e51ae0b0ddf2424e63c2","modified":1591768950596},{"_id":"public/archives/2019/06/index.html","hash":"3f945bca2da9a8095ef9e1a1fd826252f6fb1a62","modified":1591768950597},{"_id":"public/archives/2019/07/index.html","hash":"2359010023952977c94f8c55c5dc4c6996977895","modified":1591768950597},{"_id":"public/archives/2019/08/index.html","hash":"6a9dcd62d91faae338009f6f1bd4f11fe3b7a9e2","modified":1591768950597},{"_id":"public/archives/2019/09/index.html","hash":"1707ae60b3251216005333c257d8820dc5d77566","modified":1591768950597},{"_id":"public/archives/2019/10/index.html","hash":"447aa1876abaf4753d8b85f6271c71a8050fe0d3","modified":1591768950597},{"_id":"public/archives/2019/11/index.html","hash":"2a967b72681a2589f73db11db44f7cddb1693f39","modified":1591768950598},{"_id":"public/archives/2019/12/index.html","hash":"6df6123379a8d0c0a8bc96b32a14c239164f9f6d","modified":1591768950598},{"_id":"public/archives/2020/index.html","hash":"c8cf23ffc39d203e8d5e6cffd8bcbd45cae05315","modified":1591768950598},{"_id":"public/archives/2020/01/index.html","hash":"886f48d40c979e0fc57d11b5d153c26735fa2289","modified":1591768950598},{"_id":"public/categories/JAVA开发/index.html","hash":"5e161877c73b4c5de74165a4789c16524ea0912b","modified":1591768950595},{"_id":"public/categories/WEB前端/index.html","hash":"6ef0caa6703dc564ec55fbc8c56ca3e933332d48","modified":1591768950595},{"_id":"public/categories/WEB前端/page/2/index.html","hash":"abe1d003d9e80c677ac80fb33d3c2dc2fa14dd1d","modified":1591768950595},{"_id":"public/categories/WEB前端/page/3/index.html","hash":"05bedbbab5b602175714818edda2349341ceba10","modified":1591768950596},{"_id":"public/categories/C语言/index.html","hash":"bf96e5e930823dba9693115b1b217f921a28984d","modified":1591768950596},{"_id":"public/categories/iOS-Android开发/index.html","hash":"1f8d0f90bfded1fb4409623262d8ec949eac1a08","modified":1591768950596},{"_id":"public/index.html","hash":"faae46fe69a11978a77c2084c00dee4ec3b4293d","modified":1591768950598},{"_id":"public/page/2/index.html","hash":"bc1d6361efb4ab20ba13600f7fb0b8ddb5db8bb5","modified":1591768950598},{"_id":"public/page/3/index.html","hash":"23a3b2010ec3fb1cce29334926a5f541358aab02","modified":1591768950599},{"_id":"public/page/4/index.html","hash":"8623916e0d817b05ec0bcbb80a7c602e93fc8d67","modified":1591768950599},{"_id":"public/tags/java/index.html","hash":"b8095ce9061248095b38e5240717110fc7dcb6d9","modified":1591768950599},{"_id":"public/tags/avtiviti/index.html","hash":"bf6d6e227867ee4827efb75fe732d18df7697f1a","modified":1591768950599},{"_id":"public/tags/工作流/index.html","hash":"eed145a7565491172991ebb6481faafe40219699","modified":1591768950599},{"_id":"public/tags/hexo/index.html","hash":"3395a4bc2726c0c0508c6c39791f984ac0591f41","modified":1591768950599},{"_id":"public/tags/js/index.html","hash":"9a3736199d0f99a1e7fb575aef6baaefe1679cdc","modified":1591768950599},{"_id":"public/tags/js/page/2/index.html","hash":"8be927a2cc8245d410a220b8f9ddf60e3d81cdfc","modified":1591768950600},{"_id":"public/tags/html/index.html","hash":"5a6904f9a9ec305b8f16d1c13c9f2830a42dd9c9","modified":1591768950600},{"_id":"public/tags/css/index.html","hash":"76855d8511cf4bf1820e45e5a08b50487139d541","modified":1591768950600},{"_id":"public/tags/node/index.html","hash":"3f6ea45c7a51276c43166e5fe7a15c4f6fc117f4","modified":1591768950600},{"_id":"public/tags/asterrisk/index.html","hash":"cbe63b6516cb5b4adf76d4eaa21bc154fefaffa0","modified":1591768950600},{"_id":"public/tags/语音/index.html","hash":"5e6a1f0fd5bb1aa7d7f5c83f8bd7f9a705da10b7","modified":1591768950600},{"_id":"public/tags/通信/index.html","hash":"43a644e224dfdbfaea15935381927bc3c5be2330","modified":1591768950601},{"_id":"public/tags/C语言/index.html","hash":"eccf25bd92fcaa863f6255906d63b2a7ad5c9243","modified":1591768950601},{"_id":"public/tags/react/index.html","hash":"c55a2469bef7a59af186c22c2516cfcc150ea9ba","modified":1591768950601},{"_id":"public/tags/markdown/index.html","hash":"df2f7b9fb7da35e67550570cefcabf4fbdbb6281","modified":1591768950601},{"_id":"public/tags/动画/index.html","hash":"02a2e0d4982cd67bfc9cb6d9e138687985fbe6ac","modified":1591768950602},{"_id":"public/tags/antd/index.html","hash":"285ac44f48b74a5189b6798711726470fa35cdbe","modified":1591768950602},{"_id":"public/tags/sass/index.html","hash":"da96a56fda51d75532731b23138a66a434380564","modified":1591768950602},{"_id":"public/tags/compass/index.html","hash":"7b6ab51397d5ce3079f485e329ebe35be5a06d5f","modified":1591768950602},{"_id":"public/tags/npm/index.html","hash":"a75f670b3faf28c82ebfb905e6ae71b00a8321ec","modified":1591768950603},{"_id":"public/tags/web/index.html","hash":"3993505c0565ede3a472f49a9e3760485a282ac6","modified":1591768950603},{"_id":"public/tags/es6/index.html","hash":"f6a56897845a211ef0e8ed48f942ac44a73858a6","modified":1591768950604},{"_id":"public/tags/flutter/index.html","hash":"0b79db689ac18171b0d068462b9382014b44d929","modified":1591768950604},{"_id":"public/tags/app/index.html","hash":"51f842ab538240865726aeab9a687382ac5ac592","modified":1591768950604},{"_id":"public/tags/跨平台/index.html","hash":"d5dbf441a7cbdab7699d5bd94e77f32c485431c8","modified":1591768950604},{"_id":"public/tags/svg/index.html","hash":"c5afee8a20a1ac72a79d0bf9648da768ef1c4d1c","modified":1591768950604},{"_id":"public/tags/jsdoc/index.html","hash":"ec8b14558a460ef25cc4581292dd0978e4ca85b0","modified":1591768950604},{"_id":"public/tags/mongodb/index.html","hash":"21a66af993541831cfc582cc5be4fc9d495775c4","modified":1591768950604},{"_id":"public/tags/vue/index.html","hash":"1bfd14936c0d3fea5a616c322b061eaeea192dc1","modified":1591768950604},{"_id":"public/tags/react-hooks/index.html","hash":"e078d00457972eb27fed344056a76d0df1ecb6b0","modified":1591768950605},{"_id":"public/tags/vue-vuex/index.html","hash":"827ac5a50d6a980b65303f5c8f1e7a8f6c2fb37d","modified":1591768950605},{"_id":"public/tags/websocket/index.html","hash":"7ba46ed61b2f164a287037392964b7af209010c5","modified":1591768950605},{"_id":"public/tags/react-hoc-html-js/index.html","hash":"6121897f1d08956408b3b28fbe63f944c4076700","modified":1591768950605},{"_id":"public/tags/vue-cli-vue/index.html","hash":"d4221459239ad023eac3945e626d9fdba9a3ad4a","modified":1591768950605},{"_id":"public/tags/vue-router-vue/index.html","hash":"6be62c23205f0bd688fa01824de9d92970b0b5c8","modified":1591768950605},{"_id":"public/images/qidai.png","hash":"e5851bf12c41821e4d624914e4e5bf025b57418f","modified":1591768950615},{"_id":"public/css/images/opacity-10.png","hash":"bbc979866c5b50e8adb348419154b28b1ff44d78","modified":1591768950615},{"_id":"public/css/images/s-left.png","hash":"c8cac4f4e3492606fab93196364bd0f87d93bb98","modified":1591768950615},{"_id":"public/css/images/logo-header.png","hash":"1fb55625877a9cbee8276307b8c6a5cd7b67cef1","modified":1591768951267},{"_id":"public/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1591768950615},{"_id":"public/css/images/thumb-default.png","hash":"2d0ba175d958d342494241c616a74d37f48059fb","modified":1591768950615},{"_id":"public/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1591768951269},{"_id":"public/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1591768950616},{"_id":"public/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1591768950616},{"_id":"public/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1591768950616},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1591768950616},{"_id":"public/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1591768950616},{"_id":"public/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1591768950616},{"_id":"public/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1591768950617},{"_id":"public/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1591768950617},{"_id":"public/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1591768950617},{"_id":"public/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1591768950617},{"_id":"public/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcSo_WB_cotcEMUw1LsIE8mM.woff2","hash":"6d17eac7fcc2866f10d1f2725a08ab749a6e978d","modified":1591768950617},{"_id":"public/libs/titillium-web/fonts/7XUFZ5tgS-tD6QamInJTcZSnX671uNZIV63UdXh3Mg0.woff2","hash":"78029561e4c2ec565ea11c3f5bbd052b018af8a6","modified":1591768950617},{"_id":"public/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr4-67659ICLY8bMrYhtePPA.woff2","hash":"4e5557954ec161edc03b6f971ddefee6179c1305","modified":1591768950617},{"_id":"public/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr46gJz9aNFrmnwBdd69aqzY.woff2","hash":"1454a4753468b607c23deac9f5438cd0ed5cb35d","modified":1591768950618},{"_id":"public/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr9INifKjd1RJ3NxxEi9Cy2w.woff2","hash":"1758c64c8acec4497735ccb5336b1a518d24024c","modified":1591768950618},{"_id":"public/libs/titillium-web/fonts/anMUvcNT0H1YN4FII8wpr_SNRT0fZ5CX-AqRkMYgJJo.woff2","hash":"e2e2993940fc54ed41f26e39257fdbd824c05e81","modified":1591768950618},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1591768950618},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1591768950618},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1591768951270},{"_id":"public/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1591768951320},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1591768951270},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1591768951270},{"_id":"public/js/insight.js","hash":"6ee84c42c2b230ff9e9bf605a444bd671d44f9e3","modified":1591768951345},{"_id":"public/js/main.js","hash":"2ef5449478816096cdd0e9dde4d1fc1c2f33ab87","modified":1591768951315},{"_id":"public/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1591768951316},{"_id":"public/libs/titillium-web/styles.css","hash":"d98f0c50aae4c922cd0b663fa820fd7dff2dd9b1","modified":1591768951316},{"_id":"public/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1591768951315},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1591768951317},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1591768951317},{"_id":"public/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1591768951317},{"_id":"public/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1591768951317},{"_id":"public/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1591768951318},{"_id":"public/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1591768951318},{"_id":"public/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1591768951318},{"_id":"public/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1591768951318},{"_id":"public/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1591768951318},{"_id":"public/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1591768951319},{"_id":"public/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1591768951318},{"_id":"public/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1591768951318},{"_id":"public/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1591768951345},{"_id":"public/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1591768951319},{"_id":"public/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1591768951346},{"_id":"public/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1591768951346},{"_id":"public/css/style.css","hash":"13b39fa2c5178a5b6890bd8b028bdd6b71323b9f","modified":1591768951319},{"_id":"public/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1591768951375},{"_id":"public/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1591768951423},{"_id":"public/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1591768951409},{"_id":"public/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1591768951456},{"_id":"public/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1591768951375},{"_id":"public/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1591768951423},{"_id":"public/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1591768951376},{"_id":"public/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1591768951376},{"_id":"public/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1591768951376},{"_id":"public/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1591768951463},{"_id":"public/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1591768951409},{"_id":"public/libs/jquery/3.3.1/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1591768951523},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1591768951376},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1591768951472}],"Category":[{"name":"JAVA开发","_id":"cjxfsbp4b0002hgq5pfywnjis"},{"name":"WEB前端","_id":"cjxfsbp4g0007hgq5ql78yiyz"},{"name":"C语言","_id":"cjxfsbp4p000fhgq5nph4kfza"},{"name":"css","_id":"cjxfsrawf001ghgq5us4bnwqy"},{"name":"react","_id":"cjxftihqg001lhgq5xbbhdf3m"},{"name":"iOS/Android开发","_id":"ck2yl0qc10009h6q6xk3j7f7f"}],"Data":[],"Page":[{"title":"关于我们","comments":1,"date":"2019-06-11T08:05:50.000Z","_content":"\n### Zhou Jun\n","source":"about/index.md","raw":"---\ntitle: 关于我们\ncomments: true\ndate: 2019-06-11 16:05:50\n---\n\n### Zhou Jun\n","updated":"2020-04-08T10:18:22.006Z","path":"about/index.html","_id":"cjxfsbp6e001fhgq5dlx4wizu","layout":"page","content":"<h3 id=\"Zhou-Jun\"><a href=\"#Zhou-Jun\" class=\"headerlink\" title=\"Zhou Jun\"></a>Zhou Jun</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Zhou-Jun\"><a href=\"#Zhou-Jun\" class=\"headerlink\" title=\"Zhou Jun\"></a>Zhou Jun</h3>"}],"Post":[{"title":"Activiti工作流简介","comments":1,"date":"2019-06-20T08:11:02.000Z","author":"jun.zhou","_content":"\n![](https://img.fengjr.com/image/2019/06/20/ae71a151f84d8afe11ed095e4fc88ea2.png)\n# Activiti工作流简介\n\n本文根据永则分享的 Activiti工作流简介的ppt输入的博客，方便大家查看和学习。\n\n## 1、工作流的定义与基本概念\n\n### 基本概念\n\n**工作流**是指一类能够完全自动执行的经营过程，根据一系列过程规则，将文档、信息或任务在不同的执行者之间进行传递与执行。通俗的说工作流就是通过计算机控制整体业务流向，将多人的业务串联，实现整体业务的一种方式。\n\n**工作流管理系统**(Workflow Management System, WfMS)是一个软件系统，它完成工作流的定义和管理，并按照在系统中预先定义好的工作流规则进行工作流实例的执行。工作流管理系统不是企业的业务系统，而是为企业的业务系统的运行提供了一个软件的支撑环境。\n\n**工作流管理联盟**(WfMC，Workflow Management Coalition)给出的关于工作流管理系统的定义是：工作流管理系统是一个软件系统，它通过执行经过计算的流程定义去支持一批专门设定的业务流程。工作流管理系统被用来定义、管理、和执行工作流程。\n\n## 主要功能\n\n1. 定义工作流：包括具体的活动、规则等。\n2. 执行工作流：按照流程定义的规则执行，并由多个参与者进行控制\n\n\n## 主要优点\n\n1. 提高系统的柔性，适应业务流程的变化\n2. 实现更好的业务过程控制，提高顾客服务质量\n3. 降低系统开发和维护成本\n\n## 常用框架\n- Activiti\n- JBPM\n- Shark\n- OSWorkflow\n- ActiveBPEL\n- YAWL\n\n\n## 2、Activiti数据库表说明\n\n### Activiti5介绍\n\n**Activiti5**是一个针对企业用户、开发人员、系统管理员的轻量级工作流业务管理平台，其核心是使用Java开发的快速、稳定的BPMN2.0流程引擎。Activiti是在ApacheV2许可下发布的，可以运行在任何类型的Java程序中，例如服务器、集群、云服务等。Activiti可以完美地与Spring集成。同时，基于简约思想的设计使得Activiti成为一个非常轻量级框架。它特色是提供了eclipse插件，开发人员可以通过插件直接绘画出业务流程图。\n\n### 数据表说明\n\nActiviti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。\n\n命名规则：\n\n- ACT_RE_*: 'RE'表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。\n- ACT_RU_*: 'RU'表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。这样运行时表可以一直很小速度很快。\n- ACT_ID_*: 'ID'表示identity。 这些表包含身份信息，比如用户，组等等。\n- ACT_HI_*: 'HI'表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。\n- ACT_GE_*: 通用数据， 用于不同场景下，如存放资源文件。\n\n下面是数据库具体的表名和作用：\n\n|表分类 | 表名 | 注释|\n|---|---|---|\n|一般数据 | ACT_GE_BYTEARRAY | 通用的流程定义和流程资源|\n| | ACT_GE_PROPERTY | 系统相关属性|\n|流程历史记录 | ACT_HI_ACTINST | 历史的流程活动|\n| | ACT_HI_COMMENT |历史的说明性信息|\n| | ACT_HI_DETAIL |历史的流程运行中的细节信息|\n| | ACT_HI_IDENTITYLINK |历史的流程运行过程中用户关系|\n| | ACT_HI_PROCINST |历史的流程实例|\n| | ACT_HI_TASKINST |历史的任务实例|\n| | ACT_HI_VARINST |历史的流程运行中的变量信息|\n| 用户用户组表 | ACT_ID_GROUP | 身份信息-组别信息 |\n|| ACT_ID_INFO |\t身份信息-组信息|\n|| ACT_ID_MEMBERSHIP |身份信息-用户和组关系的中间表|\n|| ACT_ID_USER |身份信息-用户信息|\n|流程定义表|ACT_RE_DEPLOYMENT|部署单元信息|\n||ACT_RE_MODEL|模型信息|\n||ACT_RE_PROCDEF|已部署的流程定义|\n|运行实例表| ACT_RU_EVENT_SUBSCR|运行时事件|\n|| ACT_RU_EXECUTION\t|运行时流程执行实例|\n|| ACT_RU_IDENTITYLINK |运行时用户关系信息|\n|| ACT_RU_JOB |运行时作业|\n|| ACT_RU_TASK |运行时任务|\n|| ACT_RU_VARIABLE |运行时变量表|\n\n## 3、Activiti工作原理\n\n### 框架初始化\n\n![](https://img.fengjr.com/image/2019/06/20/e021871ae3d411953f434bf23821247b.png)\n\n**ProcessEngine**\n\n>  ProcessEngine是Activiti框架的门面，ProcessEngine本身不提供任何功能，通过getXXXService方法可以获取到对应的Service对象执行操作\n\n**ProcessEngineConfiguration**\n\n> ProcessEngineConfiguration负责Activiti框架的属性配置、初始化工作，初始化入口是buildProcessEngine方法，所有Activiti框架运行时需要用到的组件基本都在这里初始化\n\n![](https://img.fengjr.com/image/2019/06/20/4385a62264bcc07e02cc1b4bfcff9e12.png)\n\n### 流程部署\n\n#### 部署方式\n\n部署流程资源有很多种方法，包括classpath、InputStream、字符串、zip格式压缩包\n\n**1、classpath**\n\n![](https://img.fengjr.com/image/2019/06/20/34c39ee6bf51aad33f742c90c29fdf9d.png)\n\n**2、InputStream**\n\n![](https://img.fengjr.com/image/2019/06/20/7f1b3eeceafe7e190dff013787eb9fe1.png)\n\n**2、字符串**\n\n![](https://img.fengjr.com/image/2019/06/20/41c83c52086017cb8c1d70740caf40c0.png)\n\n**3、zip/bar格式压缩包**\n\n![](https://img.fengjr.com/image/2019/06/20/06ccf1d63bcba0f82e430595f6d9211d.png)\n\ncreateDeployment方法中创建了DeploymentBuilder对象，DeploymentBuilder对象负责读取指定路径的流程图xml文件的内容（byte数组），并缓存在DeploymentEntity对象中，最终DeploymentBuilder的deploy方法会调用RepositoryService的deploy方法，完成流程部署。\n\n### 流程解析\n\n在DeployCmd中，首先调用DeploymentEntityManager持久化存储DeploymentEntity对象，然后调用DeploymentManager部署流程（流程解析）\n\n##### 1、DeploymentEntityManager\n\n> DeploymentEntityManager的deploy方法中循环调用Deployer对象的deploy方法，Activiti默认的Deployer是BpmnDeployer。\n> \n> 另外DeploymentEntityManager中还缓存了解析好的流程定义对象和Bpmn模型对象。\n\n![](https://img.fengjr.com/image/2019/06/20/b46a583368f6fcc1615863ba81775cbc.png)\n\n##### 2、BpmnDeployer\n\n1. 通过BpmnParser对象创建BpmnParse。\n2. 调用BpmnParse的execute方法，将inputStream中的流程图转化ProcessDefinitionEntity。\n3. 持久化ProcessDefinitionEntity对象\n\n![](https://img.fengjr.com/image/2019/06/20/cd5cc9467fe13282859ff6d2365e0dd1.png)\n\n##### 3、BpmnParse\n\n在BpmnParse的execute中完成了xml文件到ProcessDefinitionEntity对象\n\n![](https://img.fengjr.com/image/2019/06/20/c4f5f0468d957b173844bb7fb6cacf94.png)\n\n### 运行流程\n\n#### 创建流程实例\n\n可以通过RuntimeService发起流程实例，在startProcessInstanceByKey方法中执行StartProcessInstanceCmd命令\n\n![](https://img.fengjr.com/image/2019/06/20/864e0ebbf9226f542340beb29edbc121.png)\n\n#### 驱动流程\n\nStartProcessInstanceCmd调用ExecutionEntity的start方法开始驱动流程\n\n![](https://img.fengjr.com/image/2019/06/20/a225c227a481ad4f4c551dde24c3e846.png)\n\nActiviti框架的流程运行于PVM模型之上，在流程运行时主要涉及到PVM中几个对象：ActivityImpl、TransitionImpl和ActivityBehavior\n\n1. ActivityImpl：ActivityImpl是流程节点的抽象，ActivityImpl维护流程图中节点的连线，包括有哪些进线，有哪些出线。另外还包含节点同步／异步执行等信息。\n2. TransitionImpl：TransitionImpl包含source和target两个属性，连接了两个流程节点。\n3. ActivityBehavior：每一个ActivityImpl对象都拥有一个ActivityBehavior对象，ActivityBehavior代表节点的行为。\n\nActivityImpl、TransitionImpl和ActivityBehavior只是描述了流程的节点、迁移线和节点行为，真正要让ExecutionEntity流转起来，还需要AtomicOperation的驱动。\n\n![](https://img.fengjr.com/image/2019/06/20/c77300c6f1f7c467c05d47de2434cc74.png)\n\n在ExecutionEntity的start方法中，调用了PROCESS_START，PROCESS_START做了几件事：\n\n- 获取流程定义级别定义的监听start事件的ExecutionListener，调用notify方法。\n- 如果开启了事件功能，发布ActivitiEntityWithVariablesEvent和ActivitiProcessStartedEvent。3、调用PROCESS_START_INITIAL。\n\nPROCESS_START_INITIAL也实现了类似的功能\n\n- 获取初始节点上定义的监听start事件的ExecutionListener，调用notify方法。\n- 调用ACTIVITY_EXECUTE。\n\n在流程执行中涉及的AtomicOperation的链路主要包括：\n\n1. ACTIVITY_EXECUTE：调用当前activity的behavior。\n2. TRANSITION_NOTIFY_LISTENER_END：某个activity节点执行完毕，调用节点上声明的监听end事件的ExecutionListener。\n3. TRANSITION_NOTIFY_LISTENER_TAKE：触发线上的ExecutionListener。\n4. TRANSITION_NOTIFY_LISTENER_START：某个activity节点即将开始执行，调用节点上的监听start事件的ExecutionListener。\n\n## 4、Activiti组件介绍与参数传递\n\n### 开始事件（startEvent）\n\n开始事件用来指明流程在哪里开始。开始事件的类型（流程在接收事件时启动， 还是在指定时间启动，等等），定义了流程如何启动， 这通过事件中不同的小图表来展示。 在XML中，这些类型是通过声明不同的子元素来区分的。\n\nXML结构：\n\n```\n<startEvent id=\"start\" name=\"my start event\" />\n```\n\n### 结束事件（endEvent）\n\nEnd Event 结束事件表示（子）流程（分支）的结束。 结束事件都是触发事件。 这是说当流程达到结束事件，会触发一个结果。 结果的类型是通过事件的内部黑色图标表示的。 在XML内容中，是通过包含的子元素声明的。\n\nXML结构：\n\n```\n<endEvent id=\"end\" name=\"my end event\" />\n```\n\n### 顺序流（Sequence Flow）\n\n顺序流是连接两个流程节点的连线。 流程执行完一个节点后，会沿着节点的所有外出顺序流继续执行。 就是说，BPMN 2.0默认的行为就是并发的： 两个外出顺序流会创造两个单独的，并发流程分支。\n\nXML结构：\n\n```\n<sequenceFlow id=\"flow1\" sourceRef=\"theStart\" targetRef=\"theTask\" /> \n```\n\n### 用户任务（UserTask）\n\n用户任务用来设置必须由人员完成的工作。  当流程执行到用户任务，会创建一个新任务，并把这个新任务加入到分配人或群组的任务列表中。             XML结构：\n\n```\n<userTask id=\"theTask\" name=\"Important task\" />\n```\n\n#### 任务分配\n对于用户任务的分配有4种方法，一是个人任务分配，二是组任务分配，三是角色任务分配，四是JAVA自定义扩展的分配逻辑。\n\n##### 1、Assignee属性\n\n这个自定义扩展可以直接把用户任务分配给指定用户。我们可以在流程设计时直接指定办理人（此时的办理人可以写成定值如张三；也可以写成变量表达式如${userId}，在流程实例启动时再进行办理人的赋值也是可以的；也可以不写，通过JAVA自定义扩展来指定办理人。），也可以手动分配任务从一个人给另外一个人。\n\nXML结构：\n\n```\n<userTask id=“theTask” name=“my task” activiti:assignee=“张三” /> \n```\nJAVA 代码：\n\n```\nMap<String, Object> variables = new HashMap<String,Object>();\nvariables.put(“userID”, “张三\");\nProcessInstance pi = processEngine.getRuntimeService()\n\t\t.startProcessInstanceByKey(\"taskProcess\",variables);\nprocessEngine.getTaskService().setAssignee(taskId, userId);\n```\n\n##### 2、CandidateUsers 属性\n\n这个自定义扩展可以使用户成为任务的候选者。即将一个任务分配给一组用户，让这组用户成为这个任务的候选者，直到有一个用户认领了该任务成为该任务的参与者为止。\n\n既然是一个组任务，那么在有用户参与之前，可以对该任务的候选者进行添加和删除工作。也可以在用户认领任务后，将任务回退到组任务，前提是该用户认领的这个任务之前必须是组任务。\n\nXML结构：\n\n```\n<userTask id=“theTask” name=“my task” activiti:candidateUsers=“张三, 李四” />\n```\n\nJAVA 代码：\n\n```\nMap<String, Object> variables = new HashMap<String, Object>();\nvariables.put(“userIDs”, “张三,李四,王五\");\nProcessInstance pi = processEngine.getRuntimeService()\n\t.startProcessInstanceByKey(processDefinitionKey,variables);\nprocessEngine.getTaskService().claim(taskId, userId);\n```\n##### 3、CandidateGroups属性\n\n这个自定义扩展允许为任务定义一组候选者。即将一个任务分配给一组角色，让每个角色组的用户成为这个任务的候选者，直到有一个用户认领了该任务成为该任务的参与者为止。\n\n既然是一个组任务，那么在有用户参与之前，可以对该任务的候选者进行添加和删除工作。也可以在用户认领任务后，将任务回退到组任务，前提是该用户认领的这个任务之前必须是组任务。\n\nXML结构：\n\n```\n<userTask id=“theTask” name=“my task” activiti:candidateGroups=“management, accountancy” />\n```\n\nJAVA 代码：\n\n```\nIdentityService identityService =processEngine.getIdentityService();\nidentityService.saveGroup(new GroupEntity(\"部门经理\"));\nidentityService.saveUser(new UserEntity(\"张三\"));\nidentityService.saveUser(new UserEntity(\"李四\"))\nidentityService.createMembership(\"张三\", \"部门经理\");\nidentityService.createMembership(\"李四\", \"部门经理\")\nprocessEngine.getTaskService().claim(taskId, userId);\n```\n\n##### 4、定义扩展JAVA类\n\n如果以上方案仍然不够，那么可以实现了任务监听器TaskListener的JAVA类来自定义分配逻辑。\n\nXML结构：\n\n```\n<userTask id=\"task1\" name=\"My task\" >\n    <extensionElements>\n\t    <activiti:taskListener event=\"create\"class=\"org.activiti.MyAssignmentHandler\" />\n    </extensionElements>\n</userTask>\n```\n\nJAVA代码：\n\n```\npublic class MyAssignmentHandler implements TaskListener {\n    public void notify(DelegateTask delegateTask) {\n\t    delegateTask.setAssignee(\"kermit\");\n\t    delegateTask.addCandidateUser(\"fozzie\");\n\t    delegateTask.addCandidateGroup(\"management\");\n\t    ...\n\t}\n}\n```\n\n#### 任务完成\n\nActiviti中当前任务节点完成任务时，只需要调用TaskService服务中的complete方法即可\n\n### 服务任务（Service Task）\n\nJava 服务任务用来调用外部 Java 类。\n\nXML结构：\n\n```\n<serviceTask id=\" serviceTask1“  name=\"My Java Service Task\"activiti:class=“com.demo.MyJavaDelegate1\" />\n```\n\n### 排他网关（Exclusive Gate Way）\n\n用来对流程中的决定进行建模。流程执行到这种gateway 时，按照输出流定义的顺序对它们进行计算。条件为 true 的顺序流（或没有设置条件，概念上顺序流上定义为’true’）被选取继续执行流程。\n\n##### 模型实例\n\n![](https://img.fengjr.com/image/2019/06/20/2457b668bcb956f50a729c57385f3a5a.png)\n\n### 并行网关（Parallel Gate Way）\n\n并行网关的功能要根据输入和输出的顺序流，它能拆分出多个执行路径，或多个输入执行路径进行合并。\n\n**拆分（fork）** ：并行执行所有的输出顺序流，为每一个顺序流创建一个并行执行路径。\n\n**合并（join）** ：所有到达 parallel gataway 的并发性的执行路径都等待于此，直到每个输入流都执行到。然后，流程经由 joining gateway 继续向下执行。\nXML结构：\n\n```\n<parallelGateway id=\"myParallelGateway\" />\n```\n\n##### 模型实例\n\n![](https://img.fengjr.com/image/2019/06/20/ad2e4433f234fcd31d2480f65b5dd427.png)\n\n## 5、Activiti集成Spring\n\nActiviti的所有Service服务都是通过ProcessEngine来获取的。通过查看源文件，可以发现最终是通过 ProcessEngineConfiguration来创建流程引擎对象的。而Activiti做的更好的地方是：ProcessEngineConfiguration这个抽象类有多种实现方式，这意味着我们可以通过一种实现方式把ProcessEngine作为一个普通的Spring  bean进行配置。同样，在流程引擎配置进来后，它所包含的Service服务也可以当作一个Spring Bean进行配置进来。\n\nXML代码:\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"   \n       xmlns:context=\"http://www.springframework.org/schema/context\"  \n       xmlns:tx=\"http://www.springframework.org/schema/tx\"  \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n       xsi:schemaLocation=“\n\thttp://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd  \n                 http://www.springframework.org/schema/context\n\t http://www.springframework.org/schema/context/spring-context-2.5.xsd  \n                 http://www.springframework.org/schema/tx\n\thttp://www.springframework.org/schema/tx/spring-tx-3.0.xsd\">  \n</bean>\n<!-- spring负责创建流程引擎的配置文件 -->\n<bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\"> \n    <!-- 数据源 --> \n    <property name=\"dataSource\" ref=\"dataSource\" />  \n    <!-- 配置事务管理器，统一事务 -->\n    <property name=\"transactionManager\" ref=\"transactionManager\" />  \n    <!-- 设置建表策略，如果没有表，自动创建表 -->\n    <property name=\"databaseSchemaUpdate\" value=\"true\" />  \n    <property name=\"jobExecutorActivate\" value=\"false\" />  \n   <!-- 设置记录历史级别 none:activity:audit:full -->\n    <property name=\"history\" value=\"full\" />  \n    <property name=\"processDefinitionCacheLimit\" value=\"10\" />  \n</bean>\n\n```\n\n\n![](https://img.fengjr.com/image/2019/06/20/864e0ebbf9226f542340beb29edbc121.png)","source":"_posts/2019-06-20-activiti-flow.md","raw":"---\ntitle: Activiti工作流简介\ncomments: true\ndate: 2019-06-20 16:11:02\ntags:\n- java\n- avtiviti\n- 工作流\nauthor: jun.zhou\ncategories:\n- JAVA开发\n---\n\n![](https://img.fengjr.com/image/2019/06/20/ae71a151f84d8afe11ed095e4fc88ea2.png)\n# Activiti工作流简介\n\n本文根据永则分享的 Activiti工作流简介的ppt输入的博客，方便大家查看和学习。\n\n## 1、工作流的定义与基本概念\n\n### 基本概念\n\n**工作流**是指一类能够完全自动执行的经营过程，根据一系列过程规则，将文档、信息或任务在不同的执行者之间进行传递与执行。通俗的说工作流就是通过计算机控制整体业务流向，将多人的业务串联，实现整体业务的一种方式。\n\n**工作流管理系统**(Workflow Management System, WfMS)是一个软件系统，它完成工作流的定义和管理，并按照在系统中预先定义好的工作流规则进行工作流实例的执行。工作流管理系统不是企业的业务系统，而是为企业的业务系统的运行提供了一个软件的支撑环境。\n\n**工作流管理联盟**(WfMC，Workflow Management Coalition)给出的关于工作流管理系统的定义是：工作流管理系统是一个软件系统，它通过执行经过计算的流程定义去支持一批专门设定的业务流程。工作流管理系统被用来定义、管理、和执行工作流程。\n\n## 主要功能\n\n1. 定义工作流：包括具体的活动、规则等。\n2. 执行工作流：按照流程定义的规则执行，并由多个参与者进行控制\n\n\n## 主要优点\n\n1. 提高系统的柔性，适应业务流程的变化\n2. 实现更好的业务过程控制，提高顾客服务质量\n3. 降低系统开发和维护成本\n\n## 常用框架\n- Activiti\n- JBPM\n- Shark\n- OSWorkflow\n- ActiveBPEL\n- YAWL\n\n\n## 2、Activiti数据库表说明\n\n### Activiti5介绍\n\n**Activiti5**是一个针对企业用户、开发人员、系统管理员的轻量级工作流业务管理平台，其核心是使用Java开发的快速、稳定的BPMN2.0流程引擎。Activiti是在ApacheV2许可下发布的，可以运行在任何类型的Java程序中，例如服务器、集群、云服务等。Activiti可以完美地与Spring集成。同时，基于简约思想的设计使得Activiti成为一个非常轻量级框架。它特色是提供了eclipse插件，开发人员可以通过插件直接绘画出业务流程图。\n\n### 数据表说明\n\nActiviti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。\n\n命名规则：\n\n- ACT_RE_*: 'RE'表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。\n- ACT_RU_*: 'RU'表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。这样运行时表可以一直很小速度很快。\n- ACT_ID_*: 'ID'表示identity。 这些表包含身份信息，比如用户，组等等。\n- ACT_HI_*: 'HI'表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。\n- ACT_GE_*: 通用数据， 用于不同场景下，如存放资源文件。\n\n下面是数据库具体的表名和作用：\n\n|表分类 | 表名 | 注释|\n|---|---|---|\n|一般数据 | ACT_GE_BYTEARRAY | 通用的流程定义和流程资源|\n| | ACT_GE_PROPERTY | 系统相关属性|\n|流程历史记录 | ACT_HI_ACTINST | 历史的流程活动|\n| | ACT_HI_COMMENT |历史的说明性信息|\n| | ACT_HI_DETAIL |历史的流程运行中的细节信息|\n| | ACT_HI_IDENTITYLINK |历史的流程运行过程中用户关系|\n| | ACT_HI_PROCINST |历史的流程实例|\n| | ACT_HI_TASKINST |历史的任务实例|\n| | ACT_HI_VARINST |历史的流程运行中的变量信息|\n| 用户用户组表 | ACT_ID_GROUP | 身份信息-组别信息 |\n|| ACT_ID_INFO |\t身份信息-组信息|\n|| ACT_ID_MEMBERSHIP |身份信息-用户和组关系的中间表|\n|| ACT_ID_USER |身份信息-用户信息|\n|流程定义表|ACT_RE_DEPLOYMENT|部署单元信息|\n||ACT_RE_MODEL|模型信息|\n||ACT_RE_PROCDEF|已部署的流程定义|\n|运行实例表| ACT_RU_EVENT_SUBSCR|运行时事件|\n|| ACT_RU_EXECUTION\t|运行时流程执行实例|\n|| ACT_RU_IDENTITYLINK |运行时用户关系信息|\n|| ACT_RU_JOB |运行时作业|\n|| ACT_RU_TASK |运行时任务|\n|| ACT_RU_VARIABLE |运行时变量表|\n\n## 3、Activiti工作原理\n\n### 框架初始化\n\n![](https://img.fengjr.com/image/2019/06/20/e021871ae3d411953f434bf23821247b.png)\n\n**ProcessEngine**\n\n>  ProcessEngine是Activiti框架的门面，ProcessEngine本身不提供任何功能，通过getXXXService方法可以获取到对应的Service对象执行操作\n\n**ProcessEngineConfiguration**\n\n> ProcessEngineConfiguration负责Activiti框架的属性配置、初始化工作，初始化入口是buildProcessEngine方法，所有Activiti框架运行时需要用到的组件基本都在这里初始化\n\n![](https://img.fengjr.com/image/2019/06/20/4385a62264bcc07e02cc1b4bfcff9e12.png)\n\n### 流程部署\n\n#### 部署方式\n\n部署流程资源有很多种方法，包括classpath、InputStream、字符串、zip格式压缩包\n\n**1、classpath**\n\n![](https://img.fengjr.com/image/2019/06/20/34c39ee6bf51aad33f742c90c29fdf9d.png)\n\n**2、InputStream**\n\n![](https://img.fengjr.com/image/2019/06/20/7f1b3eeceafe7e190dff013787eb9fe1.png)\n\n**2、字符串**\n\n![](https://img.fengjr.com/image/2019/06/20/41c83c52086017cb8c1d70740caf40c0.png)\n\n**3、zip/bar格式压缩包**\n\n![](https://img.fengjr.com/image/2019/06/20/06ccf1d63bcba0f82e430595f6d9211d.png)\n\ncreateDeployment方法中创建了DeploymentBuilder对象，DeploymentBuilder对象负责读取指定路径的流程图xml文件的内容（byte数组），并缓存在DeploymentEntity对象中，最终DeploymentBuilder的deploy方法会调用RepositoryService的deploy方法，完成流程部署。\n\n### 流程解析\n\n在DeployCmd中，首先调用DeploymentEntityManager持久化存储DeploymentEntity对象，然后调用DeploymentManager部署流程（流程解析）\n\n##### 1、DeploymentEntityManager\n\n> DeploymentEntityManager的deploy方法中循环调用Deployer对象的deploy方法，Activiti默认的Deployer是BpmnDeployer。\n> \n> 另外DeploymentEntityManager中还缓存了解析好的流程定义对象和Bpmn模型对象。\n\n![](https://img.fengjr.com/image/2019/06/20/b46a583368f6fcc1615863ba81775cbc.png)\n\n##### 2、BpmnDeployer\n\n1. 通过BpmnParser对象创建BpmnParse。\n2. 调用BpmnParse的execute方法，将inputStream中的流程图转化ProcessDefinitionEntity。\n3. 持久化ProcessDefinitionEntity对象\n\n![](https://img.fengjr.com/image/2019/06/20/cd5cc9467fe13282859ff6d2365e0dd1.png)\n\n##### 3、BpmnParse\n\n在BpmnParse的execute中完成了xml文件到ProcessDefinitionEntity对象\n\n![](https://img.fengjr.com/image/2019/06/20/c4f5f0468d957b173844bb7fb6cacf94.png)\n\n### 运行流程\n\n#### 创建流程实例\n\n可以通过RuntimeService发起流程实例，在startProcessInstanceByKey方法中执行StartProcessInstanceCmd命令\n\n![](https://img.fengjr.com/image/2019/06/20/864e0ebbf9226f542340beb29edbc121.png)\n\n#### 驱动流程\n\nStartProcessInstanceCmd调用ExecutionEntity的start方法开始驱动流程\n\n![](https://img.fengjr.com/image/2019/06/20/a225c227a481ad4f4c551dde24c3e846.png)\n\nActiviti框架的流程运行于PVM模型之上，在流程运行时主要涉及到PVM中几个对象：ActivityImpl、TransitionImpl和ActivityBehavior\n\n1. ActivityImpl：ActivityImpl是流程节点的抽象，ActivityImpl维护流程图中节点的连线，包括有哪些进线，有哪些出线。另外还包含节点同步／异步执行等信息。\n2. TransitionImpl：TransitionImpl包含source和target两个属性，连接了两个流程节点。\n3. ActivityBehavior：每一个ActivityImpl对象都拥有一个ActivityBehavior对象，ActivityBehavior代表节点的行为。\n\nActivityImpl、TransitionImpl和ActivityBehavior只是描述了流程的节点、迁移线和节点行为，真正要让ExecutionEntity流转起来，还需要AtomicOperation的驱动。\n\n![](https://img.fengjr.com/image/2019/06/20/c77300c6f1f7c467c05d47de2434cc74.png)\n\n在ExecutionEntity的start方法中，调用了PROCESS_START，PROCESS_START做了几件事：\n\n- 获取流程定义级别定义的监听start事件的ExecutionListener，调用notify方法。\n- 如果开启了事件功能，发布ActivitiEntityWithVariablesEvent和ActivitiProcessStartedEvent。3、调用PROCESS_START_INITIAL。\n\nPROCESS_START_INITIAL也实现了类似的功能\n\n- 获取初始节点上定义的监听start事件的ExecutionListener，调用notify方法。\n- 调用ACTIVITY_EXECUTE。\n\n在流程执行中涉及的AtomicOperation的链路主要包括：\n\n1. ACTIVITY_EXECUTE：调用当前activity的behavior。\n2. TRANSITION_NOTIFY_LISTENER_END：某个activity节点执行完毕，调用节点上声明的监听end事件的ExecutionListener。\n3. TRANSITION_NOTIFY_LISTENER_TAKE：触发线上的ExecutionListener。\n4. TRANSITION_NOTIFY_LISTENER_START：某个activity节点即将开始执行，调用节点上的监听start事件的ExecutionListener。\n\n## 4、Activiti组件介绍与参数传递\n\n### 开始事件（startEvent）\n\n开始事件用来指明流程在哪里开始。开始事件的类型（流程在接收事件时启动， 还是在指定时间启动，等等），定义了流程如何启动， 这通过事件中不同的小图表来展示。 在XML中，这些类型是通过声明不同的子元素来区分的。\n\nXML结构：\n\n```\n<startEvent id=\"start\" name=\"my start event\" />\n```\n\n### 结束事件（endEvent）\n\nEnd Event 结束事件表示（子）流程（分支）的结束。 结束事件都是触发事件。 这是说当流程达到结束事件，会触发一个结果。 结果的类型是通过事件的内部黑色图标表示的。 在XML内容中，是通过包含的子元素声明的。\n\nXML结构：\n\n```\n<endEvent id=\"end\" name=\"my end event\" />\n```\n\n### 顺序流（Sequence Flow）\n\n顺序流是连接两个流程节点的连线。 流程执行完一个节点后，会沿着节点的所有外出顺序流继续执行。 就是说，BPMN 2.0默认的行为就是并发的： 两个外出顺序流会创造两个单独的，并发流程分支。\n\nXML结构：\n\n```\n<sequenceFlow id=\"flow1\" sourceRef=\"theStart\" targetRef=\"theTask\" /> \n```\n\n### 用户任务（UserTask）\n\n用户任务用来设置必须由人员完成的工作。  当流程执行到用户任务，会创建一个新任务，并把这个新任务加入到分配人或群组的任务列表中。             XML结构：\n\n```\n<userTask id=\"theTask\" name=\"Important task\" />\n```\n\n#### 任务分配\n对于用户任务的分配有4种方法，一是个人任务分配，二是组任务分配，三是角色任务分配，四是JAVA自定义扩展的分配逻辑。\n\n##### 1、Assignee属性\n\n这个自定义扩展可以直接把用户任务分配给指定用户。我们可以在流程设计时直接指定办理人（此时的办理人可以写成定值如张三；也可以写成变量表达式如${userId}，在流程实例启动时再进行办理人的赋值也是可以的；也可以不写，通过JAVA自定义扩展来指定办理人。），也可以手动分配任务从一个人给另外一个人。\n\nXML结构：\n\n```\n<userTask id=“theTask” name=“my task” activiti:assignee=“张三” /> \n```\nJAVA 代码：\n\n```\nMap<String, Object> variables = new HashMap<String,Object>();\nvariables.put(“userID”, “张三\");\nProcessInstance pi = processEngine.getRuntimeService()\n\t\t.startProcessInstanceByKey(\"taskProcess\",variables);\nprocessEngine.getTaskService().setAssignee(taskId, userId);\n```\n\n##### 2、CandidateUsers 属性\n\n这个自定义扩展可以使用户成为任务的候选者。即将一个任务分配给一组用户，让这组用户成为这个任务的候选者，直到有一个用户认领了该任务成为该任务的参与者为止。\n\n既然是一个组任务，那么在有用户参与之前，可以对该任务的候选者进行添加和删除工作。也可以在用户认领任务后，将任务回退到组任务，前提是该用户认领的这个任务之前必须是组任务。\n\nXML结构：\n\n```\n<userTask id=“theTask” name=“my task” activiti:candidateUsers=“张三, 李四” />\n```\n\nJAVA 代码：\n\n```\nMap<String, Object> variables = new HashMap<String, Object>();\nvariables.put(“userIDs”, “张三,李四,王五\");\nProcessInstance pi = processEngine.getRuntimeService()\n\t.startProcessInstanceByKey(processDefinitionKey,variables);\nprocessEngine.getTaskService().claim(taskId, userId);\n```\n##### 3、CandidateGroups属性\n\n这个自定义扩展允许为任务定义一组候选者。即将一个任务分配给一组角色，让每个角色组的用户成为这个任务的候选者，直到有一个用户认领了该任务成为该任务的参与者为止。\n\n既然是一个组任务，那么在有用户参与之前，可以对该任务的候选者进行添加和删除工作。也可以在用户认领任务后，将任务回退到组任务，前提是该用户认领的这个任务之前必须是组任务。\n\nXML结构：\n\n```\n<userTask id=“theTask” name=“my task” activiti:candidateGroups=“management, accountancy” />\n```\n\nJAVA 代码：\n\n```\nIdentityService identityService =processEngine.getIdentityService();\nidentityService.saveGroup(new GroupEntity(\"部门经理\"));\nidentityService.saveUser(new UserEntity(\"张三\"));\nidentityService.saveUser(new UserEntity(\"李四\"))\nidentityService.createMembership(\"张三\", \"部门经理\");\nidentityService.createMembership(\"李四\", \"部门经理\")\nprocessEngine.getTaskService().claim(taskId, userId);\n```\n\n##### 4、定义扩展JAVA类\n\n如果以上方案仍然不够，那么可以实现了任务监听器TaskListener的JAVA类来自定义分配逻辑。\n\nXML结构：\n\n```\n<userTask id=\"task1\" name=\"My task\" >\n    <extensionElements>\n\t    <activiti:taskListener event=\"create\"class=\"org.activiti.MyAssignmentHandler\" />\n    </extensionElements>\n</userTask>\n```\n\nJAVA代码：\n\n```\npublic class MyAssignmentHandler implements TaskListener {\n    public void notify(DelegateTask delegateTask) {\n\t    delegateTask.setAssignee(\"kermit\");\n\t    delegateTask.addCandidateUser(\"fozzie\");\n\t    delegateTask.addCandidateGroup(\"management\");\n\t    ...\n\t}\n}\n```\n\n#### 任务完成\n\nActiviti中当前任务节点完成任务时，只需要调用TaskService服务中的complete方法即可\n\n### 服务任务（Service Task）\n\nJava 服务任务用来调用外部 Java 类。\n\nXML结构：\n\n```\n<serviceTask id=\" serviceTask1“  name=\"My Java Service Task\"activiti:class=“com.demo.MyJavaDelegate1\" />\n```\n\n### 排他网关（Exclusive Gate Way）\n\n用来对流程中的决定进行建模。流程执行到这种gateway 时，按照输出流定义的顺序对它们进行计算。条件为 true 的顺序流（或没有设置条件，概念上顺序流上定义为’true’）被选取继续执行流程。\n\n##### 模型实例\n\n![](https://img.fengjr.com/image/2019/06/20/2457b668bcb956f50a729c57385f3a5a.png)\n\n### 并行网关（Parallel Gate Way）\n\n并行网关的功能要根据输入和输出的顺序流，它能拆分出多个执行路径，或多个输入执行路径进行合并。\n\n**拆分（fork）** ：并行执行所有的输出顺序流，为每一个顺序流创建一个并行执行路径。\n\n**合并（join）** ：所有到达 parallel gataway 的并发性的执行路径都等待于此，直到每个输入流都执行到。然后，流程经由 joining gateway 继续向下执行。\nXML结构：\n\n```\n<parallelGateway id=\"myParallelGateway\" />\n```\n\n##### 模型实例\n\n![](https://img.fengjr.com/image/2019/06/20/ad2e4433f234fcd31d2480f65b5dd427.png)\n\n## 5、Activiti集成Spring\n\nActiviti的所有Service服务都是通过ProcessEngine来获取的。通过查看源文件，可以发现最终是通过 ProcessEngineConfiguration来创建流程引擎对象的。而Activiti做的更好的地方是：ProcessEngineConfiguration这个抽象类有多种实现方式，这意味着我们可以通过一种实现方式把ProcessEngine作为一个普通的Spring  bean进行配置。同样，在流程引擎配置进来后，它所包含的Service服务也可以当作一个Spring Bean进行配置进来。\n\nXML代码:\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"   \n       xmlns:context=\"http://www.springframework.org/schema/context\"  \n       xmlns:tx=\"http://www.springframework.org/schema/tx\"  \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n       xsi:schemaLocation=“\n\thttp://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd  \n                 http://www.springframework.org/schema/context\n\t http://www.springframework.org/schema/context/spring-context-2.5.xsd  \n                 http://www.springframework.org/schema/tx\n\thttp://www.springframework.org/schema/tx/spring-tx-3.0.xsd\">  \n</bean>\n<!-- spring负责创建流程引擎的配置文件 -->\n<bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\"> \n    <!-- 数据源 --> \n    <property name=\"dataSource\" ref=\"dataSource\" />  \n    <!-- 配置事务管理器，统一事务 -->\n    <property name=\"transactionManager\" ref=\"transactionManager\" />  \n    <!-- 设置建表策略，如果没有表，自动创建表 -->\n    <property name=\"databaseSchemaUpdate\" value=\"true\" />  \n    <property name=\"jobExecutorActivate\" value=\"false\" />  \n   <!-- 设置记录历史级别 none:activity:audit:full -->\n    <property name=\"history\" value=\"full\" />  \n    <property name=\"processDefinitionCacheLimit\" value=\"10\" />  \n</bean>\n\n```\n\n\n![](https://img.fengjr.com/image/2019/06/20/864e0ebbf9226f542340beb29edbc121.png)","slug":"activiti-flow","published":1,"updated":"2020-06-10T06:02:05.625Z","_id":"cjxfsbp440000hgq5mam9n8h1","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/06/20/ae71a151f84d8afe11ed095e4fc88ea2.png\" alt></p>\n<h1 id=\"Activiti工作流简介\"><a href=\"#Activiti工作流简介\" class=\"headerlink\" title=\"Activiti工作流简介\"></a>Activiti工作流简介</h1><p>本文根据永则分享的 Activiti工作流简介的ppt输入的博客，方便大家查看和学习。</p>\n<h2 id=\"1、工作流的定义与基本概念\"><a href=\"#1、工作流的定义与基本概念\" class=\"headerlink\" title=\"1、工作流的定义与基本概念\"></a>1、工作流的定义与基本概念</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p><strong>工作流</strong>是指一类能够完全自动执行的经营过程，根据一系列过程规则，将文档、信息或任务在不同的执行者之间进行传递与执行。通俗的说工作流就是通过计算机控制整体业务流向，将多人的业务串联，实现整体业务的一种方式。</p>\n<p><strong>工作流管理系统</strong>(Workflow Management System, WfMS)是一个软件系统，它完成工作流的定义和管理，并按照在系统中预先定义好的工作流规则进行工作流实例的执行。工作流管理系统不是企业的业务系统，而是为企业的业务系统的运行提供了一个软件的支撑环境。</p>\n<p><strong>工作流管理联盟</strong>(WfMC，Workflow Management Coalition)给出的关于工作流管理系统的定义是：工作流管理系统是一个软件系统，它通过执行经过计算的流程定义去支持一批专门设定的业务流程。工作流管理系统被用来定义、管理、和执行工作流程。</p>\n<h2 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h2><ol>\n<li>定义工作流：包括具体的活动、规则等。</li>\n<li>执行工作流：按照流程定义的规则执行，并由多个参与者进行控制</li>\n</ol>\n<h2 id=\"主要优点\"><a href=\"#主要优点\" class=\"headerlink\" title=\"主要优点\"></a>主要优点</h2><ol>\n<li>提高系统的柔性，适应业务流程的变化</li>\n<li>实现更好的业务过程控制，提高顾客服务质量</li>\n<li>降低系统开发和维护成本</li>\n</ol>\n<h2 id=\"常用框架\"><a href=\"#常用框架\" class=\"headerlink\" title=\"常用框架\"></a>常用框架</h2><ul>\n<li>Activiti</li>\n<li>JBPM</li>\n<li>Shark</li>\n<li>OSWorkflow</li>\n<li>ActiveBPEL</li>\n<li>YAWL</li>\n</ul>\n<h2 id=\"2、Activiti数据库表说明\"><a href=\"#2、Activiti数据库表说明\" class=\"headerlink\" title=\"2、Activiti数据库表说明\"></a>2、Activiti数据库表说明</h2><h3 id=\"Activiti5介绍\"><a href=\"#Activiti5介绍\" class=\"headerlink\" title=\"Activiti5介绍\"></a>Activiti5介绍</h3><p><strong>Activiti5</strong>是一个针对企业用户、开发人员、系统管理员的轻量级工作流业务管理平台，其核心是使用Java开发的快速、稳定的BPMN2.0流程引擎。Activiti是在ApacheV2许可下发布的，可以运行在任何类型的Java程序中，例如服务器、集群、云服务等。Activiti可以完美地与Spring集成。同时，基于简约思想的设计使得Activiti成为一个非常轻量级框架。它特色是提供了eclipse插件，开发人员可以通过插件直接绘画出业务流程图。</p>\n<h3 id=\"数据表说明\"><a href=\"#数据表说明\" class=\"headerlink\" title=\"数据表说明\"></a>数据表说明</h3><p>Activiti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。</p>\n<p>命名规则：</p>\n<ul>\n<li>ACT_RE_*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。</li>\n<li>ACT_RU_*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。这样运行时表可以一直很小速度很快。</li>\n<li>ACT_ID_*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。</li>\n<li>ACT_HI_*: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。</li>\n<li>ACT_GE_*: 通用数据， 用于不同场景下，如存放资源文件。</li>\n</ul>\n<p>下面是数据库具体的表名和作用：</p>\n<table>\n<thead>\n<tr>\n<th>表分类</th>\n<th>表名</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一般数据</td>\n<td>ACT_GE_BYTEARRAY</td>\n<td>通用的流程定义和流程资源</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_GE_PROPERTY</td>\n<td>系统相关属性</td>\n</tr>\n<tr>\n<td>流程历史记录</td>\n<td>ACT_HI_ACTINST</td>\n<td>历史的流程活动</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_COMMENT</td>\n<td>历史的说明性信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_DETAIL</td>\n<td>历史的流程运行中的细节信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_IDENTITYLINK</td>\n<td>历史的流程运行过程中用户关系</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_PROCINST</td>\n<td>历史的流程实例</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_TASKINST</td>\n<td>历史的任务实例</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_VARINST</td>\n<td>历史的流程运行中的变量信息</td>\n</tr>\n<tr>\n<td>用户用户组表</td>\n<td>ACT_ID_GROUP</td>\n<td>身份信息-组别信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_ID_INFO</td>\n<td>身份信息-组信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_ID_MEMBERSHIP</td>\n<td>身份信息-用户和组关系的中间表</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_ID_USER</td>\n<td>身份信息-用户信息</td>\n</tr>\n<tr>\n<td>流程定义表</td>\n<td>ACT_RE_DEPLOYMENT</td>\n<td>部署单元信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RE_MODEL</td>\n<td>模型信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RE_PROCDEF</td>\n<td>已部署的流程定义</td>\n</tr>\n<tr>\n<td>运行实例表</td>\n<td>ACT_RU_EVENT_SUBSCR</td>\n<td>运行时事件</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_EXECUTION</td>\n<td>运行时流程执行实例</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_IDENTITYLINK</td>\n<td>运行时用户关系信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_JOB</td>\n<td>运行时作业</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_TASK</td>\n<td>运行时任务</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_VARIABLE</td>\n<td>运行时变量表</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3、Activiti工作原理\"><a href=\"#3、Activiti工作原理\" class=\"headerlink\" title=\"3、Activiti工作原理\"></a>3、Activiti工作原理</h2><h3 id=\"框架初始化\"><a href=\"#框架初始化\" class=\"headerlink\" title=\"框架初始化\"></a>框架初始化</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/e021871ae3d411953f434bf23821247b.png\" alt></p>\n<p><strong>ProcessEngine</strong></p>\n<blockquote>\n<p> ProcessEngine是Activiti框架的门面，ProcessEngine本身不提供任何功能，通过getXXXService方法可以获取到对应的Service对象执行操作</p>\n</blockquote>\n<p><strong>ProcessEngineConfiguration</strong></p>\n<blockquote>\n<p>ProcessEngineConfiguration负责Activiti框架的属性配置、初始化工作，初始化入口是buildProcessEngine方法，所有Activiti框架运行时需要用到的组件基本都在这里初始化</p>\n</blockquote>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/4385a62264bcc07e02cc1b4bfcff9e12.png\" alt></p>\n<h3 id=\"流程部署\"><a href=\"#流程部署\" class=\"headerlink\" title=\"流程部署\"></a>流程部署</h3><h4 id=\"部署方式\"><a href=\"#部署方式\" class=\"headerlink\" title=\"部署方式\"></a>部署方式</h4><p>部署流程资源有很多种方法，包括classpath、InputStream、字符串、zip格式压缩包</p>\n<p><strong>1、classpath</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/34c39ee6bf51aad33f742c90c29fdf9d.png\" alt></p>\n<p><strong>2、InputStream</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/7f1b3eeceafe7e190dff013787eb9fe1.png\" alt></p>\n<p><strong>2、字符串</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/41c83c52086017cb8c1d70740caf40c0.png\" alt></p>\n<p><strong>3、zip/bar格式压缩包</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/06ccf1d63bcba0f82e430595f6d9211d.png\" alt></p>\n<p>createDeployment方法中创建了DeploymentBuilder对象，DeploymentBuilder对象负责读取指定路径的流程图xml文件的内容（byte数组），并缓存在DeploymentEntity对象中，最终DeploymentBuilder的deploy方法会调用RepositoryService的deploy方法，完成流程部署。</p>\n<h3 id=\"流程解析\"><a href=\"#流程解析\" class=\"headerlink\" title=\"流程解析\"></a>流程解析</h3><p>在DeployCmd中，首先调用DeploymentEntityManager持久化存储DeploymentEntity对象，然后调用DeploymentManager部署流程（流程解析）</p>\n<h5 id=\"1、DeploymentEntityManager\"><a href=\"#1、DeploymentEntityManager\" class=\"headerlink\" title=\"1、DeploymentEntityManager\"></a>1、DeploymentEntityManager</h5><blockquote>\n<p>DeploymentEntityManager的deploy方法中循环调用Deployer对象的deploy方法，Activiti默认的Deployer是BpmnDeployer。</p>\n<p>另外DeploymentEntityManager中还缓存了解析好的流程定义对象和Bpmn模型对象。</p>\n</blockquote>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/b46a583368f6fcc1615863ba81775cbc.png\" alt></p>\n<h5 id=\"2、BpmnDeployer\"><a href=\"#2、BpmnDeployer\" class=\"headerlink\" title=\"2、BpmnDeployer\"></a>2、BpmnDeployer</h5><ol>\n<li>通过BpmnParser对象创建BpmnParse。</li>\n<li>调用BpmnParse的execute方法，将inputStream中的流程图转化ProcessDefinitionEntity。</li>\n<li>持久化ProcessDefinitionEntity对象</li>\n</ol>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/cd5cc9467fe13282859ff6d2365e0dd1.png\" alt></p>\n<h5 id=\"3、BpmnParse\"><a href=\"#3、BpmnParse\" class=\"headerlink\" title=\"3、BpmnParse\"></a>3、BpmnParse</h5><p>在BpmnParse的execute中完成了xml文件到ProcessDefinitionEntity对象</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/c4f5f0468d957b173844bb7fb6cacf94.png\" alt></p>\n<h3 id=\"运行流程\"><a href=\"#运行流程\" class=\"headerlink\" title=\"运行流程\"></a>运行流程</h3><h4 id=\"创建流程实例\"><a href=\"#创建流程实例\" class=\"headerlink\" title=\"创建流程实例\"></a>创建流程实例</h4><p>可以通过RuntimeService发起流程实例，在startProcessInstanceByKey方法中执行StartProcessInstanceCmd命令</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/864e0ebbf9226f542340beb29edbc121.png\" alt></p>\n<h4 id=\"驱动流程\"><a href=\"#驱动流程\" class=\"headerlink\" title=\"驱动流程\"></a>驱动流程</h4><p>StartProcessInstanceCmd调用ExecutionEntity的start方法开始驱动流程</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/a225c227a481ad4f4c551dde24c3e846.png\" alt></p>\n<p>Activiti框架的流程运行于PVM模型之上，在流程运行时主要涉及到PVM中几个对象：ActivityImpl、TransitionImpl和ActivityBehavior</p>\n<ol>\n<li>ActivityImpl：ActivityImpl是流程节点的抽象，ActivityImpl维护流程图中节点的连线，包括有哪些进线，有哪些出线。另外还包含节点同步／异步执行等信息。</li>\n<li>TransitionImpl：TransitionImpl包含source和target两个属性，连接了两个流程节点。</li>\n<li>ActivityBehavior：每一个ActivityImpl对象都拥有一个ActivityBehavior对象，ActivityBehavior代表节点的行为。</li>\n</ol>\n<p>ActivityImpl、TransitionImpl和ActivityBehavior只是描述了流程的节点、迁移线和节点行为，真正要让ExecutionEntity流转起来，还需要AtomicOperation的驱动。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/c77300c6f1f7c467c05d47de2434cc74.png\" alt></p>\n<p>在ExecutionEntity的start方法中，调用了PROCESS_START，PROCESS_START做了几件事：</p>\n<ul>\n<li>获取流程定义级别定义的监听start事件的ExecutionListener，调用notify方法。</li>\n<li>如果开启了事件功能，发布ActivitiEntityWithVariablesEvent和ActivitiProcessStartedEvent。3、调用PROCESS_START_INITIAL。</li>\n</ul>\n<p>PROCESS_START_INITIAL也实现了类似的功能</p>\n<ul>\n<li>获取初始节点上定义的监听start事件的ExecutionListener，调用notify方法。</li>\n<li>调用ACTIVITY_EXECUTE。</li>\n</ul>\n<p>在流程执行中涉及的AtomicOperation的链路主要包括：</p>\n<ol>\n<li>ACTIVITY_EXECUTE：调用当前activity的behavior。</li>\n<li>TRANSITION_NOTIFY_LISTENER_END：某个activity节点执行完毕，调用节点上声明的监听end事件的ExecutionListener。</li>\n<li>TRANSITION_NOTIFY_LISTENER_TAKE：触发线上的ExecutionListener。</li>\n<li>TRANSITION_NOTIFY_LISTENER_START：某个activity节点即将开始执行，调用节点上的监听start事件的ExecutionListener。</li>\n</ol>\n<h2 id=\"4、Activiti组件介绍与参数传递\"><a href=\"#4、Activiti组件介绍与参数传递\" class=\"headerlink\" title=\"4、Activiti组件介绍与参数传递\"></a>4、Activiti组件介绍与参数传递</h2><h3 id=\"开始事件（startEvent）\"><a href=\"#开始事件（startEvent）\" class=\"headerlink\" title=\"开始事件（startEvent）\"></a>开始事件（startEvent）</h3><p>开始事件用来指明流程在哪里开始。开始事件的类型（流程在接收事件时启动， 还是在指定时间启动，等等），定义了流程如何启动， 这通过事件中不同的小图表来展示。 在XML中，这些类型是通过声明不同的子元素来区分的。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;startEvent id=&quot;start&quot; name=&quot;my start event&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结束事件（endEvent）\"><a href=\"#结束事件（endEvent）\" class=\"headerlink\" title=\"结束事件（endEvent）\"></a>结束事件（endEvent）</h3><p>End Event 结束事件表示（子）流程（分支）的结束。 结束事件都是触发事件。 这是说当流程达到结束事件，会触发一个结果。 结果的类型是通过事件的内部黑色图标表示的。 在XML内容中，是通过包含的子元素声明的。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;endEvent id=&quot;end&quot; name=&quot;my end event&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"顺序流（Sequence-Flow）\"><a href=\"#顺序流（Sequence-Flow）\" class=\"headerlink\" title=\"顺序流（Sequence Flow）\"></a>顺序流（Sequence Flow）</h3><p>顺序流是连接两个流程节点的连线。 流程执行完一个节点后，会沿着节点的所有外出顺序流继续执行。 就是说，BPMN 2.0默认的行为就是并发的： 两个外出顺序流会创造两个单独的，并发流程分支。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;theTask&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用户任务（UserTask）\"><a href=\"#用户任务（UserTask）\" class=\"headerlink\" title=\"用户任务（UserTask）\"></a>用户任务（UserTask）</h3><p>用户任务用来设置必须由人员完成的工作。  当流程执行到用户任务，会创建一个新任务，并把这个新任务加入到分配人或群组的任务列表中。             XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=&quot;theTask&quot; name=&quot;Important task&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"任务分配\"><a href=\"#任务分配\" class=\"headerlink\" title=\"任务分配\"></a>任务分配</h4><p>对于用户任务的分配有4种方法，一是个人任务分配，二是组任务分配，三是角色任务分配，四是JAVA自定义扩展的分配逻辑。</p>\n<h5 id=\"1、Assignee属性\"><a href=\"#1、Assignee属性\" class=\"headerlink\" title=\"1、Assignee属性\"></a>1、Assignee属性</h5><p>这个自定义扩展可以直接把用户任务分配给指定用户。我们可以在流程设计时直接指定办理人（此时的办理人可以写成定值如张三；也可以写成变量表达式如${userId}，在流程实例启动时再进行办理人的赋值也是可以的；也可以不写，通过JAVA自定义扩展来指定办理人。），也可以手动分配任务从一个人给另外一个人。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=“theTask” name=“my task” activiti:assignee=“张三” /&gt;</span><br></pre></td></tr></table></figure>\n<p>JAVA 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; variables = new HashMap&lt;String,Object&gt;();</span><br><span class=\"line\">variables.put(“userID”, “张三&quot;);</span><br><span class=\"line\">ProcessInstance pi = processEngine.getRuntimeService()</span><br><span class=\"line\">\t\t.startProcessInstanceByKey(&quot;taskProcess&quot;,variables);</span><br><span class=\"line\">processEngine.getTaskService().setAssignee(taskId, userId);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2、CandidateUsers-属性\"><a href=\"#2、CandidateUsers-属性\" class=\"headerlink\" title=\"2、CandidateUsers 属性\"></a>2、CandidateUsers 属性</h5><p>这个自定义扩展可以使用户成为任务的候选者。即将一个任务分配给一组用户，让这组用户成为这个任务的候选者，直到有一个用户认领了该任务成为该任务的参与者为止。</p>\n<p>既然是一个组任务，那么在有用户参与之前，可以对该任务的候选者进行添加和删除工作。也可以在用户认领任务后，将任务回退到组任务，前提是该用户认领的这个任务之前必须是组任务。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=“theTask” name=“my task” activiti:candidateUsers=“张三, 李四” /&gt;</span><br></pre></td></tr></table></figure>\n<p>JAVA 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">variables.put(“userIDs”, “张三,李四,王五&quot;);</span><br><span class=\"line\">ProcessInstance pi = processEngine.getRuntimeService()</span><br><span class=\"line\">\t.startProcessInstanceByKey(processDefinitionKey,variables);</span><br><span class=\"line\">processEngine.getTaskService().claim(taskId, userId);</span><br></pre></td></tr></table></figure>\n<h5 id=\"3、CandidateGroups属性\"><a href=\"#3、CandidateGroups属性\" class=\"headerlink\" title=\"3、CandidateGroups属性\"></a>3、CandidateGroups属性</h5><p>这个自定义扩展允许为任务定义一组候选者。即将一个任务分配给一组角色，让每个角色组的用户成为这个任务的候选者，直到有一个用户认领了该任务成为该任务的参与者为止。</p>\n<p>既然是一个组任务，那么在有用户参与之前，可以对该任务的候选者进行添加和删除工作。也可以在用户认领任务后，将任务回退到组任务，前提是该用户认领的这个任务之前必须是组任务。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=“theTask” name=“my task” activiti:candidateGroups=“management, accountancy” /&gt;</span><br></pre></td></tr></table></figure>\n<p>JAVA 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IdentityService identityService =processEngine.getIdentityService();</span><br><span class=\"line\">identityService.saveGroup(new GroupEntity(&quot;部门经理&quot;));</span><br><span class=\"line\">identityService.saveUser(new UserEntity(&quot;张三&quot;));</span><br><span class=\"line\">identityService.saveUser(new UserEntity(&quot;李四&quot;))</span><br><span class=\"line\">identityService.createMembership(&quot;张三&quot;, &quot;部门经理&quot;);</span><br><span class=\"line\">identityService.createMembership(&quot;李四&quot;, &quot;部门经理&quot;)</span><br><span class=\"line\">processEngine.getTaskService().claim(taskId, userId);</span><br></pre></td></tr></table></figure>\n<h5 id=\"4、定义扩展JAVA类\"><a href=\"#4、定义扩展JAVA类\" class=\"headerlink\" title=\"4、定义扩展JAVA类\"></a>4、定义扩展JAVA类</h5><p>如果以上方案仍然不够，那么可以实现了任务监听器TaskListener的JAVA类来自定义分配逻辑。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=&quot;task1&quot; name=&quot;My task&quot; &gt;</span><br><span class=\"line\">    &lt;extensionElements&gt;</span><br><span class=\"line\">\t    &lt;activiti:taskListener event=&quot;create&quot;class=&quot;org.activiti.MyAssignmentHandler&quot; /&gt;</span><br><span class=\"line\">    &lt;/extensionElements&gt;</span><br><span class=\"line\">&lt;/userTask&gt;</span><br></pre></td></tr></table></figure>\n<p>JAVA代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyAssignmentHandler implements TaskListener &#123;</span><br><span class=\"line\">    public void notify(DelegateTask delegateTask) &#123;</span><br><span class=\"line\">\t    delegateTask.setAssignee(&quot;kermit&quot;);</span><br><span class=\"line\">\t    delegateTask.addCandidateUser(&quot;fozzie&quot;);</span><br><span class=\"line\">\t    delegateTask.addCandidateGroup(&quot;management&quot;);</span><br><span class=\"line\">\t    ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"任务完成\"><a href=\"#任务完成\" class=\"headerlink\" title=\"任务完成\"></a>任务完成</h4><p>Activiti中当前任务节点完成任务时，只需要调用TaskService服务中的complete方法即可</p>\n<h3 id=\"服务任务（Service-Task）\"><a href=\"#服务任务（Service-Task）\" class=\"headerlink\" title=\"服务任务（Service Task）\"></a>服务任务（Service Task）</h3><p>Java 服务任务用来调用外部 Java 类。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;serviceTask id=&quot; serviceTask1“  name=&quot;My Java Service Task&quot;activiti:class=“com.demo.MyJavaDelegate1&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"排他网关（Exclusive-Gate-Way）\"><a href=\"#排他网关（Exclusive-Gate-Way）\" class=\"headerlink\" title=\"排他网关（Exclusive Gate Way）\"></a>排他网关（Exclusive Gate Way）</h3><p>用来对流程中的决定进行建模。流程执行到这种gateway 时，按照输出流定义的顺序对它们进行计算。条件为 true 的顺序流（或没有设置条件，概念上顺序流上定义为’true’）被选取继续执行流程。</p>\n<h5 id=\"模型实例\"><a href=\"#模型实例\" class=\"headerlink\" title=\"模型实例\"></a>模型实例</h5><p><img src=\"https://img.fengjr.com/image/2019/06/20/2457b668bcb956f50a729c57385f3a5a.png\" alt></p>\n<h3 id=\"并行网关（Parallel-Gate-Way）\"><a href=\"#并行网关（Parallel-Gate-Way）\" class=\"headerlink\" title=\"并行网关（Parallel Gate Way）\"></a>并行网关（Parallel Gate Way）</h3><p>并行网关的功能要根据输入和输出的顺序流，它能拆分出多个执行路径，或多个输入执行路径进行合并。</p>\n<p><strong>拆分（fork）</strong> ：并行执行所有的输出顺序流，为每一个顺序流创建一个并行执行路径。</p>\n<p><strong>合并（join）</strong> ：所有到达 parallel gataway 的并发性的执行路径都等待于此，直到每个输入流都执行到。然后，流程经由 joining gateway 继续向下执行。<br>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parallelGateway id=&quot;myParallelGateway&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"模型实例-1\"><a href=\"#模型实例-1\" class=\"headerlink\" title=\"模型实例\"></a>模型实例</h5><p><img src=\"https://img.fengjr.com/image/2019/06/20/ad2e4433f234fcd31d2480f65b5dd427.png\" alt></p>\n<h2 id=\"5、Activiti集成Spring\"><a href=\"#5、Activiti集成Spring\" class=\"headerlink\" title=\"5、Activiti集成Spring\"></a>5、Activiti集成Spring</h2><p>Activiti的所有Service服务都是通过ProcessEngine来获取的。通过查看源文件，可以发现最终是通过 ProcessEngineConfiguration来创建流程引擎对象的。而Activiti做的更好的地方是：ProcessEngineConfiguration这个抽象类有多种实现方式，这意味着我们可以通过一种实现方式把ProcessEngine作为一个普通的Spring  bean进行配置。同样，在流程引擎配置进来后，它所包含的Service服务也可以当作一个Spring Bean进行配置进来。</p>\n<p>XML代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   </span><br><span class=\"line\">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class=\"line\">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;  </span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </span><br><span class=\"line\">       xsi:schemaLocation=“</span><br><span class=\"line\">\thttp://www.springframework.org/schema/beans </span><br><span class=\"line\">\thttp://www.springframework.org/schema/beans/spring-beans.xsd  </span><br><span class=\"line\">                 http://www.springframework.org/schema/context</span><br><span class=\"line\">\t http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span><br><span class=\"line\">                 http://www.springframework.org/schema/tx</span><br><span class=\"line\">\thttp://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt;  </span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\">&lt;!-- spring负责创建流程引擎的配置文件 --&gt;</span><br><span class=\"line\">&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt; </span><br><span class=\"line\">    &lt;!-- 数据源 --&gt; </span><br><span class=\"line\">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  </span><br><span class=\"line\">    &lt;!-- 配置事务管理器，统一事务 --&gt;</span><br><span class=\"line\">    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  </span><br><span class=\"line\">    &lt;!-- 设置建表策略，如果没有表，自动创建表 --&gt;</span><br><span class=\"line\">    &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot; /&gt;  </span><br><span class=\"line\">    &lt;property name=&quot;jobExecutorActivate&quot; value=&quot;false&quot; /&gt;  </span><br><span class=\"line\">   &lt;!-- 设置记录历史级别 none:activity:audit:full --&gt;</span><br><span class=\"line\">    &lt;property name=&quot;history&quot; value=&quot;full&quot; /&gt;  </span><br><span class=\"line\">    &lt;property name=&quot;processDefinitionCacheLimit&quot; value=&quot;10&quot; /&gt;  </span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/864e0ebbf9226f542340beb29edbc121.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/06/20/ae71a151f84d8afe11ed095e4fc88ea2.png\" alt></p>\n<h1 id=\"Activiti工作流简介\"><a href=\"#Activiti工作流简介\" class=\"headerlink\" title=\"Activiti工作流简介\"></a>Activiti工作流简介</h1><p>本文根据永则分享的 Activiti工作流简介的ppt输入的博客，方便大家查看和学习。</p>\n<h2 id=\"1、工作流的定义与基本概念\"><a href=\"#1、工作流的定义与基本概念\" class=\"headerlink\" title=\"1、工作流的定义与基本概念\"></a>1、工作流的定义与基本概念</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p><strong>工作流</strong>是指一类能够完全自动执行的经营过程，根据一系列过程规则，将文档、信息或任务在不同的执行者之间进行传递与执行。通俗的说工作流就是通过计算机控制整体业务流向，将多人的业务串联，实现整体业务的一种方式。</p>\n<p><strong>工作流管理系统</strong>(Workflow Management System, WfMS)是一个软件系统，它完成工作流的定义和管理，并按照在系统中预先定义好的工作流规则进行工作流实例的执行。工作流管理系统不是企业的业务系统，而是为企业的业务系统的运行提供了一个软件的支撑环境。</p>\n<p><strong>工作流管理联盟</strong>(WfMC，Workflow Management Coalition)给出的关于工作流管理系统的定义是：工作流管理系统是一个软件系统，它通过执行经过计算的流程定义去支持一批专门设定的业务流程。工作流管理系统被用来定义、管理、和执行工作流程。</p>\n<h2 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h2><ol>\n<li>定义工作流：包括具体的活动、规则等。</li>\n<li>执行工作流：按照流程定义的规则执行，并由多个参与者进行控制</li>\n</ol>\n<h2 id=\"主要优点\"><a href=\"#主要优点\" class=\"headerlink\" title=\"主要优点\"></a>主要优点</h2><ol>\n<li>提高系统的柔性，适应业务流程的变化</li>\n<li>实现更好的业务过程控制，提高顾客服务质量</li>\n<li>降低系统开发和维护成本</li>\n</ol>\n<h2 id=\"常用框架\"><a href=\"#常用框架\" class=\"headerlink\" title=\"常用框架\"></a>常用框架</h2><ul>\n<li>Activiti</li>\n<li>JBPM</li>\n<li>Shark</li>\n<li>OSWorkflow</li>\n<li>ActiveBPEL</li>\n<li>YAWL</li>\n</ul>\n<h2 id=\"2、Activiti数据库表说明\"><a href=\"#2、Activiti数据库表说明\" class=\"headerlink\" title=\"2、Activiti数据库表说明\"></a>2、Activiti数据库表说明</h2><h3 id=\"Activiti5介绍\"><a href=\"#Activiti5介绍\" class=\"headerlink\" title=\"Activiti5介绍\"></a>Activiti5介绍</h3><p><strong>Activiti5</strong>是一个针对企业用户、开发人员、系统管理员的轻量级工作流业务管理平台，其核心是使用Java开发的快速、稳定的BPMN2.0流程引擎。Activiti是在ApacheV2许可下发布的，可以运行在任何类型的Java程序中，例如服务器、集群、云服务等。Activiti可以完美地与Spring集成。同时，基于简约思想的设计使得Activiti成为一个非常轻量级框架。它特色是提供了eclipse插件，开发人员可以通过插件直接绘画出业务流程图。</p>\n<h3 id=\"数据表说明\"><a href=\"#数据表说明\" class=\"headerlink\" title=\"数据表说明\"></a>数据表说明</h3><p>Activiti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。</p>\n<p>命名规则：</p>\n<ul>\n<li>ACT_RE_*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。</li>\n<li>ACT_RU_*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。这样运行时表可以一直很小速度很快。</li>\n<li>ACT_ID_*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。</li>\n<li>ACT_HI_*: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。</li>\n<li>ACT_GE_*: 通用数据， 用于不同场景下，如存放资源文件。</li>\n</ul>\n<p>下面是数据库具体的表名和作用：</p>\n<table>\n<thead>\n<tr>\n<th>表分类</th>\n<th>表名</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一般数据</td>\n<td>ACT_GE_BYTEARRAY</td>\n<td>通用的流程定义和流程资源</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_GE_PROPERTY</td>\n<td>系统相关属性</td>\n</tr>\n<tr>\n<td>流程历史记录</td>\n<td>ACT_HI_ACTINST</td>\n<td>历史的流程活动</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_COMMENT</td>\n<td>历史的说明性信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_DETAIL</td>\n<td>历史的流程运行中的细节信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_IDENTITYLINK</td>\n<td>历史的流程运行过程中用户关系</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_PROCINST</td>\n<td>历史的流程实例</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_TASKINST</td>\n<td>历史的任务实例</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_HI_VARINST</td>\n<td>历史的流程运行中的变量信息</td>\n</tr>\n<tr>\n<td>用户用户组表</td>\n<td>ACT_ID_GROUP</td>\n<td>身份信息-组别信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_ID_INFO</td>\n<td>身份信息-组信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_ID_MEMBERSHIP</td>\n<td>身份信息-用户和组关系的中间表</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_ID_USER</td>\n<td>身份信息-用户信息</td>\n</tr>\n<tr>\n<td>流程定义表</td>\n<td>ACT_RE_DEPLOYMENT</td>\n<td>部署单元信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RE_MODEL</td>\n<td>模型信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RE_PROCDEF</td>\n<td>已部署的流程定义</td>\n</tr>\n<tr>\n<td>运行实例表</td>\n<td>ACT_RU_EVENT_SUBSCR</td>\n<td>运行时事件</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_EXECUTION</td>\n<td>运行时流程执行实例</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_IDENTITYLINK</td>\n<td>运行时用户关系信息</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_JOB</td>\n<td>运行时作业</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_TASK</td>\n<td>运行时任务</td>\n</tr>\n<tr>\n<td></td>\n<td>ACT_RU_VARIABLE</td>\n<td>运行时变量表</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3、Activiti工作原理\"><a href=\"#3、Activiti工作原理\" class=\"headerlink\" title=\"3、Activiti工作原理\"></a>3、Activiti工作原理</h2><h3 id=\"框架初始化\"><a href=\"#框架初始化\" class=\"headerlink\" title=\"框架初始化\"></a>框架初始化</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/e021871ae3d411953f434bf23821247b.png\" alt></p>\n<p><strong>ProcessEngine</strong></p>\n<blockquote>\n<p> ProcessEngine是Activiti框架的门面，ProcessEngine本身不提供任何功能，通过getXXXService方法可以获取到对应的Service对象执行操作</p>\n</blockquote>\n<p><strong>ProcessEngineConfiguration</strong></p>\n<blockquote>\n<p>ProcessEngineConfiguration负责Activiti框架的属性配置、初始化工作，初始化入口是buildProcessEngine方法，所有Activiti框架运行时需要用到的组件基本都在这里初始化</p>\n</blockquote>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/4385a62264bcc07e02cc1b4bfcff9e12.png\" alt></p>\n<h3 id=\"流程部署\"><a href=\"#流程部署\" class=\"headerlink\" title=\"流程部署\"></a>流程部署</h3><h4 id=\"部署方式\"><a href=\"#部署方式\" class=\"headerlink\" title=\"部署方式\"></a>部署方式</h4><p>部署流程资源有很多种方法，包括classpath、InputStream、字符串、zip格式压缩包</p>\n<p><strong>1、classpath</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/34c39ee6bf51aad33f742c90c29fdf9d.png\" alt></p>\n<p><strong>2、InputStream</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/7f1b3eeceafe7e190dff013787eb9fe1.png\" alt></p>\n<p><strong>2、字符串</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/41c83c52086017cb8c1d70740caf40c0.png\" alt></p>\n<p><strong>3、zip/bar格式压缩包</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/06ccf1d63bcba0f82e430595f6d9211d.png\" alt></p>\n<p>createDeployment方法中创建了DeploymentBuilder对象，DeploymentBuilder对象负责读取指定路径的流程图xml文件的内容（byte数组），并缓存在DeploymentEntity对象中，最终DeploymentBuilder的deploy方法会调用RepositoryService的deploy方法，完成流程部署。</p>\n<h3 id=\"流程解析\"><a href=\"#流程解析\" class=\"headerlink\" title=\"流程解析\"></a>流程解析</h3><p>在DeployCmd中，首先调用DeploymentEntityManager持久化存储DeploymentEntity对象，然后调用DeploymentManager部署流程（流程解析）</p>\n<h5 id=\"1、DeploymentEntityManager\"><a href=\"#1、DeploymentEntityManager\" class=\"headerlink\" title=\"1、DeploymentEntityManager\"></a>1、DeploymentEntityManager</h5><blockquote>\n<p>DeploymentEntityManager的deploy方法中循环调用Deployer对象的deploy方法，Activiti默认的Deployer是BpmnDeployer。</p>\n<p>另外DeploymentEntityManager中还缓存了解析好的流程定义对象和Bpmn模型对象。</p>\n</blockquote>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/b46a583368f6fcc1615863ba81775cbc.png\" alt></p>\n<h5 id=\"2、BpmnDeployer\"><a href=\"#2、BpmnDeployer\" class=\"headerlink\" title=\"2、BpmnDeployer\"></a>2、BpmnDeployer</h5><ol>\n<li>通过BpmnParser对象创建BpmnParse。</li>\n<li>调用BpmnParse的execute方法，将inputStream中的流程图转化ProcessDefinitionEntity。</li>\n<li>持久化ProcessDefinitionEntity对象</li>\n</ol>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/cd5cc9467fe13282859ff6d2365e0dd1.png\" alt></p>\n<h5 id=\"3、BpmnParse\"><a href=\"#3、BpmnParse\" class=\"headerlink\" title=\"3、BpmnParse\"></a>3、BpmnParse</h5><p>在BpmnParse的execute中完成了xml文件到ProcessDefinitionEntity对象</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/c4f5f0468d957b173844bb7fb6cacf94.png\" alt></p>\n<h3 id=\"运行流程\"><a href=\"#运行流程\" class=\"headerlink\" title=\"运行流程\"></a>运行流程</h3><h4 id=\"创建流程实例\"><a href=\"#创建流程实例\" class=\"headerlink\" title=\"创建流程实例\"></a>创建流程实例</h4><p>可以通过RuntimeService发起流程实例，在startProcessInstanceByKey方法中执行StartProcessInstanceCmd命令</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/864e0ebbf9226f542340beb29edbc121.png\" alt></p>\n<h4 id=\"驱动流程\"><a href=\"#驱动流程\" class=\"headerlink\" title=\"驱动流程\"></a>驱动流程</h4><p>StartProcessInstanceCmd调用ExecutionEntity的start方法开始驱动流程</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/a225c227a481ad4f4c551dde24c3e846.png\" alt></p>\n<p>Activiti框架的流程运行于PVM模型之上，在流程运行时主要涉及到PVM中几个对象：ActivityImpl、TransitionImpl和ActivityBehavior</p>\n<ol>\n<li>ActivityImpl：ActivityImpl是流程节点的抽象，ActivityImpl维护流程图中节点的连线，包括有哪些进线，有哪些出线。另外还包含节点同步／异步执行等信息。</li>\n<li>TransitionImpl：TransitionImpl包含source和target两个属性，连接了两个流程节点。</li>\n<li>ActivityBehavior：每一个ActivityImpl对象都拥有一个ActivityBehavior对象，ActivityBehavior代表节点的行为。</li>\n</ol>\n<p>ActivityImpl、TransitionImpl和ActivityBehavior只是描述了流程的节点、迁移线和节点行为，真正要让ExecutionEntity流转起来，还需要AtomicOperation的驱动。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/c77300c6f1f7c467c05d47de2434cc74.png\" alt></p>\n<p>在ExecutionEntity的start方法中，调用了PROCESS_START，PROCESS_START做了几件事：</p>\n<ul>\n<li>获取流程定义级别定义的监听start事件的ExecutionListener，调用notify方法。</li>\n<li>如果开启了事件功能，发布ActivitiEntityWithVariablesEvent和ActivitiProcessStartedEvent。3、调用PROCESS_START_INITIAL。</li>\n</ul>\n<p>PROCESS_START_INITIAL也实现了类似的功能</p>\n<ul>\n<li>获取初始节点上定义的监听start事件的ExecutionListener，调用notify方法。</li>\n<li>调用ACTIVITY_EXECUTE。</li>\n</ul>\n<p>在流程执行中涉及的AtomicOperation的链路主要包括：</p>\n<ol>\n<li>ACTIVITY_EXECUTE：调用当前activity的behavior。</li>\n<li>TRANSITION_NOTIFY_LISTENER_END：某个activity节点执行完毕，调用节点上声明的监听end事件的ExecutionListener。</li>\n<li>TRANSITION_NOTIFY_LISTENER_TAKE：触发线上的ExecutionListener。</li>\n<li>TRANSITION_NOTIFY_LISTENER_START：某个activity节点即将开始执行，调用节点上的监听start事件的ExecutionListener。</li>\n</ol>\n<h2 id=\"4、Activiti组件介绍与参数传递\"><a href=\"#4、Activiti组件介绍与参数传递\" class=\"headerlink\" title=\"4、Activiti组件介绍与参数传递\"></a>4、Activiti组件介绍与参数传递</h2><h3 id=\"开始事件（startEvent）\"><a href=\"#开始事件（startEvent）\" class=\"headerlink\" title=\"开始事件（startEvent）\"></a>开始事件（startEvent）</h3><p>开始事件用来指明流程在哪里开始。开始事件的类型（流程在接收事件时启动， 还是在指定时间启动，等等），定义了流程如何启动， 这通过事件中不同的小图表来展示。 在XML中，这些类型是通过声明不同的子元素来区分的。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;startEvent id=&quot;start&quot; name=&quot;my start event&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结束事件（endEvent）\"><a href=\"#结束事件（endEvent）\" class=\"headerlink\" title=\"结束事件（endEvent）\"></a>结束事件（endEvent）</h3><p>End Event 结束事件表示（子）流程（分支）的结束。 结束事件都是触发事件。 这是说当流程达到结束事件，会触发一个结果。 结果的类型是通过事件的内部黑色图标表示的。 在XML内容中，是通过包含的子元素声明的。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;endEvent id=&quot;end&quot; name=&quot;my end event&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"顺序流（Sequence-Flow）\"><a href=\"#顺序流（Sequence-Flow）\" class=\"headerlink\" title=\"顺序流（Sequence Flow）\"></a>顺序流（Sequence Flow）</h3><p>顺序流是连接两个流程节点的连线。 流程执行完一个节点后，会沿着节点的所有外出顺序流继续执行。 就是说，BPMN 2.0默认的行为就是并发的： 两个外出顺序流会创造两个单独的，并发流程分支。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;theTask&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用户任务（UserTask）\"><a href=\"#用户任务（UserTask）\" class=\"headerlink\" title=\"用户任务（UserTask）\"></a>用户任务（UserTask）</h3><p>用户任务用来设置必须由人员完成的工作。  当流程执行到用户任务，会创建一个新任务，并把这个新任务加入到分配人或群组的任务列表中。             XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=&quot;theTask&quot; name=&quot;Important task&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"任务分配\"><a href=\"#任务分配\" class=\"headerlink\" title=\"任务分配\"></a>任务分配</h4><p>对于用户任务的分配有4种方法，一是个人任务分配，二是组任务分配，三是角色任务分配，四是JAVA自定义扩展的分配逻辑。</p>\n<h5 id=\"1、Assignee属性\"><a href=\"#1、Assignee属性\" class=\"headerlink\" title=\"1、Assignee属性\"></a>1、Assignee属性</h5><p>这个自定义扩展可以直接把用户任务分配给指定用户。我们可以在流程设计时直接指定办理人（此时的办理人可以写成定值如张三；也可以写成变量表达式如${userId}，在流程实例启动时再进行办理人的赋值也是可以的；也可以不写，通过JAVA自定义扩展来指定办理人。），也可以手动分配任务从一个人给另外一个人。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=“theTask” name=“my task” activiti:assignee=“张三” /&gt;</span><br></pre></td></tr></table></figure>\n<p>JAVA 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; variables = new HashMap&lt;String,Object&gt;();</span><br><span class=\"line\">variables.put(“userID”, “张三&quot;);</span><br><span class=\"line\">ProcessInstance pi = processEngine.getRuntimeService()</span><br><span class=\"line\">\t\t.startProcessInstanceByKey(&quot;taskProcess&quot;,variables);</span><br><span class=\"line\">processEngine.getTaskService().setAssignee(taskId, userId);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2、CandidateUsers-属性\"><a href=\"#2、CandidateUsers-属性\" class=\"headerlink\" title=\"2、CandidateUsers 属性\"></a>2、CandidateUsers 属性</h5><p>这个自定义扩展可以使用户成为任务的候选者。即将一个任务分配给一组用户，让这组用户成为这个任务的候选者，直到有一个用户认领了该任务成为该任务的参与者为止。</p>\n<p>既然是一个组任务，那么在有用户参与之前，可以对该任务的候选者进行添加和删除工作。也可以在用户认领任务后，将任务回退到组任务，前提是该用户认领的这个任务之前必须是组任务。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=“theTask” name=“my task” activiti:candidateUsers=“张三, 李四” /&gt;</span><br></pre></td></tr></table></figure>\n<p>JAVA 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">variables.put(“userIDs”, “张三,李四,王五&quot;);</span><br><span class=\"line\">ProcessInstance pi = processEngine.getRuntimeService()</span><br><span class=\"line\">\t.startProcessInstanceByKey(processDefinitionKey,variables);</span><br><span class=\"line\">processEngine.getTaskService().claim(taskId, userId);</span><br></pre></td></tr></table></figure>\n<h5 id=\"3、CandidateGroups属性\"><a href=\"#3、CandidateGroups属性\" class=\"headerlink\" title=\"3、CandidateGroups属性\"></a>3、CandidateGroups属性</h5><p>这个自定义扩展允许为任务定义一组候选者。即将一个任务分配给一组角色，让每个角色组的用户成为这个任务的候选者，直到有一个用户认领了该任务成为该任务的参与者为止。</p>\n<p>既然是一个组任务，那么在有用户参与之前，可以对该任务的候选者进行添加和删除工作。也可以在用户认领任务后，将任务回退到组任务，前提是该用户认领的这个任务之前必须是组任务。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=“theTask” name=“my task” activiti:candidateGroups=“management, accountancy” /&gt;</span><br></pre></td></tr></table></figure>\n<p>JAVA 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IdentityService identityService =processEngine.getIdentityService();</span><br><span class=\"line\">identityService.saveGroup(new GroupEntity(&quot;部门经理&quot;));</span><br><span class=\"line\">identityService.saveUser(new UserEntity(&quot;张三&quot;));</span><br><span class=\"line\">identityService.saveUser(new UserEntity(&quot;李四&quot;))</span><br><span class=\"line\">identityService.createMembership(&quot;张三&quot;, &quot;部门经理&quot;);</span><br><span class=\"line\">identityService.createMembership(&quot;李四&quot;, &quot;部门经理&quot;)</span><br><span class=\"line\">processEngine.getTaskService().claim(taskId, userId);</span><br></pre></td></tr></table></figure>\n<h5 id=\"4、定义扩展JAVA类\"><a href=\"#4、定义扩展JAVA类\" class=\"headerlink\" title=\"4、定义扩展JAVA类\"></a>4、定义扩展JAVA类</h5><p>如果以上方案仍然不够，那么可以实现了任务监听器TaskListener的JAVA类来自定义分配逻辑。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;userTask id=&quot;task1&quot; name=&quot;My task&quot; &gt;</span><br><span class=\"line\">    &lt;extensionElements&gt;</span><br><span class=\"line\">\t    &lt;activiti:taskListener event=&quot;create&quot;class=&quot;org.activiti.MyAssignmentHandler&quot; /&gt;</span><br><span class=\"line\">    &lt;/extensionElements&gt;</span><br><span class=\"line\">&lt;/userTask&gt;</span><br></pre></td></tr></table></figure>\n<p>JAVA代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyAssignmentHandler implements TaskListener &#123;</span><br><span class=\"line\">    public void notify(DelegateTask delegateTask) &#123;</span><br><span class=\"line\">\t    delegateTask.setAssignee(&quot;kermit&quot;);</span><br><span class=\"line\">\t    delegateTask.addCandidateUser(&quot;fozzie&quot;);</span><br><span class=\"line\">\t    delegateTask.addCandidateGroup(&quot;management&quot;);</span><br><span class=\"line\">\t    ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"任务完成\"><a href=\"#任务完成\" class=\"headerlink\" title=\"任务完成\"></a>任务完成</h4><p>Activiti中当前任务节点完成任务时，只需要调用TaskService服务中的complete方法即可</p>\n<h3 id=\"服务任务（Service-Task）\"><a href=\"#服务任务（Service-Task）\" class=\"headerlink\" title=\"服务任务（Service Task）\"></a>服务任务（Service Task）</h3><p>Java 服务任务用来调用外部 Java 类。</p>\n<p>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;serviceTask id=&quot; serviceTask1“  name=&quot;My Java Service Task&quot;activiti:class=“com.demo.MyJavaDelegate1&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"排他网关（Exclusive-Gate-Way）\"><a href=\"#排他网关（Exclusive-Gate-Way）\" class=\"headerlink\" title=\"排他网关（Exclusive Gate Way）\"></a>排他网关（Exclusive Gate Way）</h3><p>用来对流程中的决定进行建模。流程执行到这种gateway 时，按照输出流定义的顺序对它们进行计算。条件为 true 的顺序流（或没有设置条件，概念上顺序流上定义为’true’）被选取继续执行流程。</p>\n<h5 id=\"模型实例\"><a href=\"#模型实例\" class=\"headerlink\" title=\"模型实例\"></a>模型实例</h5><p><img src=\"https://img.fengjr.com/image/2019/06/20/2457b668bcb956f50a729c57385f3a5a.png\" alt></p>\n<h3 id=\"并行网关（Parallel-Gate-Way）\"><a href=\"#并行网关（Parallel-Gate-Way）\" class=\"headerlink\" title=\"并行网关（Parallel Gate Way）\"></a>并行网关（Parallel Gate Way）</h3><p>并行网关的功能要根据输入和输出的顺序流，它能拆分出多个执行路径，或多个输入执行路径进行合并。</p>\n<p><strong>拆分（fork）</strong> ：并行执行所有的输出顺序流，为每一个顺序流创建一个并行执行路径。</p>\n<p><strong>合并（join）</strong> ：所有到达 parallel gataway 的并发性的执行路径都等待于此，直到每个输入流都执行到。然后，流程经由 joining gateway 继续向下执行。<br>XML结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parallelGateway id=&quot;myParallelGateway&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"模型实例-1\"><a href=\"#模型实例-1\" class=\"headerlink\" title=\"模型实例\"></a>模型实例</h5><p><img src=\"https://img.fengjr.com/image/2019/06/20/ad2e4433f234fcd31d2480f65b5dd427.png\" alt></p>\n<h2 id=\"5、Activiti集成Spring\"><a href=\"#5、Activiti集成Spring\" class=\"headerlink\" title=\"5、Activiti集成Spring\"></a>5、Activiti集成Spring</h2><p>Activiti的所有Service服务都是通过ProcessEngine来获取的。通过查看源文件，可以发现最终是通过 ProcessEngineConfiguration来创建流程引擎对象的。而Activiti做的更好的地方是：ProcessEngineConfiguration这个抽象类有多种实现方式，这意味着我们可以通过一种实现方式把ProcessEngine作为一个普通的Spring  bean进行配置。同样，在流程引擎配置进来后，它所包含的Service服务也可以当作一个Spring Bean进行配置进来。</p>\n<p>XML代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   </span><br><span class=\"line\">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class=\"line\">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;  </span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </span><br><span class=\"line\">       xsi:schemaLocation=“</span><br><span class=\"line\">\thttp://www.springframework.org/schema/beans </span><br><span class=\"line\">\thttp://www.springframework.org/schema/beans/spring-beans.xsd  </span><br><span class=\"line\">                 http://www.springframework.org/schema/context</span><br><span class=\"line\">\t http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span><br><span class=\"line\">                 http://www.springframework.org/schema/tx</span><br><span class=\"line\">\thttp://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt;  </span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\">&lt;!-- spring负责创建流程引擎的配置文件 --&gt;</span><br><span class=\"line\">&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt; </span><br><span class=\"line\">    &lt;!-- 数据源 --&gt; </span><br><span class=\"line\">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  </span><br><span class=\"line\">    &lt;!-- 配置事务管理器，统一事务 --&gt;</span><br><span class=\"line\">    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  </span><br><span class=\"line\">    &lt;!-- 设置建表策略，如果没有表，自动创建表 --&gt;</span><br><span class=\"line\">    &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot; /&gt;  </span><br><span class=\"line\">    &lt;property name=&quot;jobExecutorActivate&quot; value=&quot;false&quot; /&gt;  </span><br><span class=\"line\">   &lt;!-- 设置记录历史级别 none:activity:audit:full --&gt;</span><br><span class=\"line\">    &lt;property name=&quot;history&quot; value=&quot;full&quot; /&gt;  </span><br><span class=\"line\">    &lt;property name=&quot;processDefinitionCacheLimit&quot; value=&quot;10&quot; /&gt;  </span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/864e0ebbf9226f542340beb29edbc121.png\" alt></p>\n"},{"title":"搭建你的第一个博客","comments":1,"date":"2019-06-11T10:39:03.000Z","updated":"2020-06-10T06:02:07.413Z","author":"jun.zhou","_content":"\n![](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1970559802,386658033&fm=26&gp=0.jpg)\n\n# 项目背景\nweb前端组每周会进行技术分享，分享的介质一般都是用ppt，但是ppt是属于纲领性的文件，对于技术的一些细节还是表现的不是很到位，所以前端组想搭建一个博客的平台，来承载前端技术成果，也方便大家能够对积累的成果实时查看和学习。\n# 技术选型\n因为之前用 jekyll 写过博客，但是感觉 jekyll 太重，环境配置太麻烦，当初也踩了很多坑，所以研究了一下目前主流的博客三类框架：\n#### 1) jekyll\n> jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n优点：\n- jekyll是一个生成工具，不需要数据库，将生成的目录放入网站中即可\n- 能部署到github上，不需要vps，因为是静态的，迁移方便\n- 支持markdown，并且可以免费的放在github上，github会帮你生成自己独有的域名\n- 可以直接在git仓库里面修改代码和编辑博客\n\n缺点：\n- 安装比较繁琐，环境搭建比较复杂，前期学习成本较高\n- jekyll用的liquid语法并不是太友好，官方文档不太友好，学习起来比较困难\n#### 2) wordpress\n> WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。\n\nWordPress我并没有用过，因为我想要做的是静态的博客站，所以WordPress我并不中意，以下是百度关于WordPress的优缺点介绍，供大家参考。\n\n优点：\n- WordPress 功能强大、扩展性强，这主要得益于其插件众多，易于扩充功能，基本上一个完整网站该有的功能，通过其第三方插件都能实现所有功能\n- wordpress搭建的博客对seo搜索引擎友好，收录也快，排名靠前；\n- wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。\n- 主题很多，网站上一大片都是wordpress的主题，各色各样，应有尽有！\n- wordpress备份和网站转移比较方便，原站点使用站内工具导出后，使用WordPress Importer插件就能方便地将内容导入新网站。\n- wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。\n\n缺点：\n- wordpress源码系统初始内容基本只是一个框架，需要时间自己搭建；\n- 插件虽多，但是不能安装太多插件，否则会拖累网站速度和降低用户体验；\n- 服务器空间选择自由较小！\n- 静态化较差，确切地说是真正静态化做得不好，如果要想对整个网站生成真正静态化页面，还做不好，最多只能生成首页和文章页静态页面，所以只能对整站实现伪静态化!\n- wordpress的博客程序定位，简单的数据库层等都注定了他不能适应大数据。\n\n#### 3) hexo\n> Hexo是一个基于node.js的静态博客生成系统，它使用markdown语法来写作，同时支持丰富的自定义标签系统。   \n用户在本地安装Hexo系统并进行写作，通过一条命令，Hexo可以自动生成静态页面，并发布到多个平台上。\n与传统的博客相比，Hexo可以说是一个本地运行远程发布的博客程序。\n\n优点：\n- 快速、简介，而且可以搭建在github上，公司的可以搭建在gitlab上\n- 操作简单，官方文档清晰，也比较全，容易上手\n- 安装方便，node对于前端来说比较熟悉\n- 支持markdown，而且生成的是静态博客\n缺点：\n- 没有后台和插件的支持，需要一些网页知识，学习成本略高\n- 每次换电脑需要重新安装和配置编译环境，比较繁琐\n\n最后我选择了 hexo，一来是我中了它属于静态博客，安装也比较简单，学习成本对我来说比较地，还有是因为也看到很多博主安利，所以试了试感觉还可以，主题也比较多，可以满足自己的需求。\n\n# 搭建流程\n## 环境搭建和安装\nhexo的环境搭建非常简单，可参考官方案例\n\n```\nnpm install hexo-cli -g\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n四则命令就可以启动一个hexo项目，其中blog就是你所要建立的博客仓库名，打开 http://localhost:4000 即可看到默认的博客主页\n\n## 项目结构介绍\n新建完成后，大家可以在文件夹中看到如下的目录：\n\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n|   ├──post.md\n|   ├──draft.md\n|   ├──page.md\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n### _config.yml\n这个文件是存放网站的配置信息，网站的标题、副标题、语言、分页、部署等都在这个配置文件中，相关配置文档可查看[配置](https://hexo.io/zh-cn/docs/configuration)\n### package.json\n这是应用程序的信息，程序中需要的npm包和程序的版本都会在这个中体现\n\n```\n{\n  \"name\": \"hexo-site\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"hexo\": {\n    \"version\": \"3.8.0\"\n  },\n  \"dependencies\": {\n    \"hexo\": \"^3.8.0\",\n    \"hexo-codepen\": \"^0.1.1\",\n    \"hexo-deployer-git\": \"^1.0.0\",\n    \"hexo-generator-archive\": \"^0.1.5\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.1\",\n    \"hexo-generator-json-content\": \"^4.1.3\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-renderer-ejs\": \"^0.3.1\",\n    \"hexo-renderer-jade\": \"^0.3.0\",\n    \"hexo-renderer-marked\": \"^0.3.2\",\n    \"hexo-renderer-stylus\": \"^0.3.3\",\n    \"hexo-server\": \"^0.3.3\"\n  }\n}\n\n```\n其中可以看到，程序的名称、版本，所使用的hexo的版本，和依赖的资源\n\n### scaffolds\n[模版 ](https://hexo.io/zh-cn/docs/writing)文件夹，当你新建文章时，hexo会按照scaffold来建立文件，比如之前模版文件夹中有_drafts 和 _post, _drafts 代表的是草稿文件夹， _post代表的是发布的文件夹，当执行\n> hexo new post first\n\n程序会创建一个已 _post 模版为基础的名字为 first 的md文件，该文件会在 source/_post 文件夹中\n\n### source\nsoruce 文件夹中存放用户资源的地方，除 `_posts` 文件夹之外，开头命名为 `_` (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\n\n### themes\n[主题](https://hexo.io/zh-cn/docs/themes) 文件夹，hexo会根据主题来渲染静态页面，用户可以自由切换主题，而不需要更改资源文件，做到了资源和样式分离互不影响的功能\n\n## 编写和发布博文\n\n之前介绍过，创建博客可以通过命令创建，发布博文同样也非常简单，只需要三步即可：\n### 第一步：创建博文\n\n```\nhexo new first\n```\n\n创建名为first的md文件，并且编写文件\n### 第二步：渲染静态文件\n\n```\nhexo g\n```\n该命令是将你编写的文件生成为html文件，存放到public文件下面，完整的命令为 hexo generate\n\n### 第三步：上传文件\n\n\n```\nhexo d\n```\n该命令是按照_config.yml 配置中的发布方式，将public里的静态资源上传到你的线上代码仓库（gitlab或者其它）\n\n仅需以上三步即可将你的项目托管到你的代码仓库中，deploy中还可以支持 heroku、netlify、rsync、openShift、ftpsync、\nsftp 等众多方式，还可以自己将生成的文件放在任何你想放的地方，[相关配置](https://hexo.io/zh-cn/docs/deployment)\n\n# 总结\n总的来说，hexo是一个非常方便，也很适合学习的一个博客工具，其中配置的东西还很多，这期先给大家讲一个大概，之后的篇幅会给大家具体的讲解其中主题更换、hexo中博客的语法等的内容。","source":"_posts/2019-06-11-hexo-course-1.md","raw":"---\ntitle: 搭建你的第一个博客\ncomments: true\ndate: 2019-06-11 18:39:03\ntags:\n- hexo\n- js\n- html\n- css\n- node\nupdated:\nauthor: jun.zhou\ncategories: \n- WEB前端\n---\n\n![](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1970559802,386658033&fm=26&gp=0.jpg)\n\n# 项目背景\nweb前端组每周会进行技术分享，分享的介质一般都是用ppt，但是ppt是属于纲领性的文件，对于技术的一些细节还是表现的不是很到位，所以前端组想搭建一个博客的平台，来承载前端技术成果，也方便大家能够对积累的成果实时查看和学习。\n# 技术选型\n因为之前用 jekyll 写过博客，但是感觉 jekyll 太重，环境配置太麻烦，当初也踩了很多坑，所以研究了一下目前主流的博客三类框架：\n#### 1) jekyll\n> jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。\n\n优点：\n- jekyll是一个生成工具，不需要数据库，将生成的目录放入网站中即可\n- 能部署到github上，不需要vps，因为是静态的，迁移方便\n- 支持markdown，并且可以免费的放在github上，github会帮你生成自己独有的域名\n- 可以直接在git仓库里面修改代码和编辑博客\n\n缺点：\n- 安装比较繁琐，环境搭建比较复杂，前期学习成本较高\n- jekyll用的liquid语法并不是太友好，官方文档不太友好，学习起来比较困难\n#### 2) wordpress\n> WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。\n\nWordPress我并没有用过，因为我想要做的是静态的博客站，所以WordPress我并不中意，以下是百度关于WordPress的优缺点介绍，供大家参考。\n\n优点：\n- WordPress 功能强大、扩展性强，这主要得益于其插件众多，易于扩充功能，基本上一个完整网站该有的功能，通过其第三方插件都能实现所有功能\n- wordpress搭建的博客对seo搜索引擎友好，收录也快，排名靠前；\n- wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。\n- 主题很多，网站上一大片都是wordpress的主题，各色各样，应有尽有！\n- wordpress备份和网站转移比较方便，原站点使用站内工具导出后，使用WordPress Importer插件就能方便地将内容导入新网站。\n- wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。\n\n缺点：\n- wordpress源码系统初始内容基本只是一个框架，需要时间自己搭建；\n- 插件虽多，但是不能安装太多插件，否则会拖累网站速度和降低用户体验；\n- 服务器空间选择自由较小！\n- 静态化较差，确切地说是真正静态化做得不好，如果要想对整个网站生成真正静态化页面，还做不好，最多只能生成首页和文章页静态页面，所以只能对整站实现伪静态化!\n- wordpress的博客程序定位，简单的数据库层等都注定了他不能适应大数据。\n\n#### 3) hexo\n> Hexo是一个基于node.js的静态博客生成系统，它使用markdown语法来写作，同时支持丰富的自定义标签系统。   \n用户在本地安装Hexo系统并进行写作，通过一条命令，Hexo可以自动生成静态页面，并发布到多个平台上。\n与传统的博客相比，Hexo可以说是一个本地运行远程发布的博客程序。\n\n优点：\n- 快速、简介，而且可以搭建在github上，公司的可以搭建在gitlab上\n- 操作简单，官方文档清晰，也比较全，容易上手\n- 安装方便，node对于前端来说比较熟悉\n- 支持markdown，而且生成的是静态博客\n缺点：\n- 没有后台和插件的支持，需要一些网页知识，学习成本略高\n- 每次换电脑需要重新安装和配置编译环境，比较繁琐\n\n最后我选择了 hexo，一来是我中了它属于静态博客，安装也比较简单，学习成本对我来说比较地，还有是因为也看到很多博主安利，所以试了试感觉还可以，主题也比较多，可以满足自己的需求。\n\n# 搭建流程\n## 环境搭建和安装\nhexo的环境搭建非常简单，可参考官方案例\n\n```\nnpm install hexo-cli -g\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n四则命令就可以启动一个hexo项目，其中blog就是你所要建立的博客仓库名，打开 http://localhost:4000 即可看到默认的博客主页\n\n## 项目结构介绍\n新建完成后，大家可以在文件夹中看到如下的目录：\n\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n|   ├──post.md\n|   ├──draft.md\n|   ├──page.md\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n### _config.yml\n这个文件是存放网站的配置信息，网站的标题、副标题、语言、分页、部署等都在这个配置文件中，相关配置文档可查看[配置](https://hexo.io/zh-cn/docs/configuration)\n### package.json\n这是应用程序的信息，程序中需要的npm包和程序的版本都会在这个中体现\n\n```\n{\n  \"name\": \"hexo-site\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"hexo\": {\n    \"version\": \"3.8.0\"\n  },\n  \"dependencies\": {\n    \"hexo\": \"^3.8.0\",\n    \"hexo-codepen\": \"^0.1.1\",\n    \"hexo-deployer-git\": \"^1.0.0\",\n    \"hexo-generator-archive\": \"^0.1.5\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.1\",\n    \"hexo-generator-json-content\": \"^4.1.3\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-renderer-ejs\": \"^0.3.1\",\n    \"hexo-renderer-jade\": \"^0.3.0\",\n    \"hexo-renderer-marked\": \"^0.3.2\",\n    \"hexo-renderer-stylus\": \"^0.3.3\",\n    \"hexo-server\": \"^0.3.3\"\n  }\n}\n\n```\n其中可以看到，程序的名称、版本，所使用的hexo的版本，和依赖的资源\n\n### scaffolds\n[模版 ](https://hexo.io/zh-cn/docs/writing)文件夹，当你新建文章时，hexo会按照scaffold来建立文件，比如之前模版文件夹中有_drafts 和 _post, _drafts 代表的是草稿文件夹， _post代表的是发布的文件夹，当执行\n> hexo new post first\n\n程序会创建一个已 _post 模版为基础的名字为 first 的md文件，该文件会在 source/_post 文件夹中\n\n### source\nsoruce 文件夹中存放用户资源的地方，除 `_posts` 文件夹之外，开头命名为 `_` (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\n\n### themes\n[主题](https://hexo.io/zh-cn/docs/themes) 文件夹，hexo会根据主题来渲染静态页面，用户可以自由切换主题，而不需要更改资源文件，做到了资源和样式分离互不影响的功能\n\n## 编写和发布博文\n\n之前介绍过，创建博客可以通过命令创建，发布博文同样也非常简单，只需要三步即可：\n### 第一步：创建博文\n\n```\nhexo new first\n```\n\n创建名为first的md文件，并且编写文件\n### 第二步：渲染静态文件\n\n```\nhexo g\n```\n该命令是将你编写的文件生成为html文件，存放到public文件下面，完整的命令为 hexo generate\n\n### 第三步：上传文件\n\n\n```\nhexo d\n```\n该命令是按照_config.yml 配置中的发布方式，将public里的静态资源上传到你的线上代码仓库（gitlab或者其它）\n\n仅需以上三步即可将你的项目托管到你的代码仓库中，deploy中还可以支持 heroku、netlify、rsync、openShift、ftpsync、\nsftp 等众多方式，还可以自己将生成的文件放在任何你想放的地方，[相关配置](https://hexo.io/zh-cn/docs/deployment)\n\n# 总结\n总的来说，hexo是一个非常方便，也很适合学习的一个博客工具，其中配置的东西还很多，这期先给大家讲一个大概，之后的篇幅会给大家具体的讲解其中主题更换、hexo中博客的语法等的内容。","slug":"hexo-course-1","published":1,"_id":"cjxfsbp490001hgq59tu9glg6","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1970559802,386658033&amp;fm=26&amp;gp=0.jpg\" alt></p>\n<h1 id=\"项目背景\"><a href=\"#项目背景\" class=\"headerlink\" title=\"项目背景\"></a>项目背景</h1><p>web前端组每周会进行技术分享，分享的介质一般都是用ppt，但是ppt是属于纲领性的文件，对于技术的一些细节还是表现的不是很到位，所以前端组想搭建一个博客的平台，来承载前端技术成果，也方便大家能够对积累的成果实时查看和学习。</p>\n<h1 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h1><p>因为之前用 jekyll 写过博客，但是感觉 jekyll 太重，环境配置太麻烦，当初也踩了很多坑，所以研究了一下目前主流的博客三类框架：</p>\n<h4 id=\"1-jekyll\"><a href=\"#1-jekyll\" class=\"headerlink\" title=\"1) jekyll\"></a>1) jekyll</h4><blockquote>\n<p>jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li>jekyll是一个生成工具，不需要数据库，将生成的目录放入网站中即可</li>\n<li>能部署到github上，不需要vps，因为是静态的，迁移方便</li>\n<li>支持markdown，并且可以免费的放在github上，github会帮你生成自己独有的域名</li>\n<li>可以直接在git仓库里面修改代码和编辑博客</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>安装比较繁琐，环境搭建比较复杂，前期学习成本较高</li>\n<li>jekyll用的liquid语法并不是太友好，官方文档不太友好，学习起来比较困难<h4 id=\"2-wordpress\"><a href=\"#2-wordpress\" class=\"headerlink\" title=\"2) wordpress\"></a>2) wordpress</h4><blockquote>\n<p>WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。</p>\n</blockquote>\n</li>\n</ul>\n<p>WordPress我并没有用过，因为我想要做的是静态的博客站，所以WordPress我并不中意，以下是百度关于WordPress的优缺点介绍，供大家参考。</p>\n<p>优点：</p>\n<ul>\n<li>WordPress 功能强大、扩展性强，这主要得益于其插件众多，易于扩充功能，基本上一个完整网站该有的功能，通过其第三方插件都能实现所有功能</li>\n<li>wordpress搭建的博客对seo搜索引擎友好，收录也快，排名靠前；</li>\n<li>wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。</li>\n<li>主题很多，网站上一大片都是wordpress的主题，各色各样，应有尽有！</li>\n<li>wordpress备份和网站转移比较方便，原站点使用站内工具导出后，使用WordPress Importer插件就能方便地将内容导入新网站。</li>\n<li>wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>wordpress源码系统初始内容基本只是一个框架，需要时间自己搭建；</li>\n<li>插件虽多，但是不能安装太多插件，否则会拖累网站速度和降低用户体验；</li>\n<li>服务器空间选择自由较小！</li>\n<li>静态化较差，确切地说是真正静态化做得不好，如果要想对整个网站生成真正静态化页面，还做不好，最多只能生成首页和文章页静态页面，所以只能对整站实现伪静态化!</li>\n<li>wordpress的博客程序定位，简单的数据库层等都注定了他不能适应大数据。</li>\n</ul>\n<h4 id=\"3-hexo\"><a href=\"#3-hexo\" class=\"headerlink\" title=\"3) hexo\"></a>3) hexo</h4><blockquote>\n<p>Hexo是一个基于node.js的静态博客生成系统，它使用markdown语法来写作，同时支持丰富的自定义标签系统。<br>用户在本地安装Hexo系统并进行写作，通过一条命令，Hexo可以自动生成静态页面，并发布到多个平台上。<br>与传统的博客相比，Hexo可以说是一个本地运行远程发布的博客程序。</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li>快速、简介，而且可以搭建在github上，公司的可以搭建在gitlab上</li>\n<li>操作简单，官方文档清晰，也比较全，容易上手</li>\n<li>安装方便，node对于前端来说比较熟悉</li>\n<li>支持markdown，而且生成的是静态博客<br>缺点：</li>\n<li>没有后台和插件的支持，需要一些网页知识，学习成本略高</li>\n<li>每次换电脑需要重新安装和配置编译环境，比较繁琐</li>\n</ul>\n<p>最后我选择了 hexo，一来是我中了它属于静态博客，安装也比较简单，学习成本对我来说比较地，还有是因为也看到很多博主安利，所以试了试感觉还可以，主题也比较多，可以满足自己的需求。</p>\n<h1 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h1><h2 id=\"环境搭建和安装\"><a href=\"#环境搭建和安装\" class=\"headerlink\" title=\"环境搭建和安装\"></a>环境搭建和安装</h2><p>hexo的环境搭建非常简单，可参考官方案例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>四则命令就可以启动一个hexo项目，其中blog就是你所要建立的博客仓库名，打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 即可看到默认的博客主页</p>\n<h2 id=\"项目结构介绍\"><a href=\"#项目结构介绍\" class=\"headerlink\" title=\"项目结构介绍\"></a>项目结构介绍</h2><p>新建完成后，大家可以在文件夹中看到如下的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">|   ├──post.md</span><br><span class=\"line\">|   ├──draft.md</span><br><span class=\"line\">|   ├──page.md</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<h3 id=\"config-yml\"><a href=\"#config-yml\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>这个文件是存放网站的配置信息，网站的标题、副标题、语言、分页、部署等都在这个配置文件中，相关配置文档可查看<a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">配置</a></p>\n<h3 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h3><p>这是应用程序的信息，程序中需要的npm包和程序的版本都会在这个中体现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;hexo&quot;: &#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;3.8.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class=\"line\">    &quot;hexo-codepen&quot;: &quot;^0.1.1&quot;,</span><br><span class=\"line\">    &quot;hexo-deployer-git&quot;: &quot;^1.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-json-content&quot;: &quot;^4.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-jade&quot;: &quot;^0.3.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class=\"line\">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中可以看到，程序的名称、版本，所使用的hexo的版本，和依赖的资源</p>\n<h3 id=\"scaffolds\"><a href=\"#scaffolds\" class=\"headerlink\" title=\"scaffolds\"></a>scaffolds</h3><p><a href=\"https://hexo.io/zh-cn/docs/writing\" target=\"_blank\" rel=\"noopener\">模版 </a>文件夹，当你新建文章时，hexo会按照scaffold来建立文件，比如之前模版文件夹中有_drafts 和 _post, _drafts 代表的是草稿文件夹， _post代表的是发布的文件夹，当执行</p>\n<blockquote>\n<p>hexo new post first</p>\n</blockquote>\n<p>程序会创建一个已 _post 模版为基础的名字为 first 的md文件，该文件会在 source/_post 文件夹中</p>\n<h3 id=\"source\"><a href=\"#source\" class=\"headerlink\" title=\"source\"></a>source</h3><p>soruce 文件夹中存放用户资源的地方，除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>\n<h3 id=\"themes\"><a href=\"#themes\" class=\"headerlink\" title=\"themes\"></a>themes</h3><p><a href=\"https://hexo.io/zh-cn/docs/themes\" target=\"_blank\" rel=\"noopener\">主题</a> 文件夹，hexo会根据主题来渲染静态页面，用户可以自由切换主题，而不需要更改资源文件，做到了资源和样式分离互不影响的功能</p>\n<h2 id=\"编写和发布博文\"><a href=\"#编写和发布博文\" class=\"headerlink\" title=\"编写和发布博文\"></a>编写和发布博文</h2><p>之前介绍过，创建博客可以通过命令创建，发布博文同样也非常简单，只需要三步即可：</p>\n<h3 id=\"第一步：创建博文\"><a href=\"#第一步：创建博文\" class=\"headerlink\" title=\"第一步：创建博文\"></a>第一步：创建博文</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new first</span><br></pre></td></tr></table></figure>\n<p>创建名为first的md文件，并且编写文件</p>\n<h3 id=\"第二步：渲染静态文件\"><a href=\"#第二步：渲染静态文件\" class=\"headerlink\" title=\"第二步：渲染静态文件\"></a>第二步：渲染静态文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<p>该命令是将你编写的文件生成为html文件，存放到public文件下面，完整的命令为 hexo generate</p>\n<h3 id=\"第三步：上传文件\"><a href=\"#第三步：上传文件\" class=\"headerlink\" title=\"第三步：上传文件\"></a>第三步：上传文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>该命令是按照_config.yml 配置中的发布方式，将public里的静态资源上传到你的线上代码仓库（gitlab或者其它）</p>\n<p>仅需以上三步即可将你的项目托管到你的代码仓库中，deploy中还可以支持 heroku、netlify、rsync、openShift、ftpsync、<br>sftp 等众多方式，还可以自己将生成的文件放在任何你想放的地方，<a href=\"https://hexo.io/zh-cn/docs/deployment\" target=\"_blank\" rel=\"noopener\">相关配置</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总的来说，hexo是一个非常方便，也很适合学习的一个博客工具，其中配置的东西还很多，这期先给大家讲一个大概，之后的篇幅会给大家具体的讲解其中主题更换、hexo中博客的语法等的内容。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1970559802,386658033&amp;fm=26&amp;gp=0.jpg\" alt></p>\n<h1 id=\"项目背景\"><a href=\"#项目背景\" class=\"headerlink\" title=\"项目背景\"></a>项目背景</h1><p>web前端组每周会进行技术分享，分享的介质一般都是用ppt，但是ppt是属于纲领性的文件，对于技术的一些细节还是表现的不是很到位，所以前端组想搭建一个博客的平台，来承载前端技术成果，也方便大家能够对积累的成果实时查看和学习。</p>\n<h1 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h1><p>因为之前用 jekyll 写过博客，但是感觉 jekyll 太重，环境配置太麻烦，当初也踩了很多坑，所以研究了一下目前主流的博客三类框架：</p>\n<h4 id=\"1-jekyll\"><a href=\"#1-jekyll\" class=\"headerlink\" title=\"1) jekyll\"></a>1) jekyll</h4><blockquote>\n<p>jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li>jekyll是一个生成工具，不需要数据库，将生成的目录放入网站中即可</li>\n<li>能部署到github上，不需要vps，因为是静态的，迁移方便</li>\n<li>支持markdown，并且可以免费的放在github上，github会帮你生成自己独有的域名</li>\n<li>可以直接在git仓库里面修改代码和编辑博客</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>安装比较繁琐，环境搭建比较复杂，前期学习成本较高</li>\n<li>jekyll用的liquid语法并不是太友好，官方文档不太友好，学习起来比较困难<h4 id=\"2-wordpress\"><a href=\"#2-wordpress\" class=\"headerlink\" title=\"2) wordpress\"></a>2) wordpress</h4><blockquote>\n<p>WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。</p>\n</blockquote>\n</li>\n</ul>\n<p>WordPress我并没有用过，因为我想要做的是静态的博客站，所以WordPress我并不中意，以下是百度关于WordPress的优缺点介绍，供大家参考。</p>\n<p>优点：</p>\n<ul>\n<li>WordPress 功能强大、扩展性强，这主要得益于其插件众多，易于扩充功能，基本上一个完整网站该有的功能，通过其第三方插件都能实现所有功能</li>\n<li>wordpress搭建的博客对seo搜索引擎友好，收录也快，排名靠前；</li>\n<li>wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。</li>\n<li>主题很多，网站上一大片都是wordpress的主题，各色各样，应有尽有！</li>\n<li>wordpress备份和网站转移比较方便，原站点使用站内工具导出后，使用WordPress Importer插件就能方便地将内容导入新网站。</li>\n<li>wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>wordpress源码系统初始内容基本只是一个框架，需要时间自己搭建；</li>\n<li>插件虽多，但是不能安装太多插件，否则会拖累网站速度和降低用户体验；</li>\n<li>服务器空间选择自由较小！</li>\n<li>静态化较差，确切地说是真正静态化做得不好，如果要想对整个网站生成真正静态化页面，还做不好，最多只能生成首页和文章页静态页面，所以只能对整站实现伪静态化!</li>\n<li>wordpress的博客程序定位，简单的数据库层等都注定了他不能适应大数据。</li>\n</ul>\n<h4 id=\"3-hexo\"><a href=\"#3-hexo\" class=\"headerlink\" title=\"3) hexo\"></a>3) hexo</h4><blockquote>\n<p>Hexo是一个基于node.js的静态博客生成系统，它使用markdown语法来写作，同时支持丰富的自定义标签系统。<br>用户在本地安装Hexo系统并进行写作，通过一条命令，Hexo可以自动生成静态页面，并发布到多个平台上。<br>与传统的博客相比，Hexo可以说是一个本地运行远程发布的博客程序。</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li>快速、简介，而且可以搭建在github上，公司的可以搭建在gitlab上</li>\n<li>操作简单，官方文档清晰，也比较全，容易上手</li>\n<li>安装方便，node对于前端来说比较熟悉</li>\n<li>支持markdown，而且生成的是静态博客<br>缺点：</li>\n<li>没有后台和插件的支持，需要一些网页知识，学习成本略高</li>\n<li>每次换电脑需要重新安装和配置编译环境，比较繁琐</li>\n</ul>\n<p>最后我选择了 hexo，一来是我中了它属于静态博客，安装也比较简单，学习成本对我来说比较地，还有是因为也看到很多博主安利，所以试了试感觉还可以，主题也比较多，可以满足自己的需求。</p>\n<h1 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h1><h2 id=\"环境搭建和安装\"><a href=\"#环境搭建和安装\" class=\"headerlink\" title=\"环境搭建和安装\"></a>环境搭建和安装</h2><p>hexo的环境搭建非常简单，可参考官方案例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>四则命令就可以启动一个hexo项目，其中blog就是你所要建立的博客仓库名，打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a> 即可看到默认的博客主页</p>\n<h2 id=\"项目结构介绍\"><a href=\"#项目结构介绍\" class=\"headerlink\" title=\"项目结构介绍\"></a>项目结构介绍</h2><p>新建完成后，大家可以在文件夹中看到如下的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">|   ├──post.md</span><br><span class=\"line\">|   ├──draft.md</span><br><span class=\"line\">|   ├──page.md</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<h3 id=\"config-yml\"><a href=\"#config-yml\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>这个文件是存放网站的配置信息，网站的标题、副标题、语言、分页、部署等都在这个配置文件中，相关配置文档可查看<a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">配置</a></p>\n<h3 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h3><p>这是应用程序的信息，程序中需要的npm包和程序的版本都会在这个中体现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;hexo&quot;: &#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;3.8.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class=\"line\">    &quot;hexo-codepen&quot;: &quot;^0.1.1&quot;,</span><br><span class=\"line\">    &quot;hexo-deployer-git&quot;: &quot;^1.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-json-content&quot;: &quot;^4.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-jade&quot;: &quot;^0.3.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class=\"line\">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中可以看到，程序的名称、版本，所使用的hexo的版本，和依赖的资源</p>\n<h3 id=\"scaffolds\"><a href=\"#scaffolds\" class=\"headerlink\" title=\"scaffolds\"></a>scaffolds</h3><p><a href=\"https://hexo.io/zh-cn/docs/writing\" target=\"_blank\" rel=\"noopener\">模版 </a>文件夹，当你新建文章时，hexo会按照scaffold来建立文件，比如之前模版文件夹中有_drafts 和 _post, _drafts 代表的是草稿文件夹， _post代表的是发布的文件夹，当执行</p>\n<blockquote>\n<p>hexo new post first</p>\n</blockquote>\n<p>程序会创建一个已 _post 模版为基础的名字为 first 的md文件，该文件会在 source/_post 文件夹中</p>\n<h3 id=\"source\"><a href=\"#source\" class=\"headerlink\" title=\"source\"></a>source</h3><p>soruce 文件夹中存放用户资源的地方，除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>\n<h3 id=\"themes\"><a href=\"#themes\" class=\"headerlink\" title=\"themes\"></a>themes</h3><p><a href=\"https://hexo.io/zh-cn/docs/themes\" target=\"_blank\" rel=\"noopener\">主题</a> 文件夹，hexo会根据主题来渲染静态页面，用户可以自由切换主题，而不需要更改资源文件，做到了资源和样式分离互不影响的功能</p>\n<h2 id=\"编写和发布博文\"><a href=\"#编写和发布博文\" class=\"headerlink\" title=\"编写和发布博文\"></a>编写和发布博文</h2><p>之前介绍过，创建博客可以通过命令创建，发布博文同样也非常简单，只需要三步即可：</p>\n<h3 id=\"第一步：创建博文\"><a href=\"#第一步：创建博文\" class=\"headerlink\" title=\"第一步：创建博文\"></a>第一步：创建博文</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new first</span><br></pre></td></tr></table></figure>\n<p>创建名为first的md文件，并且编写文件</p>\n<h3 id=\"第二步：渲染静态文件\"><a href=\"#第二步：渲染静态文件\" class=\"headerlink\" title=\"第二步：渲染静态文件\"></a>第二步：渲染静态文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<p>该命令是将你编写的文件生成为html文件，存放到public文件下面，完整的命令为 hexo generate</p>\n<h3 id=\"第三步：上传文件\"><a href=\"#第三步：上传文件\" class=\"headerlink\" title=\"第三步：上传文件\"></a>第三步：上传文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>该命令是按照_config.yml 配置中的发布方式，将public里的静态资源上传到你的线上代码仓库（gitlab或者其它）</p>\n<p>仅需以上三步即可将你的项目托管到你的代码仓库中，deploy中还可以支持 heroku、netlify、rsync、openShift、ftpsync、<br>sftp 等众多方式，还可以自己将生成的文件放在任何你想放的地方，<a href=\"https://hexo.io/zh-cn/docs/deployment\" target=\"_blank\" rel=\"noopener\">相关配置</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总的来说，hexo是一个非常方便，也很适合学习的一个博客工具，其中配置的东西还很多，这期先给大家讲一个大概，之后的篇幅会给大家具体的讲解其中主题更换、hexo中博客的语法等的内容。</p>\n"},{"title":"基于svg的流程图绘制实现","comments":0,"date":"2019-06-20T02:58:28.000Z","updated":"2020-06-10T06:02:02.483Z","author":"jun.zhou","_content":"\n# 1需求分析\n我们先来看一下这个需求，如下图\n![需求图](https://img.fengjr.com/image/2019/06/20/15c881ea25d14000d96c5f09a1fc094b.jpg \"需求图\")\n\n从图中我们分析发现，需要绘制的元素有表格、节点和节点之间的箭头。表格和节点并难度，稍显复杂的就是箭头的绘制。\n\n## 1.1 svg和canvs比较\n明白了我们要绘制什么，接下来就是考虑用什么绘制的问题。绘制图形需要有坐标系统和画布，对于前端来说，可选的方案还是比较多，最为常用的是svg和canvas，html不予考虑，这两种都是矢量绘图，渲染效果比较好。那这两者该怎么选呢？\n\nCanvas 类似于 Windows GDI API，您通过编程方式向窗口中绘制图形；\n SVG 类似于 HTML 标记，具有元素、样式、事件和基于 DOM 的编程能力。\n Canvas 是过程性的，而 SVG 是声明性的。\n\n![svg和scanvas比较](https://img.fengjr.com/image/2019/06/20/2123bfda7a50cbe4116eb7d93fc63071.png)\n\n从图中我们可以看到svg和canvas对于我们这个需求来说旗鼓相当，唯一好的一点是svg对于交互处理上更方便，因为可以直接在标签上绑定事件来进行交互，而不像canvas只能在最外层的画布上进行事件处理。因此我们选择了svg。svg画布的圆点在元素左上角，x轴向右，y轴向下。\n\n## 1.2 svg用法\nSVG 有一些预定义的形状元素，可被使用和操作：\n\n+ 矩形 <rect\\>\n+ 圆形 <circle\\>\n+ 椭圆 <ellipse\\>\n+ 线 <line\\>\n+ 折线 <polyline\\>\n+ 多边形 <polygon\\>\n+ 路径 <path\\>\n\n下面svg根元素的完整标签\n\n<svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"\\></svg\\>\n\n这里我们主要用到矩形和路径元素，下面是本文中用到的一个矩形绘制函数\n\n![svg绘制矩形函数图](https://img.fengjr.com/image/2019/06/20/06fcdddfc1a1d1e8152a44ad82f43e1e.png)\n\nxy为矩形左上角的坐标，w是矩形宽，h是矩形高，最后一个参数是一个已有的矩形，本函数可以向画布中添加或修改一个矩形。\n\n下面给出最终的效果图：\n![效果图](https://img.fengjr.com/image/2019/06/20/4ee8ca20d900590549e46df25e5ee530.jpg)\n\n# 2 数据结构与算法\nsvg的相关方法主要用于图形的渲染，系统的核心还在于数据计算。\n\n## 2.1 表格\n先看一个表格\n\n![表格](https://img.fengjr.com/image/2019/06/20/d42f1b1d684eb5f0f4830cd249cae42e.png)\n\n这个表格用html实现的话代码如下\n\n![表格的html结构](https://img.fengjr.com/image/2019/06/20/724efa1c77785086252329591cb826ec.png)\n\n仿照此，我们定义了表格的数据结构\n\n![表格的数据结构](https://img.fengjr.com/image/2019/06/20/2ad4a76d16950e62d44d1960c3fc116d.png)\n\n## 2.2 表格的具体算法\n![算法](https://img.fengjr.com/image/2019/06/20/af218a3b6aed9381b87dd2ebfce26f00.png)\n## 2.3 表格文字和节点数据\n![节点数据结构](https://img.fengjr.com/image/2019/06/20/d5d6fe22b14929d24f0be42cd0769b63.png)\n在表格的数据结构上进行扩充，我们添加了单元格的文字。这样在绘制表格的同时，还可以填充里面的文字。\n## 2.4 节点绘制算法\n第一种：我们刚才在绘制单元格的时候同时填充了文字，那可不可以同时填充节点呢？其实比较理想的就是这样，但存在一个问题，每行节点之间存在一定的时序先后关系，第一行的节点并不都是最先形成的，有可能流程已经到了后面，由于在某个节点被拒绝，需要从第一步重新走，这样的话这一行的节点间距控制不好，就导致连线错综复杂。\n\n第二种：为了处理箭头往上走时的交叉问题，最好是按照节点生成顺序绘制。同时记录已经绘制的每行的x值，在节点往上走时根据所有x的最大值来进行定位即可。\n\n![节点算法图](https://img.fengjr.com/image/2019/06/20/ca375382ba48bff00b15db640d0b4753.png)\n\n## 2.5 绘制箭头\n![箭头算法](https://img.fengjr.com/image/2019/06/20/859f34a9b16d4964c79e4c4a3b823fcf.png)\n\n确认两个节点之间的关系\n![节点关系](https://img.fengjr.com/image/2019/06/20/dc446bf91d84f822911f4ded5e69bee4.png)\n\n确认箭头路径\n![箭头路径](https://img.fengjr.com/image/2019/06/20/652ca81b35bf3084ab50d74eda602733.png)\n\n图中红色的是箭头路径，黄色圈代表路径上的6个点位，蓝色框表示节点，绿色框表示节点的范围。路径就是沿着节点的返回进行寻址。起始的索引点不同，路径也不同。\n\n## 2.6 线段交叉问题\n解决办法：\n\n1 绘制折线后将折线打撒成线段存储起来\n\n2 绘制折线时遍历所有线段，判断有无交叉，若有则算出交点，添加到折线上，绘制时绘成圆弧。\n\n优化：\n\n存储的线段进行添加索引。以高度为100进行划分成行，将线段存储到对应的索引空间，可以减少计算交点的计算量。\n\n\n# 3 具体实现\n\n类图：\n![类图](https://img.fengjr.com/image/2019/06/20/d60cae56b7bad4ed13284d30cd55a010.png)\n\n基本逻辑：FrameData类从接口拿到列表数据nodeList,对其进行转换，结果交给DrawFrame类，该类进行绘制逻辑控制，依次绘制表格、文字、节点和箭头。\n\n以绘制表格为例：DrawFrame的draw方法进行遍历单元格，生成Rect对象，rect调用自己的draw方法进行数据处理，rect的draw方法会继续调用Graphic的drawRect的方法完成svg的绘制，生成的rect对象会保存到Doc对象中，以备他用。绘制节点的逻辑类似。\n\n基本图形类：Shape为图形基类，分别派生Rect、Node、Arrows、Circle、CircleNode、Text类进行图形计算。Graphic是渲染层，提供基础的图画绘制方法。可以有不同的技术实现，svg、canvas、html等。Doc是文档类，用于保存所有的图形对象，方便序列化。\n\n本文主要是图形展示，设计的交互比较少。\n\n交互的基本逻辑：\n交互一般需要三个鼠标事件，mouseDown，mouseMove，mouseUp。\n需要5个变量：isMouseDown，startX，startY，endX，endY。\n以平移为例：选中一个操作对象后，先在mouseDown事件中将isMouseDown置为true，同时记下startX、startY坐标；然后移动鼠标进行平移，在mouseMove事件中，用endX，endY记录返回的新坐标点，计算出移动的距离，dx=endX-startX，dy=endY-startY，根据dx、dy对图形进行重新绘制；当鼠标抬起时，对图形进行最后一次重绘，将isMouseDown置为false，绘制结束。\n\n\n","source":"_posts/2019-06-20-基于svg的流程图展示实现.md","raw":"---\ntitle: 基于svg的流程图绘制实现\ncomments: false\ndate: 2019-06-20 10:58:28\ntags:\n- js\nupdated:\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n# 1需求分析\n我们先来看一下这个需求，如下图\n![需求图](https://img.fengjr.com/image/2019/06/20/15c881ea25d14000d96c5f09a1fc094b.jpg \"需求图\")\n\n从图中我们分析发现，需要绘制的元素有表格、节点和节点之间的箭头。表格和节点并难度，稍显复杂的就是箭头的绘制。\n\n## 1.1 svg和canvs比较\n明白了我们要绘制什么，接下来就是考虑用什么绘制的问题。绘制图形需要有坐标系统和画布，对于前端来说，可选的方案还是比较多，最为常用的是svg和canvas，html不予考虑，这两种都是矢量绘图，渲染效果比较好。那这两者该怎么选呢？\n\nCanvas 类似于 Windows GDI API，您通过编程方式向窗口中绘制图形；\n SVG 类似于 HTML 标记，具有元素、样式、事件和基于 DOM 的编程能力。\n Canvas 是过程性的，而 SVG 是声明性的。\n\n![svg和scanvas比较](https://img.fengjr.com/image/2019/06/20/2123bfda7a50cbe4116eb7d93fc63071.png)\n\n从图中我们可以看到svg和canvas对于我们这个需求来说旗鼓相当，唯一好的一点是svg对于交互处理上更方便，因为可以直接在标签上绑定事件来进行交互，而不像canvas只能在最外层的画布上进行事件处理。因此我们选择了svg。svg画布的圆点在元素左上角，x轴向右，y轴向下。\n\n## 1.2 svg用法\nSVG 有一些预定义的形状元素，可被使用和操作：\n\n+ 矩形 <rect\\>\n+ 圆形 <circle\\>\n+ 椭圆 <ellipse\\>\n+ 线 <line\\>\n+ 折线 <polyline\\>\n+ 多边形 <polygon\\>\n+ 路径 <path\\>\n\n下面svg根元素的完整标签\n\n<svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"\\></svg\\>\n\n这里我们主要用到矩形和路径元素，下面是本文中用到的一个矩形绘制函数\n\n![svg绘制矩形函数图](https://img.fengjr.com/image/2019/06/20/06fcdddfc1a1d1e8152a44ad82f43e1e.png)\n\nxy为矩形左上角的坐标，w是矩形宽，h是矩形高，最后一个参数是一个已有的矩形，本函数可以向画布中添加或修改一个矩形。\n\n下面给出最终的效果图：\n![效果图](https://img.fengjr.com/image/2019/06/20/4ee8ca20d900590549e46df25e5ee530.jpg)\n\n# 2 数据结构与算法\nsvg的相关方法主要用于图形的渲染，系统的核心还在于数据计算。\n\n## 2.1 表格\n先看一个表格\n\n![表格](https://img.fengjr.com/image/2019/06/20/d42f1b1d684eb5f0f4830cd249cae42e.png)\n\n这个表格用html实现的话代码如下\n\n![表格的html结构](https://img.fengjr.com/image/2019/06/20/724efa1c77785086252329591cb826ec.png)\n\n仿照此，我们定义了表格的数据结构\n\n![表格的数据结构](https://img.fengjr.com/image/2019/06/20/2ad4a76d16950e62d44d1960c3fc116d.png)\n\n## 2.2 表格的具体算法\n![算法](https://img.fengjr.com/image/2019/06/20/af218a3b6aed9381b87dd2ebfce26f00.png)\n## 2.3 表格文字和节点数据\n![节点数据结构](https://img.fengjr.com/image/2019/06/20/d5d6fe22b14929d24f0be42cd0769b63.png)\n在表格的数据结构上进行扩充，我们添加了单元格的文字。这样在绘制表格的同时，还可以填充里面的文字。\n## 2.4 节点绘制算法\n第一种：我们刚才在绘制单元格的时候同时填充了文字，那可不可以同时填充节点呢？其实比较理想的就是这样，但存在一个问题，每行节点之间存在一定的时序先后关系，第一行的节点并不都是最先形成的，有可能流程已经到了后面，由于在某个节点被拒绝，需要从第一步重新走，这样的话这一行的节点间距控制不好，就导致连线错综复杂。\n\n第二种：为了处理箭头往上走时的交叉问题，最好是按照节点生成顺序绘制。同时记录已经绘制的每行的x值，在节点往上走时根据所有x的最大值来进行定位即可。\n\n![节点算法图](https://img.fengjr.com/image/2019/06/20/ca375382ba48bff00b15db640d0b4753.png)\n\n## 2.5 绘制箭头\n![箭头算法](https://img.fengjr.com/image/2019/06/20/859f34a9b16d4964c79e4c4a3b823fcf.png)\n\n确认两个节点之间的关系\n![节点关系](https://img.fengjr.com/image/2019/06/20/dc446bf91d84f822911f4ded5e69bee4.png)\n\n确认箭头路径\n![箭头路径](https://img.fengjr.com/image/2019/06/20/652ca81b35bf3084ab50d74eda602733.png)\n\n图中红色的是箭头路径，黄色圈代表路径上的6个点位，蓝色框表示节点，绿色框表示节点的范围。路径就是沿着节点的返回进行寻址。起始的索引点不同，路径也不同。\n\n## 2.6 线段交叉问题\n解决办法：\n\n1 绘制折线后将折线打撒成线段存储起来\n\n2 绘制折线时遍历所有线段，判断有无交叉，若有则算出交点，添加到折线上，绘制时绘成圆弧。\n\n优化：\n\n存储的线段进行添加索引。以高度为100进行划分成行，将线段存储到对应的索引空间，可以减少计算交点的计算量。\n\n\n# 3 具体实现\n\n类图：\n![类图](https://img.fengjr.com/image/2019/06/20/d60cae56b7bad4ed13284d30cd55a010.png)\n\n基本逻辑：FrameData类从接口拿到列表数据nodeList,对其进行转换，结果交给DrawFrame类，该类进行绘制逻辑控制，依次绘制表格、文字、节点和箭头。\n\n以绘制表格为例：DrawFrame的draw方法进行遍历单元格，生成Rect对象，rect调用自己的draw方法进行数据处理，rect的draw方法会继续调用Graphic的drawRect的方法完成svg的绘制，生成的rect对象会保存到Doc对象中，以备他用。绘制节点的逻辑类似。\n\n基本图形类：Shape为图形基类，分别派生Rect、Node、Arrows、Circle、CircleNode、Text类进行图形计算。Graphic是渲染层，提供基础的图画绘制方法。可以有不同的技术实现，svg、canvas、html等。Doc是文档类，用于保存所有的图形对象，方便序列化。\n\n本文主要是图形展示，设计的交互比较少。\n\n交互的基本逻辑：\n交互一般需要三个鼠标事件，mouseDown，mouseMove，mouseUp。\n需要5个变量：isMouseDown，startX，startY，endX，endY。\n以平移为例：选中一个操作对象后，先在mouseDown事件中将isMouseDown置为true，同时记下startX、startY坐标；然后移动鼠标进行平移，在mouseMove事件中，用endX，endY记录返回的新坐标点，计算出移动的距离，dx=endX-startX，dy=endY-startY，根据dx、dy对图形进行重新绘制；当鼠标抬起时，对图形进行最后一次重绘，将isMouseDown置为false，绘制结束。\n\n\n","slug":"基于svg的流程图展示实现","published":1,"_id":"cjxfsbp4d0004hgq51v2pm6fi","layout":"post","photos":[],"link":"","content":"<h1 id=\"1需求分析\"><a href=\"#1需求分析\" class=\"headerlink\" title=\"1需求分析\"></a>1需求分析</h1><p>我们先来看一下这个需求，如下图<br><img src=\"https://img.fengjr.com/image/2019/06/20/15c881ea25d14000d96c5f09a1fc094b.jpg\" alt=\"需求图\" title=\"需求图\"></p>\n<p>从图中我们分析发现，需要绘制的元素有表格、节点和节点之间的箭头。表格和节点并难度，稍显复杂的就是箭头的绘制。</p>\n<h2 id=\"1-1-svg和canvs比较\"><a href=\"#1-1-svg和canvs比较\" class=\"headerlink\" title=\"1.1 svg和canvs比较\"></a>1.1 svg和canvs比较</h2><p>明白了我们要绘制什么，接下来就是考虑用什么绘制的问题。绘制图形需要有坐标系统和画布，对于前端来说，可选的方案还是比较多，最为常用的是svg和canvas，html不予考虑，这两种都是矢量绘图，渲染效果比较好。那这两者该怎么选呢？</p>\n<p>Canvas 类似于 Windows GDI API，您通过编程方式向窗口中绘制图形；<br> SVG 类似于 HTML 标记，具有元素、样式、事件和基于 DOM 的编程能力。<br> Canvas 是过程性的，而 SVG 是声明性的。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/2123bfda7a50cbe4116eb7d93fc63071.png\" alt=\"svg和scanvas比较\"></p>\n<p>从图中我们可以看到svg和canvas对于我们这个需求来说旗鼓相当，唯一好的一点是svg对于交互处理上更方便，因为可以直接在标签上绑定事件来进行交互，而不像canvas只能在最外层的画布上进行事件处理。因此我们选择了svg。svg画布的圆点在元素左上角，x轴向右，y轴向下。</p>\n<h2 id=\"1-2-svg用法\"><a href=\"#1-2-svg用法\" class=\"headerlink\" title=\"1.2 svg用法\"></a>1.2 svg用法</h2><p>SVG 有一些预定义的形状元素，可被使用和操作：</p>\n<ul>\n<li>矩形 &lt;rect></li>\n<li>圆形 &lt;circle></li>\n<li>椭圆 &lt;ellipse></li>\n<li>线 &lt;line></li>\n<li>折线 &lt;polyline></li>\n<li>多边形 &lt;polygon></li>\n<li>路径 &lt;path></li>\n</ul>\n<p>下面svg根元素的完整标签</p>\n<p>&lt;svg width=”100%” height=”100%” version=”1.1” xmlns=”<a href=\"http://www.w3.org/2000/svg&quot;\\&gt;\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/2000/svg&quot;\\&gt;</a>&lt;/svg></p>\n<p>这里我们主要用到矩形和路径元素，下面是本文中用到的一个矩形绘制函数</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/06fcdddfc1a1d1e8152a44ad82f43e1e.png\" alt=\"svg绘制矩形函数图\"></p>\n<p>xy为矩形左上角的坐标，w是矩形宽，h是矩形高，最后一个参数是一个已有的矩形，本函数可以向画布中添加或修改一个矩形。</p>\n<p>下面给出最终的效果图：<br><img src=\"https://img.fengjr.com/image/2019/06/20/4ee8ca20d900590549e46df25e5ee530.jpg\" alt=\"效果图\"></p>\n<h1 id=\"2-数据结构与算法\"><a href=\"#2-数据结构与算法\" class=\"headerlink\" title=\"2 数据结构与算法\"></a>2 数据结构与算法</h1><p>svg的相关方法主要用于图形的渲染，系统的核心还在于数据计算。</p>\n<h2 id=\"2-1-表格\"><a href=\"#2-1-表格\" class=\"headerlink\" title=\"2.1 表格\"></a>2.1 表格</h2><p>先看一个表格</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/d42f1b1d684eb5f0f4830cd249cae42e.png\" alt=\"表格\"></p>\n<p>这个表格用html实现的话代码如下</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/724efa1c77785086252329591cb826ec.png\" alt=\"表格的html结构\"></p>\n<p>仿照此，我们定义了表格的数据结构</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/2ad4a76d16950e62d44d1960c3fc116d.png\" alt=\"表格的数据结构\"></p>\n<h2 id=\"2-2-表格的具体算法\"><a href=\"#2-2-表格的具体算法\" class=\"headerlink\" title=\"2.2 表格的具体算法\"></a>2.2 表格的具体算法</h2><p><img src=\"https://img.fengjr.com/image/2019/06/20/af218a3b6aed9381b87dd2ebfce26f00.png\" alt=\"算法\"></p>\n<h2 id=\"2-3-表格文字和节点数据\"><a href=\"#2-3-表格文字和节点数据\" class=\"headerlink\" title=\"2.3 表格文字和节点数据\"></a>2.3 表格文字和节点数据</h2><p><img src=\"https://img.fengjr.com/image/2019/06/20/d5d6fe22b14929d24f0be42cd0769b63.png\" alt=\"节点数据结构\"><br>在表格的数据结构上进行扩充，我们添加了单元格的文字。这样在绘制表格的同时，还可以填充里面的文字。</p>\n<h2 id=\"2-4-节点绘制算法\"><a href=\"#2-4-节点绘制算法\" class=\"headerlink\" title=\"2.4 节点绘制算法\"></a>2.4 节点绘制算法</h2><p>第一种：我们刚才在绘制单元格的时候同时填充了文字，那可不可以同时填充节点呢？其实比较理想的就是这样，但存在一个问题，每行节点之间存在一定的时序先后关系，第一行的节点并不都是最先形成的，有可能流程已经到了后面，由于在某个节点被拒绝，需要从第一步重新走，这样的话这一行的节点间距控制不好，就导致连线错综复杂。</p>\n<p>第二种：为了处理箭头往上走时的交叉问题，最好是按照节点生成顺序绘制。同时记录已经绘制的每行的x值，在节点往上走时根据所有x的最大值来进行定位即可。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/ca375382ba48bff00b15db640d0b4753.png\" alt=\"节点算法图\"></p>\n<h2 id=\"2-5-绘制箭头\"><a href=\"#2-5-绘制箭头\" class=\"headerlink\" title=\"2.5 绘制箭头\"></a>2.5 绘制箭头</h2><p><img src=\"https://img.fengjr.com/image/2019/06/20/859f34a9b16d4964c79e4c4a3b823fcf.png\" alt=\"箭头算法\"></p>\n<p>确认两个节点之间的关系<br><img src=\"https://img.fengjr.com/image/2019/06/20/dc446bf91d84f822911f4ded5e69bee4.png\" alt=\"节点关系\"></p>\n<p>确认箭头路径<br><img src=\"https://img.fengjr.com/image/2019/06/20/652ca81b35bf3084ab50d74eda602733.png\" alt=\"箭头路径\"></p>\n<p>图中红色的是箭头路径，黄色圈代表路径上的6个点位，蓝色框表示节点，绿色框表示节点的范围。路径就是沿着节点的返回进行寻址。起始的索引点不同，路径也不同。</p>\n<h2 id=\"2-6-线段交叉问题\"><a href=\"#2-6-线段交叉问题\" class=\"headerlink\" title=\"2.6 线段交叉问题\"></a>2.6 线段交叉问题</h2><p>解决办法：</p>\n<p>1 绘制折线后将折线打撒成线段存储起来</p>\n<p>2 绘制折线时遍历所有线段，判断有无交叉，若有则算出交点，添加到折线上，绘制时绘成圆弧。</p>\n<p>优化：</p>\n<p>存储的线段进行添加索引。以高度为100进行划分成行，将线段存储到对应的索引空间，可以减少计算交点的计算量。</p>\n<h1 id=\"3-具体实现\"><a href=\"#3-具体实现\" class=\"headerlink\" title=\"3 具体实现\"></a>3 具体实现</h1><p>类图：<br><img src=\"https://img.fengjr.com/image/2019/06/20/d60cae56b7bad4ed13284d30cd55a010.png\" alt=\"类图\"></p>\n<p>基本逻辑：FrameData类从接口拿到列表数据nodeList,对其进行转换，结果交给DrawFrame类，该类进行绘制逻辑控制，依次绘制表格、文字、节点和箭头。</p>\n<p>以绘制表格为例：DrawFrame的draw方法进行遍历单元格，生成Rect对象，rect调用自己的draw方法进行数据处理，rect的draw方法会继续调用Graphic的drawRect的方法完成svg的绘制，生成的rect对象会保存到Doc对象中，以备他用。绘制节点的逻辑类似。</p>\n<p>基本图形类：Shape为图形基类，分别派生Rect、Node、Arrows、Circle、CircleNode、Text类进行图形计算。Graphic是渲染层，提供基础的图画绘制方法。可以有不同的技术实现，svg、canvas、html等。Doc是文档类，用于保存所有的图形对象，方便序列化。</p>\n<p>本文主要是图形展示，设计的交互比较少。</p>\n<p>交互的基本逻辑：<br>交互一般需要三个鼠标事件，mouseDown，mouseMove，mouseUp。<br>需要5个变量：isMouseDown，startX，startY，endX，endY。<br>以平移为例：选中一个操作对象后，先在mouseDown事件中将isMouseDown置为true，同时记下startX、startY坐标；然后移动鼠标进行平移，在mouseMove事件中，用endX，endY记录返回的新坐标点，计算出移动的距离，dx=endX-startX，dy=endY-startY，根据dx、dy对图形进行重新绘制；当鼠标抬起时，对图形进行最后一次重绘，将isMouseDown置为false，绘制结束。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1需求分析\"><a href=\"#1需求分析\" class=\"headerlink\" title=\"1需求分析\"></a>1需求分析</h1><p>我们先来看一下这个需求，如下图<br><img src=\"https://img.fengjr.com/image/2019/06/20/15c881ea25d14000d96c5f09a1fc094b.jpg\" alt=\"需求图\" title=\"需求图\"></p>\n<p>从图中我们分析发现，需要绘制的元素有表格、节点和节点之间的箭头。表格和节点并难度，稍显复杂的就是箭头的绘制。</p>\n<h2 id=\"1-1-svg和canvs比较\"><a href=\"#1-1-svg和canvs比较\" class=\"headerlink\" title=\"1.1 svg和canvs比较\"></a>1.1 svg和canvs比较</h2><p>明白了我们要绘制什么，接下来就是考虑用什么绘制的问题。绘制图形需要有坐标系统和画布，对于前端来说，可选的方案还是比较多，最为常用的是svg和canvas，html不予考虑，这两种都是矢量绘图，渲染效果比较好。那这两者该怎么选呢？</p>\n<p>Canvas 类似于 Windows GDI API，您通过编程方式向窗口中绘制图形；<br> SVG 类似于 HTML 标记，具有元素、样式、事件和基于 DOM 的编程能力。<br> Canvas 是过程性的，而 SVG 是声明性的。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/2123bfda7a50cbe4116eb7d93fc63071.png\" alt=\"svg和scanvas比较\"></p>\n<p>从图中我们可以看到svg和canvas对于我们这个需求来说旗鼓相当，唯一好的一点是svg对于交互处理上更方便，因为可以直接在标签上绑定事件来进行交互，而不像canvas只能在最外层的画布上进行事件处理。因此我们选择了svg。svg画布的圆点在元素左上角，x轴向右，y轴向下。</p>\n<h2 id=\"1-2-svg用法\"><a href=\"#1-2-svg用法\" class=\"headerlink\" title=\"1.2 svg用法\"></a>1.2 svg用法</h2><p>SVG 有一些预定义的形状元素，可被使用和操作：</p>\n<ul>\n<li>矩形 &lt;rect></li>\n<li>圆形 &lt;circle></li>\n<li>椭圆 &lt;ellipse></li>\n<li>线 &lt;line></li>\n<li>折线 &lt;polyline></li>\n<li>多边形 &lt;polygon></li>\n<li>路径 &lt;path></li>\n</ul>\n<p>下面svg根元素的完整标签</p>\n<p>&lt;svg width=”100%” height=”100%” version=”1.1” xmlns=”<a href=\"http://www.w3.org/2000/svg&quot;\\&gt;\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/2000/svg&quot;\\&gt;</a>&lt;/svg></p>\n<p>这里我们主要用到矩形和路径元素，下面是本文中用到的一个矩形绘制函数</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/06fcdddfc1a1d1e8152a44ad82f43e1e.png\" alt=\"svg绘制矩形函数图\"></p>\n<p>xy为矩形左上角的坐标，w是矩形宽，h是矩形高，最后一个参数是一个已有的矩形，本函数可以向画布中添加或修改一个矩形。</p>\n<p>下面给出最终的效果图：<br><img src=\"https://img.fengjr.com/image/2019/06/20/4ee8ca20d900590549e46df25e5ee530.jpg\" alt=\"效果图\"></p>\n<h1 id=\"2-数据结构与算法\"><a href=\"#2-数据结构与算法\" class=\"headerlink\" title=\"2 数据结构与算法\"></a>2 数据结构与算法</h1><p>svg的相关方法主要用于图形的渲染，系统的核心还在于数据计算。</p>\n<h2 id=\"2-1-表格\"><a href=\"#2-1-表格\" class=\"headerlink\" title=\"2.1 表格\"></a>2.1 表格</h2><p>先看一个表格</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/d42f1b1d684eb5f0f4830cd249cae42e.png\" alt=\"表格\"></p>\n<p>这个表格用html实现的话代码如下</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/724efa1c77785086252329591cb826ec.png\" alt=\"表格的html结构\"></p>\n<p>仿照此，我们定义了表格的数据结构</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/2ad4a76d16950e62d44d1960c3fc116d.png\" alt=\"表格的数据结构\"></p>\n<h2 id=\"2-2-表格的具体算法\"><a href=\"#2-2-表格的具体算法\" class=\"headerlink\" title=\"2.2 表格的具体算法\"></a>2.2 表格的具体算法</h2><p><img src=\"https://img.fengjr.com/image/2019/06/20/af218a3b6aed9381b87dd2ebfce26f00.png\" alt=\"算法\"></p>\n<h2 id=\"2-3-表格文字和节点数据\"><a href=\"#2-3-表格文字和节点数据\" class=\"headerlink\" title=\"2.3 表格文字和节点数据\"></a>2.3 表格文字和节点数据</h2><p><img src=\"https://img.fengjr.com/image/2019/06/20/d5d6fe22b14929d24f0be42cd0769b63.png\" alt=\"节点数据结构\"><br>在表格的数据结构上进行扩充，我们添加了单元格的文字。这样在绘制表格的同时，还可以填充里面的文字。</p>\n<h2 id=\"2-4-节点绘制算法\"><a href=\"#2-4-节点绘制算法\" class=\"headerlink\" title=\"2.4 节点绘制算法\"></a>2.4 节点绘制算法</h2><p>第一种：我们刚才在绘制单元格的时候同时填充了文字，那可不可以同时填充节点呢？其实比较理想的就是这样，但存在一个问题，每行节点之间存在一定的时序先后关系，第一行的节点并不都是最先形成的，有可能流程已经到了后面，由于在某个节点被拒绝，需要从第一步重新走，这样的话这一行的节点间距控制不好，就导致连线错综复杂。</p>\n<p>第二种：为了处理箭头往上走时的交叉问题，最好是按照节点生成顺序绘制。同时记录已经绘制的每行的x值，在节点往上走时根据所有x的最大值来进行定位即可。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/ca375382ba48bff00b15db640d0b4753.png\" alt=\"节点算法图\"></p>\n<h2 id=\"2-5-绘制箭头\"><a href=\"#2-5-绘制箭头\" class=\"headerlink\" title=\"2.5 绘制箭头\"></a>2.5 绘制箭头</h2><p><img src=\"https://img.fengjr.com/image/2019/06/20/859f34a9b16d4964c79e4c4a3b823fcf.png\" alt=\"箭头算法\"></p>\n<p>确认两个节点之间的关系<br><img src=\"https://img.fengjr.com/image/2019/06/20/dc446bf91d84f822911f4ded5e69bee4.png\" alt=\"节点关系\"></p>\n<p>确认箭头路径<br><img src=\"https://img.fengjr.com/image/2019/06/20/652ca81b35bf3084ab50d74eda602733.png\" alt=\"箭头路径\"></p>\n<p>图中红色的是箭头路径，黄色圈代表路径上的6个点位，蓝色框表示节点，绿色框表示节点的范围。路径就是沿着节点的返回进行寻址。起始的索引点不同，路径也不同。</p>\n<h2 id=\"2-6-线段交叉问题\"><a href=\"#2-6-线段交叉问题\" class=\"headerlink\" title=\"2.6 线段交叉问题\"></a>2.6 线段交叉问题</h2><p>解决办法：</p>\n<p>1 绘制折线后将折线打撒成线段存储起来</p>\n<p>2 绘制折线时遍历所有线段，判断有无交叉，若有则算出交点，添加到折线上，绘制时绘成圆弧。</p>\n<p>优化：</p>\n<p>存储的线段进行添加索引。以高度为100进行划分成行，将线段存储到对应的索引空间，可以减少计算交点的计算量。</p>\n<h1 id=\"3-具体实现\"><a href=\"#3-具体实现\" class=\"headerlink\" title=\"3 具体实现\"></a>3 具体实现</h1><p>类图：<br><img src=\"https://img.fengjr.com/image/2019/06/20/d60cae56b7bad4ed13284d30cd55a010.png\" alt=\"类图\"></p>\n<p>基本逻辑：FrameData类从接口拿到列表数据nodeList,对其进行转换，结果交给DrawFrame类，该类进行绘制逻辑控制，依次绘制表格、文字、节点和箭头。</p>\n<p>以绘制表格为例：DrawFrame的draw方法进行遍历单元格，生成Rect对象，rect调用自己的draw方法进行数据处理，rect的draw方法会继续调用Graphic的drawRect的方法完成svg的绘制，生成的rect对象会保存到Doc对象中，以备他用。绘制节点的逻辑类似。</p>\n<p>基本图形类：Shape为图形基类，分别派生Rect、Node、Arrows、Circle、CircleNode、Text类进行图形计算。Graphic是渲染层，提供基础的图画绘制方法。可以有不同的技术实现，svg、canvas、html等。Doc是文档类，用于保存所有的图形对象，方便序列化。</p>\n<p>本文主要是图形展示，设计的交互比较少。</p>\n<p>交互的基本逻辑：<br>交互一般需要三个鼠标事件，mouseDown，mouseMove，mouseUp。<br>需要5个变量：isMouseDown，startX，startY，endX，endY。<br>以平移为例：选中一个操作对象后，先在mouseDown事件中将isMouseDown置为true，同时记下startX、startY坐标；然后移动鼠标进行平移，在mouseMove事件中，用endX，endY记录返回的新坐标点，计算出移动的距离，dx=endX-startX，dy=endY-startY，根据dx、dy对图形进行重新绘制；当鼠标抬起时，对图形进行最后一次重绘，将isMouseDown置为false，绘制结束。</p>\n"},{"title":"基于asterisk的语音通话方案在凤金语音平台的实践","comments":1,"date":"2019-06-20T09:52:24.000Z","author":"jun.zhou","_content":"\n![](https://img.fengjr.com/image/2019/06/20/a0f32ca1a5cf0db218a0634ed40ac35f.png)\n\n# 基于Asterisk的语音通话方案在凤金语音平台的实践\n\n## 什么是 Asterisk\n\n### 1、定义\n\n**[Asterisk](https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F/100343?fromtitle=asterisk&fromid=1181693&fr=aladdin)** 是一个应用于 VOIP 的开放源代码的 PBX 系统；可以运行在 Linux，BSD，Windows(仿真的)以及 OS X 上；提供了语音邮箱服务(Voicemail)、电话会议、交互式语音应答(IVR)、呼叫队列，它还可以支持三方呼叫，主叫标识；支持 4 类 VOIP 的协议；通过使用相对便宜的硬件，它可以与几乎全部基于标准的电话设备进行互联操作。\n\n与硬件 VOIP 相比，Asterisk 不仅具有其常用功能，还具有能够支持多媒体，具有可编程功能；Asterisk 需要的带宽，一般为 32KB/线路，也就是说每支持一条线路，只需要增32KB 的带宽，但是需要网络质量良好；Asterisk 可支持成千的客户端（需要板卡与带宽支持）。\n\n**Asterisk 能够支持传统的线路，包括：**\n\n- TDM （Time Division Multiplexing） \n- T1/E1 PRI/ PRA & RBS （Robbed Bit Signal）modes \n- Analog phone lines/ phones （POTS） \n- ISDN （Integrated Services Digital Network） \n- Both BRI （Basic Rate）and PRI （Primary Rate）\n\nAsterisk 支持的协议包括：\n\n- Session Initiation Protocol （SIP） \n- H. 323 （ITU standard, contributed support） \n- Inter- Asterisk eXchange （IAX） \n- Media Gateway Control Protocol （MGCP）\n\n### 2、结构\n\n![](https://img.fengjr.com/image/2019/06/20/685dc844b97b7277c0c9a66b0f3331a6.png)\n\n### 3、主要配置文件\n#### asterisk.confAsterisk\n各模块目录配置文件\n \n#### sip.conf\n配置 sip 帐号信息文件\n\n#### extensions.conf\n拨号计划配置文件\n\n#### voicemail.conf\n语音邮箱留言配置文件\n\n#### cdr_mysql.conf\n通话记录详情文件\n\n### manager.conf\nAMI 配置文件\n\n### 4、SIP 协议\n\n#### SIP 协议介绍\n\n会话初始协议（Session Initiation Protocol）是一个在 IP 网络上进行多媒体通信的应用层控制信令协议，它被用来创建、修改、和终结一个或多个参加者参加的会话进程，与 SDP、RTP/RTCP、DNS 等协议配合，共同完成会话建立及媒体协商。\n\n#### SIP 相关协议\n\n会话描述协议 SDP（Session Description Protocol）为应用层的控制协议，用于会话建立过程中的媒体协商。\n\nRTP/RTSP：都为应用层的承载面协议，会话建立后，RTP 协议保证媒体流的实时传输。RTSP 协议对实时传输的媒体流进行监控。\n\n#### SIP 在协议栈中的位置\n\n![](https://img.fengjr.com/image/2019/06/20/190783db5ec80efe86ea90b71cf120a4.png)\n\n#### SIP 的网络模型\n\n![](https://img.fengjr.com/image/2019/06/20/36c462619b1a0c4888ae27fea6900eda.png)\n\n#### SIP 协议报文格式\n\n```\nREGISTER sip:10.10.255.161:5060 SIP/2.0\nVia: SIP/2.0/UDP 10.254.21.11:44982;branch=z9hG4bK-d87543-4c778a261b56f612-1--d87543-;rport\nMax-Forwards: 70\nContact: <sip:111@10.254.21.11:44982;rinstance=40db0908120d6299>\nTo: \"111\"<sip:111@10.10.255.161:5060>\nFrom: \"111\"<sip:111@10.10.255.161:5060>;tag=3418703c\nCall-ID: ZmRiYmQyNzA1OGI4YTc0Y2Q2NmYwMTUyOGMwYmJjOTc.\nCSeq: 1 REGISTER\nExpires: 3600\nAllow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO\nUser-Agent: eyeBeam release 1011d stamp 40820\nContent-Length: 0\n```\n\n#### 基本呼叫过程\n\n![](https://img.fengjr.com/image/2019/06/20/906a0515a50f9ed85ac7a285f5f92d79.png)\n\n### 5、Dialplan 介绍\n\nDialplan 是 Asterisk 系统的真正核心，它定义了 Asterisk 怎样处理呼入和呼出。有四个部分构成： contexts， extensions， priorities 和 applications。\n\n```\n[TestMenu]\nexten=> 1234,1,Answer()\n    same=> n, Background(main-menu)\n    same=> n, WaitExten(5)\nexten=> 1,1,Dial(SIP/111)\n    same => n,Hangup()\nexten=> 2,1,Dial(SIP/222) \n    same => n,Hangup()\nexten=> i,1,Playback(pbx-invalid) ; i  invalid\n   same=>n, Goto(TestMenu,1234,1)\n exten=> t,1,Playback(vm-goodbye) ; t  timeout\n   same=>n, Hangup()\n\n```\n\n### 6、AGI 原理\n\nAGI 即 Asterisk  Gateway  Interface 它为外部程序提供了标准的接口来控制 Asterisk 的dialplan。 \n\n拨号计划中，可以采用各种语言很方便的通过 AGI 接口写脚本。脚本和 Asterisk 之间通过标准的输入输出进行交互，标准的输入输出分别为：\n- STDIN : 标准输入，外部脚本程序通过标准的输入，从  Asterisk 接收信息。\n- STDOUT: 标准输出, 外部脚本程序通过标准的输出，发送命令到 Asterisk。\n- STDERR : 标准错误输出，外部脚本程序通过标准错误输出调式信息到 Asterisk 控制台。　\n\n用例:\n\n```\nexten => 1234,1,Answer()\nsame=> n,agi(demo.php); demo.php 位于/var/lib/asterisk/agi-bin/，并且是可执行权限\nsame=> n,NoOp(${CALL_ID}); 在 Asterisk 控制台打印 CALL_ID 变量\nsame=> n,hangup()\n```\n\n```\narray (\n  'agi_request' => 'demo/record.php',\n  'agi_channel' => 'SIP/111-00000051',\n  'agi_language' => 'en',\n  'agi_type' => 'SIP',\n  'agi_uniqueid' => '1524539689.81',\n  'agi_version' => '11.25.1',\n  'agi_callerid' => '111',\n  'agi_calleridname' => '111',\n  'agi_callingpres' => '0',\n  'agi_callingani2' => '0',\n  'agi_callington' => '0',\n  'agi_callingtns' => '0',\n  'agi_dnid' => '444',\n  'agi_rdnis' => 'unknown',\n  'agi_context' => 'internal',\n  'agi_extension' => '444',\n  'agi_priority' => '2',\n  'agi_enhanced' => '0.0',\n  'agi_accountcode' => '',\n  'agi_threadid' => '140102795544320',\n  'agi_arg_1' => '111',\n  'agi_arg_2' => 'SIP/111-00000051',\n)\n\n```\n\n![](https://img.fengjr.com/image/2019/06/20/8f52d5d355486b664bd8996a0af18b82.png)\n\n### 7、AMI 远程控制 Asterisk\n\nAsterisk Manager API (Asterisk 控制接口)允许管理客户端程序连接到一个 Asterisk 实例，并且可以通过 TCP/IP (AMI 通过 TCP/IP 协议连接到 Asterisk 服务器的端口默认为 5038)流发送命令或读取事件。通过此接口，可以实现对 Asterisk 系统的监控和控制。\n\n/etc/asterisk/manager.conf 用于对这个管理接口进行配置，可以在 manager.conf 中设定新的用户名、口令和允许连接的网络地址，读写的权限等。\n\n```\n[general]\nenabled = yes\nport = 5038\nbindaddr = 10.254.21.11\n[admin]\nsecret = admin\ndeny = 0.0.0.0/0.0.0.0\npermit = 127.0.0.1/ 10.254.21.11\nread = all,system,call,log,verbose,command,agent,user,config\nwrite = all,system,call,log,verbose,command,agent,user,config\n```\n\nTCP 的 AMI 可以简单使用 telnet 命令 连接，例如\n\n\n```\ntelnet 10.254.21.11 5038\n```\n\n\n登录\n\n\n```\nAction: Login\nUsername: admin\nSecret: admin\n```\n\n拨打电话\n\n```\nAction: Originate\nChannel: SIP/111 ;主叫通道，只有主叫通道接通后，才会调用被叫号码/被叫所属 context\nExten: 222 ; 被叫号码，与 Context、 Priority 一起，是必须的参数\nContext: internal ; Exten 关联的上下文\nPriority: 1 ; Exten 关联的优先级\nTimeout: 3000  ;发起连接发生的超时（以毫秒为单位）（默认为30000毫秒）\nCallerId: 111 ;用于呼叫的来电显示\nAsync: true ;对于发起来说是异步的（允许在不等待响应的情况下生成多个调用）\n```\n\n\n退出\n\n```\nAction: Logoff\n```\n\n### 8、SIP Proxy\n\n1 . 配置 Asterisk 作为 SIP Proxy, 并让 eyeBeam 注册上去, 确保能打通电话就要用到  sip.conf  , Extension.conf 文件。\n\n配制分别如下：\n\n在 sip.conf文件中分别添加如下内容，其中 111 和 222 是预设的两个 sip 号码\n\n```\n[111]\nsecret=aaa                         ;密码，随意设置\nport=5060                         ;SIP端口地址\ntype=friend                       ;类型为 friend，可以相互拨打对方\nhost=dynamic                   ;要求号码注册,以便 Asterisk 可以知道如何找到电话\nqualify = yes                      ;确认远端设备是否可达\nnat = no                            ;如果一个号码在NAT设备后面,例如防火墙，配置为yes\ncontext = internal            ;定义了指令的地点,用于控制电话的权限,及如何处理此号码的呼入叫。\n```\n\n```\n[222]\nsecret=aaa\nport=5060\nqualify = yes\nnat = no\ncontext = internal\ncanreinvite = no\ntype=friend\nhost=dynamic\n```\n\n## Asterisk 语音通话方案\n\n### 1、网络拓扑\n\n![](https://img.fengjr.com/image/2019/06/20/287a9c0702e7d3b4e8c7ec7c94b4c39f.png)\n\n### 2、系统明细\n\n|项次|产品|\n|---|---|\n|1|系统服务器（32G 内存，8 核 CPU，1.8T 硬盘）|\n|1.1|语音服务器 |\n|1.2|录音服务器|\n|1.3|WEB 服务器|\n|2|数字中继网关|\n|3|CTI 坐席授权|\n|4|SIP 话机|\n|5|耳麦|\n\n- 语音服务器。部署基于开放源代码的 Asterisk 的 PBX 系统，提供了语音邮箱服务、电话会议、交互式语音应答(IVR)、呼叫队列，它还可以支持三方呼叫，主叫标识。\n- 录音服务器。存放、管理呼叫中心所有通话录音，同时防止单机问题，采取双台冗余。\n- WEB 服务器。业务管理、分机授权、线路接入、API 调用等功能模块。\n- 数字中继网关。接运营商中继线；与语音服务器对接。\n\n### 3、呼叫中心\n\n![](https://img.fengjr.com/image/2019/06/20/d8c6b0531e961c6b1c64cbcf96662e6b.png)\n### 4、中继线路\n\n- 独立组建。在 IDC 接入运行商中继线，配置语音网关。\n- 三方线路。三方给定语音服务器地址和端口，呼叫中心开发对接流程，在呼叫时与三方交互，同时由于通话经过 PBX 系统，因此录音也会在录音服务器有存留，方便后续检索。\n\n### 5、话机与中继网关\n\n话机。支持 SIP 协议，同时配有耳麦。\n\n![](https://img.fengjr.com/image/2019/06/20/8383a003a66405aea52ca8a5e2c233f8.png)\n\n中继网关。\n\n![](https://img.fengjr.com/image/2019/06/20/bb5c08e0a05a415f864ba6ba39bce8a2.png)\n\n![](https://img.fengjr.com/image/2019/06/20/594d180a3c02777646fb91e34bbbb8e8.png)\n\n## 凤金语音平台\n\n### 1、系统架构\n![系统架构图](https://img.fengjr.com/image/2019/06/20/0c4492813f1a2e28b3bdc40dee6681ec.png)\n### 2、线路对接\n\n|项次|厂商|\n|---|---|\n|1|中通|\n|2|鼎信通达 GSM 无线网关|\n|3|云之讯|\n|4|其他厂商（支持扩展）|\n\n### 3、数据统计\n\n**业务分机使用情况，总计 95**\n\n\n|业务|数量|备注|\n|---|---|---|\n|信审|\t26\t||\n||12|\t外包|\n|催收|\t45|\t包含提醒|\n||12|\t回访外包|\n\n**2018年7月到2019年5月外呼量**\n\n![](https://img.fengjr.com/image/2019/06/20/e9b231aef189017fd015dfe6bc2e337b.png)\n\n### 4、安全规划\n\n#### 分机、线路、业务日期设定\n\n![](https://img.fengjr.com/image/2019/06/20/96d3ec785bff1a62152568c222e0a2b4.png)\n\n![](https://img.fengjr.com/image/2019/06/20/b57fd122947e194f34483f497d59b60c.png)\n\n\n![](https://img.fengjr.com/image/2019/06/20/6fc2e68b65eb69e66d85519af4025f3c.png)\n\n#### API 鉴权\n\n![](https://img.fengjr.com/image/2019/06/20/a324aac1e30b64fdfcf1dcce6b9489d8.png)\n\n#### CTI 服务器防火墙白名单\n#### 服务器多机部署，数据冗余\n\n\n![](https://img.fengjr.com/image/2019/06/20/041eae51d040aed6aff301ccfdc7f4f0.png)","source":"_posts/2019-06-20-asterisk-share.md","raw":"---\ntitle: 基于asterisk的语音通话方案在凤金语音平台的实践\ncomments: true\ndate: 2019-06-20 17:52:24\ntags:\n- asterrisk\n- 语音\n- 通信\n- C语言\ncategories:\n- C语言\nauthor: jun.zhou\n---\n\n![](https://img.fengjr.com/image/2019/06/20/a0f32ca1a5cf0db218a0634ed40ac35f.png)\n\n# 基于Asterisk的语音通话方案在凤金语音平台的实践\n\n## 什么是 Asterisk\n\n### 1、定义\n\n**[Asterisk](https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F/100343?fromtitle=asterisk&fromid=1181693&fr=aladdin)** 是一个应用于 VOIP 的开放源代码的 PBX 系统；可以运行在 Linux，BSD，Windows(仿真的)以及 OS X 上；提供了语音邮箱服务(Voicemail)、电话会议、交互式语音应答(IVR)、呼叫队列，它还可以支持三方呼叫，主叫标识；支持 4 类 VOIP 的协议；通过使用相对便宜的硬件，它可以与几乎全部基于标准的电话设备进行互联操作。\n\n与硬件 VOIP 相比，Asterisk 不仅具有其常用功能，还具有能够支持多媒体，具有可编程功能；Asterisk 需要的带宽，一般为 32KB/线路，也就是说每支持一条线路，只需要增32KB 的带宽，但是需要网络质量良好；Asterisk 可支持成千的客户端（需要板卡与带宽支持）。\n\n**Asterisk 能够支持传统的线路，包括：**\n\n- TDM （Time Division Multiplexing） \n- T1/E1 PRI/ PRA & RBS （Robbed Bit Signal）modes \n- Analog phone lines/ phones （POTS） \n- ISDN （Integrated Services Digital Network） \n- Both BRI （Basic Rate）and PRI （Primary Rate）\n\nAsterisk 支持的协议包括：\n\n- Session Initiation Protocol （SIP） \n- H. 323 （ITU standard, contributed support） \n- Inter- Asterisk eXchange （IAX） \n- Media Gateway Control Protocol （MGCP）\n\n### 2、结构\n\n![](https://img.fengjr.com/image/2019/06/20/685dc844b97b7277c0c9a66b0f3331a6.png)\n\n### 3、主要配置文件\n#### asterisk.confAsterisk\n各模块目录配置文件\n \n#### sip.conf\n配置 sip 帐号信息文件\n\n#### extensions.conf\n拨号计划配置文件\n\n#### voicemail.conf\n语音邮箱留言配置文件\n\n#### cdr_mysql.conf\n通话记录详情文件\n\n### manager.conf\nAMI 配置文件\n\n### 4、SIP 协议\n\n#### SIP 协议介绍\n\n会话初始协议（Session Initiation Protocol）是一个在 IP 网络上进行多媒体通信的应用层控制信令协议，它被用来创建、修改、和终结一个或多个参加者参加的会话进程，与 SDP、RTP/RTCP、DNS 等协议配合，共同完成会话建立及媒体协商。\n\n#### SIP 相关协议\n\n会话描述协议 SDP（Session Description Protocol）为应用层的控制协议，用于会话建立过程中的媒体协商。\n\nRTP/RTSP：都为应用层的承载面协议，会话建立后，RTP 协议保证媒体流的实时传输。RTSP 协议对实时传输的媒体流进行监控。\n\n#### SIP 在协议栈中的位置\n\n![](https://img.fengjr.com/image/2019/06/20/190783db5ec80efe86ea90b71cf120a4.png)\n\n#### SIP 的网络模型\n\n![](https://img.fengjr.com/image/2019/06/20/36c462619b1a0c4888ae27fea6900eda.png)\n\n#### SIP 协议报文格式\n\n```\nREGISTER sip:10.10.255.161:5060 SIP/2.0\nVia: SIP/2.0/UDP 10.254.21.11:44982;branch=z9hG4bK-d87543-4c778a261b56f612-1--d87543-;rport\nMax-Forwards: 70\nContact: <sip:111@10.254.21.11:44982;rinstance=40db0908120d6299>\nTo: \"111\"<sip:111@10.10.255.161:5060>\nFrom: \"111\"<sip:111@10.10.255.161:5060>;tag=3418703c\nCall-ID: ZmRiYmQyNzA1OGI4YTc0Y2Q2NmYwMTUyOGMwYmJjOTc.\nCSeq: 1 REGISTER\nExpires: 3600\nAllow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO\nUser-Agent: eyeBeam release 1011d stamp 40820\nContent-Length: 0\n```\n\n#### 基本呼叫过程\n\n![](https://img.fengjr.com/image/2019/06/20/906a0515a50f9ed85ac7a285f5f92d79.png)\n\n### 5、Dialplan 介绍\n\nDialplan 是 Asterisk 系统的真正核心，它定义了 Asterisk 怎样处理呼入和呼出。有四个部分构成： contexts， extensions， priorities 和 applications。\n\n```\n[TestMenu]\nexten=> 1234,1,Answer()\n    same=> n, Background(main-menu)\n    same=> n, WaitExten(5)\nexten=> 1,1,Dial(SIP/111)\n    same => n,Hangup()\nexten=> 2,1,Dial(SIP/222) \n    same => n,Hangup()\nexten=> i,1,Playback(pbx-invalid) ; i  invalid\n   same=>n, Goto(TestMenu,1234,1)\n exten=> t,1,Playback(vm-goodbye) ; t  timeout\n   same=>n, Hangup()\n\n```\n\n### 6、AGI 原理\n\nAGI 即 Asterisk  Gateway  Interface 它为外部程序提供了标准的接口来控制 Asterisk 的dialplan。 \n\n拨号计划中，可以采用各种语言很方便的通过 AGI 接口写脚本。脚本和 Asterisk 之间通过标准的输入输出进行交互，标准的输入输出分别为：\n- STDIN : 标准输入，外部脚本程序通过标准的输入，从  Asterisk 接收信息。\n- STDOUT: 标准输出, 外部脚本程序通过标准的输出，发送命令到 Asterisk。\n- STDERR : 标准错误输出，外部脚本程序通过标准错误输出调式信息到 Asterisk 控制台。　\n\n用例:\n\n```\nexten => 1234,1,Answer()\nsame=> n,agi(demo.php); demo.php 位于/var/lib/asterisk/agi-bin/，并且是可执行权限\nsame=> n,NoOp(${CALL_ID}); 在 Asterisk 控制台打印 CALL_ID 变量\nsame=> n,hangup()\n```\n\n```\narray (\n  'agi_request' => 'demo/record.php',\n  'agi_channel' => 'SIP/111-00000051',\n  'agi_language' => 'en',\n  'agi_type' => 'SIP',\n  'agi_uniqueid' => '1524539689.81',\n  'agi_version' => '11.25.1',\n  'agi_callerid' => '111',\n  'agi_calleridname' => '111',\n  'agi_callingpres' => '0',\n  'agi_callingani2' => '0',\n  'agi_callington' => '0',\n  'agi_callingtns' => '0',\n  'agi_dnid' => '444',\n  'agi_rdnis' => 'unknown',\n  'agi_context' => 'internal',\n  'agi_extension' => '444',\n  'agi_priority' => '2',\n  'agi_enhanced' => '0.0',\n  'agi_accountcode' => '',\n  'agi_threadid' => '140102795544320',\n  'agi_arg_1' => '111',\n  'agi_arg_2' => 'SIP/111-00000051',\n)\n\n```\n\n![](https://img.fengjr.com/image/2019/06/20/8f52d5d355486b664bd8996a0af18b82.png)\n\n### 7、AMI 远程控制 Asterisk\n\nAsterisk Manager API (Asterisk 控制接口)允许管理客户端程序连接到一个 Asterisk 实例，并且可以通过 TCP/IP (AMI 通过 TCP/IP 协议连接到 Asterisk 服务器的端口默认为 5038)流发送命令或读取事件。通过此接口，可以实现对 Asterisk 系统的监控和控制。\n\n/etc/asterisk/manager.conf 用于对这个管理接口进行配置，可以在 manager.conf 中设定新的用户名、口令和允许连接的网络地址，读写的权限等。\n\n```\n[general]\nenabled = yes\nport = 5038\nbindaddr = 10.254.21.11\n[admin]\nsecret = admin\ndeny = 0.0.0.0/0.0.0.0\npermit = 127.0.0.1/ 10.254.21.11\nread = all,system,call,log,verbose,command,agent,user,config\nwrite = all,system,call,log,verbose,command,agent,user,config\n```\n\nTCP 的 AMI 可以简单使用 telnet 命令 连接，例如\n\n\n```\ntelnet 10.254.21.11 5038\n```\n\n\n登录\n\n\n```\nAction: Login\nUsername: admin\nSecret: admin\n```\n\n拨打电话\n\n```\nAction: Originate\nChannel: SIP/111 ;主叫通道，只有主叫通道接通后，才会调用被叫号码/被叫所属 context\nExten: 222 ; 被叫号码，与 Context、 Priority 一起，是必须的参数\nContext: internal ; Exten 关联的上下文\nPriority: 1 ; Exten 关联的优先级\nTimeout: 3000  ;发起连接发生的超时（以毫秒为单位）（默认为30000毫秒）\nCallerId: 111 ;用于呼叫的来电显示\nAsync: true ;对于发起来说是异步的（允许在不等待响应的情况下生成多个调用）\n```\n\n\n退出\n\n```\nAction: Logoff\n```\n\n### 8、SIP Proxy\n\n1 . 配置 Asterisk 作为 SIP Proxy, 并让 eyeBeam 注册上去, 确保能打通电话就要用到  sip.conf  , Extension.conf 文件。\n\n配制分别如下：\n\n在 sip.conf文件中分别添加如下内容，其中 111 和 222 是预设的两个 sip 号码\n\n```\n[111]\nsecret=aaa                         ;密码，随意设置\nport=5060                         ;SIP端口地址\ntype=friend                       ;类型为 friend，可以相互拨打对方\nhost=dynamic                   ;要求号码注册,以便 Asterisk 可以知道如何找到电话\nqualify = yes                      ;确认远端设备是否可达\nnat = no                            ;如果一个号码在NAT设备后面,例如防火墙，配置为yes\ncontext = internal            ;定义了指令的地点,用于控制电话的权限,及如何处理此号码的呼入叫。\n```\n\n```\n[222]\nsecret=aaa\nport=5060\nqualify = yes\nnat = no\ncontext = internal\ncanreinvite = no\ntype=friend\nhost=dynamic\n```\n\n## Asterisk 语音通话方案\n\n### 1、网络拓扑\n\n![](https://img.fengjr.com/image/2019/06/20/287a9c0702e7d3b4e8c7ec7c94b4c39f.png)\n\n### 2、系统明细\n\n|项次|产品|\n|---|---|\n|1|系统服务器（32G 内存，8 核 CPU，1.8T 硬盘）|\n|1.1|语音服务器 |\n|1.2|录音服务器|\n|1.3|WEB 服务器|\n|2|数字中继网关|\n|3|CTI 坐席授权|\n|4|SIP 话机|\n|5|耳麦|\n\n- 语音服务器。部署基于开放源代码的 Asterisk 的 PBX 系统，提供了语音邮箱服务、电话会议、交互式语音应答(IVR)、呼叫队列，它还可以支持三方呼叫，主叫标识。\n- 录音服务器。存放、管理呼叫中心所有通话录音，同时防止单机问题，采取双台冗余。\n- WEB 服务器。业务管理、分机授权、线路接入、API 调用等功能模块。\n- 数字中继网关。接运营商中继线；与语音服务器对接。\n\n### 3、呼叫中心\n\n![](https://img.fengjr.com/image/2019/06/20/d8c6b0531e961c6b1c64cbcf96662e6b.png)\n### 4、中继线路\n\n- 独立组建。在 IDC 接入运行商中继线，配置语音网关。\n- 三方线路。三方给定语音服务器地址和端口，呼叫中心开发对接流程，在呼叫时与三方交互，同时由于通话经过 PBX 系统，因此录音也会在录音服务器有存留，方便后续检索。\n\n### 5、话机与中继网关\n\n话机。支持 SIP 协议，同时配有耳麦。\n\n![](https://img.fengjr.com/image/2019/06/20/8383a003a66405aea52ca8a5e2c233f8.png)\n\n中继网关。\n\n![](https://img.fengjr.com/image/2019/06/20/bb5c08e0a05a415f864ba6ba39bce8a2.png)\n\n![](https://img.fengjr.com/image/2019/06/20/594d180a3c02777646fb91e34bbbb8e8.png)\n\n## 凤金语音平台\n\n### 1、系统架构\n![系统架构图](https://img.fengjr.com/image/2019/06/20/0c4492813f1a2e28b3bdc40dee6681ec.png)\n### 2、线路对接\n\n|项次|厂商|\n|---|---|\n|1|中通|\n|2|鼎信通达 GSM 无线网关|\n|3|云之讯|\n|4|其他厂商（支持扩展）|\n\n### 3、数据统计\n\n**业务分机使用情况，总计 95**\n\n\n|业务|数量|备注|\n|---|---|---|\n|信审|\t26\t||\n||12|\t外包|\n|催收|\t45|\t包含提醒|\n||12|\t回访外包|\n\n**2018年7月到2019年5月外呼量**\n\n![](https://img.fengjr.com/image/2019/06/20/e9b231aef189017fd015dfe6bc2e337b.png)\n\n### 4、安全规划\n\n#### 分机、线路、业务日期设定\n\n![](https://img.fengjr.com/image/2019/06/20/96d3ec785bff1a62152568c222e0a2b4.png)\n\n![](https://img.fengjr.com/image/2019/06/20/b57fd122947e194f34483f497d59b60c.png)\n\n\n![](https://img.fengjr.com/image/2019/06/20/6fc2e68b65eb69e66d85519af4025f3c.png)\n\n#### API 鉴权\n\n![](https://img.fengjr.com/image/2019/06/20/a324aac1e30b64fdfcf1dcce6b9489d8.png)\n\n#### CTI 服务器防火墙白名单\n#### 服务器多机部署，数据冗余\n\n\n![](https://img.fengjr.com/image/2019/06/20/041eae51d040aed6aff301ccfdc7f4f0.png)","slug":"asterisk-share","published":1,"updated":"2020-06-10T06:02:03.477Z","_id":"cjxfsbp4e0005hgq5kods3x24","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/06/20/a0f32ca1a5cf0db218a0634ed40ac35f.png\" alt></p>\n<h1 id=\"基于Asterisk的语音通话方案在凤金语音平台的实践\"><a href=\"#基于Asterisk的语音通话方案在凤金语音平台的实践\" class=\"headerlink\" title=\"基于Asterisk的语音通话方案在凤金语音平台的实践\"></a>基于Asterisk的语音通话方案在凤金语音平台的实践</h1><h2 id=\"什么是-Asterisk\"><a href=\"#什么是-Asterisk\" class=\"headerlink\" title=\"什么是 Asterisk\"></a>什么是 Asterisk</h2><h3 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h3><p><strong><a href=\"https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F/100343?fromtitle=asterisk&amp;fromid=1181693&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">Asterisk</a></strong> 是一个应用于 VOIP 的开放源代码的 PBX 系统；可以运行在 Linux，BSD，Windows(仿真的)以及 OS X 上；提供了语音邮箱服务(Voicemail)、电话会议、交互式语音应答(IVR)、呼叫队列，它还可以支持三方呼叫，主叫标识；支持 4 类 VOIP 的协议；通过使用相对便宜的硬件，它可以与几乎全部基于标准的电话设备进行互联操作。</p>\n<p>与硬件 VOIP 相比，Asterisk 不仅具有其常用功能，还具有能够支持多媒体，具有可编程功能；Asterisk 需要的带宽，一般为 32KB/线路，也就是说每支持一条线路，只需要增32KB 的带宽，但是需要网络质量良好；Asterisk 可支持成千的客户端（需要板卡与带宽支持）。</p>\n<p><strong>Asterisk 能够支持传统的线路，包括：</strong></p>\n<ul>\n<li>TDM （Time Division Multiplexing） </li>\n<li>T1/E1 PRI/ PRA &amp; RBS （Robbed Bit Signal）modes </li>\n<li>Analog phone lines/ phones （POTS） </li>\n<li>ISDN （Integrated Services Digital Network） </li>\n<li>Both BRI （Basic Rate）and PRI （Primary Rate）</li>\n</ul>\n<p>Asterisk 支持的协议包括：</p>\n<ul>\n<li>Session Initiation Protocol （SIP） </li>\n<li>H. 323 （ITU standard, contributed support） </li>\n<li>Inter- Asterisk eXchange （IAX） </li>\n<li>Media Gateway Control Protocol （MGCP）</li>\n</ul>\n<h3 id=\"2、结构\"><a href=\"#2、结构\" class=\"headerlink\" title=\"2、结构\"></a>2、结构</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/685dc844b97b7277c0c9a66b0f3331a6.png\" alt></p>\n<h3 id=\"3、主要配置文件\"><a href=\"#3、主要配置文件\" class=\"headerlink\" title=\"3、主要配置文件\"></a>3、主要配置文件</h3><h4 id=\"asterisk-confAsterisk\"><a href=\"#asterisk-confAsterisk\" class=\"headerlink\" title=\"asterisk.confAsterisk\"></a>asterisk.confAsterisk</h4><p>各模块目录配置文件</p>\n<h4 id=\"sip-conf\"><a href=\"#sip-conf\" class=\"headerlink\" title=\"sip.conf\"></a>sip.conf</h4><p>配置 sip 帐号信息文件</p>\n<h4 id=\"extensions-conf\"><a href=\"#extensions-conf\" class=\"headerlink\" title=\"extensions.conf\"></a>extensions.conf</h4><p>拨号计划配置文件</p>\n<h4 id=\"voicemail-conf\"><a href=\"#voicemail-conf\" class=\"headerlink\" title=\"voicemail.conf\"></a>voicemail.conf</h4><p>语音邮箱留言配置文件</p>\n<h4 id=\"cdr-mysql-conf\"><a href=\"#cdr-mysql-conf\" class=\"headerlink\" title=\"cdr_mysql.conf\"></a>cdr_mysql.conf</h4><p>通话记录详情文件</p>\n<h3 id=\"manager-conf\"><a href=\"#manager-conf\" class=\"headerlink\" title=\"manager.conf\"></a>manager.conf</h3><p>AMI 配置文件</p>\n<h3 id=\"4、SIP-协议\"><a href=\"#4、SIP-协议\" class=\"headerlink\" title=\"4、SIP 协议\"></a>4、SIP 协议</h3><h4 id=\"SIP-协议介绍\"><a href=\"#SIP-协议介绍\" class=\"headerlink\" title=\"SIP 协议介绍\"></a>SIP 协议介绍</h4><p>会话初始协议（Session Initiation Protocol）是一个在 IP 网络上进行多媒体通信的应用层控制信令协议，它被用来创建、修改、和终结一个或多个参加者参加的会话进程，与 SDP、RTP/RTCP、DNS 等协议配合，共同完成会话建立及媒体协商。</p>\n<h4 id=\"SIP-相关协议\"><a href=\"#SIP-相关协议\" class=\"headerlink\" title=\"SIP 相关协议\"></a>SIP 相关协议</h4><p>会话描述协议 SDP（Session Description Protocol）为应用层的控制协议，用于会话建立过程中的媒体协商。</p>\n<p>RTP/RTSP：都为应用层的承载面协议，会话建立后，RTP 协议保证媒体流的实时传输。RTSP 协议对实时传输的媒体流进行监控。</p>\n<h4 id=\"SIP-在协议栈中的位置\"><a href=\"#SIP-在协议栈中的位置\" class=\"headerlink\" title=\"SIP 在协议栈中的位置\"></a>SIP 在协议栈中的位置</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/190783db5ec80efe86ea90b71cf120a4.png\" alt></p>\n<h4 id=\"SIP-的网络模型\"><a href=\"#SIP-的网络模型\" class=\"headerlink\" title=\"SIP 的网络模型\"></a>SIP 的网络模型</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/36c462619b1a0c4888ae27fea6900eda.png\" alt></p>\n<h4 id=\"SIP-协议报文格式\"><a href=\"#SIP-协议报文格式\" class=\"headerlink\" title=\"SIP 协议报文格式\"></a>SIP 协议报文格式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REGISTER sip:10.10.255.161:5060 SIP/2.0</span><br><span class=\"line\">Via: SIP/2.0/UDP 10.254.21.11:44982;branch=z9hG4bK-d87543-4c778a261b56f612-1--d87543-;rport</span><br><span class=\"line\">Max-Forwards: 70</span><br><span class=\"line\">Contact: &lt;sip:111@10.254.21.11:44982;rinstance=40db0908120d6299&gt;</span><br><span class=\"line\">To: &quot;111&quot;&lt;sip:111@10.10.255.161:5060&gt;</span><br><span class=\"line\">From: &quot;111&quot;&lt;sip:111@10.10.255.161:5060&gt;;tag=3418703c</span><br><span class=\"line\">Call-ID: ZmRiYmQyNzA1OGI4YTc0Y2Q2NmYwMTUyOGMwYmJjOTc.</span><br><span class=\"line\">CSeq: 1 REGISTER</span><br><span class=\"line\">Expires: 3600</span><br><span class=\"line\">Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO</span><br><span class=\"line\">User-Agent: eyeBeam release 1011d stamp 40820</span><br><span class=\"line\">Content-Length: 0</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本呼叫过程\"><a href=\"#基本呼叫过程\" class=\"headerlink\" title=\"基本呼叫过程\"></a>基本呼叫过程</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/906a0515a50f9ed85ac7a285f5f92d79.png\" alt></p>\n<h3 id=\"5、Dialplan-介绍\"><a href=\"#5、Dialplan-介绍\" class=\"headerlink\" title=\"5、Dialplan 介绍\"></a>5、Dialplan 介绍</h3><p>Dialplan 是 Asterisk 系统的真正核心，它定义了 Asterisk 怎样处理呼入和呼出。有四个部分构成： contexts， extensions， priorities 和 applications。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[TestMenu]</span><br><span class=\"line\">exten=&gt; 1234,1,Answer()</span><br><span class=\"line\">    same=&gt; n, Background(main-menu)</span><br><span class=\"line\">    same=&gt; n, WaitExten(5)</span><br><span class=\"line\">exten=&gt; 1,1,Dial(SIP/111)</span><br><span class=\"line\">    same =&gt; n,Hangup()</span><br><span class=\"line\">exten=&gt; 2,1,Dial(SIP/222) </span><br><span class=\"line\">    same =&gt; n,Hangup()</span><br><span class=\"line\">exten=&gt; i,1,Playback(pbx-invalid) ; i  invalid</span><br><span class=\"line\">   same=&gt;n, Goto(TestMenu,1234,1)</span><br><span class=\"line\"> exten=&gt; t,1,Playback(vm-goodbye) ; t  timeout</span><br><span class=\"line\">   same=&gt;n, Hangup()</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、AGI-原理\"><a href=\"#6、AGI-原理\" class=\"headerlink\" title=\"6、AGI 原理\"></a>6、AGI 原理</h3><p>AGI 即 Asterisk  Gateway  Interface 它为外部程序提供了标准的接口来控制 Asterisk 的dialplan。 </p>\n<p>拨号计划中，可以采用各种语言很方便的通过 AGI 接口写脚本。脚本和 Asterisk 之间通过标准的输入输出进行交互，标准的输入输出分别为：</p>\n<ul>\n<li>STDIN : 标准输入，外部脚本程序通过标准的输入，从  Asterisk 接收信息。</li>\n<li>STDOUT: 标准输出, 外部脚本程序通过标准的输出，发送命令到 Asterisk。</li>\n<li>STDERR : 标准错误输出，外部脚本程序通过标准错误输出调式信息到 Asterisk 控制台。　</li>\n</ul>\n<p>用例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exten =&gt; 1234,1,Answer()</span><br><span class=\"line\">same=&gt; n,agi(demo.php); demo.php 位于/var/lib/asterisk/agi-bin/，并且是可执行权限</span><br><span class=\"line\">same=&gt; n,NoOp($&#123;CALL_ID&#125;); 在 Asterisk 控制台打印 CALL_ID 变量</span><br><span class=\"line\">same=&gt; n,hangup()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array (</span><br><span class=\"line\">  &apos;agi_request&apos; =&gt; &apos;demo/record.php&apos;,</span><br><span class=\"line\">  &apos;agi_channel&apos; =&gt; &apos;SIP/111-00000051&apos;,</span><br><span class=\"line\">  &apos;agi_language&apos; =&gt; &apos;en&apos;,</span><br><span class=\"line\">  &apos;agi_type&apos; =&gt; &apos;SIP&apos;,</span><br><span class=\"line\">  &apos;agi_uniqueid&apos; =&gt; &apos;1524539689.81&apos;,</span><br><span class=\"line\">  &apos;agi_version&apos; =&gt; &apos;11.25.1&apos;,</span><br><span class=\"line\">  &apos;agi_callerid&apos; =&gt; &apos;111&apos;,</span><br><span class=\"line\">  &apos;agi_calleridname&apos; =&gt; &apos;111&apos;,</span><br><span class=\"line\">  &apos;agi_callingpres&apos; =&gt; &apos;0&apos;,</span><br><span class=\"line\">  &apos;agi_callingani2&apos; =&gt; &apos;0&apos;,</span><br><span class=\"line\">  &apos;agi_callington&apos; =&gt; &apos;0&apos;,</span><br><span class=\"line\">  &apos;agi_callingtns&apos; =&gt; &apos;0&apos;,</span><br><span class=\"line\">  &apos;agi_dnid&apos; =&gt; &apos;444&apos;,</span><br><span class=\"line\">  &apos;agi_rdnis&apos; =&gt; &apos;unknown&apos;,</span><br><span class=\"line\">  &apos;agi_context&apos; =&gt; &apos;internal&apos;,</span><br><span class=\"line\">  &apos;agi_extension&apos; =&gt; &apos;444&apos;,</span><br><span class=\"line\">  &apos;agi_priority&apos; =&gt; &apos;2&apos;,</span><br><span class=\"line\">  &apos;agi_enhanced&apos; =&gt; &apos;0.0&apos;,</span><br><span class=\"line\">  &apos;agi_accountcode&apos; =&gt; &apos;&apos;,</span><br><span class=\"line\">  &apos;agi_threadid&apos; =&gt; &apos;140102795544320&apos;,</span><br><span class=\"line\">  &apos;agi_arg_1&apos; =&gt; &apos;111&apos;,</span><br><span class=\"line\">  &apos;agi_arg_2&apos; =&gt; &apos;SIP/111-00000051&apos;,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/8f52d5d355486b664bd8996a0af18b82.png\" alt></p>\n<h3 id=\"7、AMI-远程控制-Asterisk\"><a href=\"#7、AMI-远程控制-Asterisk\" class=\"headerlink\" title=\"7、AMI 远程控制 Asterisk\"></a>7、AMI 远程控制 Asterisk</h3><p>Asterisk Manager API (Asterisk 控制接口)允许管理客户端程序连接到一个 Asterisk 实例，并且可以通过 TCP/IP (AMI 通过 TCP/IP 协议连接到 Asterisk 服务器的端口默认为 5038)流发送命令或读取事件。通过此接口，可以实现对 Asterisk 系统的监控和控制。</p>\n<p>/etc/asterisk/manager.conf 用于对这个管理接口进行配置，可以在 manager.conf 中设定新的用户名、口令和允许连接的网络地址，读写的权限等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[general]</span><br><span class=\"line\">enabled = yes</span><br><span class=\"line\">port = 5038</span><br><span class=\"line\">bindaddr = 10.254.21.11</span><br><span class=\"line\">[admin]</span><br><span class=\"line\">secret = admin</span><br><span class=\"line\">deny = 0.0.0.0/0.0.0.0</span><br><span class=\"line\">permit = 127.0.0.1/ 10.254.21.11</span><br><span class=\"line\">read = all,system,call,log,verbose,command,agent,user,config</span><br><span class=\"line\">write = all,system,call,log,verbose,command,agent,user,config</span><br></pre></td></tr></table></figure>\n<p>TCP 的 AMI 可以简单使用 telnet 命令 连接，例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet 10.254.21.11 5038</span><br></pre></td></tr></table></figure>\n<p>登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Action: Login</span><br><span class=\"line\">Username: admin</span><br><span class=\"line\">Secret: admin</span><br></pre></td></tr></table></figure>\n<p>拨打电话</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Action: Originate</span><br><span class=\"line\">Channel: SIP/111 ;主叫通道，只有主叫通道接通后，才会调用被叫号码/被叫所属 context</span><br><span class=\"line\">Exten: 222 ; 被叫号码，与 Context、 Priority 一起，是必须的参数</span><br><span class=\"line\">Context: internal ; Exten 关联的上下文</span><br><span class=\"line\">Priority: 1 ; Exten 关联的优先级</span><br><span class=\"line\">Timeout: 3000  ;发起连接发生的超时（以毫秒为单位）（默认为30000毫秒）</span><br><span class=\"line\">CallerId: 111 ;用于呼叫的来电显示</span><br><span class=\"line\">Async: true ;对于发起来说是异步的（允许在不等待响应的情况下生成多个调用）</span><br></pre></td></tr></table></figure>\n<p>退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Action: Logoff</span><br></pre></td></tr></table></figure>\n<h3 id=\"8、SIP-Proxy\"><a href=\"#8、SIP-Proxy\" class=\"headerlink\" title=\"8、SIP Proxy\"></a>8、SIP Proxy</h3><p>1 . 配置 Asterisk 作为 SIP Proxy, 并让 eyeBeam 注册上去, 确保能打通电话就要用到  sip.conf  , Extension.conf 文件。</p>\n<p>配制分别如下：</p>\n<p>在 sip.conf文件中分别添加如下内容，其中 111 和 222 是预设的两个 sip 号码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[111]</span><br><span class=\"line\">secret=aaa                         ;密码，随意设置</span><br><span class=\"line\">port=5060                         ;SIP端口地址</span><br><span class=\"line\">type=friend                       ;类型为 friend，可以相互拨打对方</span><br><span class=\"line\">host=dynamic                   ;要求号码注册,以便 Asterisk 可以知道如何找到电话</span><br><span class=\"line\">qualify = yes                      ;确认远端设备是否可达</span><br><span class=\"line\">nat = no                            ;如果一个号码在NAT设备后面,例如防火墙，配置为yes</span><br><span class=\"line\">context = internal            ;定义了指令的地点,用于控制电话的权限,及如何处理此号码的呼入叫。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[222]</span><br><span class=\"line\">secret=aaa</span><br><span class=\"line\">port=5060</span><br><span class=\"line\">qualify = yes</span><br><span class=\"line\">nat = no</span><br><span class=\"line\">context = internal</span><br><span class=\"line\">canreinvite = no</span><br><span class=\"line\">type=friend</span><br><span class=\"line\">host=dynamic</span><br></pre></td></tr></table></figure>\n<h2 id=\"Asterisk-语音通话方案\"><a href=\"#Asterisk-语音通话方案\" class=\"headerlink\" title=\"Asterisk 语音通话方案\"></a>Asterisk 语音通话方案</h2><h3 id=\"1、网络拓扑\"><a href=\"#1、网络拓扑\" class=\"headerlink\" title=\"1、网络拓扑\"></a>1、网络拓扑</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/287a9c0702e7d3b4e8c7ec7c94b4c39f.png\" alt></p>\n<h3 id=\"2、系统明细\"><a href=\"#2、系统明细\" class=\"headerlink\" title=\"2、系统明细\"></a>2、系统明细</h3><table>\n<thead>\n<tr>\n<th>项次</th>\n<th>产品</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>系统服务器（32G 内存，8 核 CPU，1.8T 硬盘）</td>\n</tr>\n<tr>\n<td>1.1</td>\n<td>语音服务器</td>\n</tr>\n<tr>\n<td>1.2</td>\n<td>录音服务器</td>\n</tr>\n<tr>\n<td>1.3</td>\n<td>WEB 服务器</td>\n</tr>\n<tr>\n<td>2</td>\n<td>数字中继网关</td>\n</tr>\n<tr>\n<td>3</td>\n<td>CTI 坐席授权</td>\n</tr>\n<tr>\n<td>4</td>\n<td>SIP 话机</td>\n</tr>\n<tr>\n<td>5</td>\n<td>耳麦</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>语音服务器。部署基于开放源代码的 Asterisk 的 PBX 系统，提供了语音邮箱服务、电话会议、交互式语音应答(IVR)、呼叫队列，它还可以支持三方呼叫，主叫标识。</li>\n<li>录音服务器。存放、管理呼叫中心所有通话录音，同时防止单机问题，采取双台冗余。</li>\n<li>WEB 服务器。业务管理、分机授权、线路接入、API 调用等功能模块。</li>\n<li>数字中继网关。接运营商中继线；与语音服务器对接。</li>\n</ul>\n<h3 id=\"3、呼叫中心\"><a href=\"#3、呼叫中心\" class=\"headerlink\" title=\"3、呼叫中心\"></a>3、呼叫中心</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/d8c6b0531e961c6b1c64cbcf96662e6b.png\" alt></p>\n<h3 id=\"4、中继线路\"><a href=\"#4、中继线路\" class=\"headerlink\" title=\"4、中继线路\"></a>4、中继线路</h3><ul>\n<li>独立组建。在 IDC 接入运行商中继线，配置语音网关。</li>\n<li>三方线路。三方给定语音服务器地址和端口，呼叫中心开发对接流程，在呼叫时与三方交互，同时由于通话经过 PBX 系统，因此录音也会在录音服务器有存留，方便后续检索。</li>\n</ul>\n<h3 id=\"5、话机与中继网关\"><a href=\"#5、话机与中继网关\" class=\"headerlink\" title=\"5、话机与中继网关\"></a>5、话机与中继网关</h3><p>话机。支持 SIP 协议，同时配有耳麦。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/8383a003a66405aea52ca8a5e2c233f8.png\" alt></p>\n<p>中继网关。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/bb5c08e0a05a415f864ba6ba39bce8a2.png\" alt></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/594d180a3c02777646fb91e34bbbb8e8.png\" alt></p>\n<h2 id=\"凤金语音平台\"><a href=\"#凤金语音平台\" class=\"headerlink\" title=\"凤金语音平台\"></a>凤金语音平台</h2><h3 id=\"1、系统架构\"><a href=\"#1、系统架构\" class=\"headerlink\" title=\"1、系统架构\"></a>1、系统架构</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/0c4492813f1a2e28b3bdc40dee6681ec.png\" alt=\"系统架构图\"></p>\n<h3 id=\"2、线路对接\"><a href=\"#2、线路对接\" class=\"headerlink\" title=\"2、线路对接\"></a>2、线路对接</h3><table>\n<thead>\n<tr>\n<th>项次</th>\n<th>厂商</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>中通</td>\n</tr>\n<tr>\n<td>2</td>\n<td>鼎信通达 GSM 无线网关</td>\n</tr>\n<tr>\n<td>3</td>\n<td>云之讯</td>\n</tr>\n<tr>\n<td>4</td>\n<td>其他厂商（支持扩展）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3、数据统计\"><a href=\"#3、数据统计\" class=\"headerlink\" title=\"3、数据统计\"></a>3、数据统计</h3><p><strong>业务分机使用情况，总计 95</strong></p>\n<table>\n<thead>\n<tr>\n<th>业务</th>\n<th>数量</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>信审</td>\n<td>26</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>12</td>\n<td>外包</td>\n</tr>\n<tr>\n<td>催收</td>\n<td>45</td>\n<td>包含提醒</td>\n</tr>\n<tr>\n<td></td>\n<td>12</td>\n<td>回访外包</td>\n</tr>\n</tbody>\n</table>\n<p><strong>2018年7月到2019年5月外呼量</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/e9b231aef189017fd015dfe6bc2e337b.png\" alt></p>\n<h3 id=\"4、安全规划\"><a href=\"#4、安全规划\" class=\"headerlink\" title=\"4、安全规划\"></a>4、安全规划</h3><h4 id=\"分机、线路、业务日期设定\"><a href=\"#分机、线路、业务日期设定\" class=\"headerlink\" title=\"分机、线路、业务日期设定\"></a>分机、线路、业务日期设定</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/96d3ec785bff1a62152568c222e0a2b4.png\" alt></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/b57fd122947e194f34483f497d59b60c.png\" alt></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/6fc2e68b65eb69e66d85519af4025f3c.png\" alt></p>\n<h4 id=\"API-鉴权\"><a href=\"#API-鉴权\" class=\"headerlink\" title=\"API 鉴权\"></a>API 鉴权</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/a324aac1e30b64fdfcf1dcce6b9489d8.png\" alt></p>\n<h4 id=\"CTI-服务器防火墙白名单\"><a href=\"#CTI-服务器防火墙白名单\" class=\"headerlink\" title=\"CTI 服务器防火墙白名单\"></a>CTI 服务器防火墙白名单</h4><h4 id=\"服务器多机部署，数据冗余\"><a href=\"#服务器多机部署，数据冗余\" class=\"headerlink\" title=\"服务器多机部署，数据冗余\"></a>服务器多机部署，数据冗余</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/041eae51d040aed6aff301ccfdc7f4f0.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/06/20/a0f32ca1a5cf0db218a0634ed40ac35f.png\" alt></p>\n<h1 id=\"基于Asterisk的语音通话方案在凤金语音平台的实践\"><a href=\"#基于Asterisk的语音通话方案在凤金语音平台的实践\" class=\"headerlink\" title=\"基于Asterisk的语音通话方案在凤金语音平台的实践\"></a>基于Asterisk的语音通话方案在凤金语音平台的实践</h1><h2 id=\"什么是-Asterisk\"><a href=\"#什么是-Asterisk\" class=\"headerlink\" title=\"什么是 Asterisk\"></a>什么是 Asterisk</h2><h3 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h3><p><strong><a href=\"https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F/100343?fromtitle=asterisk&amp;fromid=1181693&amp;fr=aladdin\" target=\"_blank\" rel=\"noopener\">Asterisk</a></strong> 是一个应用于 VOIP 的开放源代码的 PBX 系统；可以运行在 Linux，BSD，Windows(仿真的)以及 OS X 上；提供了语音邮箱服务(Voicemail)、电话会议、交互式语音应答(IVR)、呼叫队列，它还可以支持三方呼叫，主叫标识；支持 4 类 VOIP 的协议；通过使用相对便宜的硬件，它可以与几乎全部基于标准的电话设备进行互联操作。</p>\n<p>与硬件 VOIP 相比，Asterisk 不仅具有其常用功能，还具有能够支持多媒体，具有可编程功能；Asterisk 需要的带宽，一般为 32KB/线路，也就是说每支持一条线路，只需要增32KB 的带宽，但是需要网络质量良好；Asterisk 可支持成千的客户端（需要板卡与带宽支持）。</p>\n<p><strong>Asterisk 能够支持传统的线路，包括：</strong></p>\n<ul>\n<li>TDM （Time Division Multiplexing） </li>\n<li>T1/E1 PRI/ PRA &amp; RBS （Robbed Bit Signal）modes </li>\n<li>Analog phone lines/ phones （POTS） </li>\n<li>ISDN （Integrated Services Digital Network） </li>\n<li>Both BRI （Basic Rate）and PRI （Primary Rate）</li>\n</ul>\n<p>Asterisk 支持的协议包括：</p>\n<ul>\n<li>Session Initiation Protocol （SIP） </li>\n<li>H. 323 （ITU standard, contributed support） </li>\n<li>Inter- Asterisk eXchange （IAX） </li>\n<li>Media Gateway Control Protocol （MGCP）</li>\n</ul>\n<h3 id=\"2、结构\"><a href=\"#2、结构\" class=\"headerlink\" title=\"2、结构\"></a>2、结构</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/685dc844b97b7277c0c9a66b0f3331a6.png\" alt></p>\n<h3 id=\"3、主要配置文件\"><a href=\"#3、主要配置文件\" class=\"headerlink\" title=\"3、主要配置文件\"></a>3、主要配置文件</h3><h4 id=\"asterisk-confAsterisk\"><a href=\"#asterisk-confAsterisk\" class=\"headerlink\" title=\"asterisk.confAsterisk\"></a>asterisk.confAsterisk</h4><p>各模块目录配置文件</p>\n<h4 id=\"sip-conf\"><a href=\"#sip-conf\" class=\"headerlink\" title=\"sip.conf\"></a>sip.conf</h4><p>配置 sip 帐号信息文件</p>\n<h4 id=\"extensions-conf\"><a href=\"#extensions-conf\" class=\"headerlink\" title=\"extensions.conf\"></a>extensions.conf</h4><p>拨号计划配置文件</p>\n<h4 id=\"voicemail-conf\"><a href=\"#voicemail-conf\" class=\"headerlink\" title=\"voicemail.conf\"></a>voicemail.conf</h4><p>语音邮箱留言配置文件</p>\n<h4 id=\"cdr-mysql-conf\"><a href=\"#cdr-mysql-conf\" class=\"headerlink\" title=\"cdr_mysql.conf\"></a>cdr_mysql.conf</h4><p>通话记录详情文件</p>\n<h3 id=\"manager-conf\"><a href=\"#manager-conf\" class=\"headerlink\" title=\"manager.conf\"></a>manager.conf</h3><p>AMI 配置文件</p>\n<h3 id=\"4、SIP-协议\"><a href=\"#4、SIP-协议\" class=\"headerlink\" title=\"4、SIP 协议\"></a>4、SIP 协议</h3><h4 id=\"SIP-协议介绍\"><a href=\"#SIP-协议介绍\" class=\"headerlink\" title=\"SIP 协议介绍\"></a>SIP 协议介绍</h4><p>会话初始协议（Session Initiation Protocol）是一个在 IP 网络上进行多媒体通信的应用层控制信令协议，它被用来创建、修改、和终结一个或多个参加者参加的会话进程，与 SDP、RTP/RTCP、DNS 等协议配合，共同完成会话建立及媒体协商。</p>\n<h4 id=\"SIP-相关协议\"><a href=\"#SIP-相关协议\" class=\"headerlink\" title=\"SIP 相关协议\"></a>SIP 相关协议</h4><p>会话描述协议 SDP（Session Description Protocol）为应用层的控制协议，用于会话建立过程中的媒体协商。</p>\n<p>RTP/RTSP：都为应用层的承载面协议，会话建立后，RTP 协议保证媒体流的实时传输。RTSP 协议对实时传输的媒体流进行监控。</p>\n<h4 id=\"SIP-在协议栈中的位置\"><a href=\"#SIP-在协议栈中的位置\" class=\"headerlink\" title=\"SIP 在协议栈中的位置\"></a>SIP 在协议栈中的位置</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/190783db5ec80efe86ea90b71cf120a4.png\" alt></p>\n<h4 id=\"SIP-的网络模型\"><a href=\"#SIP-的网络模型\" class=\"headerlink\" title=\"SIP 的网络模型\"></a>SIP 的网络模型</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/36c462619b1a0c4888ae27fea6900eda.png\" alt></p>\n<h4 id=\"SIP-协议报文格式\"><a href=\"#SIP-协议报文格式\" class=\"headerlink\" title=\"SIP 协议报文格式\"></a>SIP 协议报文格式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REGISTER sip:10.10.255.161:5060 SIP/2.0</span><br><span class=\"line\">Via: SIP/2.0/UDP 10.254.21.11:44982;branch=z9hG4bK-d87543-4c778a261b56f612-1--d87543-;rport</span><br><span class=\"line\">Max-Forwards: 70</span><br><span class=\"line\">Contact: &lt;sip:111@10.254.21.11:44982;rinstance=40db0908120d6299&gt;</span><br><span class=\"line\">To: &quot;111&quot;&lt;sip:111@10.10.255.161:5060&gt;</span><br><span class=\"line\">From: &quot;111&quot;&lt;sip:111@10.10.255.161:5060&gt;;tag=3418703c</span><br><span class=\"line\">Call-ID: ZmRiYmQyNzA1OGI4YTc0Y2Q2NmYwMTUyOGMwYmJjOTc.</span><br><span class=\"line\">CSeq: 1 REGISTER</span><br><span class=\"line\">Expires: 3600</span><br><span class=\"line\">Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO</span><br><span class=\"line\">User-Agent: eyeBeam release 1011d stamp 40820</span><br><span class=\"line\">Content-Length: 0</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本呼叫过程\"><a href=\"#基本呼叫过程\" class=\"headerlink\" title=\"基本呼叫过程\"></a>基本呼叫过程</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/906a0515a50f9ed85ac7a285f5f92d79.png\" alt></p>\n<h3 id=\"5、Dialplan-介绍\"><a href=\"#5、Dialplan-介绍\" class=\"headerlink\" title=\"5、Dialplan 介绍\"></a>5、Dialplan 介绍</h3><p>Dialplan 是 Asterisk 系统的真正核心，它定义了 Asterisk 怎样处理呼入和呼出。有四个部分构成： contexts， extensions， priorities 和 applications。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[TestMenu]</span><br><span class=\"line\">exten=&gt; 1234,1,Answer()</span><br><span class=\"line\">    same=&gt; n, Background(main-menu)</span><br><span class=\"line\">    same=&gt; n, WaitExten(5)</span><br><span class=\"line\">exten=&gt; 1,1,Dial(SIP/111)</span><br><span class=\"line\">    same =&gt; n,Hangup()</span><br><span class=\"line\">exten=&gt; 2,1,Dial(SIP/222) </span><br><span class=\"line\">    same =&gt; n,Hangup()</span><br><span class=\"line\">exten=&gt; i,1,Playback(pbx-invalid) ; i  invalid</span><br><span class=\"line\">   same=&gt;n, Goto(TestMenu,1234,1)</span><br><span class=\"line\"> exten=&gt; t,1,Playback(vm-goodbye) ; t  timeout</span><br><span class=\"line\">   same=&gt;n, Hangup()</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、AGI-原理\"><a href=\"#6、AGI-原理\" class=\"headerlink\" title=\"6、AGI 原理\"></a>6、AGI 原理</h3><p>AGI 即 Asterisk  Gateway  Interface 它为外部程序提供了标准的接口来控制 Asterisk 的dialplan。 </p>\n<p>拨号计划中，可以采用各种语言很方便的通过 AGI 接口写脚本。脚本和 Asterisk 之间通过标准的输入输出进行交互，标准的输入输出分别为：</p>\n<ul>\n<li>STDIN : 标准输入，外部脚本程序通过标准的输入，从  Asterisk 接收信息。</li>\n<li>STDOUT: 标准输出, 外部脚本程序通过标准的输出，发送命令到 Asterisk。</li>\n<li>STDERR : 标准错误输出，外部脚本程序通过标准错误输出调式信息到 Asterisk 控制台。　</li>\n</ul>\n<p>用例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exten =&gt; 1234,1,Answer()</span><br><span class=\"line\">same=&gt; n,agi(demo.php); demo.php 位于/var/lib/asterisk/agi-bin/，并且是可执行权限</span><br><span class=\"line\">same=&gt; n,NoOp($&#123;CALL_ID&#125;); 在 Asterisk 控制台打印 CALL_ID 变量</span><br><span class=\"line\">same=&gt; n,hangup()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array (</span><br><span class=\"line\">  &apos;agi_request&apos; =&gt; &apos;demo/record.php&apos;,</span><br><span class=\"line\">  &apos;agi_channel&apos; =&gt; &apos;SIP/111-00000051&apos;,</span><br><span class=\"line\">  &apos;agi_language&apos; =&gt; &apos;en&apos;,</span><br><span class=\"line\">  &apos;agi_type&apos; =&gt; &apos;SIP&apos;,</span><br><span class=\"line\">  &apos;agi_uniqueid&apos; =&gt; &apos;1524539689.81&apos;,</span><br><span class=\"line\">  &apos;agi_version&apos; =&gt; &apos;11.25.1&apos;,</span><br><span class=\"line\">  &apos;agi_callerid&apos; =&gt; &apos;111&apos;,</span><br><span class=\"line\">  &apos;agi_calleridname&apos; =&gt; &apos;111&apos;,</span><br><span class=\"line\">  &apos;agi_callingpres&apos; =&gt; &apos;0&apos;,</span><br><span class=\"line\">  &apos;agi_callingani2&apos; =&gt; &apos;0&apos;,</span><br><span class=\"line\">  &apos;agi_callington&apos; =&gt; &apos;0&apos;,</span><br><span class=\"line\">  &apos;agi_callingtns&apos; =&gt; &apos;0&apos;,</span><br><span class=\"line\">  &apos;agi_dnid&apos; =&gt; &apos;444&apos;,</span><br><span class=\"line\">  &apos;agi_rdnis&apos; =&gt; &apos;unknown&apos;,</span><br><span class=\"line\">  &apos;agi_context&apos; =&gt; &apos;internal&apos;,</span><br><span class=\"line\">  &apos;agi_extension&apos; =&gt; &apos;444&apos;,</span><br><span class=\"line\">  &apos;agi_priority&apos; =&gt; &apos;2&apos;,</span><br><span class=\"line\">  &apos;agi_enhanced&apos; =&gt; &apos;0.0&apos;,</span><br><span class=\"line\">  &apos;agi_accountcode&apos; =&gt; &apos;&apos;,</span><br><span class=\"line\">  &apos;agi_threadid&apos; =&gt; &apos;140102795544320&apos;,</span><br><span class=\"line\">  &apos;agi_arg_1&apos; =&gt; &apos;111&apos;,</span><br><span class=\"line\">  &apos;agi_arg_2&apos; =&gt; &apos;SIP/111-00000051&apos;,</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/8f52d5d355486b664bd8996a0af18b82.png\" alt></p>\n<h3 id=\"7、AMI-远程控制-Asterisk\"><a href=\"#7、AMI-远程控制-Asterisk\" class=\"headerlink\" title=\"7、AMI 远程控制 Asterisk\"></a>7、AMI 远程控制 Asterisk</h3><p>Asterisk Manager API (Asterisk 控制接口)允许管理客户端程序连接到一个 Asterisk 实例，并且可以通过 TCP/IP (AMI 通过 TCP/IP 协议连接到 Asterisk 服务器的端口默认为 5038)流发送命令或读取事件。通过此接口，可以实现对 Asterisk 系统的监控和控制。</p>\n<p>/etc/asterisk/manager.conf 用于对这个管理接口进行配置，可以在 manager.conf 中设定新的用户名、口令和允许连接的网络地址，读写的权限等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[general]</span><br><span class=\"line\">enabled = yes</span><br><span class=\"line\">port = 5038</span><br><span class=\"line\">bindaddr = 10.254.21.11</span><br><span class=\"line\">[admin]</span><br><span class=\"line\">secret = admin</span><br><span class=\"line\">deny = 0.0.0.0/0.0.0.0</span><br><span class=\"line\">permit = 127.0.0.1/ 10.254.21.11</span><br><span class=\"line\">read = all,system,call,log,verbose,command,agent,user,config</span><br><span class=\"line\">write = all,system,call,log,verbose,command,agent,user,config</span><br></pre></td></tr></table></figure>\n<p>TCP 的 AMI 可以简单使用 telnet 命令 连接，例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet 10.254.21.11 5038</span><br></pre></td></tr></table></figure>\n<p>登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Action: Login</span><br><span class=\"line\">Username: admin</span><br><span class=\"line\">Secret: admin</span><br></pre></td></tr></table></figure>\n<p>拨打电话</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Action: Originate</span><br><span class=\"line\">Channel: SIP/111 ;主叫通道，只有主叫通道接通后，才会调用被叫号码/被叫所属 context</span><br><span class=\"line\">Exten: 222 ; 被叫号码，与 Context、 Priority 一起，是必须的参数</span><br><span class=\"line\">Context: internal ; Exten 关联的上下文</span><br><span class=\"line\">Priority: 1 ; Exten 关联的优先级</span><br><span class=\"line\">Timeout: 3000  ;发起连接发生的超时（以毫秒为单位）（默认为30000毫秒）</span><br><span class=\"line\">CallerId: 111 ;用于呼叫的来电显示</span><br><span class=\"line\">Async: true ;对于发起来说是异步的（允许在不等待响应的情况下生成多个调用）</span><br></pre></td></tr></table></figure>\n<p>退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Action: Logoff</span><br></pre></td></tr></table></figure>\n<h3 id=\"8、SIP-Proxy\"><a href=\"#8、SIP-Proxy\" class=\"headerlink\" title=\"8、SIP Proxy\"></a>8、SIP Proxy</h3><p>1 . 配置 Asterisk 作为 SIP Proxy, 并让 eyeBeam 注册上去, 确保能打通电话就要用到  sip.conf  , Extension.conf 文件。</p>\n<p>配制分别如下：</p>\n<p>在 sip.conf文件中分别添加如下内容，其中 111 和 222 是预设的两个 sip 号码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[111]</span><br><span class=\"line\">secret=aaa                         ;密码，随意设置</span><br><span class=\"line\">port=5060                         ;SIP端口地址</span><br><span class=\"line\">type=friend                       ;类型为 friend，可以相互拨打对方</span><br><span class=\"line\">host=dynamic                   ;要求号码注册,以便 Asterisk 可以知道如何找到电话</span><br><span class=\"line\">qualify = yes                      ;确认远端设备是否可达</span><br><span class=\"line\">nat = no                            ;如果一个号码在NAT设备后面,例如防火墙，配置为yes</span><br><span class=\"line\">context = internal            ;定义了指令的地点,用于控制电话的权限,及如何处理此号码的呼入叫。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[222]</span><br><span class=\"line\">secret=aaa</span><br><span class=\"line\">port=5060</span><br><span class=\"line\">qualify = yes</span><br><span class=\"line\">nat = no</span><br><span class=\"line\">context = internal</span><br><span class=\"line\">canreinvite = no</span><br><span class=\"line\">type=friend</span><br><span class=\"line\">host=dynamic</span><br></pre></td></tr></table></figure>\n<h2 id=\"Asterisk-语音通话方案\"><a href=\"#Asterisk-语音通话方案\" class=\"headerlink\" title=\"Asterisk 语音通话方案\"></a>Asterisk 语音通话方案</h2><h3 id=\"1、网络拓扑\"><a href=\"#1、网络拓扑\" class=\"headerlink\" title=\"1、网络拓扑\"></a>1、网络拓扑</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/287a9c0702e7d3b4e8c7ec7c94b4c39f.png\" alt></p>\n<h3 id=\"2、系统明细\"><a href=\"#2、系统明细\" class=\"headerlink\" title=\"2、系统明细\"></a>2、系统明细</h3><table>\n<thead>\n<tr>\n<th>项次</th>\n<th>产品</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>系统服务器（32G 内存，8 核 CPU，1.8T 硬盘）</td>\n</tr>\n<tr>\n<td>1.1</td>\n<td>语音服务器</td>\n</tr>\n<tr>\n<td>1.2</td>\n<td>录音服务器</td>\n</tr>\n<tr>\n<td>1.3</td>\n<td>WEB 服务器</td>\n</tr>\n<tr>\n<td>2</td>\n<td>数字中继网关</td>\n</tr>\n<tr>\n<td>3</td>\n<td>CTI 坐席授权</td>\n</tr>\n<tr>\n<td>4</td>\n<td>SIP 话机</td>\n</tr>\n<tr>\n<td>5</td>\n<td>耳麦</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>语音服务器。部署基于开放源代码的 Asterisk 的 PBX 系统，提供了语音邮箱服务、电话会议、交互式语音应答(IVR)、呼叫队列，它还可以支持三方呼叫，主叫标识。</li>\n<li>录音服务器。存放、管理呼叫中心所有通话录音，同时防止单机问题，采取双台冗余。</li>\n<li>WEB 服务器。业务管理、分机授权、线路接入、API 调用等功能模块。</li>\n<li>数字中继网关。接运营商中继线；与语音服务器对接。</li>\n</ul>\n<h3 id=\"3、呼叫中心\"><a href=\"#3、呼叫中心\" class=\"headerlink\" title=\"3、呼叫中心\"></a>3、呼叫中心</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/d8c6b0531e961c6b1c64cbcf96662e6b.png\" alt></p>\n<h3 id=\"4、中继线路\"><a href=\"#4、中继线路\" class=\"headerlink\" title=\"4、中继线路\"></a>4、中继线路</h3><ul>\n<li>独立组建。在 IDC 接入运行商中继线，配置语音网关。</li>\n<li>三方线路。三方给定语音服务器地址和端口，呼叫中心开发对接流程，在呼叫时与三方交互，同时由于通话经过 PBX 系统，因此录音也会在录音服务器有存留，方便后续检索。</li>\n</ul>\n<h3 id=\"5、话机与中继网关\"><a href=\"#5、话机与中继网关\" class=\"headerlink\" title=\"5、话机与中继网关\"></a>5、话机与中继网关</h3><p>话机。支持 SIP 协议，同时配有耳麦。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/8383a003a66405aea52ca8a5e2c233f8.png\" alt></p>\n<p>中继网关。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/bb5c08e0a05a415f864ba6ba39bce8a2.png\" alt></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/594d180a3c02777646fb91e34bbbb8e8.png\" alt></p>\n<h2 id=\"凤金语音平台\"><a href=\"#凤金语音平台\" class=\"headerlink\" title=\"凤金语音平台\"></a>凤金语音平台</h2><h3 id=\"1、系统架构\"><a href=\"#1、系统架构\" class=\"headerlink\" title=\"1、系统架构\"></a>1、系统架构</h3><p><img src=\"https://img.fengjr.com/image/2019/06/20/0c4492813f1a2e28b3bdc40dee6681ec.png\" alt=\"系统架构图\"></p>\n<h3 id=\"2、线路对接\"><a href=\"#2、线路对接\" class=\"headerlink\" title=\"2、线路对接\"></a>2、线路对接</h3><table>\n<thead>\n<tr>\n<th>项次</th>\n<th>厂商</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>中通</td>\n</tr>\n<tr>\n<td>2</td>\n<td>鼎信通达 GSM 无线网关</td>\n</tr>\n<tr>\n<td>3</td>\n<td>云之讯</td>\n</tr>\n<tr>\n<td>4</td>\n<td>其他厂商（支持扩展）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3、数据统计\"><a href=\"#3、数据统计\" class=\"headerlink\" title=\"3、数据统计\"></a>3、数据统计</h3><p><strong>业务分机使用情况，总计 95</strong></p>\n<table>\n<thead>\n<tr>\n<th>业务</th>\n<th>数量</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>信审</td>\n<td>26</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>12</td>\n<td>外包</td>\n</tr>\n<tr>\n<td>催收</td>\n<td>45</td>\n<td>包含提醒</td>\n</tr>\n<tr>\n<td></td>\n<td>12</td>\n<td>回访外包</td>\n</tr>\n</tbody>\n</table>\n<p><strong>2018年7月到2019年5月外呼量</strong></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/e9b231aef189017fd015dfe6bc2e337b.png\" alt></p>\n<h3 id=\"4、安全规划\"><a href=\"#4、安全规划\" class=\"headerlink\" title=\"4、安全规划\"></a>4、安全规划</h3><h4 id=\"分机、线路、业务日期设定\"><a href=\"#分机、线路、业务日期设定\" class=\"headerlink\" title=\"分机、线路、业务日期设定\"></a>分机、线路、业务日期设定</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/96d3ec785bff1a62152568c222e0a2b4.png\" alt></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/b57fd122947e194f34483f497d59b60c.png\" alt></p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/20/6fc2e68b65eb69e66d85519af4025f3c.png\" alt></p>\n<h4 id=\"API-鉴权\"><a href=\"#API-鉴权\" class=\"headerlink\" title=\"API 鉴权\"></a>API 鉴权</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/a324aac1e30b64fdfcf1dcce6b9489d8.png\" alt></p>\n<h4 id=\"CTI-服务器防火墙白名单\"><a href=\"#CTI-服务器防火墙白名单\" class=\"headerlink\" title=\"CTI 服务器防火墙白名单\"></a>CTI 服务器防火墙白名单</h4><h4 id=\"服务器多机部署，数据冗余\"><a href=\"#服务器多机部署，数据冗余\" class=\"headerlink\" title=\"服务器多机部署，数据冗余\"></a>服务器多机部署，数据冗余</h4><p><img src=\"https://img.fengjr.com/image/2019/06/20/041eae51d040aed6aff301ccfdc7f4f0.png\" alt></p>\n"},{"title":"针对PDM系统开发所遇到的问题","comments":1,"date":"2019-06-28T09:10:00.000Z","author":"jun.zhou","_content":"\n![](https://img.fengjr.com/image/2019/06/28/4f400053a504e31cda1550ce9eacb0df.png)\n\n# 针对PDM系统开发所遇到的问题（react+antd）\n\n### 一、查询选择分页问题（先选值不查询进行分页）\n\n 我们在查询搜索的时候，如果选择查询条件但未点击查询搜索的时候点击分页，会出现所分页内容已经是刚所选择的条件查询内容，原因是state里的查询值是公用的且每次选择条件完之后已经给其字段赋值。\n\n* 解决办法\n\ta. 查询和传值分开存储\n\t\n```js\nstata={\n\tquery:{...}\n\tqueryData:{...}\n}\n```\n\tb. 查询选择使用form表单的形式\n\t\n###  二、setState修改深层对象问题\t\n\t\n我们在修改数据的时候会遇到深层对象的值，无法用常规的直接键值对的方式获取。\n\t\n* 解决办法\n\n\t以下三种方式可解决\n\t\n```js\nlet data = Object.assign({}, this.state.list, {a: 'D1'})\nthis.setState({\n\tlist: data\n})\n\nlet data = this.state.list;\ndata.a.name = 'A1';\ndata.b.name = 'B1';\nthis.setState({\n\tlist: data\n})\n\nthis.setState({\n\tlist: {\n\t\t...this.state.list,\n\t\ta: {},\n\t\tb: {}\n\t}\n})\n\n```\n\t\n\n### 三、Ant Design开发中遇到问题\n\n1、单组件里多表单校验问题，我们在开发经常会遇到一个页面里面会有多张表单提交，比如编辑、新建~。这样会造成我们在提交进行校验会出现多张表单同时被校验，无法进行单个表单校验通过的问题。\n\n* 解决办法\n\t单独给表单建立一个新的子组件，然后将校验的表单统一传给需要提交的组件里面\n\t\n2、动态添加表单，删除表单时会出现空值且占数组一个位置问题。\n\n* 解决办法\n\t做删减操作时过滤清空数组\n\t\n```js\nif (val.names) {\n\tval.names.push(val.departmentName);\n}\nlet arr = val.names ? val.names.filter(k => k) : [];\nlet jsonData = {\n\tcompanyId: val.companyName,\n\tdepartmentNames: val.names ? arr.join() : val.departmentName\n};\n```\n\t\n3、无法清空表单问题，当使用了默认值initailValue时this.props.form.resetFields()无法清空。\n\n* 解决办法\n\ta. 清除state中对应的变量字段\n\tb. 不使用initailValue\n\n4、单个文件上传问题，每次上传单个文件且下次上传需替换上次上传的。\n\n* 解决办法\n\t再次上传清空当前数组，重新push\n\t\n```js\n<FormItem label=\"附件上传\">\n\t{this.state.visible &&\n\tgetFieldDecorator('upload', {\n\t\trules: isFile ? []:\n\t\t[{ required: true, message: '您未上传文件！' }]\n\t})(\n\t<Upload {...upLoadProps} fileList={fileList || []}>\n\t\t<Button icon=\"upload\">上传文件</Button>\n\t</Upload>\n</FormItem>\n```\n```js\nuploadOnchage = info => {\n    const maxCount = 1; //限制上传个数\n    if (info.file.status === 'done') {\n      if (info.fileList.length > maxCount) {\n        info.fileList.shift();\n      }\n      message.success(`${info.file.name} 上传成功`);\n      getUploadFileNameApi(info.file.response.data.targetFileName)\n        .then(resData => {\n          let fileListNew = info.fileList;\n          fileListNew = fileListNew.slice(-2);\n          fileListNew = fileListNew.map(file => {\n            const item = file;\n            if (file.response) {\n              item.url = resData;\n            }\n            return item;\n          });\n          this.setState({\n            fileUrl: resData,\n            fileList: fileListNew\n          });\n        })\n        .catch(err => message.error(err.message));\n    } else if (info.file.status === 'error') {\n      message.error(`${info.file.name} 上传失败`);\n    }\n    this.onChangeFileList(info.fileList);\n};\n```\n\n","source":"_posts/2019-06-28-pdm系统开发遇到的相关问题.md","raw":"---\ntitle: 针对PDM系统开发所遇到的问题\ncomments: true\ndate: 2019-06-28 17:10:00\ntags:\n- react\n- antd\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n![](https://img.fengjr.com/image/2019/06/28/4f400053a504e31cda1550ce9eacb0df.png)\n\n# 针对PDM系统开发所遇到的问题（react+antd）\n\n### 一、查询选择分页问题（先选值不查询进行分页）\n\n 我们在查询搜索的时候，如果选择查询条件但未点击查询搜索的时候点击分页，会出现所分页内容已经是刚所选择的条件查询内容，原因是state里的查询值是公用的且每次选择条件完之后已经给其字段赋值。\n\n* 解决办法\n\ta. 查询和传值分开存储\n\t\n```js\nstata={\n\tquery:{...}\n\tqueryData:{...}\n}\n```\n\tb. 查询选择使用form表单的形式\n\t\n###  二、setState修改深层对象问题\t\n\t\n我们在修改数据的时候会遇到深层对象的值，无法用常规的直接键值对的方式获取。\n\t\n* 解决办法\n\n\t以下三种方式可解决\n\t\n```js\nlet data = Object.assign({}, this.state.list, {a: 'D1'})\nthis.setState({\n\tlist: data\n})\n\nlet data = this.state.list;\ndata.a.name = 'A1';\ndata.b.name = 'B1';\nthis.setState({\n\tlist: data\n})\n\nthis.setState({\n\tlist: {\n\t\t...this.state.list,\n\t\ta: {},\n\t\tb: {}\n\t}\n})\n\n```\n\t\n\n### 三、Ant Design开发中遇到问题\n\n1、单组件里多表单校验问题，我们在开发经常会遇到一个页面里面会有多张表单提交，比如编辑、新建~。这样会造成我们在提交进行校验会出现多张表单同时被校验，无法进行单个表单校验通过的问题。\n\n* 解决办法\n\t单独给表单建立一个新的子组件，然后将校验的表单统一传给需要提交的组件里面\n\t\n2、动态添加表单，删除表单时会出现空值且占数组一个位置问题。\n\n* 解决办法\n\t做删减操作时过滤清空数组\n\t\n```js\nif (val.names) {\n\tval.names.push(val.departmentName);\n}\nlet arr = val.names ? val.names.filter(k => k) : [];\nlet jsonData = {\n\tcompanyId: val.companyName,\n\tdepartmentNames: val.names ? arr.join() : val.departmentName\n};\n```\n\t\n3、无法清空表单问题，当使用了默认值initailValue时this.props.form.resetFields()无法清空。\n\n* 解决办法\n\ta. 清除state中对应的变量字段\n\tb. 不使用initailValue\n\n4、单个文件上传问题，每次上传单个文件且下次上传需替换上次上传的。\n\n* 解决办法\n\t再次上传清空当前数组，重新push\n\t\n```js\n<FormItem label=\"附件上传\">\n\t{this.state.visible &&\n\tgetFieldDecorator('upload', {\n\t\trules: isFile ? []:\n\t\t[{ required: true, message: '您未上传文件！' }]\n\t})(\n\t<Upload {...upLoadProps} fileList={fileList || []}>\n\t\t<Button icon=\"upload\">上传文件</Button>\n\t</Upload>\n</FormItem>\n```\n```js\nuploadOnchage = info => {\n    const maxCount = 1; //限制上传个数\n    if (info.file.status === 'done') {\n      if (info.fileList.length > maxCount) {\n        info.fileList.shift();\n      }\n      message.success(`${info.file.name} 上传成功`);\n      getUploadFileNameApi(info.file.response.data.targetFileName)\n        .then(resData => {\n          let fileListNew = info.fileList;\n          fileListNew = fileListNew.slice(-2);\n          fileListNew = fileListNew.map(file => {\n            const item = file;\n            if (file.response) {\n              item.url = resData;\n            }\n            return item;\n          });\n          this.setState({\n            fileUrl: resData,\n            fileList: fileListNew\n          });\n        })\n        .catch(err => message.error(err.message));\n    } else if (info.file.status === 'error') {\n      message.error(`${info.file.name} 上传失败`);\n    }\n    this.onChangeFileList(info.fileList);\n};\n```\n\n","slug":"pdm系统开发遇到的相关问题","published":1,"updated":"2020-06-10T06:01:58.795Z","_id":"cjxfsbp4h0009hgq569lsne3l","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/06/28/4f400053a504e31cda1550ce9eacb0df.png\" alt></p>\n<h1 id=\"针对PDM系统开发所遇到的问题（react-antd）\"><a href=\"#针对PDM系统开发所遇到的问题（react-antd）\" class=\"headerlink\" title=\"针对PDM系统开发所遇到的问题（react+antd）\"></a>针对PDM系统开发所遇到的问题（react+antd）</h1><h3 id=\"一、查询选择分页问题（先选值不查询进行分页）\"><a href=\"#一、查询选择分页问题（先选值不查询进行分页）\" class=\"headerlink\" title=\"一、查询选择分页问题（先选值不查询进行分页）\"></a>一、查询选择分页问题（先选值不查询进行分页）</h3><p> 我们在查询搜索的时候，如果选择查询条件但未点击查询搜索的时候点击分页，会出现所分页内容已经是刚所选择的条件查询内容，原因是state里的查询值是公用的且每次选择条件完之后已经给其字段赋值。</p>\n<ul>\n<li>解决办法<br>  a. 查询和传值分开存储</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stata=&#123;</span><br><span class=\"line\">\tquery:&#123;...&#125;</span><br><span class=\"line\">\tqueryData:&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>b. 查询选择使用form表单的形式\n</code></pre><h3 id=\"二、setState修改深层对象问题\"><a href=\"#二、setState修改深层对象问题\" class=\"headerlink\" title=\"二、setState修改深层对象问题\"></a>二、setState修改深层对象问题</h3><p>我们在修改数据的时候会遇到深层对象的值，无法用常规的直接键值对的方式获取。</p>\n<ul>\n<li><p>解决办法</p>\n<p>  以下三种方式可解决</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"keyword\">this</span>.state.list, &#123;<span class=\"attr\">a</span>: <span class=\"string\">'D1'</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">\tlist: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"keyword\">this</span>.state.list;</span><br><span class=\"line\">data.a.name = <span class=\"string\">'A1'</span>;</span><br><span class=\"line\">data.b.name = <span class=\"string\">'B1'</span>;</span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">\tlist: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">\tlist: &#123;</span><br><span class=\"line\">\t\t...this.state.list,</span><br><span class=\"line\">\t\ta: &#123;&#125;,</span><br><span class=\"line\">\t\tb: &#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、Ant-Design开发中遇到问题\"><a href=\"#三、Ant-Design开发中遇到问题\" class=\"headerlink\" title=\"三、Ant Design开发中遇到问题\"></a>三、Ant Design开发中遇到问题</h3><p>1、单组件里多表单校验问题，我们在开发经常会遇到一个页面里面会有多张表单提交，比如编辑、新建~。这样会造成我们在提交进行校验会出现多张表单同时被校验，无法进行单个表单校验通过的问题。</p>\n<ul>\n<li>解决办法<br>  单独给表单建立一个新的子组件，然后将校验的表单统一传给需要提交的组件里面</li>\n</ul>\n<p>2、动态添加表单，删除表单时会出现空值且占数组一个位置问题。</p>\n<ul>\n<li>解决办法<br>  做删减操作时过滤清空数组</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (val.names) &#123;</span><br><span class=\"line\">\tval.names.push(val.departmentName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = val.names ? val.names.filter(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> k) : [];</span><br><span class=\"line\"><span class=\"keyword\">let</span> jsonData = &#123;</span><br><span class=\"line\">\tcompanyId: val.companyName,</span><br><span class=\"line\">\tdepartmentNames: val.names ? arr.join() : val.departmentName</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>3、无法清空表单问题，当使用了默认值initailValue时this.props.form.resetFields()无法清空。</p>\n<ul>\n<li>解决办法<br>  a. 清除state中对应的变量字段<br>  b. 不使用initailValue</li>\n</ul>\n<p>4、单个文件上传问题，每次上传单个文件且下次上传需替换上次上传的。</p>\n<ul>\n<li>解决办法<br>  再次上传清空当前数组，重新push</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;FormItem label=<span class=\"string\">\"附件上传\"</span>&gt;</span><br><span class=\"line\">\t&#123;<span class=\"keyword\">this</span>.state.visible &amp;&amp;</span><br><span class=\"line\">\tgetFieldDecorator(<span class=\"string\">'upload'</span>, &#123;</span><br><span class=\"line\">\t\trules: isFile ? []:</span><br><span class=\"line\">\t\t[&#123; <span class=\"attr\">required</span>: <span class=\"literal\">true</span>, <span class=\"attr\">message</span>: <span class=\"string\">'您未上传文件！'</span> &#125;]</span><br><span class=\"line\">\t&#125;)(</span><br><span class=\"line\">\t&lt;Upload &#123;...upLoadProps&#125; fileList=&#123;fileList || []&#125;&gt;</span><br><span class=\"line\">\t\t&lt;Button icon=<span class=\"string\">\"upload\"</span>&gt;上传文件&lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t&lt;/</span>Upload&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/FormItem&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uploadOnchage = <span class=\"function\"><span class=\"params\">info</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> maxCount = <span class=\"number\">1</span>; <span class=\"comment\">//限制上传个数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info.file.status === <span class=\"string\">'done'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (info.fileList.length &gt; maxCount) &#123;</span><br><span class=\"line\">        info.fileList.shift();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      message.success(<span class=\"string\">`<span class=\"subst\">$&#123;info.file.name&#125;</span> 上传成功`</span>);</span><br><span class=\"line\">      getUploadFileNameApi(info.file.response.data.targetFileName)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">resData</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> fileListNew = info.fileList;</span><br><span class=\"line\">          fileListNew = fileListNew.slice(<span class=\"number\">-2</span>);</span><br><span class=\"line\">          fileListNew = fileListNew.map(<span class=\"function\"><span class=\"params\">file</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> item = file;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (file.response) &#123;</span><br><span class=\"line\">              item.url = resData;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            fileUrl: resData,</span><br><span class=\"line\">            fileList: fileListNew</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> message.error(err.message));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (info.file.status === <span class=\"string\">'error'</span>) &#123;</span><br><span class=\"line\">      message.error(<span class=\"string\">`<span class=\"subst\">$&#123;info.file.name&#125;</span> 上传失败`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onChangeFileList(info.fileList);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/06/28/4f400053a504e31cda1550ce9eacb0df.png\" alt></p>\n<h1 id=\"针对PDM系统开发所遇到的问题（react-antd）\"><a href=\"#针对PDM系统开发所遇到的问题（react-antd）\" class=\"headerlink\" title=\"针对PDM系统开发所遇到的问题（react+antd）\"></a>针对PDM系统开发所遇到的问题（react+antd）</h1><h3 id=\"一、查询选择分页问题（先选值不查询进行分页）\"><a href=\"#一、查询选择分页问题（先选值不查询进行分页）\" class=\"headerlink\" title=\"一、查询选择分页问题（先选值不查询进行分页）\"></a>一、查询选择分页问题（先选值不查询进行分页）</h3><p> 我们在查询搜索的时候，如果选择查询条件但未点击查询搜索的时候点击分页，会出现所分页内容已经是刚所选择的条件查询内容，原因是state里的查询值是公用的且每次选择条件完之后已经给其字段赋值。</p>\n<ul>\n<li>解决办法<br>  a. 查询和传值分开存储</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stata=&#123;</span><br><span class=\"line\">\tquery:&#123;...&#125;</span><br><span class=\"line\">\tqueryData:&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>b. 查询选择使用form表单的形式\n</code></pre><h3 id=\"二、setState修改深层对象问题\"><a href=\"#二、setState修改深层对象问题\" class=\"headerlink\" title=\"二、setState修改深层对象问题\"></a>二、setState修改深层对象问题</h3><p>我们在修改数据的时候会遇到深层对象的值，无法用常规的直接键值对的方式获取。</p>\n<ul>\n<li><p>解决办法</p>\n<p>  以下三种方式可解决</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"keyword\">this</span>.state.list, &#123;<span class=\"attr\">a</span>: <span class=\"string\">'D1'</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">\tlist: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"keyword\">this</span>.state.list;</span><br><span class=\"line\">data.a.name = <span class=\"string\">'A1'</span>;</span><br><span class=\"line\">data.b.name = <span class=\"string\">'B1'</span>;</span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">\tlist: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">\tlist: &#123;</span><br><span class=\"line\">\t\t...this.state.list,</span><br><span class=\"line\">\t\ta: &#123;&#125;,</span><br><span class=\"line\">\t\tb: &#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、Ant-Design开发中遇到问题\"><a href=\"#三、Ant-Design开发中遇到问题\" class=\"headerlink\" title=\"三、Ant Design开发中遇到问题\"></a>三、Ant Design开发中遇到问题</h3><p>1、单组件里多表单校验问题，我们在开发经常会遇到一个页面里面会有多张表单提交，比如编辑、新建~。这样会造成我们在提交进行校验会出现多张表单同时被校验，无法进行单个表单校验通过的问题。</p>\n<ul>\n<li>解决办法<br>  单独给表单建立一个新的子组件，然后将校验的表单统一传给需要提交的组件里面</li>\n</ul>\n<p>2、动态添加表单，删除表单时会出现空值且占数组一个位置问题。</p>\n<ul>\n<li>解决办法<br>  做删减操作时过滤清空数组</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (val.names) &#123;</span><br><span class=\"line\">\tval.names.push(val.departmentName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = val.names ? val.names.filter(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> k) : [];</span><br><span class=\"line\"><span class=\"keyword\">let</span> jsonData = &#123;</span><br><span class=\"line\">\tcompanyId: val.companyName,</span><br><span class=\"line\">\tdepartmentNames: val.names ? arr.join() : val.departmentName</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>3、无法清空表单问题，当使用了默认值initailValue时this.props.form.resetFields()无法清空。</p>\n<ul>\n<li>解决办法<br>  a. 清除state中对应的变量字段<br>  b. 不使用initailValue</li>\n</ul>\n<p>4、单个文件上传问题，每次上传单个文件且下次上传需替换上次上传的。</p>\n<ul>\n<li>解决办法<br>  再次上传清空当前数组，重新push</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;FormItem label=<span class=\"string\">\"附件上传\"</span>&gt;</span><br><span class=\"line\">\t&#123;<span class=\"keyword\">this</span>.state.visible &amp;&amp;</span><br><span class=\"line\">\tgetFieldDecorator(<span class=\"string\">'upload'</span>, &#123;</span><br><span class=\"line\">\t\trules: isFile ? []:</span><br><span class=\"line\">\t\t[&#123; <span class=\"attr\">required</span>: <span class=\"literal\">true</span>, <span class=\"attr\">message</span>: <span class=\"string\">'您未上传文件！'</span> &#125;]</span><br><span class=\"line\">\t&#125;)(</span><br><span class=\"line\">\t&lt;Upload &#123;...upLoadProps&#125; fileList=&#123;fileList || []&#125;&gt;</span><br><span class=\"line\">\t\t&lt;Button icon=<span class=\"string\">\"upload\"</span>&gt;上传文件&lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t&lt;/</span>Upload&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/FormItem&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uploadOnchage = <span class=\"function\"><span class=\"params\">info</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> maxCount = <span class=\"number\">1</span>; <span class=\"comment\">//限制上传个数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info.file.status === <span class=\"string\">'done'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (info.fileList.length &gt; maxCount) &#123;</span><br><span class=\"line\">        info.fileList.shift();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      message.success(<span class=\"string\">`<span class=\"subst\">$&#123;info.file.name&#125;</span> 上传成功`</span>);</span><br><span class=\"line\">      getUploadFileNameApi(info.file.response.data.targetFileName)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">resData</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> fileListNew = info.fileList;</span><br><span class=\"line\">          fileListNew = fileListNew.slice(<span class=\"number\">-2</span>);</span><br><span class=\"line\">          fileListNew = fileListNew.map(<span class=\"function\"><span class=\"params\">file</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> item = file;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (file.response) &#123;</span><br><span class=\"line\">              item.url = resData;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            fileUrl: resData,</span><br><span class=\"line\">            fileList: fileListNew</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> message.error(err.message));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (info.file.status === <span class=\"string\">'error'</span>) &#123;</span><br><span class=\"line\">      message.error(<span class=\"string\">`<span class=\"subst\">$&#123;info.file.name&#125;</span> 上传失败`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onChangeFileList(info.fileList);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Markdown语法介绍","comments":1,"date":"2019-06-25T07:17:43.000Z","author":"jun.zhou","_content":"\n![](https://img.fengjr.com/image/2019/06/25/0009fcafbf34692f4af135f52bc3227a.png)\n\n# Markdown语法介绍\n\n我们新开通的博客已经陆续登载了一些大家分享的内容，大家可能要问，这是什么语法写成的，为什么可以插入代码、图片、视频呢，其实这是用到了一种Markdown的语言，下面由我来向大家详细介绍一下这门语言。\n\n## 什么是Markdown\n\n> [Markdown](https://zh.wikipedia.org/wiki/Markdown)是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。\n\n由于Markdown轻量化、易读易写的特性，而且对图片、图标、数学公示都有支持，所以很多网站用它来写帮助文档，例如github的Readme就是用Markdown写的。\n\nMarkdown书写非常简单，开发人员基本学习不到一个小时就可以很快速的掌握它的开发技巧，下面我来讲解一下Markdown的基本用法。\n\n## Markdown 的基本用法\n\n### 1、标题\n\n想要设置标题，只需在文字前面加`#`即可，文件和`#`中间需要有空格。Markdown 跟据`#`的个数一共分六种标题，\n\n```\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n#### 这是五级标题\n##### 这是六级标题\n```\n预览效果如下：\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n#### 这是五级标题\n##### 这是六级标题\n\n### 2、字体\n\n- #### 斜体\n\n倾斜的文字需要用一个*包起来\n\n- #### 加粗\n\n要加粗的话需要用两个*号包起来\n\n- #### 斜体加粗\n\n文字需要用三个*包起来\n\n- #### 删除线\n\n要加删除线的文字用两个~包起来\n\n示例代码：\n\n```\n*斜体*\n**加粗**\n***斜体加粗***\n~~删除文字~~\n```\n\n预览：\n\n*斜体*\n\n**加粗**\n\n***斜体加粗***\n\n~~删除文字~~\n\n### 3、引用\n\n引用名人名言等，只需要在内容前加 `>` 即可，引用可以嵌套，>>、>>> 都可以\n\n示例：\n\n\n```\n> 内容\n>> 第二段内容\n>>> 第三段内容\n>> 第二段内容\n> 内容\n```\n\n> 内容\n>> 第二段内容\n>>> 第三段内容\n\n### 4、分割线\n\n分割线通常用三个以上的 `*` 或者 `-` 都可以\n\n示例：\n\n```\n---\n----\n*** \n****\n```\n\n效果：\n\n---\n----\n***\n****\n\n### 5、图片\n\nMarkdown使用了类似链接的语法插入图片，包含两种形式：**内联**和**引用**。\n\n#### 内联语法\n\n```\n![图片alt](图片地址 \"图片title\")\n\n图片alt是显示在图片下面的文字，相当于对图片的解释\n\n图片title是图片的标题，鼠标移到图片上会显示\n\n```\n\n示例：\n\n```\n![凤金logo](https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png \"logo图片\")\n```\n\n效果：\n\n![凤金logo](https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png \"logo图片\")\n\n#### 引用语法\n\n```\n[id]: 图片地址 \"图片标题\"\n\n![图片alt][id]\n\n```\n\n示例：\n\n\n```\n[logo]: https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png \"logo图片\"\n![凤金logo][logo]\n\n```\n\n[logo]: https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png \"logo图片\"\n![凤金logo][logo]\n\n### 6、超链接\n\n方括号显示说明，圆括号显示地址，Markdown会将其显示为地址\n\n语法：\n\n```\n[超链接名](超链接地址 \"超链接title\")\ntitle可加可不加\n```\n\n示例：\n\n```\n[凤凰金融](https://www.fengjr.com \"凤凰金融\")\n```\n\n效果：\n\n[凤凰金融](https://www.fengjr.com \"凤凰金融\")\n\n### 锚点\n\nMarkdown 会针对每个标题，在解析时都会加入锚点，跳转到指定标题只需要通过超链接的方式访问即可，有的平台支持的锚点只能小写\n\n语法：\n\n```\n[访问链接](#锚点名称)\n```\n示例：\n\n```\n[什么是Markdown](#什么是Markdown)\n```\n\n效果：\n\n[什么是Markdown](#什么是Markdown)\n\n\n### 7、列表\n\n#### 无序列表\n\n无序列表用 - + * 任何一种都可以\n\n语法：\n```\n- 列表\n+ 列表\n* 列表\n```\n效果\n\n- 列表\n+ 列表\n* 列表\n\n#### 有序列表\n\n前面加数字和.即可生成有序列表：\n\n示例：\n\n```\n1. 有序列表\n2. 有序列表\n3. 有序列表\n```\n效果\n\n1. 有序列表\n2. 有序列表\n3. 有序列表\n\n### 8、表格\n\n语法：\n\n```\n表头|表头|表头\n---|:--:|---:\n内容|内容|内容\n内容|内容|内容\n\n第二行分割表头和内容。\n- 有一个就行，为了对齐，多加了几个\n文字默认居左\n-两边加：表示文字居中\n-右边加：表示文字居右\n注：原生的语法两边都要用 | 包起来。此处省略\n```\n\n示例：\n\n```\n姓名|技能|排行\n--|:--:|--:\n刘备|哭|大哥\n关羽|打|二哥\n张飞|骂|三弟\n```\n\n姓名|技能|排行\n--|:--:|--:\n刘备|哭|大哥很厉害\n关羽|打|二哥\n张飞|骂|三弟\n\n### 9、代码\n\n语法：\n\n单行代码：代码只见用一个反引号包起来\n\n```\n`代码内容`\n```\n\n代码块：代码块用三个反引号包起来，两边反引号独占一行\n\n\n```\n(```)\n    代码...\n    代码...\n    代码...\n(```)\n```\n> 了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可\n\n示例：\n\n单行代码：\n\n```\n`markdown语法介绍`\n```\n\n代码块\n\n```\n(```)\n    function fun(){\n         echo \"这是一句非常牛逼的代码\";\n    }\n    fun();\n(```)\n```\n\n效果：\n\n单行代码：\n\n`markdown语法介绍`\n\n代码块：\n\n```\nfunction fun(){\n     echo \"这是一句非常牛逼的代码\";\n}\nfun();\n```\n\n## 总结\n\n上面介绍了markdown的一些基本用法，其实在md文件中可以直接书写HTML标签，所以md也支持插入视频，iframe 等所有HTML元素。Markdown的优点就在于书写简单，不需排版，让作者能够专心写作。","source":"_posts/2019-06-25-markdown-introduction.md","raw":"---\ntitle: Markdown语法介绍\ncomments: true\ndate: 2019-06-25 15:17:43\ntags:\n- markdown\n- html\ncategories: \n- WEB前端\nauthor: jun.zhou\n---\n\n![](https://img.fengjr.com/image/2019/06/25/0009fcafbf34692f4af135f52bc3227a.png)\n\n# Markdown语法介绍\n\n我们新开通的博客已经陆续登载了一些大家分享的内容，大家可能要问，这是什么语法写成的，为什么可以插入代码、图片、视频呢，其实这是用到了一种Markdown的语言，下面由我来向大家详细介绍一下这门语言。\n\n## 什么是Markdown\n\n> [Markdown](https://zh.wikipedia.org/wiki/Markdown)是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。\n\n由于Markdown轻量化、易读易写的特性，而且对图片、图标、数学公示都有支持，所以很多网站用它来写帮助文档，例如github的Readme就是用Markdown写的。\n\nMarkdown书写非常简单，开发人员基本学习不到一个小时就可以很快速的掌握它的开发技巧，下面我来讲解一下Markdown的基本用法。\n\n## Markdown 的基本用法\n\n### 1、标题\n\n想要设置标题，只需在文字前面加`#`即可，文件和`#`中间需要有空格。Markdown 跟据`#`的个数一共分六种标题，\n\n```\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n#### 这是五级标题\n##### 这是六级标题\n```\n预览效果如下：\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n#### 这是五级标题\n##### 这是六级标题\n\n### 2、字体\n\n- #### 斜体\n\n倾斜的文字需要用一个*包起来\n\n- #### 加粗\n\n要加粗的话需要用两个*号包起来\n\n- #### 斜体加粗\n\n文字需要用三个*包起来\n\n- #### 删除线\n\n要加删除线的文字用两个~包起来\n\n示例代码：\n\n```\n*斜体*\n**加粗**\n***斜体加粗***\n~~删除文字~~\n```\n\n预览：\n\n*斜体*\n\n**加粗**\n\n***斜体加粗***\n\n~~删除文字~~\n\n### 3、引用\n\n引用名人名言等，只需要在内容前加 `>` 即可，引用可以嵌套，>>、>>> 都可以\n\n示例：\n\n\n```\n> 内容\n>> 第二段内容\n>>> 第三段内容\n>> 第二段内容\n> 内容\n```\n\n> 内容\n>> 第二段内容\n>>> 第三段内容\n\n### 4、分割线\n\n分割线通常用三个以上的 `*` 或者 `-` 都可以\n\n示例：\n\n```\n---\n----\n*** \n****\n```\n\n效果：\n\n---\n----\n***\n****\n\n### 5、图片\n\nMarkdown使用了类似链接的语法插入图片，包含两种形式：**内联**和**引用**。\n\n#### 内联语法\n\n```\n![图片alt](图片地址 \"图片title\")\n\n图片alt是显示在图片下面的文字，相当于对图片的解释\n\n图片title是图片的标题，鼠标移到图片上会显示\n\n```\n\n示例：\n\n```\n![凤金logo](https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png \"logo图片\")\n```\n\n效果：\n\n![凤金logo](https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png \"logo图片\")\n\n#### 引用语法\n\n```\n[id]: 图片地址 \"图片标题\"\n\n![图片alt][id]\n\n```\n\n示例：\n\n\n```\n[logo]: https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png \"logo图片\"\n![凤金logo][logo]\n\n```\n\n[logo]: https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png \"logo图片\"\n![凤金logo][logo]\n\n### 6、超链接\n\n方括号显示说明，圆括号显示地址，Markdown会将其显示为地址\n\n语法：\n\n```\n[超链接名](超链接地址 \"超链接title\")\ntitle可加可不加\n```\n\n示例：\n\n```\n[凤凰金融](https://www.fengjr.com \"凤凰金融\")\n```\n\n效果：\n\n[凤凰金融](https://www.fengjr.com \"凤凰金融\")\n\n### 锚点\n\nMarkdown 会针对每个标题，在解析时都会加入锚点，跳转到指定标题只需要通过超链接的方式访问即可，有的平台支持的锚点只能小写\n\n语法：\n\n```\n[访问链接](#锚点名称)\n```\n示例：\n\n```\n[什么是Markdown](#什么是Markdown)\n```\n\n效果：\n\n[什么是Markdown](#什么是Markdown)\n\n\n### 7、列表\n\n#### 无序列表\n\n无序列表用 - + * 任何一种都可以\n\n语法：\n```\n- 列表\n+ 列表\n* 列表\n```\n效果\n\n- 列表\n+ 列表\n* 列表\n\n#### 有序列表\n\n前面加数字和.即可生成有序列表：\n\n示例：\n\n```\n1. 有序列表\n2. 有序列表\n3. 有序列表\n```\n效果\n\n1. 有序列表\n2. 有序列表\n3. 有序列表\n\n### 8、表格\n\n语法：\n\n```\n表头|表头|表头\n---|:--:|---:\n内容|内容|内容\n内容|内容|内容\n\n第二行分割表头和内容。\n- 有一个就行，为了对齐，多加了几个\n文字默认居左\n-两边加：表示文字居中\n-右边加：表示文字居右\n注：原生的语法两边都要用 | 包起来。此处省略\n```\n\n示例：\n\n```\n姓名|技能|排行\n--|:--:|--:\n刘备|哭|大哥\n关羽|打|二哥\n张飞|骂|三弟\n```\n\n姓名|技能|排行\n--|:--:|--:\n刘备|哭|大哥很厉害\n关羽|打|二哥\n张飞|骂|三弟\n\n### 9、代码\n\n语法：\n\n单行代码：代码只见用一个反引号包起来\n\n```\n`代码内容`\n```\n\n代码块：代码块用三个反引号包起来，两边反引号独占一行\n\n\n```\n(```)\n    代码...\n    代码...\n    代码...\n(```)\n```\n> 了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可\n\n示例：\n\n单行代码：\n\n```\n`markdown语法介绍`\n```\n\n代码块\n\n```\n(```)\n    function fun(){\n         echo \"这是一句非常牛逼的代码\";\n    }\n    fun();\n(```)\n```\n\n效果：\n\n单行代码：\n\n`markdown语法介绍`\n\n代码块：\n\n```\nfunction fun(){\n     echo \"这是一句非常牛逼的代码\";\n}\nfun();\n```\n\n## 总结\n\n上面介绍了markdown的一些基本用法，其实在md文件中可以直接书写HTML标签，所以md也支持插入视频，iframe 等所有HTML元素。Markdown的优点就在于书写简单，不需排版，让作者能够专心写作。","slug":"markdown-introduction","published":1,"updated":"2020-06-10T06:02:01.527Z","_id":"cjxfsbp4i000ahgq58qd16amy","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/06/25/0009fcafbf34692f4af135f52bc3227a.png\" alt></p>\n<h1 id=\"Markdown语法介绍\"><a href=\"#Markdown语法介绍\" class=\"headerlink\" title=\"Markdown语法介绍\"></a>Markdown语法介绍</h1><p>我们新开通的博客已经陆续登载了一些大家分享的内容，大家可能要问，这是什么语法写成的，为什么可以插入代码、图片、视频呢，其实这是用到了一种Markdown的语言，下面由我来向大家详细介绍一下这门语言。</p>\n<h2 id=\"什么是Markdown\"><a href=\"#什么是Markdown\" class=\"headerlink\" title=\"什么是Markdown\"></a>什么是Markdown</h2><blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"noopener\">Markdown</a>是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>\n</blockquote>\n<p>由于Markdown轻量化、易读易写的特性，而且对图片、图标、数学公示都有支持，所以很多网站用它来写帮助文档，例如github的Readme就是用Markdown写的。</p>\n<p>Markdown书写非常简单，开发人员基本学习不到一个小时就可以很快速的掌握它的开发技巧，下面我来讲解一下Markdown的基本用法。</p>\n<h2 id=\"Markdown-的基本用法\"><a href=\"#Markdown-的基本用法\" class=\"headerlink\" title=\"Markdown 的基本用法\"></a>Markdown 的基本用法</h2><h3 id=\"1、标题\"><a href=\"#1、标题\" class=\"headerlink\" title=\"1、标题\"></a>1、标题</h3><p>想要设置标题，只需在文字前面加<code>#</code>即可，文件和<code>#</code>中间需要有空格。Markdown 跟据<code>#</code>的个数一共分六种标题，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是一级标题</span><br><span class=\"line\">## 这是二级标题</span><br><span class=\"line\">### 这是三级标题</span><br><span class=\"line\">#### 这是四级标题</span><br><span class=\"line\">#### 这是五级标题</span><br><span class=\"line\">##### 这是六级标题</span><br></pre></td></tr></table></figure>\n<p>预览效果如下：</p>\n<h1 id=\"这是一级标题\"><a href=\"#这是一级标题\" class=\"headerlink\" title=\"这是一级标题\"></a>这是一级标题</h1><h2 id=\"这是二级标题\"><a href=\"#这是二级标题\" class=\"headerlink\" title=\"这是二级标题\"></a>这是二级标题</h2><h3 id=\"这是三级标题\"><a href=\"#这是三级标题\" class=\"headerlink\" title=\"这是三级标题\"></a>这是三级标题</h3><h4 id=\"这是四级标题\"><a href=\"#这是四级标题\" class=\"headerlink\" title=\"这是四级标题\"></a>这是四级标题</h4><h4 id=\"这是五级标题\"><a href=\"#这是五级标题\" class=\"headerlink\" title=\"这是五级标题\"></a>这是五级标题</h4><h5 id=\"这是六级标题\"><a href=\"#这是六级标题\" class=\"headerlink\" title=\"这是六级标题\"></a>这是六级标题</h5><h3 id=\"2、字体\"><a href=\"#2、字体\" class=\"headerlink\" title=\"2、字体\"></a>2、字体</h3><ul>\n<li><h4 id=\"斜体\"><a href=\"#斜体\" class=\"headerlink\" title=\"斜体\"></a>斜体</h4></li>\n</ul>\n<p>倾斜的文字需要用一个*包起来</p>\n<ul>\n<li><h4 id=\"加粗\"><a href=\"#加粗\" class=\"headerlink\" title=\"加粗\"></a>加粗</h4></li>\n</ul>\n<p>要加粗的话需要用两个*号包起来</p>\n<ul>\n<li><h4 id=\"斜体加粗\"><a href=\"#斜体加粗\" class=\"headerlink\" title=\"斜体加粗\"></a>斜体加粗</h4></li>\n</ul>\n<p>文字需要用三个*包起来</p>\n<ul>\n<li><h4 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h4></li>\n</ul>\n<p>要加删除线的文字用两个~包起来</p>\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体*</span><br><span class=\"line\">**加粗**</span><br><span class=\"line\">***斜体加粗***</span><br><span class=\"line\">~~删除文字~~</span><br></pre></td></tr></table></figure>\n<p>预览：</p>\n<p><em>斜体</em></p>\n<p><strong>加粗</strong></p>\n<p><strong><em>斜体加粗</em></strong></p>\n<p><del>删除文字</del></p>\n<h3 id=\"3、引用\"><a href=\"#3、引用\" class=\"headerlink\" title=\"3、引用\"></a>3、引用</h3><p>引用名人名言等，只需要在内容前加 <code>&gt;</code> 即可，引用可以嵌套，&gt;&gt;、&gt;&gt;&gt; 都可以</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 内容</span><br><span class=\"line\">&gt;&gt; 第二段内容</span><br><span class=\"line\">&gt;&gt;&gt; 第三段内容</span><br><span class=\"line\">&gt;&gt; 第二段内容</span><br><span class=\"line\">&gt; 内容</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>内容</p>\n<blockquote>\n<p>第二段内容</p>\n<blockquote>\n<p>第三段内容</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"4、分割线\"><a href=\"#4、分割线\" class=\"headerlink\" title=\"4、分割线\"></a>4、分割线</h3><p>分割线通常用三个以上的 <code>*</code> 或者 <code>-</code> 都可以</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">----</span><br><span class=\"line\">*** </span><br><span class=\"line\">****</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<hr>\n<hr>\n<hr>\n<hr>\n<h3 id=\"5、图片\"><a href=\"#5、图片\" class=\"headerlink\" title=\"5、图片\"></a>5、图片</h3><p>Markdown使用了类似链接的语法插入图片，包含两种形式：<strong>内联</strong>和<strong>引用</strong>。</p>\n<h4 id=\"内联语法\"><a href=\"#内联语法\" class=\"headerlink\" title=\"内联语法\"></a>内联语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">图片alt是显示在图片下面的文字，相当于对图片的解释</span><br><span class=\"line\"></span><br><span class=\"line\">图片title是图片的标题，鼠标移到图片上会显示</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![凤金logo](https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png &quot;logo图片&quot;)</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png\" alt=\"凤金logo\" title=\"logo图片\"></p>\n<h4 id=\"引用语法\"><a href=\"#引用语法\" class=\"headerlink\" title=\"引用语法\"></a>引用语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[id]: 图片地址 &quot;图片标题&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">![图片alt][id]</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[logo]: https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png &quot;logo图片&quot;</span><br><span class=\"line\">![凤金logo][logo]</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png\" alt=\"凤金logo\" title=\"logo图片\"></p>\n<h3 id=\"6、超链接\"><a href=\"#6、超链接\" class=\"headerlink\" title=\"6、超链接\"></a>6、超链接</h3><p>方括号显示说明，圆括号显示地址，Markdown会将其显示为地址</p>\n<p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class=\"line\">title可加可不加</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[凤凰金融](https://www.fengjr.com &quot;凤凰金融&quot;)</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><a href=\"https://www.fengjr.com\" title=\"凤凰金融\" target=\"_blank\" rel=\"noopener\">凤凰金融</a></p>\n<h3 id=\"锚点\"><a href=\"#锚点\" class=\"headerlink\" title=\"锚点\"></a>锚点</h3><p>Markdown 会针对每个标题，在解析时都会加入锚点，跳转到指定标题只需要通过超链接的方式访问即可，有的平台支持的锚点只能小写</p>\n<p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[访问链接](#锚点名称)</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[什么是Markdown](#什么是Markdown)</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><a href=\"#什么是Markdown\">什么是Markdown</a></p>\n<h3 id=\"7、列表\"><a href=\"#7、列表\" class=\"headerlink\" title=\"7、列表\"></a>7、列表</h3><h4 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h4><p>无序列表用 - + * 任何一种都可以</p>\n<p>语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 列表</span><br><span class=\"line\">+ 列表</span><br><span class=\"line\">* 列表</span><br></pre></td></tr></table></figure></p>\n<p>效果</p>\n<ul>\n<li>列表</li>\n</ul>\n<ul>\n<li>列表</li>\n</ul>\n<ul>\n<li>列表</li>\n</ul>\n<h4 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h4><p>前面加数字和.即可生成有序列表：</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 有序列表</span><br><span class=\"line\">2. 有序列表</span><br><span class=\"line\">3. 有序列表</span><br></pre></td></tr></table></figure>\n<p>效果</p>\n<ol>\n<li>有序列表</li>\n<li>有序列表</li>\n<li>有序列表</li>\n</ol>\n<h3 id=\"8、表格\"><a href=\"#8、表格\" class=\"headerlink\" title=\"8、表格\"></a>8、表格</h3><p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表头|表头|表头</span><br><span class=\"line\">---|:--:|---:</span><br><span class=\"line\">内容|内容|内容</span><br><span class=\"line\">内容|内容|内容</span><br><span class=\"line\"></span><br><span class=\"line\">第二行分割表头和内容。</span><br><span class=\"line\">- 有一个就行，为了对齐，多加了几个</span><br><span class=\"line\">文字默认居左</span><br><span class=\"line\">-两边加：表示文字居中</span><br><span class=\"line\">-右边加：表示文字居右</span><br><span class=\"line\">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">姓名|技能|排行</span><br><span class=\"line\">--|:--:|--:</span><br><span class=\"line\">刘备|哭|大哥</span><br><span class=\"line\">关羽|打|二哥</span><br><span class=\"line\">张飞|骂|三弟</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th style=\"text-align:center\">技能</th>\n<th style=\"text-align:right\">排行</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>刘备</td>\n<td style=\"text-align:center\">哭</td>\n<td style=\"text-align:right\">大哥很厉害</td>\n</tr>\n<tr>\n<td>关羽</td>\n<td style=\"text-align:center\">打</td>\n<td style=\"text-align:right\">二哥</td>\n</tr>\n<tr>\n<td>张飞</td>\n<td style=\"text-align:center\">骂</td>\n<td style=\"text-align:right\">三弟</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"9、代码\"><a href=\"#9、代码\" class=\"headerlink\" title=\"9、代码\"></a>9、代码</h3><p>语法：</p>\n<p>单行代码：代码只见用一个反引号包起来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`代码内容`</span><br></pre></td></tr></table></figure>\n<p>代码块：代码块用三个反引号包起来，两边反引号独占一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(```)</span><br><span class=\"line\">    代码...</span><br><span class=\"line\">    代码...</span><br><span class=\"line\">    代码...</span><br><span class=\"line\">(```)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可</p>\n</blockquote>\n<p>示例：</p>\n<p>单行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`markdown语法介绍`</span><br></pre></td></tr></table></figure>\n<p>代码块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(```)</span><br><span class=\"line\">    function fun()&#123;</span><br><span class=\"line\">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fun();</span><br><span class=\"line\">(```)</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p>单行代码：</p>\n<p><code>markdown语法介绍</code></p>\n<p>代码块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fun()&#123;</span><br><span class=\"line\">     echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun();</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面介绍了markdown的一些基本用法，其实在md文件中可以直接书写HTML标签，所以md也支持插入视频，iframe 等所有HTML元素。Markdown的优点就在于书写简单，不需排版，让作者能够专心写作。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/06/25/0009fcafbf34692f4af135f52bc3227a.png\" alt></p>\n<h1 id=\"Markdown语法介绍\"><a href=\"#Markdown语法介绍\" class=\"headerlink\" title=\"Markdown语法介绍\"></a>Markdown语法介绍</h1><p>我们新开通的博客已经陆续登载了一些大家分享的内容，大家可能要问，这是什么语法写成的，为什么可以插入代码、图片、视频呢，其实这是用到了一种Markdown的语言，下面由我来向大家详细介绍一下这门语言。</p>\n<h2 id=\"什么是Markdown\"><a href=\"#什么是Markdown\" class=\"headerlink\" title=\"什么是Markdown\"></a>什么是Markdown</h2><blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"noopener\">Markdown</a>是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>\n</blockquote>\n<p>由于Markdown轻量化、易读易写的特性，而且对图片、图标、数学公示都有支持，所以很多网站用它来写帮助文档，例如github的Readme就是用Markdown写的。</p>\n<p>Markdown书写非常简单，开发人员基本学习不到一个小时就可以很快速的掌握它的开发技巧，下面我来讲解一下Markdown的基本用法。</p>\n<h2 id=\"Markdown-的基本用法\"><a href=\"#Markdown-的基本用法\" class=\"headerlink\" title=\"Markdown 的基本用法\"></a>Markdown 的基本用法</h2><h3 id=\"1、标题\"><a href=\"#1、标题\" class=\"headerlink\" title=\"1、标题\"></a>1、标题</h3><p>想要设置标题，只需在文字前面加<code>#</code>即可，文件和<code>#</code>中间需要有空格。Markdown 跟据<code>#</code>的个数一共分六种标题，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是一级标题</span><br><span class=\"line\">## 这是二级标题</span><br><span class=\"line\">### 这是三级标题</span><br><span class=\"line\">#### 这是四级标题</span><br><span class=\"line\">#### 这是五级标题</span><br><span class=\"line\">##### 这是六级标题</span><br></pre></td></tr></table></figure>\n<p>预览效果如下：</p>\n<h1 id=\"这是一级标题\"><a href=\"#这是一级标题\" class=\"headerlink\" title=\"这是一级标题\"></a>这是一级标题</h1><h2 id=\"这是二级标题\"><a href=\"#这是二级标题\" class=\"headerlink\" title=\"这是二级标题\"></a>这是二级标题</h2><h3 id=\"这是三级标题\"><a href=\"#这是三级标题\" class=\"headerlink\" title=\"这是三级标题\"></a>这是三级标题</h3><h4 id=\"这是四级标题\"><a href=\"#这是四级标题\" class=\"headerlink\" title=\"这是四级标题\"></a>这是四级标题</h4><h4 id=\"这是五级标题\"><a href=\"#这是五级标题\" class=\"headerlink\" title=\"这是五级标题\"></a>这是五级标题</h4><h5 id=\"这是六级标题\"><a href=\"#这是六级标题\" class=\"headerlink\" title=\"这是六级标题\"></a>这是六级标题</h5><h3 id=\"2、字体\"><a href=\"#2、字体\" class=\"headerlink\" title=\"2、字体\"></a>2、字体</h3><ul>\n<li><h4 id=\"斜体\"><a href=\"#斜体\" class=\"headerlink\" title=\"斜体\"></a>斜体</h4></li>\n</ul>\n<p>倾斜的文字需要用一个*包起来</p>\n<ul>\n<li><h4 id=\"加粗\"><a href=\"#加粗\" class=\"headerlink\" title=\"加粗\"></a>加粗</h4></li>\n</ul>\n<p>要加粗的话需要用两个*号包起来</p>\n<ul>\n<li><h4 id=\"斜体加粗\"><a href=\"#斜体加粗\" class=\"headerlink\" title=\"斜体加粗\"></a>斜体加粗</h4></li>\n</ul>\n<p>文字需要用三个*包起来</p>\n<ul>\n<li><h4 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h4></li>\n</ul>\n<p>要加删除线的文字用两个~包起来</p>\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体*</span><br><span class=\"line\">**加粗**</span><br><span class=\"line\">***斜体加粗***</span><br><span class=\"line\">~~删除文字~~</span><br></pre></td></tr></table></figure>\n<p>预览：</p>\n<p><em>斜体</em></p>\n<p><strong>加粗</strong></p>\n<p><strong><em>斜体加粗</em></strong></p>\n<p><del>删除文字</del></p>\n<h3 id=\"3、引用\"><a href=\"#3、引用\" class=\"headerlink\" title=\"3、引用\"></a>3、引用</h3><p>引用名人名言等，只需要在内容前加 <code>&gt;</code> 即可，引用可以嵌套，&gt;&gt;、&gt;&gt;&gt; 都可以</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 内容</span><br><span class=\"line\">&gt;&gt; 第二段内容</span><br><span class=\"line\">&gt;&gt;&gt; 第三段内容</span><br><span class=\"line\">&gt;&gt; 第二段内容</span><br><span class=\"line\">&gt; 内容</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>内容</p>\n<blockquote>\n<p>第二段内容</p>\n<blockquote>\n<p>第三段内容</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"4、分割线\"><a href=\"#4、分割线\" class=\"headerlink\" title=\"4、分割线\"></a>4、分割线</h3><p>分割线通常用三个以上的 <code>*</code> 或者 <code>-</code> 都可以</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">----</span><br><span class=\"line\">*** </span><br><span class=\"line\">****</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<hr>\n<hr>\n<hr>\n<hr>\n<h3 id=\"5、图片\"><a href=\"#5、图片\" class=\"headerlink\" title=\"5、图片\"></a>5、图片</h3><p>Markdown使用了类似链接的语法插入图片，包含两种形式：<strong>内联</strong>和<strong>引用</strong>。</p>\n<h4 id=\"内联语法\"><a href=\"#内联语法\" class=\"headerlink\" title=\"内联语法\"></a>内联语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">图片alt是显示在图片下面的文字，相当于对图片的解释</span><br><span class=\"line\"></span><br><span class=\"line\">图片title是图片的标题，鼠标移到图片上会显示</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![凤金logo](https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png &quot;logo图片&quot;)</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png\" alt=\"凤金logo\" title=\"logo图片\"></p>\n<h4 id=\"引用语法\"><a href=\"#引用语法\" class=\"headerlink\" title=\"引用语法\"></a>引用语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[id]: 图片地址 &quot;图片标题&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">![图片alt][id]</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[logo]: https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png &quot;logo图片&quot;</span><br><span class=\"line\">![凤金logo][logo]</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.fengjr.com/image/2018/10/12/FENGJR-FJr-YZ-21-152-1DC99935BB2A4F0AB9FA04779E52D748.png\" alt=\"凤金logo\" title=\"logo图片\"></p>\n<h3 id=\"6、超链接\"><a href=\"#6、超链接\" class=\"headerlink\" title=\"6、超链接\"></a>6、超链接</h3><p>方括号显示说明，圆括号显示地址，Markdown会将其显示为地址</p>\n<p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class=\"line\">title可加可不加</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[凤凰金融](https://www.fengjr.com &quot;凤凰金融&quot;)</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><a href=\"https://www.fengjr.com\" title=\"凤凰金融\" target=\"_blank\" rel=\"noopener\">凤凰金融</a></p>\n<h3 id=\"锚点\"><a href=\"#锚点\" class=\"headerlink\" title=\"锚点\"></a>锚点</h3><p>Markdown 会针对每个标题，在解析时都会加入锚点，跳转到指定标题只需要通过超链接的方式访问即可，有的平台支持的锚点只能小写</p>\n<p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[访问链接](#锚点名称)</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[什么是Markdown](#什么是Markdown)</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><a href=\"#什么是Markdown\">什么是Markdown</a></p>\n<h3 id=\"7、列表\"><a href=\"#7、列表\" class=\"headerlink\" title=\"7、列表\"></a>7、列表</h3><h4 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h4><p>无序列表用 - + * 任何一种都可以</p>\n<p>语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 列表</span><br><span class=\"line\">+ 列表</span><br><span class=\"line\">* 列表</span><br></pre></td></tr></table></figure></p>\n<p>效果</p>\n<ul>\n<li>列表</li>\n</ul>\n<ul>\n<li>列表</li>\n</ul>\n<ul>\n<li>列表</li>\n</ul>\n<h4 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h4><p>前面加数字和.即可生成有序列表：</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 有序列表</span><br><span class=\"line\">2. 有序列表</span><br><span class=\"line\">3. 有序列表</span><br></pre></td></tr></table></figure>\n<p>效果</p>\n<ol>\n<li>有序列表</li>\n<li>有序列表</li>\n<li>有序列表</li>\n</ol>\n<h3 id=\"8、表格\"><a href=\"#8、表格\" class=\"headerlink\" title=\"8、表格\"></a>8、表格</h3><p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表头|表头|表头</span><br><span class=\"line\">---|:--:|---:</span><br><span class=\"line\">内容|内容|内容</span><br><span class=\"line\">内容|内容|内容</span><br><span class=\"line\"></span><br><span class=\"line\">第二行分割表头和内容。</span><br><span class=\"line\">- 有一个就行，为了对齐，多加了几个</span><br><span class=\"line\">文字默认居左</span><br><span class=\"line\">-两边加：表示文字居中</span><br><span class=\"line\">-右边加：表示文字居右</span><br><span class=\"line\">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">姓名|技能|排行</span><br><span class=\"line\">--|:--:|--:</span><br><span class=\"line\">刘备|哭|大哥</span><br><span class=\"line\">关羽|打|二哥</span><br><span class=\"line\">张飞|骂|三弟</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th style=\"text-align:center\">技能</th>\n<th style=\"text-align:right\">排行</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>刘备</td>\n<td style=\"text-align:center\">哭</td>\n<td style=\"text-align:right\">大哥很厉害</td>\n</tr>\n<tr>\n<td>关羽</td>\n<td style=\"text-align:center\">打</td>\n<td style=\"text-align:right\">二哥</td>\n</tr>\n<tr>\n<td>张飞</td>\n<td style=\"text-align:center\">骂</td>\n<td style=\"text-align:right\">三弟</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"9、代码\"><a href=\"#9、代码\" class=\"headerlink\" title=\"9、代码\"></a>9、代码</h3><p>语法：</p>\n<p>单行代码：代码只见用一个反引号包起来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`代码内容`</span><br></pre></td></tr></table></figure>\n<p>代码块：代码块用三个反引号包起来，两边反引号独占一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(```)</span><br><span class=\"line\">    代码...</span><br><span class=\"line\">    代码...</span><br><span class=\"line\">    代码...</span><br><span class=\"line\">(```)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可</p>\n</blockquote>\n<p>示例：</p>\n<p>单行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`markdown语法介绍`</span><br></pre></td></tr></table></figure>\n<p>代码块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(```)</span><br><span class=\"line\">    function fun()&#123;</span><br><span class=\"line\">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fun();</span><br><span class=\"line\">(```)</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p>单行代码：</p>\n<p><code>markdown语法介绍</code></p>\n<p>代码块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fun()&#123;</span><br><span class=\"line\">     echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun();</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面介绍了markdown的一些基本用法，其实在md文件中可以直接书写HTML标签，所以md也支持插入视频，iframe 等所有HTML元素。Markdown的优点就在于书写简单，不需排版，让作者能够专心写作。</p>\n"},{"title":"你不知道的css技巧","comments":1,"date":"2019-06-28T09:00:00.000Z","author":"jun.zhou","_content":"\n![](https://img.fengjr.com/image/2019/06/28/7b2fa1b3d5eaafe09136f314a4cd6d36.png)\n\n## CSS是什么（简介）\n层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。\nCSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。\n\n## CSS发展史\n\n\n* 1990年，Tim Berners-Lee和Robert Cailliau共同发明了Web。1994年，Web真正走出实验室。\n\n* 1997年初，W3C开始接管CSS，W3C内组织了专门管CSS的工作组\n\n* 1988年5月W3C发表了CSS2，CSS2.1修改了CSS2中的一些错误，删除了其中不被支持的内容和增加了一些已有的浏览器的扩展内容\n\n* 从2011年开始CSS被分为多个模块单独升级。统称为CSS3\n    模块有：CSS选择器level3、CSS媒体查询level3、CSS color level3\n\n* 预编译工具SASS,LESS\n    Less和Sass的主要不同就是他们的实现方式。\n    Less是基于JavaScript，是在客户端处理的。\n    Sass是基于Ruby的，是在服务器端处理的。\n\n\n## css奇技淫巧\n### 1、tab\n* 效果：\n\n![tab技巧](https://img.fengjr.com/image/2019/06/27/10ab0bba9acfc64eb4d1f8e7f66ada81.png)\n  \n* HTML代码：\n\n ```html\n<div class=\"tabs-box\">\n    <div class=\"tab\">\n        <input type=\"radio\" class=\"radio\" id=\"radio1\" name=\"radiogroup\" checked/>\n        <label for=\"radio1\">标签1</label>\n        <section>内容1</section>\n    </div>\n    <div class=\"tab\">\n        <input type=\"radio\" class=\"radio\" id=\"radio2\" name=\"radiogroup\"/>\n        <label for=\"radio2\">标签2</label>\n        <section>内容2</section>\n    </div>\n    <div class=\"tab\">\n        <input type=\"radio\" class=\"radio\" id=\"radio3\" name=\"radiogroup\"/>\n        <label for=\"radio3\">标签3</label>\n        <section>内容3</section>\n    </div>\n</div> \n ```\n\n* CSS代码：\n\n```css\n.tabs-box {\n    margin:230px auto 30px;\n    width:40%;\n    height:200px;\n    position:relative;\n}\n.tab {\n    float:left;\n}\n.tabs-box input {\n    position:absolute;\n    opacity: 0;\n}\n.radio:checked ~ label {\n    background: #e67e22;\n}\n.radio:checked ~ section {\n    z-index: 1\n}\n.tabs-box label {\n    padding:.5em .5em;\n    background:#2980b9;\n    color:#fff;\n    border-radius:3px;\n    cursor: pointer;\n}\n.tabs-box section {\n    width:100%;\n    background:#ddd;\n    height:150px;\n    position:absolute;\n    padding:10px;\n    top:30px;\n    left:0;\n}   \n```\n\n* 实现原理：\n\n    1、相同name属性的radio组一次性只能选择一个，模拟面板切换\n    \n    2、利用radio具有可聚焦属性，模拟点击事件\n    \n    3、通过CSS派生选择器，结合z-index层级来完成内容显隐切换\n\n\n### 2、collapse（折叠面板）\n\n* 效果：\n\n![折叠面板](https://img.fengjr.com/image/2019/06/27/5e913333a4f99eb22dfa5e4bd4693bbf.png)\n\n* HTML代码：\n\n```html\n<div class=\"toggle-box\">\n    <input type=\"checkbox\" id=\"checkbox1\" class=\"checkbox-common\"/>\n    <label for=\"checkbox1\" class=\"panel-title\">面板1</label>\n    <section class=\"panel-content\" id=\"content1\">内容1</section>\n    <input type=\"checkbox\" id=\"checkbox2\" class=\"checkbox-common\"/>\n    <label for=\"checkbox2\" class=\"panel-title\">面板2</label>\n    <section class=\"panel-content\" id=\"content2\">内容2</section>\n    <input type=\"checkbox\" id=\"checkbox3\" class=\"checkbox-common\"/>\n    <label for=\"checkbox3\" class=\"panel-title\">面板3</label>\n    <section class=\"panel-content\" id=\"content3\">内容3</section>\n</div> \n```\n* CSS代码：\n\n```css\n.toggle-box{\n    width:50%;\n    margin:30px auto;\n    border:1px solid red;\n}\n.panel-title{\n    background:orange;\n    color:#fff;\n    display:block;\n    position:relative;\n    padding:.2em;\n    border-bottom:1px solid #fff;\n}\n.checkbox-common{\n    position:absolute;\n}\n#checkbox1:checked ~ #content1,\n#checkbox2:checked ~ #content2,\n#checkbox3:checked ~ #content3{\n    height:100px;\n}\n.panel-content{\n    height:0;\n    transition:all 300ms;\n    overflow:hidden\n}\n```\n\n* 实现原理：\n\n    1、利用checkbox多选特性，模拟同时事件聚焦\n    \n    2、利用checkbox具有可聚焦属性，模拟点击事件\n    \n    3、通过CSS派生选择器来变换内容高度完成面版折叠效果\n\n\n### 3、dialog（模态框）\n\n* 效果：\n\n![模态框](https://img.fengjr.com/image/2019/06/27/b2aa836a5ad00d60a0e70c6a5094cb50.png)\n\n* HTML代码：\n\n```html\n<a href=\"#dialog\" class=\"dialog-btn\">click me</a>\n<div class=\"dialog-box\" id=\"dialog\">\n    <div class=\"dialog-con\">\n        <a href=\"#\" class=\"dialog-close\">X</a>\n\t    content\n    </div>\n</div>\n```\n     \n* CSS代码：\n\n```css\n.dialog-btn{\n    margin:10px auto;\n    width:120px;\n    color:#fff;\n    text-align:center;\n    background:#ffaf40;\n    padding:10px;\n    display:block;\n    border-radius: 30px;\n    text-decoration:none\n}\n.dialog-box{\n    position:fixed;\n    top:0;\n    left:0;\n    right:0;\n    bottom:0;\n    background:rgba(0,0,0,0.5);\n    visibility:hidden;\n    z-index: 10000;\n}\n.dialog-con{\n    width:400px;\n    padding:100px;\n    background:#cd84f1;\n    margin:10px auto;\n    color:#fff;\n    text-align:center;\n    position:relative;\n}\n.dialog-box:target{\n    visibility:visible\n}\n.dialog-close{\n    position:absolute;\n    right:10px;\n    top:10px;\n    text-decoration:none;\n    color:#fff;\n}\n```\n\n* 实现原理：\n\n    1、通过a标签瞄点定位元素，href和id一致，模拟点击\n\n    2、通过:target选择器定位模态元素，切换显隐\n\n\n### 4、tooltip（文字提示）\n\n* 效果：\n\n![文字提示](https://img.fengjr.com/image/2019/06/27/cd8b68fa85eed4746fbcf1af352ce278.png)\n\n* HTML代码：\n\n```html\n<p class=\"poem\">昼短<span data-tip=\"痛苦难熬的夜晚\" class=\"tooltip\" href=\"\" tabindex=\"0\">苦夜</span>长，何不<span href=\"\"class=\"tooltip\" data-tip=\"一起夜晚游玩\" tabindex=\"0\">秉夜</span>游</p>\n```\n     \n* CSS代码：\n\n```css\n.poem{\n    display:flex;\n    color:#3d3d3d;\n    justify-content:center;\n    margin-top:150px;\n    font-size:20px;\n}\n.tooltip{\n    color:#7d5fff;\n    position:relative;\n}\n.tooltip:before{\n    content: attr(data-tip);\n    position:absolute;\n    left:50%;\n    bottom:120%;\n    display:block;\n    padding:.5em;\n    width:150px;\n    transform:translateX(-50%);\n    background:#111;\n    color:#fff;\n    opacity:0;\n    text-align:center;\n    outline:none;\n    border-radius: 5px;\n}\n.tooltip:after{\n    content:'';\n    display: block;\n    height: 0px;\n    width: 0px;\n    border: 10px solid transparent;\n    border-top-color: #111;\n    position: absolute;\n    top:-20%;\n    transform:translateX(-50%);\n    left:50%;opacity:0\n}\n.tooltip:hover::before,\n.tooltip:focus::before,\n.tooltip:hover::after,\n.tooltip:focus::after{\n    opacity:1\n}\n```\n\n* 实现原理：\n\n    1、利用html自定义属性data-attr来存储提示内容\n\n    2、通过attr(data-attr)来获得提示内容并通过hover来显示文字提示\n\n\n### 5、indicator （阅读进度）\n\n* 效果：\n\n![阅读进度](https://img.fengjr.com/image/2019/06/27/edc650060b8ac2812ec4e7aa64d3043d.png)\n\n* HTML代码：\n\n```html\n<header>\n    <h1>Scroll Indicator</h1>\n</header>\n<main>\n    <h2>I was interested to see if I could make a scroll indicator <a href=\"https://codepen.io/derekjp/pen/pJzpxB\" target=\"_blank\">like this</a> with just CSS.</h2>\n    <p>You can! But maybe you shouldn't. This is an interesting consequence of a bunch of hacks held together with duct tape. It uses z-index hacks, gradient hacks and tricks with calc and viewport units.</p>\n    <p>Having said that, hacks are not always bad. I love hacks and many of us have made quite a good living selling floats and clearfixes.</p>\n    <p>The techniques used here are well supported, if not conventional. If you can read the CSS, understand how it works, and how to change it, and you think this works better for you than JavaScript, feel free to implement it. Just be aware of the z-index behaviour and possible conflict with other CSS using negative z-index.</p>\n    <hr>\n    ...\n</main>\n```\n     \n* CSS代码：\n\n```css\nheader{\n  position: fixed;\n  top:0;\n  height: 125px;\n  width: 100%;\n  background: white;\n  z-index: 100;\n}\nmain {\n  margin-top: 128px;\n}\n@supports (height: 100vh) { \n  body{\n    background: linear-gradient(to right top, #0089f2 50%, #DDD 50%);\n    background-size: 100% calc(100% - 100vh + 129px);\n    background-repeat: no-repeat;\n  }\n  body:before{\n    content:'';\n    position: fixed;\n    top: 128px;\n    bottom: 0;\n    width: 100%;\n    z-index: -1;\n    background: white;\n  }\n}\n```\n\n* 实现原理：\n\n    1、body设置一个对角线的渐变背景\n\n    2、在body上覆盖一个背景为白色的遮盖层，露出顶部一点点用来显示进度\n    \n    \n","source":"_posts/2019-06-28-csstrick.md","raw":"---\ntitle: 你不知道的css技巧\ncomments: true\ndate: 2019-06-28 17:00:00\ntags:\n- css\n- 动画\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n![](https://img.fengjr.com/image/2019/06/28/7b2fa1b3d5eaafe09136f314a4cd6d36.png)\n\n## CSS是什么（简介）\n层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。\nCSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。\n\n## CSS发展史\n\n\n* 1990年，Tim Berners-Lee和Robert Cailliau共同发明了Web。1994年，Web真正走出实验室。\n\n* 1997年初，W3C开始接管CSS，W3C内组织了专门管CSS的工作组\n\n* 1988年5月W3C发表了CSS2，CSS2.1修改了CSS2中的一些错误，删除了其中不被支持的内容和增加了一些已有的浏览器的扩展内容\n\n* 从2011年开始CSS被分为多个模块单独升级。统称为CSS3\n    模块有：CSS选择器level3、CSS媒体查询level3、CSS color level3\n\n* 预编译工具SASS,LESS\n    Less和Sass的主要不同就是他们的实现方式。\n    Less是基于JavaScript，是在客户端处理的。\n    Sass是基于Ruby的，是在服务器端处理的。\n\n\n## css奇技淫巧\n### 1、tab\n* 效果：\n\n![tab技巧](https://img.fengjr.com/image/2019/06/27/10ab0bba9acfc64eb4d1f8e7f66ada81.png)\n  \n* HTML代码：\n\n ```html\n<div class=\"tabs-box\">\n    <div class=\"tab\">\n        <input type=\"radio\" class=\"radio\" id=\"radio1\" name=\"radiogroup\" checked/>\n        <label for=\"radio1\">标签1</label>\n        <section>内容1</section>\n    </div>\n    <div class=\"tab\">\n        <input type=\"radio\" class=\"radio\" id=\"radio2\" name=\"radiogroup\"/>\n        <label for=\"radio2\">标签2</label>\n        <section>内容2</section>\n    </div>\n    <div class=\"tab\">\n        <input type=\"radio\" class=\"radio\" id=\"radio3\" name=\"radiogroup\"/>\n        <label for=\"radio3\">标签3</label>\n        <section>内容3</section>\n    </div>\n</div> \n ```\n\n* CSS代码：\n\n```css\n.tabs-box {\n    margin:230px auto 30px;\n    width:40%;\n    height:200px;\n    position:relative;\n}\n.tab {\n    float:left;\n}\n.tabs-box input {\n    position:absolute;\n    opacity: 0;\n}\n.radio:checked ~ label {\n    background: #e67e22;\n}\n.radio:checked ~ section {\n    z-index: 1\n}\n.tabs-box label {\n    padding:.5em .5em;\n    background:#2980b9;\n    color:#fff;\n    border-radius:3px;\n    cursor: pointer;\n}\n.tabs-box section {\n    width:100%;\n    background:#ddd;\n    height:150px;\n    position:absolute;\n    padding:10px;\n    top:30px;\n    left:0;\n}   \n```\n\n* 实现原理：\n\n    1、相同name属性的radio组一次性只能选择一个，模拟面板切换\n    \n    2、利用radio具有可聚焦属性，模拟点击事件\n    \n    3、通过CSS派生选择器，结合z-index层级来完成内容显隐切换\n\n\n### 2、collapse（折叠面板）\n\n* 效果：\n\n![折叠面板](https://img.fengjr.com/image/2019/06/27/5e913333a4f99eb22dfa5e4bd4693bbf.png)\n\n* HTML代码：\n\n```html\n<div class=\"toggle-box\">\n    <input type=\"checkbox\" id=\"checkbox1\" class=\"checkbox-common\"/>\n    <label for=\"checkbox1\" class=\"panel-title\">面板1</label>\n    <section class=\"panel-content\" id=\"content1\">内容1</section>\n    <input type=\"checkbox\" id=\"checkbox2\" class=\"checkbox-common\"/>\n    <label for=\"checkbox2\" class=\"panel-title\">面板2</label>\n    <section class=\"panel-content\" id=\"content2\">内容2</section>\n    <input type=\"checkbox\" id=\"checkbox3\" class=\"checkbox-common\"/>\n    <label for=\"checkbox3\" class=\"panel-title\">面板3</label>\n    <section class=\"panel-content\" id=\"content3\">内容3</section>\n</div> \n```\n* CSS代码：\n\n```css\n.toggle-box{\n    width:50%;\n    margin:30px auto;\n    border:1px solid red;\n}\n.panel-title{\n    background:orange;\n    color:#fff;\n    display:block;\n    position:relative;\n    padding:.2em;\n    border-bottom:1px solid #fff;\n}\n.checkbox-common{\n    position:absolute;\n}\n#checkbox1:checked ~ #content1,\n#checkbox2:checked ~ #content2,\n#checkbox3:checked ~ #content3{\n    height:100px;\n}\n.panel-content{\n    height:0;\n    transition:all 300ms;\n    overflow:hidden\n}\n```\n\n* 实现原理：\n\n    1、利用checkbox多选特性，模拟同时事件聚焦\n    \n    2、利用checkbox具有可聚焦属性，模拟点击事件\n    \n    3、通过CSS派生选择器来变换内容高度完成面版折叠效果\n\n\n### 3、dialog（模态框）\n\n* 效果：\n\n![模态框](https://img.fengjr.com/image/2019/06/27/b2aa836a5ad00d60a0e70c6a5094cb50.png)\n\n* HTML代码：\n\n```html\n<a href=\"#dialog\" class=\"dialog-btn\">click me</a>\n<div class=\"dialog-box\" id=\"dialog\">\n    <div class=\"dialog-con\">\n        <a href=\"#\" class=\"dialog-close\">X</a>\n\t    content\n    </div>\n</div>\n```\n     \n* CSS代码：\n\n```css\n.dialog-btn{\n    margin:10px auto;\n    width:120px;\n    color:#fff;\n    text-align:center;\n    background:#ffaf40;\n    padding:10px;\n    display:block;\n    border-radius: 30px;\n    text-decoration:none\n}\n.dialog-box{\n    position:fixed;\n    top:0;\n    left:0;\n    right:0;\n    bottom:0;\n    background:rgba(0,0,0,0.5);\n    visibility:hidden;\n    z-index: 10000;\n}\n.dialog-con{\n    width:400px;\n    padding:100px;\n    background:#cd84f1;\n    margin:10px auto;\n    color:#fff;\n    text-align:center;\n    position:relative;\n}\n.dialog-box:target{\n    visibility:visible\n}\n.dialog-close{\n    position:absolute;\n    right:10px;\n    top:10px;\n    text-decoration:none;\n    color:#fff;\n}\n```\n\n* 实现原理：\n\n    1、通过a标签瞄点定位元素，href和id一致，模拟点击\n\n    2、通过:target选择器定位模态元素，切换显隐\n\n\n### 4、tooltip（文字提示）\n\n* 效果：\n\n![文字提示](https://img.fengjr.com/image/2019/06/27/cd8b68fa85eed4746fbcf1af352ce278.png)\n\n* HTML代码：\n\n```html\n<p class=\"poem\">昼短<span data-tip=\"痛苦难熬的夜晚\" class=\"tooltip\" href=\"\" tabindex=\"0\">苦夜</span>长，何不<span href=\"\"class=\"tooltip\" data-tip=\"一起夜晚游玩\" tabindex=\"0\">秉夜</span>游</p>\n```\n     \n* CSS代码：\n\n```css\n.poem{\n    display:flex;\n    color:#3d3d3d;\n    justify-content:center;\n    margin-top:150px;\n    font-size:20px;\n}\n.tooltip{\n    color:#7d5fff;\n    position:relative;\n}\n.tooltip:before{\n    content: attr(data-tip);\n    position:absolute;\n    left:50%;\n    bottom:120%;\n    display:block;\n    padding:.5em;\n    width:150px;\n    transform:translateX(-50%);\n    background:#111;\n    color:#fff;\n    opacity:0;\n    text-align:center;\n    outline:none;\n    border-radius: 5px;\n}\n.tooltip:after{\n    content:'';\n    display: block;\n    height: 0px;\n    width: 0px;\n    border: 10px solid transparent;\n    border-top-color: #111;\n    position: absolute;\n    top:-20%;\n    transform:translateX(-50%);\n    left:50%;opacity:0\n}\n.tooltip:hover::before,\n.tooltip:focus::before,\n.tooltip:hover::after,\n.tooltip:focus::after{\n    opacity:1\n}\n```\n\n* 实现原理：\n\n    1、利用html自定义属性data-attr来存储提示内容\n\n    2、通过attr(data-attr)来获得提示内容并通过hover来显示文字提示\n\n\n### 5、indicator （阅读进度）\n\n* 效果：\n\n![阅读进度](https://img.fengjr.com/image/2019/06/27/edc650060b8ac2812ec4e7aa64d3043d.png)\n\n* HTML代码：\n\n```html\n<header>\n    <h1>Scroll Indicator</h1>\n</header>\n<main>\n    <h2>I was interested to see if I could make a scroll indicator <a href=\"https://codepen.io/derekjp/pen/pJzpxB\" target=\"_blank\">like this</a> with just CSS.</h2>\n    <p>You can! But maybe you shouldn't. This is an interesting consequence of a bunch of hacks held together with duct tape. It uses z-index hacks, gradient hacks and tricks with calc and viewport units.</p>\n    <p>Having said that, hacks are not always bad. I love hacks and many of us have made quite a good living selling floats and clearfixes.</p>\n    <p>The techniques used here are well supported, if not conventional. If you can read the CSS, understand how it works, and how to change it, and you think this works better for you than JavaScript, feel free to implement it. Just be aware of the z-index behaviour and possible conflict with other CSS using negative z-index.</p>\n    <hr>\n    ...\n</main>\n```\n     \n* CSS代码：\n\n```css\nheader{\n  position: fixed;\n  top:0;\n  height: 125px;\n  width: 100%;\n  background: white;\n  z-index: 100;\n}\nmain {\n  margin-top: 128px;\n}\n@supports (height: 100vh) { \n  body{\n    background: linear-gradient(to right top, #0089f2 50%, #DDD 50%);\n    background-size: 100% calc(100% - 100vh + 129px);\n    background-repeat: no-repeat;\n  }\n  body:before{\n    content:'';\n    position: fixed;\n    top: 128px;\n    bottom: 0;\n    width: 100%;\n    z-index: -1;\n    background: white;\n  }\n}\n```\n\n* 实现原理：\n\n    1、body设置一个对角线的渐变背景\n\n    2、在body上覆盖一个背景为白色的遮盖层，露出顶部一点点用来显示进度\n    \n    \n","slug":"csstrick","published":1,"updated":"2020-06-10T06:01:59.713Z","_id":"cjxfsbp4l000ehgq51qcgfn9h","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/06/28/7b2fa1b3d5eaafe09136f314a4cd6d36.png\" alt></p>\n<h2 id=\"CSS是什么（简介）\"><a href=\"#CSS是什么（简介）\" class=\"headerlink\" title=\"CSS是什么（简介）\"></a>CSS是什么（简介）</h2><p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。<br>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p>\n<h2 id=\"CSS发展史\"><a href=\"#CSS发展史\" class=\"headerlink\" title=\"CSS发展史\"></a>CSS发展史</h2><ul>\n<li><p>1990年，Tim Berners-Lee和Robert Cailliau共同发明了Web。1994年，Web真正走出实验室。</p>\n</li>\n<li><p>1997年初，W3C开始接管CSS，W3C内组织了专门管CSS的工作组</p>\n</li>\n<li><p>1988年5月W3C发表了CSS2，CSS2.1修改了CSS2中的一些错误，删除了其中不被支持的内容和增加了一些已有的浏览器的扩展内容</p>\n</li>\n<li><p>从2011年开始CSS被分为多个模块单独升级。统称为CSS3<br>  模块有：CSS选择器level3、CSS媒体查询level3、CSS color level3</p>\n</li>\n<li><p>预编译工具SASS,LESS<br>  Less和Sass的主要不同就是他们的实现方式。<br>  Less是基于JavaScript，是在客户端处理的。<br>  Sass是基于Ruby的，是在服务器端处理的。</p>\n</li>\n</ul>\n<h2 id=\"css奇技淫巧\"><a href=\"#css奇技淫巧\" class=\"headerlink\" title=\"css奇技淫巧\"></a>css奇技淫巧</h2><h3 id=\"1、tab\"><a href=\"#1、tab\" class=\"headerlink\" title=\"1、tab\"></a>1、tab</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/10ab0bba9acfc64eb4d1f8e7f66ada81.png\" alt=\"tab技巧\"></p>\n<ul>\n<li><p>HTML代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tabs-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tab\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radio1\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radiogroup\"</span> <span class=\"attr\">checked</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radio1\"</span>&gt;</span>标签1<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span>内容1<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tab\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radio2\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radiogroup\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radio2\"</span>&gt;</span>标签2<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span>内容2<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tab\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radio3\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radiogroup\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radio3\"</span>&gt;</span>标签3<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span>内容3<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS代码：</p>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tabs-box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">230px</span> auto <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">40%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tab</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tabs-box</span> <span class=\"selector-tag\">input</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.radio</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-tag\">label</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#e67e22</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.radio</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-tag\">section</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tabs-box</span> <span class=\"selector-tag\">label</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:.<span class=\"number\">5em</span> .<span class=\"number\">5em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#2980b9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">3px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tabs-box</span> <span class=\"selector-tag\">section</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#ddd</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、相同name属性的radio组一次性只能选择一个，模拟面板切换</p>\n<p>  2、利用radio具有可聚焦属性，模拟点击事件</p>\n<p>  3、通过CSS派生选择器，结合z-index层级来完成内容显隐切换</p>\n</li>\n</ul>\n<h3 id=\"2、collapse（折叠面板）\"><a href=\"#2、collapse（折叠面板）\" class=\"headerlink\" title=\"2、collapse（折叠面板）\"></a>2、collapse（折叠面板）</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/5e913333a4f99eb22dfa5e4bd4693bbf.png\" alt=\"折叠面板\"></p>\n<ul>\n<li>HTML代码：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"toggle-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"checkbox-common\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-title\"</span>&gt;</span>面板1<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-content\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content1\"</span>&gt;</span>内容1<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"checkbox-common\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-title\"</span>&gt;</span>面板2<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-content\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content2\"</span>&gt;</span>内容2<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"checkbox-common\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-title\"</span>&gt;</span>面板3<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-content\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content3\"</span>&gt;</span>内容3<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>CSS代码：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.toggle-box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">30px</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.panel-title</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:orange;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:.<span class=\"number\">2em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.checkbox-common</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#checkbox1</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-id\">#content1</span>,</span><br><span class=\"line\"><span class=\"selector-id\">#checkbox2</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-id\">#content2</span>,</span><br><span class=\"line\"><span class=\"selector-id\">#checkbox3</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-id\">#content3</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.panel-content</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>:all <span class=\"number\">300ms</span>;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>:hidden</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、利用checkbox多选特性，模拟同时事件聚焦</p>\n<p>  2、利用checkbox具有可聚焦属性，模拟点击事件</p>\n<p>  3、通过CSS派生选择器来变换内容高度完成面版折叠效果</p>\n</li>\n</ul>\n<h3 id=\"3、dialog（模态框）\"><a href=\"#3、dialog（模态框）\" class=\"headerlink\" title=\"3、dialog（模态框）\"></a>3、dialog（模态框）</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/b2aa836a5ad00d60a0e70c6a5094cb50.png\" alt=\"模态框\"></p>\n<ul>\n<li>HTML代码：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#dialog\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dialog-btn\"</span>&gt;</span>click me<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dialog-box\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dialog\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dialog-con\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dialog-close\"</span>&gt;</span>X<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">\t    content</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>CSS代码：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.dialog-btn</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">120px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#ffaf40</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-decoration</span>:none</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dialog-box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:fixed;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"built_in\">rgba</span>(0,0,0,0.5);</span><br><span class=\"line\">    <span class=\"attribute\">visibility</span>:hidden;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">10000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dialog-con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#cd84f1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dialog-box</span><span class=\"selector-pseudo\">:target</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">visibility</span>:visible</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dialog-close</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-decoration</span>:none;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、通过a标签瞄点定位元素，href和id一致，模拟点击</p>\n<p>  2、通过:target选择器定位模态元素，切换显隐</p>\n</li>\n</ul>\n<h3 id=\"4、tooltip（文字提示）\"><a href=\"#4、tooltip（文字提示）\" class=\"headerlink\" title=\"4、tooltip（文字提示）\"></a>4、tooltip（文字提示）</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/cd8b68fa85eed4746fbcf1af352ce278.png\" alt=\"文字提示\"></p>\n<ul>\n<li>HTML代码：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"poem\"</span>&gt;</span>昼短<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-tip</span>=<span class=\"string\">\"痛苦难熬的夜晚\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tooltip\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">tabindex</span>=<span class=\"string\">\"0\"</span>&gt;</span>苦夜<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>长，何不<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span><span class=\"attr\">class</span>=<span class=\"string\">\"tooltip\"</span> <span class=\"attr\">data-tip</span>=<span class=\"string\">\"一起夜晚游玩\"</span> <span class=\"attr\">tabindex</span>=<span class=\"string\">\"0\"</span>&gt;</span>秉夜<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>游<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>CSS代码：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.poem</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:flex;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#3d3d3d</span>;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>:center;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#7d5fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:before</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"built_in\">attr</span>(data-tip);</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">120%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:.<span class=\"number\">5em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>:<span class=\"built_in\">translateX</span>(-50%);</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#111</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>:none;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>:<span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-top-color</span>: <span class=\"number\">#111</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:-<span class=\"number\">20%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>:<span class=\"built_in\">translateX</span>(-50%);</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:hover</span><span class=\"selector-pseudo\">::before</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">::before</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:hover</span><span class=\"selector-pseudo\">::after</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>:<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、利用html自定义属性data-attr来存储提示内容</p>\n<p>  2、通过attr(data-attr)来获得提示内容并通过hover来显示文字提示</p>\n</li>\n</ul>\n<h3 id=\"5、indicator-（阅读进度）\"><a href=\"#5、indicator-（阅读进度）\" class=\"headerlink\" title=\"5、indicator （阅读进度）\"></a>5、indicator （阅读进度）</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/edc650060b8ac2812ec4e7aa64d3043d.png\" alt=\"阅读进度\"></p>\n<ul>\n<li>HTML代码：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Scroll Indicator<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>I was interested to see if I could make a scroll indicator <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://codepen.io/derekjp/pen/pJzpxB\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>like this<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> with just CSS.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>You can! But maybe you shouldn't. This is an interesting consequence of a bunch of hacks held together with duct tape. It uses z-index hacks, gradient hacks and tricks with calc and viewport units.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Having said that, hacks are not always bad. I love hacks and many of us have made quite a good living selling floats and clearfixes.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The techniques used here are well supported, if not conventional. If you can read the CSS, understand how it works, and how to change it, and you think this works better for you than JavaScript, feel free to implement it. Just be aware of the z-index behaviour and possible conflict with other CSS using negative z-index.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>CSS代码：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">header</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">125px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: white;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">128px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">supports</span> (height: <span class=\"number\">100vh</span>) &#123; </span><br><span class=\"line\">  <span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">linear-gradient</span>(to right top, #0089f2 50%, #DDD 50%);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"built_in\">calc</span>(100% - 100vh + 129px);</span><br><span class=\"line\">    <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">body</span><span class=\"selector-pseudo\">:before</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>:<span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">128px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: white;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、body设置一个对角线的渐变背景</p>\n<p>  2、在body上覆盖一个背景为白色的遮盖层，露出顶部一点点用来显示进度</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/06/28/7b2fa1b3d5eaafe09136f314a4cd6d36.png\" alt></p>\n<h2 id=\"CSS是什么（简介）\"><a href=\"#CSS是什么（简介）\" class=\"headerlink\" title=\"CSS是什么（简介）\"></a>CSS是什么（简介）</h2><p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。<br>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p>\n<h2 id=\"CSS发展史\"><a href=\"#CSS发展史\" class=\"headerlink\" title=\"CSS发展史\"></a>CSS发展史</h2><ul>\n<li><p>1990年，Tim Berners-Lee和Robert Cailliau共同发明了Web。1994年，Web真正走出实验室。</p>\n</li>\n<li><p>1997年初，W3C开始接管CSS，W3C内组织了专门管CSS的工作组</p>\n</li>\n<li><p>1988年5月W3C发表了CSS2，CSS2.1修改了CSS2中的一些错误，删除了其中不被支持的内容和增加了一些已有的浏览器的扩展内容</p>\n</li>\n<li><p>从2011年开始CSS被分为多个模块单独升级。统称为CSS3<br>  模块有：CSS选择器level3、CSS媒体查询level3、CSS color level3</p>\n</li>\n<li><p>预编译工具SASS,LESS<br>  Less和Sass的主要不同就是他们的实现方式。<br>  Less是基于JavaScript，是在客户端处理的。<br>  Sass是基于Ruby的，是在服务器端处理的。</p>\n</li>\n</ul>\n<h2 id=\"css奇技淫巧\"><a href=\"#css奇技淫巧\" class=\"headerlink\" title=\"css奇技淫巧\"></a>css奇技淫巧</h2><h3 id=\"1、tab\"><a href=\"#1、tab\" class=\"headerlink\" title=\"1、tab\"></a>1、tab</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/10ab0bba9acfc64eb4d1f8e7f66ada81.png\" alt=\"tab技巧\"></p>\n<ul>\n<li><p>HTML代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tabs-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tab\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radio1\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radiogroup\"</span> <span class=\"attr\">checked</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radio1\"</span>&gt;</span>标签1<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span>内容1<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tab\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radio2\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radiogroup\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radio2\"</span>&gt;</span>标签2<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span>内容2<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tab\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radio3\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radiogroup\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radio3\"</span>&gt;</span>标签3<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span>内容3<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS代码：</p>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tabs-box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">230px</span> auto <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">40%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tab</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tabs-box</span> <span class=\"selector-tag\">input</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.radio</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-tag\">label</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#e67e22</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.radio</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-tag\">section</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tabs-box</span> <span class=\"selector-tag\">label</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:.<span class=\"number\">5em</span> .<span class=\"number\">5em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#2980b9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">3px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tabs-box</span> <span class=\"selector-tag\">section</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#ddd</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、相同name属性的radio组一次性只能选择一个，模拟面板切换</p>\n<p>  2、利用radio具有可聚焦属性，模拟点击事件</p>\n<p>  3、通过CSS派生选择器，结合z-index层级来完成内容显隐切换</p>\n</li>\n</ul>\n<h3 id=\"2、collapse（折叠面板）\"><a href=\"#2、collapse（折叠面板）\" class=\"headerlink\" title=\"2、collapse（折叠面板）\"></a>2、collapse（折叠面板）</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/5e913333a4f99eb22dfa5e4bd4693bbf.png\" alt=\"折叠面板\"></p>\n<ul>\n<li>HTML代码：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"toggle-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"checkbox-common\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-title\"</span>&gt;</span>面板1<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-content\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content1\"</span>&gt;</span>内容1<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"checkbox-common\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-title\"</span>&gt;</span>面板2<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-content\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content2\"</span>&gt;</span>内容2<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"checkbox3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"checkbox-common\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"checkbox3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-title\"</span>&gt;</span>面板3<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"panel-content\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content3\"</span>&gt;</span>内容3<span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>CSS代码：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.toggle-box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">30px</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.panel-title</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:orange;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:.<span class=\"number\">2em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.checkbox-common</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#checkbox1</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-id\">#content1</span>,</span><br><span class=\"line\"><span class=\"selector-id\">#checkbox2</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-id\">#content2</span>,</span><br><span class=\"line\"><span class=\"selector-id\">#checkbox3</span><span class=\"selector-pseudo\">:checked</span> ~ <span class=\"selector-id\">#content3</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.panel-content</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>:all <span class=\"number\">300ms</span>;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>:hidden</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、利用checkbox多选特性，模拟同时事件聚焦</p>\n<p>  2、利用checkbox具有可聚焦属性，模拟点击事件</p>\n<p>  3、通过CSS派生选择器来变换内容高度完成面版折叠效果</p>\n</li>\n</ul>\n<h3 id=\"3、dialog（模态框）\"><a href=\"#3、dialog（模态框）\" class=\"headerlink\" title=\"3、dialog（模态框）\"></a>3、dialog（模态框）</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/b2aa836a5ad00d60a0e70c6a5094cb50.png\" alt=\"模态框\"></p>\n<ul>\n<li>HTML代码：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#dialog\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dialog-btn\"</span>&gt;</span>click me<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dialog-box\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dialog\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dialog-con\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dialog-close\"</span>&gt;</span>X<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">\t    content</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>CSS代码：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.dialog-btn</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">120px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#ffaf40</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-decoration</span>:none</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dialog-box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:fixed;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"built_in\">rgba</span>(0,0,0,0.5);</span><br><span class=\"line\">    <span class=\"attribute\">visibility</span>:hidden;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">10000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dialog-con</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#cd84f1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dialog-box</span><span class=\"selector-pseudo\">:target</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">visibility</span>:visible</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.dialog-close</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-decoration</span>:none;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、通过a标签瞄点定位元素，href和id一致，模拟点击</p>\n<p>  2、通过:target选择器定位模态元素，切换显隐</p>\n</li>\n</ul>\n<h3 id=\"4、tooltip（文字提示）\"><a href=\"#4、tooltip（文字提示）\" class=\"headerlink\" title=\"4、tooltip（文字提示）\"></a>4、tooltip（文字提示）</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/cd8b68fa85eed4746fbcf1af352ce278.png\" alt=\"文字提示\"></p>\n<ul>\n<li>HTML代码：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"poem\"</span>&gt;</span>昼短<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-tip</span>=<span class=\"string\">\"痛苦难熬的夜晚\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tooltip\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">tabindex</span>=<span class=\"string\">\"0\"</span>&gt;</span>苦夜<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>长，何不<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span><span class=\"attr\">class</span>=<span class=\"string\">\"tooltip\"</span> <span class=\"attr\">data-tip</span>=<span class=\"string\">\"一起夜晚游玩\"</span> <span class=\"attr\">tabindex</span>=<span class=\"string\">\"0\"</span>&gt;</span>秉夜<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>游<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>CSS代码：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.poem</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:flex;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#3d3d3d</span>;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>:center;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#7d5fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:before</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"built_in\">attr</span>(data-tip);</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">120%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:.<span class=\"number\">5em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>:<span class=\"built_in\">translateX</span>(-50%);</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#111</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>:none;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>:<span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-top-color</span>: <span class=\"number\">#111</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>:-<span class=\"number\">20%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>:<span class=\"built_in\">translateX</span>(-50%);</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;<span class=\"attribute\">opacity</span>:<span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:hover</span><span class=\"selector-pseudo\">::before</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">::before</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:hover</span><span class=\"selector-pseudo\">::after</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.tooltip</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>:<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、利用html自定义属性data-attr来存储提示内容</p>\n<p>  2、通过attr(data-attr)来获得提示内容并通过hover来显示文字提示</p>\n</li>\n</ul>\n<h3 id=\"5、indicator-（阅读进度）\"><a href=\"#5、indicator-（阅读进度）\" class=\"headerlink\" title=\"5、indicator （阅读进度）\"></a>5、indicator （阅读进度）</h3><ul>\n<li>效果：</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/06/27/edc650060b8ac2812ec4e7aa64d3043d.png\" alt=\"阅读进度\"></p>\n<ul>\n<li>HTML代码：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Scroll Indicator<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>I was interested to see if I could make a scroll indicator <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://codepen.io/derekjp/pen/pJzpxB\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>like this<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> with just CSS.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>You can! But maybe you shouldn't. This is an interesting consequence of a bunch of hacks held together with duct tape. It uses z-index hacks, gradient hacks and tricks with calc and viewport units.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Having said that, hacks are not always bad. I love hacks and many of us have made quite a good living selling floats and clearfixes.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The techniques used here are well supported, if not conventional. If you can read the CSS, understand how it works, and how to change it, and you think this works better for you than JavaScript, feel free to implement it. Just be aware of the z-index behaviour and possible conflict with other CSS using negative z-index.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>CSS代码：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">header</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">125px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: white;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">128px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">supports</span> (height: <span class=\"number\">100vh</span>) &#123; </span><br><span class=\"line\">  <span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">linear-gradient</span>(to right top, #0089f2 50%, #DDD 50%);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"built_in\">calc</span>(100% - 100vh + 129px);</span><br><span class=\"line\">    <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">body</span><span class=\"selector-pseudo\">:before</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>:<span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">128px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: white;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>实现原理：</p>\n<p>  1、body设置一个对角线的渐变背景</p>\n<p>  2、在body上覆盖一个背景为白色的遮盖层，露出顶部一点点用来显示进度</p>\n</li>\n</ul>\n"},{"title":"sass+compass使用","comments":1,"date":"2019-08-01T09:00:00.000Z","author":"jun.zhou","_content":"\n![](https://img.fengjr.com/image/2019/07/31/14b7d54d9c92f52c211549ef418441de.png)\n\n## 一、什么是sass\n<font color=red>Sass</font> 是对<font color=red>CSS</font> 的扩展，让<font color=red> CSS </font>语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins</font>、导入等众多功能， 并且完全兼容 <font color=red>CSS</font> 语法。 <font color=red>Sass</font> 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， 特别是在搭配 <font color=red>Compass</font> 样式库一同使用时。\n## 二、sass语法\n\n<font color=red>Sass</font> 有两种语法。 第一种被称为<font color=red> SCSS (Sassy CSS)</font>，是一个 <font color=red>CSS3</font> 语法的扩充版本，这份参考资料使用的就是此语法。 也就是说，所有符合 <font color=red>CSS3</font> 语法的样式表也都是具有相同语法意义的 <font color=red>SCSS</font> 文件。 另外，<font color=red>SCSS</font> 理解大多数 <font color=red>CSS hacks</font> 以及浏览器专属语法，例如IE 古老的<font color=red> filter</font> 语法。 这种语种语法的样式表文件需要以 <font color=red>.scss</font> 扩展名。\n\n<font color=red>SCSS </font>是<font color=red> Sass 3</font> 引入新的语法，其语法完全兼容<font color=red> CSS3</font>，并且继承了 <font color=red>Sass</font> 的强大功能。也就是说，任何标准的<font color=red> CSS3</font> 样式表都是具有相同语义的有效的<font color=red> SCSS</font> 文件。另外，<font color=red>SCSS </font>还能识别大部分 <font color=red>CSS hacks</font>（一些 <font color=red>CSS </font>小技巧）和特定于浏览器的语法\n\n第二种比较老的语法成为缩排语法（或者就称为 \"<font color=red>Sass</font>\"）， 提供了一种更简洁的 <font color=red>CSS</font> 书写方式。 它不使用花括号，而是通过缩排的方式来表达选择符的嵌套层级，I 而且也不使用分号，而是用换行符来分隔属性。 很多人认为这种格式比 <font color=red>SCSS</font> 更容易阅读，书写也更快速。 缩排语法具有 <font color=red>Sass</font> 的所有特色功能， 虽然有些语法上稍有差异；使用此种语法的样式表文件需要以 <font color=red>.sass </font>作为扩展名。\n\n任一语法都可以导入另一种语法撰写的文件中。 只要使用 <font color=red>sass-convert</font> 命令行工具，就可以将一种语法转换为另一种语法：\n```css\n# 将 Sass 转换为 SCSS\n$ sass-convert style.sass style.scss\n\n# 将 SCSS 转换为 Sass\n$ sass-convert style.scss style.sass\n```\n## 三、sass安装及使用\n<font color=red>SASS</font>是<font color=red>Ruby</font>语言写的，但是两者的语法没有关系。不懂<font color=red>Ruby</font>，照样使用。只是必须先安装<font color=red>Ruby</font>，然后再安装<font color=red>SASS</font>。\n```css\ngem install sass\n```\n如果你使用的是 <font color=red>Windows</font>， 就需要先安装 <font color=red>Ruby</font>,因为<font color=red>sass</font>编译是基于<font color=red>Ruby</font>环境的。\n\n如果要在命令行中运行 <font color=red>Sass</font> ,只要输入\n```css\nsass input.scss output.css\n```\nSASS提供四个编译风格的选项：\n```\nnested：嵌套缩进的css代码，它是默认值。\n\nexpanded：没有缩进的、扩展的css代码。\n\ncompact：简洁格式的css代码。\n\ncompressed：压缩后的css代码。\n```\n```\nsass --style compressed test.sass test.css\n```\n你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。\n```\n// watch a file\nsass --watch input.scss:output.css\n\n// watch a directory\nsass --watch app/sass:public/stylesheets\n```\n### 1、变量声明\n```css\n//编译前\n$nav-color: #F90;\nnav {\n  $width: 100px;\n  width: $width;\n  color: $nav-color;\n}\n\n//编译后\nnav {\n  width: 100px;\n  color: #F90;\n}\n```\n在这段代码中，<font color=red>$nav-color</font>这个变量定义在了规则块外边，相当于全局变量，所以在这个样式表中都可以像<font color=red>nav</font>规则块那样引用它。<font color=red>$width</font>这个变量定义在了<font color=red>nav</font>的<font color=red>{ }</font>规则块内，相当于局部变量，所以它只能在<font color=red>nav</font>规则块内使用。这意味着是你可以在样式表的其他地方定义和使用<font color=red>$width</font>变量，不会对这里造成影响。其变量名用中线和下划线<font color=red>sass</font>不做强求且相互兼容。\n### 2、嵌套CSS 规则\n#### 2.1、 父选择器的标识符&\n\n```css\n//编译前\narticle a {\n  color: blue;\n  &:hover { color: red }\n}\n#content aside {\n  color: red;\n  body.ie & { color: green }\n}\n#content {\n    &-item {\n        font-size: #ff0;\n    }\n}\n//编译后\narticle a { color: blue }\narticle a:hover { color: red }\n#content aside {color: red};\nbody.ie #content aside { color: green }\n#content-item { font-size: #ff0; }\n```\n一般情况下，<font color=red>sass</font>在解开一个嵌套规则时就会把父选择器通过一个空格连接到子选择器的前边，这种在<font color=red>CSS</font>里边被称为后代选择器。但在有些情况下你却不会希望<font color=red>sass</font>使用这种后代选择器的方式生成这种连接，这时候我们会用到'<font color=red>&</font>'符号，它起到连接作用\n\n#### 2.2、群组选择器的嵌套\n\n```css\n//编译前\n.container {\n  h1, h2, h3 {margin-bottom: .8em}\n}\nnav, aside {\n  a {color: blue}\n}\n\n//编译后\n.container h1, .container h2, .container h3 { margin-bottom: .8em }\nnav a, aside a {color: blue}\n```\n处理这种群组选择器规则嵌套上的强大能力，正是<font color=red>sass</font>在减少重复敲写方面的贡献之一。尤其在当嵌套级别达到两层甚至三层以上时，与普通的<font color=red>css</font>编写方式相比，只写一遍群组选择器大大减少了工作量。\n\n有利必有弊，你需要特别注意群组选择器的规则嵌套生成的<font color=red>css</font>。虽然<font color=red>sass</font>让你的样式表看上去很小，但实际生成的<font color=red>css</font>却可能非常大，这会降低网站的速度。\n#### 2.3、子组合选择器和同层组合选择器：<font color=red> >、+</font>和<font color=red>~</font>\n```css\n//编译前\narticle {\n  ~ article { border-top: 1px dashed #ccc }\n  > section { background: #eee }\n  dl > {\n    dt { color: #333 }\n    dd { color: #555 }\n  }\n  nav + & { margin-top: 0 }\n}\n\n//编译后\narticle ~ article { border-top: 1px dashed #ccc }\narticle > footer { background: #eee }\narticle dl > dt { color: #333 }\narticle dl > dd { color: #555 }\nnav + article { margin-top: 0 }\n```\n你可以用子组合选择器<font color=red> > </font>选择一个元素的直接子元素。你可以用同层相邻组合选择器<font color=red> + </font>选择<font color=red>nav</font>元素后紧跟的<font color=red>article</font>元素。你还可以用同层全体组合选择器<font color=red> ~ </font>，选择所有跟在<font color=red>article</font>后的同层<font color=red>article</font>元素，不管它们之间隔了多少其他元素。\n\n在<font color=red>sass</font>中，不仅仅<font color=red>css</font>规则可以嵌套，对属性进行嵌套也可以减少很多重复性的工作。\n\n#### 2.4、嵌套属性\n在<font color=red>sass</font>中，除了<font color=red>CSS</font>选择器，属性也可以进行嵌套。\n```css\nnav {\n  border: {\n  style: solid;\n  width: 1px;\n  color: #ccc;\n  }\n}\n```\n嵌套属性的规则是这样的<font color=red>:</font>把属性名从中划线<font color=red> - </font>的地方断开，在根属性后边添加一个冒号<font color=red> : </font>，紧跟一个<font color=red>{ }</font>块，把子属性部分写在这个<font color=red>{ }</font>块中。就像<font color=red>css</font>选择器嵌套一样，<font color=red>sass</font>会把你的子属性一一解开，把根属性和子属性部分通过中划线<font color=red> - </font>连接起来，最后生成的效果与你手动一遍遍写的<font color=red>css</font>样式一样:\n```css\nnav {\n  border-style: solid;\n  border-width: 1px;\n  border-color: #ccc;\n}\n```\n对于属性的缩写形式，你甚至可以像下边这样来嵌套，指明例外规则:\n```css\n//编译前\nnav {\n  border: 1px solid #ccc {\n  left: 0px;\n  right: 0px;\n  }\n}\n\n//编译后\nnav {\n  border: 1px solid #ccc;\n  border-left: 0px;\n  border-right: 0px;\n}\n```\n属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。\n\n即便如此，随着你的样式表变得越来越大，这种写法也很难保持结构清晰。有时，处理这种大量样式的唯一方法就是把它们分拆到多个文件中。<font color=red>sass</font>通过对<font color=red>css</font>原有<font color=red>@import</font>规则的改进直接支持了这一特性。\n#### 2.5、计算功能\n<font color=red>sass</font> 允许使用算式。\n```css\n//编译前\ndiv {\n    padding: 2px * 4;\n    margin: (10px / 2);\n    height: 112px - 12px;\n    font-size: 12px + 4px;\n}\n\n//编译后\ndiv{\n    padding:8px;\n    margin:5px;\n    height:100px;\n    font-size:16px;\n}\n```\n###  三、导入SASS文件\n<font color=red>css</font>有一个特别不常用的特性，即<font color=red>@import</font>规则，它允许在一个<font color=red>css</font>文件中导入其他<font color=red>css</font>文件。然而，后果是只有执行到<font color=red>@import</font>时，浏览器才会去下载其他<font color=red>css</font>文件，这导致页面加载起来特别慢。\n\n<font color=red>sass</font>也有一个<font color=red>@import</font>规则，但不同的是，<font color=red>sass</font>的<font color=red>@import</font>规则在生成<font color=red>css</font>文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个<font color=red>css</font>文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器均可在导入文件中使用。\n\n使用<font color=red>sass</font>的<font color=red>@import</font>规则并不需要指明被导入文件的全名。你可以省略<font color=red>.sass</font>或<font color=red>.scss</font>文件后缀。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的<font color=red>sass</font>样式文件语法，在<font color=red>sass</font>和<font color=red>scss</font>语法之间随意切换。举例来说，<font color=red>@import\"sidebar\"</font>;这条命令将把<font color=red>sidebar.scss</font>文件中所有样式添加到当前样式表中。\n\n#### 3.2、默认变量值\n一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明:\n```css\n//编译前\n$link-color: blue;\n$link-color: red;\na {\n    color: $link-color;\n}\n\n//编译后\na {\n    color: red;\n}\n```\n在上边的例子中，超链接的<font color=red>color</font>会被设置为<font color=red>red</font>。这可能并不是你想要的结果，假如你写了一个可被他人通过<font color=red>@import</font>导入的<font color=red>sass</font>库文件，你可能希望导入者可以定制修改<font color=red>sass</font>库文件中的某些值。使用<font color=red>sass</font>的<font color=red>!default</font>标签可以实现这个目的。它很像<font color=red>css</font>属性中<font color=red>!important</font>标签的对立面，不同的是<font color=red>!default</font>用于变量，含义是:如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。\n```css\n//编译前\n$link-color: red !default;\n.a {\n    color: $link-color;\n}\n//编译后\n.a {\n    color: blue;\n}\n```\n在上例中，如果用户在导入你的<font color=red>sass</font>局部文件之前声明了一个<font color=red>$link-color</font>变量，那么你的局部文件中对<font color=red>color</font>赋<font color=red>red</font>的操作就无效。如果用户没有做这样的声明，则<font color=red>$link-color</font>将默认为<font color=red>red</font>。\n\n#### 3.3、嵌套导入\n跟原生的<font color=red>css</font>不同，<font color=red>sass</font>允许<font color=red>@import</font>命令写在<font color=red>css</font>规则内。这种导入方式下，生成对应的<font color=red>css</font>文件时，局部文件会被直接插入到<font color=red>css</font>规则内导入它的地方。举例说明，有一个名为<font color=red>_blue-theme.scss</font>的局部文件，内容如下:\n```css\naside {\n  background: blue;\n  color: white;\n}\n```\n然后把它导入到一个<font color=red>CSS</font>规则内，如下所示:\n```css\n.blue-theme {\n    @import \"blue-theme\"\n}\n\n//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。\n\n.blue-theme {\n  aside {\n    background: blue;\n    color: #fff;\n  }\n}\n```\n被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。\n\n有时，可用<font color=red>css</font>原生的<font color=red>@import</font>机制，在浏览器中下载必需的<font color=red>css</font>文件。<font color=red>sass</font>也提供了几种方法来达成这种需求。\n### 四、混合器\n如果你的整个网站中有几处小小的样式类似(例如一致的颜色和字体)，那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过<font color=red>sass的</font>混合器实现大段样式的重用。\n\n下边的这段<font color=red>sass</font>代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。\n```css\n@mixin rounded-corners {\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  border-radius: 5px;\n}\n```\n然后就可以在你的样式表中通过<font color=red>@include</font>来使用这个混合器，放在你希望的任何地方。<font color=red>@include</font>调用会把混合器中的所有样式提取出来放在<font color=red>@include</font>被调用的地方。如果像下边这样写:\n```css\nnotice {\n  background-color: green;\n  border: 2px solid #00aa00;\n  @include rounded-corners;\n}\n//编译后\n.notice {\n  background-color: green;\n  border: 2px solid #00aa00;\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  border-radius: 5px;\n}\n```\n这一节将介绍使用混合器来避免重复。通过使用参数，你可以使用混合器把你样式中的通用样式抽离出来，然后轻松地在其他地方重用。实际上，混合器太好用了，一不小心你可能会过度使用。大量的重用可能会导致生成的样式表过大，导致加载缓慢。所以，首先我们将讨论混合器的使用场景，避免滥用。\n#### 4.1、混合器中的CSS规则\n混合器中不仅可以包含属性，也可以包含<font color=red>css</font>规则，包含选择器和选择器中的属性，如下代码:\n```css\n@mixin no-bullets {\n  list-style: none;\n  li {\n    list-style-image: none;\n    list-style-type: none;\n    margin-left: 0px;\n  }\n}\n```\n当一个包含<font color=red>css</font>规则的混合器通过<font color=red>@include</font>包含在一个父规则中时，在混合器中的规则最终会生成父规则中的嵌套规则。举个例子，看看下边的<font color=red>sass</font>代码，这个例子中使用了<font color=red>no-bullets</font>这个混合器:\n```css\nul.plain {\n  color: #444;\n  @include no-bullets;\n}\n```\n<font color=red>sass</font>的<font color=red>@include</font>指令会将引入混合器的那行代码替换成混合器里边的内容。最终，上边的例子如下代码:\n```css\nul.plain {\n  color: #444;\n  list-style: none;\n}\nul.plain li {\n  list-style-image: none;\n  list-style-type: none;\n  margin-left: 0px;\n}\n```\n混合器中的规则甚至可以使用<font color=red> sass</font>的父选择器标识符<font color=red>&</font>。使用起来跟不用混合器时一样，<font color=red>sass</font>解开嵌套规则时，用父规则中的选择器替代<font color=red>&</font>。\n\n如果一个混合器只包含<font color=red>css</font>规则，不包含属性，那么这个混合器就可以在文档的顶部调用，写在所有的<font color=red>css</font>规则之外。如果你只是为自己写一些混合器，这并没有什么大的用途，但是当你使用一个类似于<font color=red>Compass</font>的库时，你会发现，这是提供样式的好方法，原因在于你可以选择是否使用这些样式。\n#### 4.2、给混合器传参\n混合器并不一定总得生成相同的样式。可以通过在<font color=red>@include</font>混合器时给混合器传参，来定制混合器生成的精确样式。当<font color=red>@include</font>混合器时，参数其实就是可以赋值给<font color=red>css</font>属性值的变量。如果你写过<font color=red>JavaScript</font>，这种方式跟<font color=red>JavaScript</font>的<font color=red>function</font>很像:\n```css\n@mixin link-colors($normal, $hover, $visited) {\n  color: $normal;\n  &:hover { color: $hover; }\n  &:visited { color: $visited; }\n}\n```\n当混合器被<font color=red>@include</font>时，你可以把它当作一个<font color=red>css</font>函数来传参。如果你像下边这样写:\n```css\na {\n  @include link-colors(blue, red, green);\n}\n\n//Sass最终生成的是:\n\na { color: blue; }\na:hover { color: red; }\na:visited { color: green; }\n```\n当你<font color=red>@include</font>混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，<font color=red>sass</font>允许通过语法<font color=red>$name: value</font>的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可:\n```css\na {\n    @include link-colors(\n      $normal: blue,\n      $visited: green,\n      $hover: red\n  );\n}\n```\n尽管给混合器加参数来实现定制很好，但是有时有些参数我们没有定制的需要，这时候也需要赋值一个变量就变成很痛苦的事情了。所以<font color=red>sass</font>允许混合器声明时给参数赋默认值。\n#### 4.3、默认参数值\n为了在<font color=red>@include</font>混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用<font color=red>$name: default-value</font>的声明形式，默认值可以是任何有效的<font color=red>css</font>属性值，甚至是其他参数的引用，如下代码:\n```css\n@mixin link-colors(\n    $normal,\n    $hover: $normal,\n    $visited: $normal\n  )\n{\n  color: $normal;\n  &:hover { color: $hover; }\n  &:visited { color: $visited; }\n}\n```\n如果像下边这样调用:<font color=red>@include link-colors(red) $hover</font>和<font color=red>$visited</font>也会被自动赋值为<font color=red>red</font>。\n\n混合器只是<font color=red>sass</font>样式重用特性中的一个。我们已经了解到混合器主要用于样式展示层的重用，如果你想重用语义化的类呢？这就涉及<font color=red>sass</font>的另一个重要的重用特性:选择器继承。\n### 五、使用选择器继承来精简CSS\n使用<font color=red>sass</font>的时候，一个减少重复的主要特性就是选择器继承。选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过<font color=red>@extend</font>语法实现，如下代码:\n```css\n//通过选择器继承继承样式\n.error {\n  border: 1px red;\n  background-color: #fdd;\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n```\n任何<font color=red>css</font>规则都可以继承其他规则，几乎任何<font color=red>css</font>规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个<font color=red>html</font>元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对<font color=red>html</font>元素添加的所有样式都会被继承。\n\n### 六、sass扩展及更新\n#### 6.1、使用占位符选择器 % \n从<font color=red>sass3.2.0</font>后，就可以定义占位选择器<font color=red>%</font>，这个的优势在于，不调用不会有多余的<font color=red>css</font>文件\n```css\n// sass样式\n%h1 {\n    font-size:20px;\n}\ndiv {\n    @extend %h1;\n    color:red;\n}\n// css编译后样式\ndiv {\n    font-size:20px;\n    color:red;\n}\n```\n#### 6.2、@content\n在<font color=red>sass3.2.0</font>中引入， 可以用来解决<font color=red>css3</font>中 <font color=red>@meidia</font> 或者<font color=red> @keyframes</font> 带来的问题。它可以使<font color=red>@mixin</font>接受一整块样式，接收的样式从<font color=red>@content</font>开始\n```css\n//sass 样式              \n@mixin max-screen($res){\n  @media only screen and ( max-width: $res )\n  {\n    @content;\n  }\n}\n \n@include max-screen(480px) {\n  body { color: red }\n}\n \n//css 编译后样式\n@media only screen and (max-width: 480px) {\n  body { color: red }\n}\n```\n使用<font color=red>@content</font>解决<font color=red>@keyframes</font>关键帧的浏览器前缀问题\n```css\n// 初始化变量\n$browser: null;\n// 设置关键帧\n@mixin keyframes($name) {\n    @-webkit-keyframes #{$name} {\n        $browser: '-webkit-'; @content;\n    }\n    @-moz-keyframes #{$name} {\n        $browser: '-moz-'; @content;\n    }\n    @-o-keyframes #{$name} {\n        $browser: '-o-'; @content;\n    }\n    @keyframes #{$name} {\n        $browser: ''; @content;\n    }\n}\n \n// 引入\n@include keyframes(scale) {\n    100% {\n        #{$browser}transform: scale(0.8);\n    }\n}\n \n// css编译后\n@-webkit-keyframes scale {\n    -webkit-transform: scale(0.8);\n}\n@-moz-keyframes scale  {\n   -moz-transform: scale(0.8);\n}\n@-o-keyframes scale  {\n    -o-transform: scale(0.8);\n}\n@keyframes scale  {\n    transform: scale(0.8);\n}\n```\n#### 6.3、颜色函数\n<font color=red>sass</font>提供了一些内置的颜色函数\n```css\nlighten(#cc3, 10%)　　  // #d6d65c\ndarken(#cc3, 10%) 　　　// #a3a329\ngrayscale(#cc3) 　　　　// #808080\ncomplement(#cc3) 　　　// #33c\n```\n\n### 七、sass高级用发\n#### 7.1、函数 function\n<font color=red>sass</font>允许用户编写自己的函数，以<font color=red>@function</font>开始\n```css\n// css编译前\n$fontSize: 10px;\n@function pxTorem($px) {\n    @return $px / $fontSize * 1rem;\n}\ndiv {\n    font-size: pxTorem(16px);\n}\n\n// css编译后\ndiv {\n    font-size: 1.6rem;\n}\n```\n\n#### 7.2、if条件语句\n<font color=red>@if</font>语句可以用来判断\n```css\n// sass样式\n$type: monster;\ndiv {\n    @if $type == ocean {\n        color: blue;\n    } @else if $type == matador {\n        color: red;\n    } @else if $type == monster {\n        color: green;\n    } @else {\n        color: black;\n    }\n}\n// css编译后样式\ndiv {\n    color: green;\n}\n```\n三目判断：语法为 <font color=red>if($condition, $if_true, $if_false)</font>。 三个参数分别表示： 条件，条件为真的值，条件为假的值\n```css\nif(true, 1px, 2px) => 1px\nif(false, 1px, 2px) => 2px\n```\n\n#### 7.3、循环语句\n<font color=red>for</font> 循环有两种形式，分别为：<font color=red>@for $var from <start> through <end></font> 和 <font color=red>@for $var from <start> to <end></font>。 <font color=red>$var </font>表示变量，<font color=red>start</font>表示开始值，end</font>表示结束值，两种形式的区别在于 <font color=red>through</font> 包括 <font color=red>end</font> 的值，<font color=red>to </font>不包括 <font color=red>end</font> 值。\n```css\n// sass样式\n@for $i from 1 to 4 {\n    .item-#{$i} {width: 2em * $i;}\n}\n// css编译后样式\n.item-1 {\n    width: 2em;\n}\n.item-2 {\n    width: 4em;\n}\n.item-3 {\n    width: 6em;\n}\n```\n<font color=red>while</font>循环\n```css\n// sass样式\n$i: 2;\n@while $i > 0 {\n    .item-#{$i} {width: 2em * $i;}\n    $i: $i - 1;\n}\n// css编译后样式\n.item-2 {\n  width: 4em;\n}\n.item-1 {\n  width: 2em;\n}\n```\n<font color=red>@each</font>循环：语法为<font color=red>@each $var in <list or map></font>。 其中<font color=red>$var</font>表示变量，而<font color=red>list</font>和<font color=red>map</font>表示数据类型，<font color=red>sass3.3.0</font>新加入多字段循环和<font color=red>map</font>数据循环\n\n单字段<font color=red> list </font>数据循环\n```css\n//sass 样式\n$animal-list: puma, sea-slug, egret;\n@each $animal in $animal-list {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n  }\n}\n//css 编译后样式\n.puma-icon {\n  background-image: url('/images/puma.png');\n}\n.sea-slug-icon {\n  background-image: url('/images/sea-slug.png');\n}\n.egret-icon {\n  background-image: url('/images/egret.png');\n}\n```\n多字段<font color=red>list</font>数据循环\n```css\n//sass 样式\n$animal-data: (puma, black, default),(sea-slug, blue, pointer);\n@each $animal, $color, $cursor in $animal-data {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n    border: 2px solid $color;\n    cursor: $cursor;\n  }\n}\n//css 编译后样式\n.puma-icon {\n  background-image: url('/images/puma.png');\n  border: 2px solid black;\n  cursor: default;\n}\n.sea-slug-icon {\n  background-image: url('/images/sea-slug.png');\n  border: 2px solid blue;\n  cursor: pointer;\n}\n```\n多字段 <font color=red>map</font> 数据循环\n```css\n//sass 样式\n$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);\n@each $header, $size in $headings {\n  #{$header} {\n    font-size: $size;\n  }\n}\n//css 编译后样式\nh1 {\n  font-size: 2em;\n}\nh2 {\n  font-size: 1.5em;\n}\nh3 {\n  font-size: 1.2em;\n}\n```\n\n### 八、compass用法\n前面介绍了Sass的用法。\n\nSass是一种\"CSS预处理器\"，可以让CSS的开发变得简单和可维护。但是，只有搭配Compass，它才能显出真正的威力。学会了Compass，你的CSS开发效率会上一个台阶。\n#### 1、compass是什么？\n简单说，Compass是Sass的工具库（toolkit）。\n\nSass本身只是一个编译器，Compass在它的基础上，封装了一系列有用的模块和模板，补充Sass的功能。它们之间的关系，有点像Javascript和jQuery关系。\n\n#### 2、安装\nCompass是用Ruby语言开发的，所以安装它之前，必须安装Ruby。\n\n假定你的机器（Linux或OS X）已经安装好Ruby，那么在命令行模式下键入：\n```\nsudo gem install compass\n```\n如果你用的是Windows系统，那么要省略前面的sudo。\n#### 3、项目初始化\n接下来，要创建一个你的Compass项目，假定它的名字叫做myproject，然后进入该目录，命令行键入：\n```\ncompass create myproject\ncd myproject\n```\n然后你会看到，里面有一个config.rb文件，这是你的项目的配置文件。还有两个子目录sass和stylesheets，前者存放Sass源文件，后者存放编译后的css文件。\n\n#### 4、编译\n```\ncompass compile\n```\n该命令在项目根目录下运行，会将sass子目录中的scss文件，编译成css文件，保存在stylesheets子目录中。\n\n默认状态下，编译出来的css文件带有大量的注释。但是，生产环境需要压缩后的css文件，这时要使用--output-style参数。\n```\ncompass compile --output-style compressed\n```\nCompass只编译发生变动的文件，如果你要重新编译未变动的文件，需要使用--force参数。\n```\ncompass compile --force\n```\n除了使用命令行参数，还可以在配置文件config.rb中指定编译模式。\n\n:expanded模式表示编译后保留原格式，其他值还包括:nested、:compact和:compressed。进入生产阶段后，就要改为:compressed模式。\n```\noutput_style = :expanded\noutput_style = :compressed\n```\n\n\n也可以通过指定environment的值（:production或者:development），智能判断编译模式。\n```\nenvironment = :development\noutput_style = (environment == :production) ? :compressed : :expanded\n```\ncompass还有自动编译命令\n```\ncompass watch\n```\n运行该命令后，只要scss文件发生变化，就会被自动编译成css文件。\n#### 5、Compass的模块\nCompass采用模块结构，不同模块提供不同的功能。目前，它内置五个模块：\n```\n* reset\n* css3\n* layout\n* typography\n* utilities\n```\n##### 5.1、reset模块\n通常，编写自己的样式之前，有必要重置浏览器的默认样式。\n```\n@import \"compass/reset\";\n```\n\n##### 5.2、css3模块\n 目前，该模块提供19种CSS3命令\n \n ```\n// 圆角（border-radius）的写法\n\n @import \"compass/css3\";\n.rounded {\n    @include border-radius(5px); //圆角\n    //如果只需要左上角为圆角\n    //@include border-corner-radius(top, left, 5px);\n}\n\n//编译后\n.rounded {\n    -moz-border-radius: 5px;\n    -webkit-border-radius: 5px;\n    -o-border-radius: 5px;\n    -ms-border-radius: 5px;\n    -khtml-border-radius: 5px;\n    border-radius: 5px;\n}\n ```\n ```\n // 透明（opacity）的写法为\n @import \"compass/css3\";\n#opacity {\n　@include opacity(0.5); \n}\n\n//编译后\n#opacity {\n    filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=0.5);\n　　opacity: 0.5;\n}\n ```\n ```\n // 行内区块（inline-block）的写法为\n@import \"compass/css3\";\n#inline-block {\n    @include inline-block;\n}\n\n//编译后\n#inline-block {\n　　display: -moz-inline-stack;\n　　display: inline-block;\n　　vertical-align: middle;\n　　*vertical-align: auto;\n　　zoom: 1;\n　　*display: inline;\n}\n ```\n##### 5.3、layout模块\n 该模块提供布局功能。\n \n比如，指定页面的footer部分总是出现在浏览器最底端：\n ```\n @import \"compass/layout\";\n#footer {\n    @include sticky-footer(54px);\n}\n```\n又比如，指定子元素占满父元素的空间：\n```\n@import \"compass/layout\";\n#stretch-full {\n　　@include stretch; \n}\n```\n##### 5.4、typography模块\n该模块提供版式功能。\n\n比如，指定链接颜色的mixin为：\n```\nlink-colors($normal, $hover, $active, $visited, $focus);\n\n//使用时写成\n @import \"compass/typography\";\na {\n    @include link-colors(#00c, #0cc, #c0c, #ccc, #cc0);\n}\n```\n##### 5.5、utilities模块\n该模块提供某些不属于其他模块的功能。\n\n比如，清除浮动：\n```\nimport \"compass/utilities/\";\n.clearfix {\n　　@include clearfix;\n}\n```\n```\n@import \"compass/utilities\";\ntable {\n    @include table-scaffolding;\n}\n\n//编译后\n\ntable th {\n    text-align: center;\n    font-weight: bold;\n}\ntable td,\ntable th {\n    padding: 2px;\n}\n\ntable td.numeric,\ntable th.numeric {\n    text-align: right;\n}\n```\n#### 6、Helper函数\n除了模块，Compass还提供一系列函数。\n\n有些函数非常有用，比如image-width()和image-height()返回图片的宽和高。\n\n再比如，inline-image()可以将图片转为data协议的数据。\n```\n@import \"compass\";\n.icon { background-image: inline-image(\"icon.png\");}\n\n//编译后\n.icon { background-image: url('data:image/png;base64,iBROR...QmCC');}\n```\n函数与mixin的主要区别是，不需要使用@include命令，可以直接调用。\n\n### 九、sass和less区别\n#### 1.编译环境不一样\n\nSass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。\n\n#### 2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。\n```\n//Less-作用域\n@color: #00c; /* 蓝色 */\n#header {\n  @color: #c00; /* red */\n  border: 1px solid @color; /* 红色边框 */\n}\n\n#footer {\n  border: 1px solid @color; /* 蓝色边框 */\n}\n\n//Less-作用域编译后\n#header{border:1px solid #cc0000;}\n#footer{border:1px solid #0000cc;}\n\n//scss-作用域\n$color: #00c; /* 蓝色 */\n\n#header {\n\n  $color: #c00; /* red */\n  border: 1px solid $color; /* 红色边框 */\n}\n\n#footer {\n  border: 1px solid $color; /* 蓝色边框 */\n}\n\n//Sass-作用域编译后\n\n#header{border:1px solid #c00}\n#footer{border:1px solid #c00}\n```\n我们可以看出来，less和scss中的变量会随着作用域的变化而不一样。\n#### 3.输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。\n输出样式的风格可以有四种选择，默认为nested\n```\nnested：//嵌套缩进的css代码\nexpanded：//展开的多行css代码\ncompact：//简洁格式的css代码\ncompressed：//压缩后的css代码\n```\n#### 4.Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。\n```\n/* Sample Sass “if” statement */\n\n@if lightness($color) > 30% {\n\n} @else {\n\n}\n\n/* Sample Sass “for” loop */\n\n@for $i from 1 to 10 {\n  .border-#{$i} {\n    border: #{$i}px solid blue;\n  }\n}\n```\n#### 5. 引用外部CSS文件\ncss引用的外部文件命名必须以_开头, 如下例所示:其中_test1.scss、_test2.scss、_test3.scss文件分别设置的h1 h2 h3。文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件.\n```\n// 源代码：\n@import \"_test1.scss\";\n@import \"_test2.scss\";\n@import \"_test3.scss\";\n\n// 编译后：\nh1 {\n  font-size: 17px;\n}\n \nh2 {\n  font-size: 17px;\n}\n \nh3 {\n  font-size: 17px;\n}\n```\nLess引用外部文件和css中的@import没什么差异。\n\nLess还有其他强大的功能，比如雪碧图等等...\n#### 6.Sass和Less的工具库不同\nSass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。\n\nLess有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。\n\n### 十、 总结\n不管是Sass，还是Less，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，Sass的功能比Less强大,基本可以说是一种真正的编程语言了，Less则相对清晰明了,易于上手,对编译环境要求比较宽松。考虑到编译Sass要安装Ruby,而Ruby官网在国内访问不了,个人在实际开发中更倾向于选择Less。\n最后还有个stylu，其接触的不多，它相对于前两种学习难度大点，其规范少如果想了解可以找些相关资料，这里就不多说了~","source":"_posts/2019-08-01-sass+compass.md","raw":"---\ntitle: sass+compass使用\ncomments: true\ndate: 2019-08-01 17:00:00\ntags:\n- sass\n- compass\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n![](https://img.fengjr.com/image/2019/07/31/14b7d54d9c92f52c211549ef418441de.png)\n\n## 一、什么是sass\n<font color=red>Sass</font> 是对<font color=red>CSS</font> 的扩展，让<font color=red> CSS </font>语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins</font>、导入等众多功能， 并且完全兼容 <font color=red>CSS</font> 语法。 <font color=red>Sass</font> 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， 特别是在搭配 <font color=red>Compass</font> 样式库一同使用时。\n## 二、sass语法\n\n<font color=red>Sass</font> 有两种语法。 第一种被称为<font color=red> SCSS (Sassy CSS)</font>，是一个 <font color=red>CSS3</font> 语法的扩充版本，这份参考资料使用的就是此语法。 也就是说，所有符合 <font color=red>CSS3</font> 语法的样式表也都是具有相同语法意义的 <font color=red>SCSS</font> 文件。 另外，<font color=red>SCSS</font> 理解大多数 <font color=red>CSS hacks</font> 以及浏览器专属语法，例如IE 古老的<font color=red> filter</font> 语法。 这种语种语法的样式表文件需要以 <font color=red>.scss</font> 扩展名。\n\n<font color=red>SCSS </font>是<font color=red> Sass 3</font> 引入新的语法，其语法完全兼容<font color=red> CSS3</font>，并且继承了 <font color=red>Sass</font> 的强大功能。也就是说，任何标准的<font color=red> CSS3</font> 样式表都是具有相同语义的有效的<font color=red> SCSS</font> 文件。另外，<font color=red>SCSS </font>还能识别大部分 <font color=red>CSS hacks</font>（一些 <font color=red>CSS </font>小技巧）和特定于浏览器的语法\n\n第二种比较老的语法成为缩排语法（或者就称为 \"<font color=red>Sass</font>\"）， 提供了一种更简洁的 <font color=red>CSS</font> 书写方式。 它不使用花括号，而是通过缩排的方式来表达选择符的嵌套层级，I 而且也不使用分号，而是用换行符来分隔属性。 很多人认为这种格式比 <font color=red>SCSS</font> 更容易阅读，书写也更快速。 缩排语法具有 <font color=red>Sass</font> 的所有特色功能， 虽然有些语法上稍有差异；使用此种语法的样式表文件需要以 <font color=red>.sass </font>作为扩展名。\n\n任一语法都可以导入另一种语法撰写的文件中。 只要使用 <font color=red>sass-convert</font> 命令行工具，就可以将一种语法转换为另一种语法：\n```css\n# 将 Sass 转换为 SCSS\n$ sass-convert style.sass style.scss\n\n# 将 SCSS 转换为 Sass\n$ sass-convert style.scss style.sass\n```\n## 三、sass安装及使用\n<font color=red>SASS</font>是<font color=red>Ruby</font>语言写的，但是两者的语法没有关系。不懂<font color=red>Ruby</font>，照样使用。只是必须先安装<font color=red>Ruby</font>，然后再安装<font color=red>SASS</font>。\n```css\ngem install sass\n```\n如果你使用的是 <font color=red>Windows</font>， 就需要先安装 <font color=red>Ruby</font>,因为<font color=red>sass</font>编译是基于<font color=red>Ruby</font>环境的。\n\n如果要在命令行中运行 <font color=red>Sass</font> ,只要输入\n```css\nsass input.scss output.css\n```\nSASS提供四个编译风格的选项：\n```\nnested：嵌套缩进的css代码，它是默认值。\n\nexpanded：没有缩进的、扩展的css代码。\n\ncompact：简洁格式的css代码。\n\ncompressed：压缩后的css代码。\n```\n```\nsass --style compressed test.sass test.css\n```\n你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。\n```\n// watch a file\nsass --watch input.scss:output.css\n\n// watch a directory\nsass --watch app/sass:public/stylesheets\n```\n### 1、变量声明\n```css\n//编译前\n$nav-color: #F90;\nnav {\n  $width: 100px;\n  width: $width;\n  color: $nav-color;\n}\n\n//编译后\nnav {\n  width: 100px;\n  color: #F90;\n}\n```\n在这段代码中，<font color=red>$nav-color</font>这个变量定义在了规则块外边，相当于全局变量，所以在这个样式表中都可以像<font color=red>nav</font>规则块那样引用它。<font color=red>$width</font>这个变量定义在了<font color=red>nav</font>的<font color=red>{ }</font>规则块内，相当于局部变量，所以它只能在<font color=red>nav</font>规则块内使用。这意味着是你可以在样式表的其他地方定义和使用<font color=red>$width</font>变量，不会对这里造成影响。其变量名用中线和下划线<font color=red>sass</font>不做强求且相互兼容。\n### 2、嵌套CSS 规则\n#### 2.1、 父选择器的标识符&\n\n```css\n//编译前\narticle a {\n  color: blue;\n  &:hover { color: red }\n}\n#content aside {\n  color: red;\n  body.ie & { color: green }\n}\n#content {\n    &-item {\n        font-size: #ff0;\n    }\n}\n//编译后\narticle a { color: blue }\narticle a:hover { color: red }\n#content aside {color: red};\nbody.ie #content aside { color: green }\n#content-item { font-size: #ff0; }\n```\n一般情况下，<font color=red>sass</font>在解开一个嵌套规则时就会把父选择器通过一个空格连接到子选择器的前边，这种在<font color=red>CSS</font>里边被称为后代选择器。但在有些情况下你却不会希望<font color=red>sass</font>使用这种后代选择器的方式生成这种连接，这时候我们会用到'<font color=red>&</font>'符号，它起到连接作用\n\n#### 2.2、群组选择器的嵌套\n\n```css\n//编译前\n.container {\n  h1, h2, h3 {margin-bottom: .8em}\n}\nnav, aside {\n  a {color: blue}\n}\n\n//编译后\n.container h1, .container h2, .container h3 { margin-bottom: .8em }\nnav a, aside a {color: blue}\n```\n处理这种群组选择器规则嵌套上的强大能力，正是<font color=red>sass</font>在减少重复敲写方面的贡献之一。尤其在当嵌套级别达到两层甚至三层以上时，与普通的<font color=red>css</font>编写方式相比，只写一遍群组选择器大大减少了工作量。\n\n有利必有弊，你需要特别注意群组选择器的规则嵌套生成的<font color=red>css</font>。虽然<font color=red>sass</font>让你的样式表看上去很小，但实际生成的<font color=red>css</font>却可能非常大，这会降低网站的速度。\n#### 2.3、子组合选择器和同层组合选择器：<font color=red> >、+</font>和<font color=red>~</font>\n```css\n//编译前\narticle {\n  ~ article { border-top: 1px dashed #ccc }\n  > section { background: #eee }\n  dl > {\n    dt { color: #333 }\n    dd { color: #555 }\n  }\n  nav + & { margin-top: 0 }\n}\n\n//编译后\narticle ~ article { border-top: 1px dashed #ccc }\narticle > footer { background: #eee }\narticle dl > dt { color: #333 }\narticle dl > dd { color: #555 }\nnav + article { margin-top: 0 }\n```\n你可以用子组合选择器<font color=red> > </font>选择一个元素的直接子元素。你可以用同层相邻组合选择器<font color=red> + </font>选择<font color=red>nav</font>元素后紧跟的<font color=red>article</font>元素。你还可以用同层全体组合选择器<font color=red> ~ </font>，选择所有跟在<font color=red>article</font>后的同层<font color=red>article</font>元素，不管它们之间隔了多少其他元素。\n\n在<font color=red>sass</font>中，不仅仅<font color=red>css</font>规则可以嵌套，对属性进行嵌套也可以减少很多重复性的工作。\n\n#### 2.4、嵌套属性\n在<font color=red>sass</font>中，除了<font color=red>CSS</font>选择器，属性也可以进行嵌套。\n```css\nnav {\n  border: {\n  style: solid;\n  width: 1px;\n  color: #ccc;\n  }\n}\n```\n嵌套属性的规则是这样的<font color=red>:</font>把属性名从中划线<font color=red> - </font>的地方断开，在根属性后边添加一个冒号<font color=red> : </font>，紧跟一个<font color=red>{ }</font>块，把子属性部分写在这个<font color=red>{ }</font>块中。就像<font color=red>css</font>选择器嵌套一样，<font color=red>sass</font>会把你的子属性一一解开，把根属性和子属性部分通过中划线<font color=red> - </font>连接起来，最后生成的效果与你手动一遍遍写的<font color=red>css</font>样式一样:\n```css\nnav {\n  border-style: solid;\n  border-width: 1px;\n  border-color: #ccc;\n}\n```\n对于属性的缩写形式，你甚至可以像下边这样来嵌套，指明例外规则:\n```css\n//编译前\nnav {\n  border: 1px solid #ccc {\n  left: 0px;\n  right: 0px;\n  }\n}\n\n//编译后\nnav {\n  border: 1px solid #ccc;\n  border-left: 0px;\n  border-right: 0px;\n}\n```\n属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。\n\n即便如此，随着你的样式表变得越来越大，这种写法也很难保持结构清晰。有时，处理这种大量样式的唯一方法就是把它们分拆到多个文件中。<font color=red>sass</font>通过对<font color=red>css</font>原有<font color=red>@import</font>规则的改进直接支持了这一特性。\n#### 2.5、计算功能\n<font color=red>sass</font> 允许使用算式。\n```css\n//编译前\ndiv {\n    padding: 2px * 4;\n    margin: (10px / 2);\n    height: 112px - 12px;\n    font-size: 12px + 4px;\n}\n\n//编译后\ndiv{\n    padding:8px;\n    margin:5px;\n    height:100px;\n    font-size:16px;\n}\n```\n###  三、导入SASS文件\n<font color=red>css</font>有一个特别不常用的特性，即<font color=red>@import</font>规则，它允许在一个<font color=red>css</font>文件中导入其他<font color=red>css</font>文件。然而，后果是只有执行到<font color=red>@import</font>时，浏览器才会去下载其他<font color=red>css</font>文件，这导致页面加载起来特别慢。\n\n<font color=red>sass</font>也有一个<font color=red>@import</font>规则，但不同的是，<font color=red>sass</font>的<font color=red>@import</font>规则在生成<font color=red>css</font>文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个<font color=red>css</font>文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器均可在导入文件中使用。\n\n使用<font color=red>sass</font>的<font color=red>@import</font>规则并不需要指明被导入文件的全名。你可以省略<font color=red>.sass</font>或<font color=red>.scss</font>文件后缀。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的<font color=red>sass</font>样式文件语法，在<font color=red>sass</font>和<font color=red>scss</font>语法之间随意切换。举例来说，<font color=red>@import\"sidebar\"</font>;这条命令将把<font color=red>sidebar.scss</font>文件中所有样式添加到当前样式表中。\n\n#### 3.2、默认变量值\n一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明:\n```css\n//编译前\n$link-color: blue;\n$link-color: red;\na {\n    color: $link-color;\n}\n\n//编译后\na {\n    color: red;\n}\n```\n在上边的例子中，超链接的<font color=red>color</font>会被设置为<font color=red>red</font>。这可能并不是你想要的结果，假如你写了一个可被他人通过<font color=red>@import</font>导入的<font color=red>sass</font>库文件，你可能希望导入者可以定制修改<font color=red>sass</font>库文件中的某些值。使用<font color=red>sass</font>的<font color=red>!default</font>标签可以实现这个目的。它很像<font color=red>css</font>属性中<font color=red>!important</font>标签的对立面，不同的是<font color=red>!default</font>用于变量，含义是:如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。\n```css\n//编译前\n$link-color: red !default;\n.a {\n    color: $link-color;\n}\n//编译后\n.a {\n    color: blue;\n}\n```\n在上例中，如果用户在导入你的<font color=red>sass</font>局部文件之前声明了一个<font color=red>$link-color</font>变量，那么你的局部文件中对<font color=red>color</font>赋<font color=red>red</font>的操作就无效。如果用户没有做这样的声明，则<font color=red>$link-color</font>将默认为<font color=red>red</font>。\n\n#### 3.3、嵌套导入\n跟原生的<font color=red>css</font>不同，<font color=red>sass</font>允许<font color=red>@import</font>命令写在<font color=red>css</font>规则内。这种导入方式下，生成对应的<font color=red>css</font>文件时，局部文件会被直接插入到<font color=red>css</font>规则内导入它的地方。举例说明，有一个名为<font color=red>_blue-theme.scss</font>的局部文件，内容如下:\n```css\naside {\n  background: blue;\n  color: white;\n}\n```\n然后把它导入到一个<font color=red>CSS</font>规则内，如下所示:\n```css\n.blue-theme {\n    @import \"blue-theme\"\n}\n\n//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。\n\n.blue-theme {\n  aside {\n    background: blue;\n    color: #fff;\n  }\n}\n```\n被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。\n\n有时，可用<font color=red>css</font>原生的<font color=red>@import</font>机制，在浏览器中下载必需的<font color=red>css</font>文件。<font color=red>sass</font>也提供了几种方法来达成这种需求。\n### 四、混合器\n如果你的整个网站中有几处小小的样式类似(例如一致的颜色和字体)，那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过<font color=red>sass的</font>混合器实现大段样式的重用。\n\n下边的这段<font color=red>sass</font>代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。\n```css\n@mixin rounded-corners {\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  border-radius: 5px;\n}\n```\n然后就可以在你的样式表中通过<font color=red>@include</font>来使用这个混合器，放在你希望的任何地方。<font color=red>@include</font>调用会把混合器中的所有样式提取出来放在<font color=red>@include</font>被调用的地方。如果像下边这样写:\n```css\nnotice {\n  background-color: green;\n  border: 2px solid #00aa00;\n  @include rounded-corners;\n}\n//编译后\n.notice {\n  background-color: green;\n  border: 2px solid #00aa00;\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  border-radius: 5px;\n}\n```\n这一节将介绍使用混合器来避免重复。通过使用参数，你可以使用混合器把你样式中的通用样式抽离出来，然后轻松地在其他地方重用。实际上，混合器太好用了，一不小心你可能会过度使用。大量的重用可能会导致生成的样式表过大，导致加载缓慢。所以，首先我们将讨论混合器的使用场景，避免滥用。\n#### 4.1、混合器中的CSS规则\n混合器中不仅可以包含属性，也可以包含<font color=red>css</font>规则，包含选择器和选择器中的属性，如下代码:\n```css\n@mixin no-bullets {\n  list-style: none;\n  li {\n    list-style-image: none;\n    list-style-type: none;\n    margin-left: 0px;\n  }\n}\n```\n当一个包含<font color=red>css</font>规则的混合器通过<font color=red>@include</font>包含在一个父规则中时，在混合器中的规则最终会生成父规则中的嵌套规则。举个例子，看看下边的<font color=red>sass</font>代码，这个例子中使用了<font color=red>no-bullets</font>这个混合器:\n```css\nul.plain {\n  color: #444;\n  @include no-bullets;\n}\n```\n<font color=red>sass</font>的<font color=red>@include</font>指令会将引入混合器的那行代码替换成混合器里边的内容。最终，上边的例子如下代码:\n```css\nul.plain {\n  color: #444;\n  list-style: none;\n}\nul.plain li {\n  list-style-image: none;\n  list-style-type: none;\n  margin-left: 0px;\n}\n```\n混合器中的规则甚至可以使用<font color=red> sass</font>的父选择器标识符<font color=red>&</font>。使用起来跟不用混合器时一样，<font color=red>sass</font>解开嵌套规则时，用父规则中的选择器替代<font color=red>&</font>。\n\n如果一个混合器只包含<font color=red>css</font>规则，不包含属性，那么这个混合器就可以在文档的顶部调用，写在所有的<font color=red>css</font>规则之外。如果你只是为自己写一些混合器，这并没有什么大的用途，但是当你使用一个类似于<font color=red>Compass</font>的库时，你会发现，这是提供样式的好方法，原因在于你可以选择是否使用这些样式。\n#### 4.2、给混合器传参\n混合器并不一定总得生成相同的样式。可以通过在<font color=red>@include</font>混合器时给混合器传参，来定制混合器生成的精确样式。当<font color=red>@include</font>混合器时，参数其实就是可以赋值给<font color=red>css</font>属性值的变量。如果你写过<font color=red>JavaScript</font>，这种方式跟<font color=red>JavaScript</font>的<font color=red>function</font>很像:\n```css\n@mixin link-colors($normal, $hover, $visited) {\n  color: $normal;\n  &:hover { color: $hover; }\n  &:visited { color: $visited; }\n}\n```\n当混合器被<font color=red>@include</font>时，你可以把它当作一个<font color=red>css</font>函数来传参。如果你像下边这样写:\n```css\na {\n  @include link-colors(blue, red, green);\n}\n\n//Sass最终生成的是:\n\na { color: blue; }\na:hover { color: red; }\na:visited { color: green; }\n```\n当你<font color=red>@include</font>混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，<font color=red>sass</font>允许通过语法<font color=red>$name: value</font>的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可:\n```css\na {\n    @include link-colors(\n      $normal: blue,\n      $visited: green,\n      $hover: red\n  );\n}\n```\n尽管给混合器加参数来实现定制很好，但是有时有些参数我们没有定制的需要，这时候也需要赋值一个变量就变成很痛苦的事情了。所以<font color=red>sass</font>允许混合器声明时给参数赋默认值。\n#### 4.3、默认参数值\n为了在<font color=red>@include</font>混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用<font color=red>$name: default-value</font>的声明形式，默认值可以是任何有效的<font color=red>css</font>属性值，甚至是其他参数的引用，如下代码:\n```css\n@mixin link-colors(\n    $normal,\n    $hover: $normal,\n    $visited: $normal\n  )\n{\n  color: $normal;\n  &:hover { color: $hover; }\n  &:visited { color: $visited; }\n}\n```\n如果像下边这样调用:<font color=red>@include link-colors(red) $hover</font>和<font color=red>$visited</font>也会被自动赋值为<font color=red>red</font>。\n\n混合器只是<font color=red>sass</font>样式重用特性中的一个。我们已经了解到混合器主要用于样式展示层的重用，如果你想重用语义化的类呢？这就涉及<font color=red>sass</font>的另一个重要的重用特性:选择器继承。\n### 五、使用选择器继承来精简CSS\n使用<font color=red>sass</font>的时候，一个减少重复的主要特性就是选择器继承。选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过<font color=red>@extend</font>语法实现，如下代码:\n```css\n//通过选择器继承继承样式\n.error {\n  border: 1px red;\n  background-color: #fdd;\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n```\n任何<font color=red>css</font>规则都可以继承其他规则，几乎任何<font color=red>css</font>规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个<font color=red>html</font>元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对<font color=red>html</font>元素添加的所有样式都会被继承。\n\n### 六、sass扩展及更新\n#### 6.1、使用占位符选择器 % \n从<font color=red>sass3.2.0</font>后，就可以定义占位选择器<font color=red>%</font>，这个的优势在于，不调用不会有多余的<font color=red>css</font>文件\n```css\n// sass样式\n%h1 {\n    font-size:20px;\n}\ndiv {\n    @extend %h1;\n    color:red;\n}\n// css编译后样式\ndiv {\n    font-size:20px;\n    color:red;\n}\n```\n#### 6.2、@content\n在<font color=red>sass3.2.0</font>中引入， 可以用来解决<font color=red>css3</font>中 <font color=red>@meidia</font> 或者<font color=red> @keyframes</font> 带来的问题。它可以使<font color=red>@mixin</font>接受一整块样式，接收的样式从<font color=red>@content</font>开始\n```css\n//sass 样式              \n@mixin max-screen($res){\n  @media only screen and ( max-width: $res )\n  {\n    @content;\n  }\n}\n \n@include max-screen(480px) {\n  body { color: red }\n}\n \n//css 编译后样式\n@media only screen and (max-width: 480px) {\n  body { color: red }\n}\n```\n使用<font color=red>@content</font>解决<font color=red>@keyframes</font>关键帧的浏览器前缀问题\n```css\n// 初始化变量\n$browser: null;\n// 设置关键帧\n@mixin keyframes($name) {\n    @-webkit-keyframes #{$name} {\n        $browser: '-webkit-'; @content;\n    }\n    @-moz-keyframes #{$name} {\n        $browser: '-moz-'; @content;\n    }\n    @-o-keyframes #{$name} {\n        $browser: '-o-'; @content;\n    }\n    @keyframes #{$name} {\n        $browser: ''; @content;\n    }\n}\n \n// 引入\n@include keyframes(scale) {\n    100% {\n        #{$browser}transform: scale(0.8);\n    }\n}\n \n// css编译后\n@-webkit-keyframes scale {\n    -webkit-transform: scale(0.8);\n}\n@-moz-keyframes scale  {\n   -moz-transform: scale(0.8);\n}\n@-o-keyframes scale  {\n    -o-transform: scale(0.8);\n}\n@keyframes scale  {\n    transform: scale(0.8);\n}\n```\n#### 6.3、颜色函数\n<font color=red>sass</font>提供了一些内置的颜色函数\n```css\nlighten(#cc3, 10%)　　  // #d6d65c\ndarken(#cc3, 10%) 　　　// #a3a329\ngrayscale(#cc3) 　　　　// #808080\ncomplement(#cc3) 　　　// #33c\n```\n\n### 七、sass高级用发\n#### 7.1、函数 function\n<font color=red>sass</font>允许用户编写自己的函数，以<font color=red>@function</font>开始\n```css\n// css编译前\n$fontSize: 10px;\n@function pxTorem($px) {\n    @return $px / $fontSize * 1rem;\n}\ndiv {\n    font-size: pxTorem(16px);\n}\n\n// css编译后\ndiv {\n    font-size: 1.6rem;\n}\n```\n\n#### 7.2、if条件语句\n<font color=red>@if</font>语句可以用来判断\n```css\n// sass样式\n$type: monster;\ndiv {\n    @if $type == ocean {\n        color: blue;\n    } @else if $type == matador {\n        color: red;\n    } @else if $type == monster {\n        color: green;\n    } @else {\n        color: black;\n    }\n}\n// css编译后样式\ndiv {\n    color: green;\n}\n```\n三目判断：语法为 <font color=red>if($condition, $if_true, $if_false)</font>。 三个参数分别表示： 条件，条件为真的值，条件为假的值\n```css\nif(true, 1px, 2px) => 1px\nif(false, 1px, 2px) => 2px\n```\n\n#### 7.3、循环语句\n<font color=red>for</font> 循环有两种形式，分别为：<font color=red>@for $var from <start> through <end></font> 和 <font color=red>@for $var from <start> to <end></font>。 <font color=red>$var </font>表示变量，<font color=red>start</font>表示开始值，end</font>表示结束值，两种形式的区别在于 <font color=red>through</font> 包括 <font color=red>end</font> 的值，<font color=red>to </font>不包括 <font color=red>end</font> 值。\n```css\n// sass样式\n@for $i from 1 to 4 {\n    .item-#{$i} {width: 2em * $i;}\n}\n// css编译后样式\n.item-1 {\n    width: 2em;\n}\n.item-2 {\n    width: 4em;\n}\n.item-3 {\n    width: 6em;\n}\n```\n<font color=red>while</font>循环\n```css\n// sass样式\n$i: 2;\n@while $i > 0 {\n    .item-#{$i} {width: 2em * $i;}\n    $i: $i - 1;\n}\n// css编译后样式\n.item-2 {\n  width: 4em;\n}\n.item-1 {\n  width: 2em;\n}\n```\n<font color=red>@each</font>循环：语法为<font color=red>@each $var in <list or map></font>。 其中<font color=red>$var</font>表示变量，而<font color=red>list</font>和<font color=red>map</font>表示数据类型，<font color=red>sass3.3.0</font>新加入多字段循环和<font color=red>map</font>数据循环\n\n单字段<font color=red> list </font>数据循环\n```css\n//sass 样式\n$animal-list: puma, sea-slug, egret;\n@each $animal in $animal-list {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n  }\n}\n//css 编译后样式\n.puma-icon {\n  background-image: url('/images/puma.png');\n}\n.sea-slug-icon {\n  background-image: url('/images/sea-slug.png');\n}\n.egret-icon {\n  background-image: url('/images/egret.png');\n}\n```\n多字段<font color=red>list</font>数据循环\n```css\n//sass 样式\n$animal-data: (puma, black, default),(sea-slug, blue, pointer);\n@each $animal, $color, $cursor in $animal-data {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n    border: 2px solid $color;\n    cursor: $cursor;\n  }\n}\n//css 编译后样式\n.puma-icon {\n  background-image: url('/images/puma.png');\n  border: 2px solid black;\n  cursor: default;\n}\n.sea-slug-icon {\n  background-image: url('/images/sea-slug.png');\n  border: 2px solid blue;\n  cursor: pointer;\n}\n```\n多字段 <font color=red>map</font> 数据循环\n```css\n//sass 样式\n$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);\n@each $header, $size in $headings {\n  #{$header} {\n    font-size: $size;\n  }\n}\n//css 编译后样式\nh1 {\n  font-size: 2em;\n}\nh2 {\n  font-size: 1.5em;\n}\nh3 {\n  font-size: 1.2em;\n}\n```\n\n### 八、compass用法\n前面介绍了Sass的用法。\n\nSass是一种\"CSS预处理器\"，可以让CSS的开发变得简单和可维护。但是，只有搭配Compass，它才能显出真正的威力。学会了Compass，你的CSS开发效率会上一个台阶。\n#### 1、compass是什么？\n简单说，Compass是Sass的工具库（toolkit）。\n\nSass本身只是一个编译器，Compass在它的基础上，封装了一系列有用的模块和模板，补充Sass的功能。它们之间的关系，有点像Javascript和jQuery关系。\n\n#### 2、安装\nCompass是用Ruby语言开发的，所以安装它之前，必须安装Ruby。\n\n假定你的机器（Linux或OS X）已经安装好Ruby，那么在命令行模式下键入：\n```\nsudo gem install compass\n```\n如果你用的是Windows系统，那么要省略前面的sudo。\n#### 3、项目初始化\n接下来，要创建一个你的Compass项目，假定它的名字叫做myproject，然后进入该目录，命令行键入：\n```\ncompass create myproject\ncd myproject\n```\n然后你会看到，里面有一个config.rb文件，这是你的项目的配置文件。还有两个子目录sass和stylesheets，前者存放Sass源文件，后者存放编译后的css文件。\n\n#### 4、编译\n```\ncompass compile\n```\n该命令在项目根目录下运行，会将sass子目录中的scss文件，编译成css文件，保存在stylesheets子目录中。\n\n默认状态下，编译出来的css文件带有大量的注释。但是，生产环境需要压缩后的css文件，这时要使用--output-style参数。\n```\ncompass compile --output-style compressed\n```\nCompass只编译发生变动的文件，如果你要重新编译未变动的文件，需要使用--force参数。\n```\ncompass compile --force\n```\n除了使用命令行参数，还可以在配置文件config.rb中指定编译模式。\n\n:expanded模式表示编译后保留原格式，其他值还包括:nested、:compact和:compressed。进入生产阶段后，就要改为:compressed模式。\n```\noutput_style = :expanded\noutput_style = :compressed\n```\n\n\n也可以通过指定environment的值（:production或者:development），智能判断编译模式。\n```\nenvironment = :development\noutput_style = (environment == :production) ? :compressed : :expanded\n```\ncompass还有自动编译命令\n```\ncompass watch\n```\n运行该命令后，只要scss文件发生变化，就会被自动编译成css文件。\n#### 5、Compass的模块\nCompass采用模块结构，不同模块提供不同的功能。目前，它内置五个模块：\n```\n* reset\n* css3\n* layout\n* typography\n* utilities\n```\n##### 5.1、reset模块\n通常，编写自己的样式之前，有必要重置浏览器的默认样式。\n```\n@import \"compass/reset\";\n```\n\n##### 5.2、css3模块\n 目前，该模块提供19种CSS3命令\n \n ```\n// 圆角（border-radius）的写法\n\n @import \"compass/css3\";\n.rounded {\n    @include border-radius(5px); //圆角\n    //如果只需要左上角为圆角\n    //@include border-corner-radius(top, left, 5px);\n}\n\n//编译后\n.rounded {\n    -moz-border-radius: 5px;\n    -webkit-border-radius: 5px;\n    -o-border-radius: 5px;\n    -ms-border-radius: 5px;\n    -khtml-border-radius: 5px;\n    border-radius: 5px;\n}\n ```\n ```\n // 透明（opacity）的写法为\n @import \"compass/css3\";\n#opacity {\n　@include opacity(0.5); \n}\n\n//编译后\n#opacity {\n    filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=0.5);\n　　opacity: 0.5;\n}\n ```\n ```\n // 行内区块（inline-block）的写法为\n@import \"compass/css3\";\n#inline-block {\n    @include inline-block;\n}\n\n//编译后\n#inline-block {\n　　display: -moz-inline-stack;\n　　display: inline-block;\n　　vertical-align: middle;\n　　*vertical-align: auto;\n　　zoom: 1;\n　　*display: inline;\n}\n ```\n##### 5.3、layout模块\n 该模块提供布局功能。\n \n比如，指定页面的footer部分总是出现在浏览器最底端：\n ```\n @import \"compass/layout\";\n#footer {\n    @include sticky-footer(54px);\n}\n```\n又比如，指定子元素占满父元素的空间：\n```\n@import \"compass/layout\";\n#stretch-full {\n　　@include stretch; \n}\n```\n##### 5.4、typography模块\n该模块提供版式功能。\n\n比如，指定链接颜色的mixin为：\n```\nlink-colors($normal, $hover, $active, $visited, $focus);\n\n//使用时写成\n @import \"compass/typography\";\na {\n    @include link-colors(#00c, #0cc, #c0c, #ccc, #cc0);\n}\n```\n##### 5.5、utilities模块\n该模块提供某些不属于其他模块的功能。\n\n比如，清除浮动：\n```\nimport \"compass/utilities/\";\n.clearfix {\n　　@include clearfix;\n}\n```\n```\n@import \"compass/utilities\";\ntable {\n    @include table-scaffolding;\n}\n\n//编译后\n\ntable th {\n    text-align: center;\n    font-weight: bold;\n}\ntable td,\ntable th {\n    padding: 2px;\n}\n\ntable td.numeric,\ntable th.numeric {\n    text-align: right;\n}\n```\n#### 6、Helper函数\n除了模块，Compass还提供一系列函数。\n\n有些函数非常有用，比如image-width()和image-height()返回图片的宽和高。\n\n再比如，inline-image()可以将图片转为data协议的数据。\n```\n@import \"compass\";\n.icon { background-image: inline-image(\"icon.png\");}\n\n//编译后\n.icon { background-image: url('data:image/png;base64,iBROR...QmCC');}\n```\n函数与mixin的主要区别是，不需要使用@include命令，可以直接调用。\n\n### 九、sass和less区别\n#### 1.编译环境不一样\n\nSass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。\n\n#### 2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。\n```\n//Less-作用域\n@color: #00c; /* 蓝色 */\n#header {\n  @color: #c00; /* red */\n  border: 1px solid @color; /* 红色边框 */\n}\n\n#footer {\n  border: 1px solid @color; /* 蓝色边框 */\n}\n\n//Less-作用域编译后\n#header{border:1px solid #cc0000;}\n#footer{border:1px solid #0000cc;}\n\n//scss-作用域\n$color: #00c; /* 蓝色 */\n\n#header {\n\n  $color: #c00; /* red */\n  border: 1px solid $color; /* 红色边框 */\n}\n\n#footer {\n  border: 1px solid $color; /* 蓝色边框 */\n}\n\n//Sass-作用域编译后\n\n#header{border:1px solid #c00}\n#footer{border:1px solid #c00}\n```\n我们可以看出来，less和scss中的变量会随着作用域的变化而不一样。\n#### 3.输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。\n输出样式的风格可以有四种选择，默认为nested\n```\nnested：//嵌套缩进的css代码\nexpanded：//展开的多行css代码\ncompact：//简洁格式的css代码\ncompressed：//压缩后的css代码\n```\n#### 4.Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。\n```\n/* Sample Sass “if” statement */\n\n@if lightness($color) > 30% {\n\n} @else {\n\n}\n\n/* Sample Sass “for” loop */\n\n@for $i from 1 to 10 {\n  .border-#{$i} {\n    border: #{$i}px solid blue;\n  }\n}\n```\n#### 5. 引用外部CSS文件\ncss引用的外部文件命名必须以_开头, 如下例所示:其中_test1.scss、_test2.scss、_test3.scss文件分别设置的h1 h2 h3。文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件.\n```\n// 源代码：\n@import \"_test1.scss\";\n@import \"_test2.scss\";\n@import \"_test3.scss\";\n\n// 编译后：\nh1 {\n  font-size: 17px;\n}\n \nh2 {\n  font-size: 17px;\n}\n \nh3 {\n  font-size: 17px;\n}\n```\nLess引用外部文件和css中的@import没什么差异。\n\nLess还有其他强大的功能，比如雪碧图等等...\n#### 6.Sass和Less的工具库不同\nSass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。\n\nLess有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。\n\n### 十、 总结\n不管是Sass，还是Less，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，Sass的功能比Less强大,基本可以说是一种真正的编程语言了，Less则相对清晰明了,易于上手,对编译环境要求比较宽松。考虑到编译Sass要安装Ruby,而Ruby官网在国内访问不了,个人在实际开发中更倾向于选择Less。\n最后还有个stylu，其接触的不多，它相对于前两种学习难度大点，其规范少如果想了解可以找些相关资料，这里就不多说了~","slug":"sass+compass","published":1,"updated":"2020-06-10T06:01:53.290Z","_id":"cjypnrl860000ryq5u8w4tbwa","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/07/31/14b7d54d9c92f52c211549ef418441de.png\" alt></p>\n<h2 id=\"一、什么是sass\"><a href=\"#一、什么是sass\" class=\"headerlink\" title=\"一、什么是sass\"></a>一、什么是sass</h2><p><font color=\"red\">Sass</font> 是对<font color=\"red\">CSS</font> 的扩展，让<font color=\"red\"> CSS </font>语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins、导入等众多功能， 并且完全兼容 <font color=\"red\">CSS</font> 语法。 <font color=\"red\">Sass</font> 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， 特别是在搭配 <font color=\"red\">Compass</font> 样式库一同使用时。</p>\n<h2 id=\"二、sass语法\"><a href=\"#二、sass语法\" class=\"headerlink\" title=\"二、sass语法\"></a>二、sass语法</h2><p><font color=\"red\">Sass</font> 有两种语法。 第一种被称为<font color=\"red\"> SCSS (Sassy CSS)</font>，是一个 <font color=\"red\">CSS3</font> 语法的扩充版本，这份参考资料使用的就是此语法。 也就是说，所有符合 <font color=\"red\">CSS3</font> 语法的样式表也都是具有相同语法意义的 <font color=\"red\">SCSS</font> 文件。 另外，<font color=\"red\">SCSS</font> 理解大多数 <font color=\"red\">CSS hacks</font> 以及浏览器专属语法，例如IE 古老的<font color=\"red\"> filter</font> 语法。 这种语种语法的样式表文件需要以 <font color=\"red\">.scss</font> 扩展名。</p>\n<p><font color=\"red\">SCSS </font>是<font color=\"red\"> Sass 3</font> 引入新的语法，其语法完全兼容<font color=\"red\"> CSS3</font>，并且继承了 <font color=\"red\">Sass</font> 的强大功能。也就是说，任何标准的<font color=\"red\"> CSS3</font> 样式表都是具有相同语义的有效的<font color=\"red\"> SCSS</font> 文件。另外，<font color=\"red\">SCSS </font>还能识别大部分 <font color=\"red\">CSS hacks</font>（一些 <font color=\"red\">CSS </font>小技巧）和特定于浏览器的语法</p>\n<p>第二种比较老的语法成为缩排语法（或者就称为 “<font color=\"red\">Sass</font>“）， 提供了一种更简洁的 <font color=\"red\">CSS</font> 书写方式。 它不使用花括号，而是通过缩排的方式来表达选择符的嵌套层级，I 而且也不使用分号，而是用换行符来分隔属性。 很多人认为这种格式比 <font color=\"red\">SCSS</font> 更容易阅读，书写也更快速。 缩排语法具有 <font color=\"red\">Sass</font> 的所有特色功能， 虽然有些语法上稍有差异；使用此种语法的样式表文件需要以 <font color=\"red\">.sass </font>作为扩展名。</p>\n<p>任一语法都可以导入另一种语法撰写的文件中。 只要使用 <font color=\"red\">sass-convert</font> 命令行工具，就可以将一种语法转换为另一种语法：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 将 <span class=\"selector-tag\">Sass</span> 转换为 <span class=\"selector-tag\">SCSS</span></span><br><span class=\"line\">$ sass-convert style.sass style.scss</span><br><span class=\"line\"></span><br><span class=\"line\"># 将 <span class=\"selector-tag\">SCSS</span> 转换为 <span class=\"selector-tag\">Sass</span></span><br><span class=\"line\">$ sass-convert style.scss style.sass</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三、sass安装及使用\"><a href=\"#三、sass安装及使用\" class=\"headerlink\" title=\"三、sass安装及使用\"></a>三、sass安装及使用</h2><p><font color=\"red\">SASS</font>是<font color=\"red\">Ruby</font>语言写的，但是两者的语法没有关系。不懂<font color=\"red\">Ruby</font>，照样使用。只是必须先安装<font color=\"red\">Ruby</font>，然后再安装<font color=\"red\">SASS</font>。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">gem</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">sass</span></span><br></pre></td></tr></table></figure></p>\n<p>如果你使用的是 <font color=\"red\">Windows</font>， 就需要先安装 <font color=\"red\">Ruby</font>,因为<font color=\"red\">sass</font>编译是基于<font color=\"red\">Ruby</font>环境的。</p>\n<p>如果要在命令行中运行 <font color=\"red\">Sass</font> ,只要输入<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">sass</span> <span class=\"selector-tag\">input</span><span class=\"selector-class\">.scss</span> <span class=\"selector-tag\">output</span><span class=\"selector-class\">.css</span></span><br></pre></td></tr></table></figure></p>\n<p>SASS提供四个编译风格的选项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nested：嵌套缩进的css代码，它是默认值。</span><br><span class=\"line\"></span><br><span class=\"line\">expanded：没有缩进的、扩展的css代码。</span><br><span class=\"line\"></span><br><span class=\"line\">compact：简洁格式的css代码。</span><br><span class=\"line\"></span><br><span class=\"line\">compressed：压缩后的css代码。</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass --style compressed test.sass test.css</span><br></pre></td></tr></table></figure>\n<p>你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// watch a file</span><br><span class=\"line\">sass --watch input.scss:output.css</span><br><span class=\"line\"></span><br><span class=\"line\">// watch a directory</span><br><span class=\"line\">sass --watch app/sass:public/stylesheets</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1、变量声明\"><a href=\"#1、变量声明\" class=\"headerlink\" title=\"1、变量声明\"></a>1、变量声明</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\">$nav-color: #F90;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  $width: 100px;</span><br><span class=\"line\">  width: $width;</span><br><span class=\"line\">  color: $nav-color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，<font color=\"red\">$nav-color</font>这个变量定义在了规则块外边，相当于全局变量，所以在这个样式表中都可以像<font color=\"red\">nav</font>规则块那样引用它。<font color=\"red\">$width</font>这个变量定义在了<font color=\"red\">nav</font>的<font color=\"red\">{ }</font>规则块内，相当于局部变量，所以它只能在<font color=\"red\">nav</font>规则块内使用。这意味着是你可以在样式表的其他地方定义和使用<font color=\"red\">$width</font>变量，不会对这里造成影响。其变量名用中线和下划线<font color=\"red\">sass</font>不做强求且相互兼容。</p>\n<h3 id=\"2、嵌套CSS-规则\"><a href=\"#2、嵌套CSS-规则\" class=\"headerlink\" title=\"2、嵌套CSS 规则\"></a>2、嵌套CSS 规则</h3><h4 id=\"2-1、-父选择器的标识符-amp\"><a href=\"#2-1、-父选择器的标识符-amp\" class=\"headerlink\" title=\"2.1、 父选择器的标识符&amp;\"></a>2.1、 父选择器的标识符&amp;</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">  &amp;:hover &#123; color: red &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  body.ie &amp; &#123; color: green &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> &#123;</span><br><span class=\"line\">    &amp;-item &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">font-size</span>: <span class=\"selector-id\">#ff0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">color</span>: blue &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123;<span class=\"attribute\">color</span>: red&#125;;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.ie</span> <span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">color</span>: green &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content-item</span> &#123; <span class=\"attribute\">font-size</span>: <span class=\"number\">#ff0</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>一般情况下，<font color=\"red\">sass</font>在解开一个嵌套规则时就会把父选择器通过一个空格连接到子选择器的前边，这种在<font color=\"red\">CSS</font>里边被称为后代选择器。但在有些情况下你却不会希望<font color=\"red\">sass</font>使用这种后代选择器的方式生成这种连接，这时候我们会用到’<font color=\"red\">&amp;</font>‘符号，它起到连接作用</p>\n<h4 id=\"2-2、群组选择器的嵌套\"><a href=\"#2-2、群组选择器的嵌套\" class=\"headerlink\" title=\"2.2、群组选择器的嵌套\"></a>2.2、群组选择器的嵌套</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  h1, h2, h3 &#123;margin-bottom: .8em&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span>, <span class=\"selector-tag\">aside</span> &#123;</span><br><span class=\"line\">  a &#123;color: blue&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-tag\">h1</span>, <span class=\"selector-class\">.container</span> <span class=\"selector-tag\">h2</span>, <span class=\"selector-class\">.container</span> <span class=\"selector-tag\">h3</span> &#123; <span class=\"attribute\">margin-bottom</span>: .<span class=\"number\">8em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">a</span>, <span class=\"selector-tag\">aside</span> <span class=\"selector-tag\">a</span> &#123;<span class=\"attribute\">color</span>: blue&#125;</span><br></pre></td></tr></table></figure>\n<p>处理这种群组选择器规则嵌套上的强大能力，正是<font color=\"red\">sass</font>在减少重复敲写方面的贡献之一。尤其在当嵌套级别达到两层甚至三层以上时，与普通的<font color=\"red\">css</font>编写方式相比，只写一遍群组选择器大大减少了工作量。</p>\n<p>有利必有弊，你需要特别注意群组选择器的规则嵌套生成的<font color=\"red\">css</font>。虽然<font color=\"red\">sass</font>让你的样式表看上去很小，但实际生成的<font color=\"red\">css</font>却可能非常大，这会降低网站的速度。</p>\n<h4 id=\"2-3、子组合选择器和同层组合选择器：-gt-、-和\"><a href=\"#2-3、子组合选择器和同层组合选择器：-gt-、-和\" class=\"headerlink\" title=\"2.3、子组合选择器和同层组合选择器： &gt;、+和~\"></a>2.3、子组合选择器和同层组合选择器：<font color=\"red\"> &gt;、+</font>和<font color=\"red\">~</font></h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> &#123;</span><br><span class=\"line\">  ~ article &#123; border-top: 1px dashed #ccc &#125;</span><br><span class=\"line\">  &gt; <span class=\"selector-tag\">section</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span> &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">dl</span> &gt; &#123;</span><br><span class=\"line\">    dt &#123; color: #333 &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">dd</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#555</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">nav</span> + &amp; &#123; <span class=\"attribute\">margin-top</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> ~ <span class=\"selector-tag\">article</span> &#123; <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> dashed <span class=\"number\">#ccc</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> &gt; <span class=\"selector-tag\">footer</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">dl</span> &gt; <span class=\"selector-tag\">dt</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">dl</span> &gt; <span class=\"selector-tag\">dd</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#555</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> + <span class=\"selector-tag\">article</span> &#123; <span class=\"attribute\">margin-top</span>: <span class=\"number\">0</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>你可以用子组合选择器<font color=\"red\"> &gt; </font>选择一个元素的直接子元素。你可以用同层相邻组合选择器<font color=\"red\"> + </font>选择<font color=\"red\">nav</font>元素后紧跟的<font color=\"red\">article</font>元素。你还可以用同层全体组合选择器<font color=\"red\"> ~ </font>，选择所有跟在<font color=\"red\">article</font>后的同层<font color=\"red\">article</font>元素，不管它们之间隔了多少其他元素。</p>\n<p>在<font color=\"red\">sass</font>中，不仅仅<font color=\"red\">css</font>规则可以嵌套，对属性进行嵌套也可以减少很多重复性的工作。</p>\n<h4 id=\"2-4、嵌套属性\"><a href=\"#2-4、嵌套属性\" class=\"headerlink\" title=\"2.4、嵌套属性\"></a>2.4、嵌套属性</h4><p>在<font color=\"red\">sass</font>中，除了<font color=\"red\">CSS</font>选择器，属性也可以进行嵌套。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: &#123;</span><br><span class=\"line\">  style: solid;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>嵌套属性的规则是这样的<font color=\"red\">:</font>把属性名从中划线<font color=\"red\"> - </font>的地方断开，在根属性后边添加一个冒号<font color=\"red\"> : </font>，紧跟一个<font color=\"red\">{ }</font>块，把子属性部分写在这个<font color=\"red\">{ }</font>块中。就像<font color=\"red\">css</font>选择器嵌套一样，<font color=\"red\">sass</font>会把你的子属性一一解开，把根属性和子属性部分通过中划线<font color=\"red\"> - </font>连接起来，最后生成的效果与你手动一遍遍写的<font color=\"red\">css</font>样式一样:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于属性的缩写形式，你甚至可以像下边这样来嵌套，指明例外规则:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span> &#123;</span><br><span class=\"line\">  left: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。</p>\n<p>即便如此，随着你的样式表变得越来越大，这种写法也很难保持结构清晰。有时，处理这种大量样式的唯一方法就是把它们分拆到多个文件中。<font color=\"red\">sass</font>通过对<font color=\"red\">css</font>原有<font color=\"red\">@import</font>规则的改进直接支持了这一特性。</p>\n<h4 id=\"2-5、计算功能\"><a href=\"#2-5、计算功能\" class=\"headerlink\" title=\"2.5、计算功能\"></a>2.5、计算功能</h4><p><font color=\"red\">sass</font> 允许使用算式。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">2px</span> * <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: (<span class=\"number\">10px</span> / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">112px</span> - <span class=\"number\">12px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">12px</span> + <span class=\"number\">4px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">8px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三、导入SASS文件\"><a href=\"#三、导入SASS文件\" class=\"headerlink\" title=\"三、导入SASS文件\"></a>三、导入SASS文件</h3><p><font color=\"red\">css</font>有一个特别不常用的特性，即<font color=\"red\">@import</font>规则，它允许在一个<font color=\"red\">css</font>文件中导入其他<font color=\"red\">css</font>文件。然而，后果是只有执行到<font color=\"red\">@import</font>时，浏览器才会去下载其他<font color=\"red\">css</font>文件，这导致页面加载起来特别慢。</p>\n<p><font color=\"red\">sass</font>也有一个<font color=\"red\">@import</font>规则，但不同的是，<font color=\"red\">sass</font>的<font color=\"red\">@import</font>规则在生成<font color=\"red\">css</font>文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个<font color=\"red\">css</font>文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器均可在导入文件中使用。</p>\n<p>使用<font color=\"red\">sass</font>的<font color=\"red\">@import</font>规则并不需要指明被导入文件的全名。你可以省略<font color=\"red\">.sass</font>或<font color=\"red\">.scss</font>文件后缀。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的<font color=\"red\">sass</font>样式文件语法，在<font color=\"red\">sass</font>和<font color=\"red\">scss</font>语法之间随意切换。举例来说，<font color=\"red\">@import”sidebar”</font>;这条命令将把<font color=\"red\">sidebar.scss</font>文件中所有样式添加到当前样式表中。</p>\n<h4 id=\"3-2、默认变量值\"><a href=\"#3-2、默认变量值\" class=\"headerlink\" title=\"3.2、默认变量值\"></a>3.2、默认变量值</h4><p>一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\">$link-color: blue;</span><br><span class=\"line\">$link-color: red;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: $link-color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上边的例子中，超链接的<font color=\"red\">color</font>会被设置为<font color=\"red\">red</font>。这可能并不是你想要的结果，假如你写了一个可被他人通过<font color=\"red\">@import</font>导入的<font color=\"red\">sass</font>库文件，你可能希望导入者可以定制修改<font color=\"red\">sass</font>库文件中的某些值。使用<font color=\"red\">sass</font>的<font color=\"red\">!default</font>标签可以实现这个目的。它很像<font color=\"red\">css</font>属性中<font color=\"red\">!important</font>标签的对立面，不同的是<font color=\"red\">!default</font>用于变量，含义是:如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\">$link-color: red !default;</span><br><span class=\"line\"><span class=\"selector-class\">.a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: $link-color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-class\">.a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上例中，如果用户在导入你的<font color=\"red\">sass</font>局部文件之前声明了一个<font color=\"red\">$link-color</font>变量，那么你的局部文件中对<font color=\"red\">color</font>赋<font color=\"red\">red</font>的操作就无效。如果用户没有做这样的声明，则<font color=\"red\">$link-color</font>将默认为<font color=\"red\">red</font>。</p>\n<h4 id=\"3-3、嵌套导入\"><a href=\"#3-3、嵌套导入\" class=\"headerlink\" title=\"3.3、嵌套导入\"></a>3.3、嵌套导入</h4><p>跟原生的<font color=\"red\">css</font>不同，<font color=\"red\">sass</font>允许<font color=\"red\">@import</font>命令写在<font color=\"red\">css</font>规则内。这种导入方式下，生成对应的<font color=\"red\">css</font>文件时，局部文件会被直接插入到<font color=\"red\">css</font>规则内导入它的地方。举例说明，有一个名为<font color=\"red\">_blue-theme.scss</font>的局部文件，内容如下:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">aside</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后把它导入到一个<font color=\"red\">CSS</font>规则内，如下所示:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.blue-theme</span> &#123;</span><br><span class=\"line\">    @import \"blue-theme\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.blue-theme</span> &#123;</span><br><span class=\"line\">  aside &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">blue</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">color</span>: <span class=\"selector-id\">#fff</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。</p>\n<p>有时，可用<font color=\"red\">css</font>原生的<font color=\"red\">@import</font>机制，在浏览器中下载必需的<font color=\"red\">css</font>文件。<font color=\"red\">sass</font>也提供了几种方法来达成这种需求。</p>\n<h3 id=\"四、混合器\"><a href=\"#四、混合器\" class=\"headerlink\" title=\"四、混合器\"></a>四、混合器</h3><p>如果你的整个网站中有几处小小的样式类似(例如一致的颜色和字体)，那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过<font color=\"red\">sass的</font>混合器实现大段样式的重用。</p>\n<p>下边的这段<font color=\"red\">sass</font>代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> rounded-corners &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">-moz-border-radius</span>: 5<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">-webkit-border-radius</span>: 5<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">border-radius</span>: 5<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后就可以在你的样式表中通过<font color=\"red\">@include</font>来使用这个混合器，放在你希望的任何地方。<font color=\"red\">@include</font>调用会把混合器中的所有样式提取出来放在<font color=\"red\">@include</font>被调用的地方。如果像下边这样写:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">notice</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#00aa00</span>;</span><br><span class=\"line\">  @include rounded-corners;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-class\">.notice</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#00aa00</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-moz-border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一节将介绍使用混合器来避免重复。通过使用参数，你可以使用混合器把你样式中的通用样式抽离出来，然后轻松地在其他地方重用。实际上，混合器太好用了，一不小心你可能会过度使用。大量的重用可能会导致生成的样式表过大，导致加载缓慢。所以，首先我们将讨论混合器的使用场景，避免滥用。</p>\n<h4 id=\"4-1、混合器中的CSS规则\"><a href=\"#4-1、混合器中的CSS规则\" class=\"headerlink\" title=\"4.1、混合器中的CSS规则\"></a>4.1、混合器中的CSS规则</h4><p>混合器中不仅可以包含属性，也可以包含<font color=\"red\">css</font>规则，包含选择器和选择器中的属性，如下代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> no-bullets &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">list-style</span>: <span class=\"selector-tag\">none</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">list-style-image</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">list-style-type</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当一个包含<font color=\"red\">css</font>规则的混合器通过<font color=\"red\">@include</font>包含在一个父规则中时，在混合器中的规则最终会生成父规则中的嵌套规则。举个例子，看看下边的<font color=\"red\">sass</font>代码，这个例子中使用了<font color=\"red\">no-bullets</font>这个混合器:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span><span class=\"selector-class\">.plain</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#444</span>;</span><br><span class=\"line\">  @include no-bullets;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><font color=\"red\">sass</font>的<font color=\"red\">@include</font>指令会将引入混合器的那行代码替换成混合器里边的内容。最终，上边的例子如下代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span><span class=\"selector-class\">.plain</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#444</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ul</span><span class=\"selector-class\">.plain</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">list-style-image</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">list-style-type</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>混合器中的规则甚至可以使用<font color=\"red\"> sass</font>的父选择器标识符<font color=\"red\">&amp;</font>。使用起来跟不用混合器时一样，<font color=\"red\">sass</font>解开嵌套规则时，用父规则中的选择器替代<font color=\"red\">&amp;</font>。</p>\n<p>如果一个混合器只包含<font color=\"red\">css</font>规则，不包含属性，那么这个混合器就可以在文档的顶部调用，写在所有的<font color=\"red\">css</font>规则之外。如果你只是为自己写一些混合器，这并没有什么大的用途，但是当你使用一个类似于<font color=\"red\">Compass</font>的库时，你会发现，这是提供样式的好方法，原因在于你可以选择是否使用这些样式。</p>\n<h4 id=\"4-2、给混合器传参\"><a href=\"#4-2、给混合器传参\" class=\"headerlink\" title=\"4.2、给混合器传参\"></a>4.2、给混合器传参</h4><p>混合器并不一定总得生成相同的样式。可以通过在<font color=\"red\">@include</font>混合器时给混合器传参，来定制混合器生成的精确样式。当<font color=\"red\">@include</font>混合器时，参数其实就是可以赋值给<font color=\"red\">css</font>属性值的变量。如果你写过<font color=\"red\">JavaScript</font>，这种方式跟<font color=\"red\">JavaScript</font>的<font color=\"red\">function</font>很像:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> link-colors($normal, $hover, $visited) &#123;</span><br><span class=\"line\">  color: $normal;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: $hover; &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:visited</span> &#123; <span class=\"attribute\">color</span>: $visited; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当混合器被<font color=\"red\">@include</font>时，你可以把它当作一个<font color=\"red\">css</font>函数来传参。如果你像下边这样写:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  @include link-colors(blue, red, green);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Sass最终生成的是:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">color</span>: blue; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: red; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:visited</span> &#123; <span class=\"attribute\">color</span>: green; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当你<font color=\"red\">@include</font>混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，<font color=\"red\">sass</font>允许通过语法<font color=\"red\">$name: value</font>的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    @include link-colors(</span><br><span class=\"line\">      $normal: blue,</span><br><span class=\"line\">      $visited: green,</span><br><span class=\"line\">      $hover: red</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>尽管给混合器加参数来实现定制很好，但是有时有些参数我们没有定制的需要，这时候也需要赋值一个变量就变成很痛苦的事情了。所以<font color=\"red\">sass</font>允许混合器声明时给参数赋默认值。</p>\n<h4 id=\"4-3、默认参数值\"><a href=\"#4-3、默认参数值\" class=\"headerlink\" title=\"4.3、默认参数值\"></a>4.3、默认参数值</h4><p>为了在<font color=\"red\">@include</font>混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用<font color=\"red\">$name: default-value</font>的声明形式，默认值可以是任何有效的<font color=\"red\">css</font>属性值，甚至是其他参数的引用，如下代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> link-colors(</span><br><span class=\"line\">    $normal,</span><br><span class=\"line\">    $hover: $normal,</span><br><span class=\"line\">    $visited: $normal</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  color: $normal;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: $hover; &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:visited</span> &#123; <span class=\"attribute\">color</span>: $visited; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果像下边这样调用:<font color=\"red\">@include link-colors(red) $hover</font>和<font color=\"red\">$visited</font>也会被自动赋值为<font color=\"red\">red</font>。</p>\n<p>混合器只是<font color=\"red\">sass</font>样式重用特性中的一个。我们已经了解到混合器主要用于样式展示层的重用，如果你想重用语义化的类呢？这就涉及<font color=\"red\">sass</font>的另一个重要的重用特性:选择器继承。</p>\n<h3 id=\"五、使用选择器继承来精简CSS\"><a href=\"#五、使用选择器继承来精简CSS\" class=\"headerlink\" title=\"五、使用选择器继承来精简CSS\"></a>五、使用选择器继承来精简CSS</h3><p>使用<font color=\"red\">sass</font>的时候，一个减少重复的主要特性就是选择器继承。选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过<font color=\"red\">@extend</font>语法实现，如下代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通过选择器继承继承样式</span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> red;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fdd</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.seriousError</span> &#123;</span><br><span class=\"line\">  @extend .error;</span><br><span class=\"line\">  <span class=\"selector-tag\">border-width</span>: 3<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>任何<font color=\"red\">css</font>规则都可以继承其他规则，几乎任何<font color=\"red\">css</font>规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个<font color=\"red\">html</font>元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对<font color=\"red\">html</font>元素添加的所有样式都会被继承。</p>\n<h3 id=\"六、sass扩展及更新\"><a href=\"#六、sass扩展及更新\" class=\"headerlink\" title=\"六、sass扩展及更新\"></a>六、sass扩展及更新</h3><h4 id=\"6-1、使用占位符选择器\"><a href=\"#6-1、使用占位符选择器\" class=\"headerlink\" title=\"6.1、使用占位符选择器 %\"></a>6.1、使用占位符选择器 %</h4><p>从<font color=\"red\">sass3.2.0</font>后，就可以定义占位选择器<font color=\"red\">%</font>，这个的优势在于，不调用不会有多余的<font color=\"red\">css</font>文件<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sass样式</span><br><span class=\"line\">%<span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    @extend %h1;</span><br><span class=\"line\">    <span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:red</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// css编译后样式</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-2、-content\"><a href=\"#6-2、-content\" class=\"headerlink\" title=\"6.2、@content\"></a>6.2、@content</h4><p>在<font color=\"red\">sass3.2.0</font>中引入， 可以用来解决<font color=\"red\">css3</font>中 <font color=\"red\">@meidia</font> 或者<font color=\"red\"> @keyframes</font> 带来的问题。它可以使<font color=\"red\">@mixin</font>接受一整块样式，接收的样式从<font color=\"red\">@content</font>开始<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sass 样式              </span><br><span class=\"line\">@<span class=\"keyword\">mixin</span> max-screen($res)&#123;</span><br><span class=\"line\">  @<span class=\"keyword\">media</span> only screen and ( max-width: $res )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">content</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">@<span class=\"keyword\">include</span> max-screen(<span class=\"number\">480px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">body</span> &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">//css 编译后样式</span><br><span class=\"line\">@<span class=\"keyword\">media</span> only screen and (max-width: <span class=\"number\">480px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">body</span> &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用<font color=\"red\">@content</font>解决<font color=\"red\">@keyframes</font>关键帧的浏览器前缀问题<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 初始化变量</span><br><span class=\"line\">$browser: null;</span><br><span class=\"line\">// 设置关键帧</span><br><span class=\"line\">@<span class=\"keyword\">mixin</span> keyframes($name) &#123;</span><br><span class=\"line\">    @-webkit-keyframes #&#123;$name&#125; &#123;</span><br><span class=\"line\">        $browser: '-webkit-'; @content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @-moz-keyframes #&#123;$name&#125; &#123;</span><br><span class=\"line\">        $browser: '-moz-'; @content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @-o-keyframes #&#123;$name&#125; &#123;</span><br><span class=\"line\">        $browser: '-o-'; @content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @keyframes #&#123;$name&#125; &#123;</span><br><span class=\"line\">        $browser: ''; @content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// 引入</span><br><span class=\"line\">@<span class=\"keyword\">include</span> keyframes(scale) &#123;</span><br><span class=\"line\">    100% &#123;</span><br><span class=\"line\">        #&#123;$browser&#125;transform: scale(0.8);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// css编译后</span><br><span class=\"line\">@-<span class=\"keyword\">webkit</span>-<span class=\"keyword\">keyframes</span> scale &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">-webkit-transform</span>: <span class=\"selector-tag\">scale</span>(0<span class=\"selector-class\">.8</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@-<span class=\"keyword\">moz</span>-<span class=\"keyword\">keyframes</span> scale  &#123;</span><br><span class=\"line\">   <span class=\"selector-tag\">-moz-transform</span>: <span class=\"selector-tag\">scale</span>(0<span class=\"selector-class\">.8</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@-<span class=\"keyword\">o</span>-<span class=\"keyword\">keyframes</span> scale  &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">-o-transform</span>: <span class=\"selector-tag\">scale</span>(0<span class=\"selector-class\">.8</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> scale  &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scale</span>(0<span class=\"selector-class\">.8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-3、颜色函数\"><a href=\"#6-3、颜色函数\" class=\"headerlink\" title=\"6.3、颜色函数\"></a>6.3、颜色函数</h4><p><font color=\"red\">sass</font>提供了一些内置的颜色函数<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lighten(#cc3, 10%)　　  // #d6d65c</span><br><span class=\"line\">darken(#cc3, 10%) 　　　// #a3a329</span><br><span class=\"line\">grayscale(#cc3) 　　　　// #808080</span><br><span class=\"line\">complement(#cc3) 　　　// #33c</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"七、sass高级用发\"><a href=\"#七、sass高级用发\" class=\"headerlink\" title=\"七、sass高级用发\"></a>七、sass高级用发</h3><h4 id=\"7-1、函数-function\"><a href=\"#7-1、函数-function\" class=\"headerlink\" title=\"7.1、函数 function\"></a>7.1、函数 function</h4><p><font color=\"red\">sass</font>允许用户编写自己的函数，以<font color=\"red\">@function</font>开始<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// css编译前</span><br><span class=\"line\">$fontSize: 10px;</span><br><span class=\"line\">@<span class=\"keyword\">function</span> pxTorem($px) &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">return</span> $px / $fontSize * <span class=\"number\">1rem</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"built_in\">pxTorem</span>(16px);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// css编译后</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">1.6rem</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-2、if条件语句\"><a href=\"#7-2、if条件语句\" class=\"headerlink\" title=\"7.2、if条件语句\"></a>7.2、if条件语句</h4><p><font color=\"red\">@if</font>语句可以用来判断<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sass样式</span><br><span class=\"line\">$type: monster;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    @if $type == ocean &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">blue</span>;</span><br><span class=\"line\">    &#125; @<span class=\"keyword\">else</span> if $type == matador &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">red</span>;</span><br><span class=\"line\">    &#125; @<span class=\"keyword\">else</span> if $type == monster &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">green</span>;</span><br><span class=\"line\">    &#125; @<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">black</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// css编译后样式</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: green;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>三目判断：语法为 <font color=\"red\">if($condition, $if_true, $if_false)</font>。 三个参数分别表示： 条件，条件为真的值，条件为假的值<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true, 1px, 2px) =&gt; 1px</span><br><span class=\"line\">if(false, 1px, 2px) =&gt; 2px</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-3、循环语句\"><a href=\"#7-3、循环语句\" class=\"headerlink\" title=\"7.3、循环语句\"></a>7.3、循环语句</h4><p><font color=\"red\">for</font> 循环有两种形式，分别为：<font color=\"red\">@for $var from <start> through <end></end></start></font> 和 <font color=\"red\">@for $var from <start> to <end></end></start></font>。 <font color=\"red\">$var </font>表示变量，<font color=\"red\">start</font>表示开始值，end表示结束值，两种形式的区别在于 <font color=\"red\">through</font> 包括 <font color=\"red\">end</font> 的值，<font color=\"red\">to </font>不包括 <font color=\"red\">end</font> 值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sass样式</span><br><span class=\"line\">@<span class=\"keyword\">for</span> $i from <span class=\"number\">1</span> to <span class=\"number\">4</span> &#123;</span><br><span class=\"line\">    .item-#&#123;$i&#125; &#123;width: 2em * $i;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// css编译后样式</span><br><span class=\"line\"><span class=\"selector-class\">.item-1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">2em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item-2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">4em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item-3</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">6em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><font color=\"red\">while</font>循环<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sass样式</span><br><span class=\"line\">$i: 2;</span><br><span class=\"line\">@<span class=\"keyword\">while</span> $i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    .item-#&#123;$i&#125; &#123;width: 2em * $i;&#125;</span><br><span class=\"line\">    $i: $i - 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// css编译后样式</span><br><span class=\"line\"><span class=\"selector-class\">.item-2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">4em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item-1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">2em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><font color=\"red\">@each</font>循环：语法为<font color=\"red\">@each $var in <list or map></list></font>。 其中<font color=\"red\">$var</font>表示变量，而<font color=\"red\">list</font>和<font color=\"red\">map</font>表示数据类型，<font color=\"red\">sass3.3.0</font>新加入多字段循环和<font color=\"red\">map</font>数据循环</p>\n<p>单字段<font color=\"red\"> list </font>数据循环<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sass 样式</span><br><span class=\"line\">$animal-list: puma, sea-slug, egret;</span><br><span class=\"line\">@<span class=\"keyword\">each</span> $animal in $animal-list &#123;</span><br><span class=\"line\">  .#&#123;$animal&#125;-icon &#123;</span><br><span class=\"line\">    background-image: url('/images/#&#123;$animal&#125;.png');</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//css 编译后样式</span><br><span class=\"line\"><span class=\"selector-class\">.puma-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/puma.png'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.sea-slug-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/sea-slug.png'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.egret-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/egret.png'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>多字段<font color=\"red\">list</font>数据循环<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sass 样式</span><br><span class=\"line\">$animal-data: (puma, black, default),(sea-slug, blue, pointer);</span><br><span class=\"line\">@<span class=\"keyword\">each</span> $animal, $color, $cursor in $animal-data &#123;</span><br><span class=\"line\">  .#&#123;$animal&#125;-icon &#123;</span><br><span class=\"line\">    background-image: url('/images/#&#123;$animal&#125;.png');</span><br><span class=\"line\">    border: 2px solid $color;</span><br><span class=\"line\">    cursor: $cursor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//css 编译后样式</span><br><span class=\"line\"><span class=\"selector-class\">.puma-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/puma.png'</span>);</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: default;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.sea-slug-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/sea-slug.png'</span>);</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid blue;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>多字段 <font color=\"red\">map</font> 数据循环<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sass 样式</span><br><span class=\"line\">$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);</span><br><span class=\"line\">@<span class=\"keyword\">each</span> $header, $size in $headings &#123;</span><br><span class=\"line\">  #&#123;$header&#125; &#123;</span><br><span class=\"line\">    font-size: $size;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//css 编译后样式</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"八、compass用法\"><a href=\"#八、compass用法\" class=\"headerlink\" title=\"八、compass用法\"></a>八、compass用法</h3><p>前面介绍了Sass的用法。</p>\n<p>Sass是一种”CSS预处理器”，可以让CSS的开发变得简单和可维护。但是，只有搭配Compass，它才能显出真正的威力。学会了Compass，你的CSS开发效率会上一个台阶。</p>\n<h4 id=\"1、compass是什么？\"><a href=\"#1、compass是什么？\" class=\"headerlink\" title=\"1、compass是什么？\"></a>1、compass是什么？</h4><p>简单说，Compass是Sass的工具库（toolkit）。</p>\n<p>Sass本身只是一个编译器，Compass在它的基础上，封装了一系列有用的模块和模板，补充Sass的功能。它们之间的关系，有点像Javascript和jQuery关系。</p>\n<h4 id=\"2、安装\"><a href=\"#2、安装\" class=\"headerlink\" title=\"2、安装\"></a>2、安装</h4><p>Compass是用Ruby语言开发的，所以安装它之前，必须安装Ruby。</p>\n<p>假定你的机器（Linux或OS X）已经安装好Ruby，那么在命令行模式下键入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install compass</span><br></pre></td></tr></table></figure></p>\n<p>如果你用的是Windows系统，那么要省略前面的sudo。</p>\n<h4 id=\"3、项目初始化\"><a href=\"#3、项目初始化\" class=\"headerlink\" title=\"3、项目初始化\"></a>3、项目初始化</h4><p>接下来，要创建一个你的Compass项目，假定它的名字叫做myproject，然后进入该目录，命令行键入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass create myproject</span><br><span class=\"line\">cd myproject</span><br></pre></td></tr></table></figure></p>\n<p>然后你会看到，里面有一个config.rb文件，这是你的项目的配置文件。还有两个子目录sass和stylesheets，前者存放Sass源文件，后者存放编译后的css文件。</p>\n<h4 id=\"4、编译\"><a href=\"#4、编译\" class=\"headerlink\" title=\"4、编译\"></a>4、编译</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass compile</span><br></pre></td></tr></table></figure>\n<p>该命令在项目根目录下运行，会将sass子目录中的scss文件，编译成css文件，保存在stylesheets子目录中。</p>\n<p>默认状态下，编译出来的css文件带有大量的注释。但是，生产环境需要压缩后的css文件，这时要使用–output-style参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass compile --output-style compressed</span><br></pre></td></tr></table></figure></p>\n<p>Compass只编译发生变动的文件，如果你要重新编译未变动的文件，需要使用–force参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass compile --force</span><br></pre></td></tr></table></figure></p>\n<p>除了使用命令行参数，还可以在配置文件config.rb中指定编译模式。</p>\n<p>:expanded模式表示编译后保留原格式，其他值还包括:nested、:compact和:compressed。进入生产阶段后，就要改为:compressed模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output_style = :expanded</span><br><span class=\"line\">output_style = :compressed</span><br></pre></td></tr></table></figure></p>\n<p>也可以通过指定environment的值（:production或者:development），智能判断编译模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">environment = :development</span><br><span class=\"line\">output_style = (environment == :production) ? :compressed : :expanded</span><br></pre></td></tr></table></figure></p>\n<p>compass还有自动编译命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass watch</span><br></pre></td></tr></table></figure></p>\n<p>运行该命令后，只要scss文件发生变化，就会被自动编译成css文件。</p>\n<h4 id=\"5、Compass的模块\"><a href=\"#5、Compass的模块\" class=\"headerlink\" title=\"5、Compass的模块\"></a>5、Compass的模块</h4><p>Compass采用模块结构，不同模块提供不同的功能。目前，它内置五个模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* reset</span><br><span class=\"line\">* css3</span><br><span class=\"line\">* layout</span><br><span class=\"line\">* typography</span><br><span class=\"line\">* utilities</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5-1、reset模块\"><a href=\"#5-1、reset模块\" class=\"headerlink\" title=\"5.1、reset模块\"></a>5.1、reset模块</h5><p>通常，编写自己的样式之前，有必要重置浏览器的默认样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;compass/reset&quot;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5-2、css3模块\"><a href=\"#5-2、css3模块\" class=\"headerlink\" title=\"5.2、css3模块\"></a>5.2、css3模块</h5><p> 目前，该模块提供19种CSS3命令</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 圆角（border-radius）的写法</span><br><span class=\"line\"></span><br><span class=\"line\"> @import &quot;compass/css3&quot;;</span><br><span class=\"line\">.rounded &#123;</span><br><span class=\"line\">    @include border-radius(5px); //圆角</span><br><span class=\"line\">    //如果只需要左上角为圆角</span><br><span class=\"line\">    //@include border-corner-radius(top, left, 5px);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">.rounded &#123;</span><br><span class=\"line\">    -moz-border-radius: 5px;</span><br><span class=\"line\">    -webkit-border-radius: 5px;</span><br><span class=\"line\">    -o-border-radius: 5px;</span><br><span class=\"line\">    -ms-border-radius: 5px;</span><br><span class=\"line\">    -khtml-border-radius: 5px;</span><br><span class=\"line\">    border-radius: 5px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 透明（opacity）的写法为</span><br><span class=\"line\"> @import &quot;compass/css3&quot;;</span><br><span class=\"line\">#opacity &#123;</span><br><span class=\"line\">　@include opacity(0.5); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">#opacity &#123;</span><br><span class=\"line\">    filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=0.5);</span><br><span class=\"line\">　　opacity: 0.5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 行内区块（inline-block）的写法为</span><br><span class=\"line\">@import &quot;compass/css3&quot;;</span><br><span class=\"line\">#inline-block &#123;</span><br><span class=\"line\">    @include inline-block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">#inline-block &#123;</span><br><span class=\"line\">　　display: -moz-inline-stack;</span><br><span class=\"line\">　　display: inline-block;</span><br><span class=\"line\">　　vertical-align: middle;</span><br><span class=\"line\">　　*vertical-align: auto;</span><br><span class=\"line\">　　zoom: 1;</span><br><span class=\"line\">　　*display: inline;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"5-3、layout模块\"><a href=\"#5-3、layout模块\" class=\"headerlink\" title=\"5.3、layout模块\"></a>5.3、layout模块</h5><p> 该模块提供布局功能。</p>\n<p>比如，指定页面的footer部分总是出现在浏览器最底端：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @import &quot;compass/layout&quot;;</span><br><span class=\"line\">#footer &#123;</span><br><span class=\"line\">    @include sticky-footer(54px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>又比如，指定子元素占满父元素的空间：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;compass/layout&quot;;</span><br><span class=\"line\">#stretch-full &#123;</span><br><span class=\"line\">　　@include stretch; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5-4、typography模块\"><a href=\"#5-4、typography模块\" class=\"headerlink\" title=\"5.4、typography模块\"></a>5.4、typography模块</h5><p>该模块提供版式功能。</p>\n<p>比如，指定链接颜色的mixin为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">link-colors($normal, $hover, $active, $visited, $focus);</span><br><span class=\"line\"></span><br><span class=\"line\">//使用时写成</span><br><span class=\"line\"> @import &quot;compass/typography&quot;;</span><br><span class=\"line\">a &#123;</span><br><span class=\"line\">    @include link-colors(#00c, #0cc, #c0c, #ccc, #cc0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5-5、utilities模块\"><a href=\"#5-5、utilities模块\" class=\"headerlink\" title=\"5.5、utilities模块\"></a>5.5、utilities模块</h5><p>该模块提供某些不属于其他模块的功能。</p>\n<p>比如，清除浮动：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;compass/utilities/&quot;;</span><br><span class=\"line\">.clearfix &#123;</span><br><span class=\"line\">　　@include clearfix;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;compass/utilities&quot;;</span><br><span class=\"line\">table &#123;</span><br><span class=\"line\">    @include table-scaffolding;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"></span><br><span class=\"line\">table th &#123;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">    font-weight: bold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">table td,</span><br><span class=\"line\">table th &#123;</span><br><span class=\"line\">    padding: 2px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">table td.numeric,</span><br><span class=\"line\">table th.numeric &#123;</span><br><span class=\"line\">    text-align: right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6、Helper函数\"><a href=\"#6、Helper函数\" class=\"headerlink\" title=\"6、Helper函数\"></a>6、Helper函数</h4><p>除了模块，Compass还提供一系列函数。</p>\n<p>有些函数非常有用，比如image-width()和image-height()返回图片的宽和高。</p>\n<p>再比如，inline-image()可以将图片转为data协议的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;compass&quot;;</span><br><span class=\"line\">.icon &#123; background-image: inline-image(&quot;icon.png&quot;);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">.icon &#123; background-image: url(&apos;data:image/png;base64,iBROR...QmCC&apos;);&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数与mixin的主要区别是，不需要使用@include命令，可以直接调用。</p>\n<h3 id=\"九、sass和less区别\"><a href=\"#九、sass和less区别\" class=\"headerlink\" title=\"九、sass和less区别\"></a>九、sass和less区别</h3><h4 id=\"1-编译环境不一样\"><a href=\"#1-编译环境不一样\" class=\"headerlink\" title=\"1.编译环境不一样\"></a>1.编译环境不一样</h4><p>Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。</p>\n<h4 id=\"2-变量符不一样，Less是-，而Scss是-，而且变量的作用域也不一样。\"><a href=\"#2-变量符不一样，Less是-，而Scss是-，而且变量的作用域也不一样。\" class=\"headerlink\" title=\"2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。\"></a>2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Less-作用域</span><br><span class=\"line\">@color: #00c; /* 蓝色 */</span><br><span class=\"line\">#header &#123;</span><br><span class=\"line\">  @color: #c00; /* red */</span><br><span class=\"line\">  border: 1px solid @color; /* 红色边框 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#footer &#123;</span><br><span class=\"line\">  border: 1px solid @color; /* 蓝色边框 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Less-作用域编译后</span><br><span class=\"line\">#header&#123;border:1px solid #cc0000;&#125;</span><br><span class=\"line\">#footer&#123;border:1px solid #0000cc;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//scss-作用域</span><br><span class=\"line\">$color: #00c; /* 蓝色 */</span><br><span class=\"line\"></span><br><span class=\"line\">#header &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  $color: #c00; /* red */</span><br><span class=\"line\">  border: 1px solid $color; /* 红色边框 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#footer &#123;</span><br><span class=\"line\">  border: 1px solid $color; /* 蓝色边框 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Sass-作用域编译后</span><br><span class=\"line\"></span><br><span class=\"line\">#header&#123;border:1px solid #c00&#125;</span><br><span class=\"line\">#footer&#123;border:1px solid #c00&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看出来，less和scss中的变量会随着作用域的变化而不一样。</p>\n<h4 id=\"3-输出设置，Less没有输出设置，Sass提供4中输出选项：nested-compact-compressed-和-expanded。\"><a href=\"#3-输出设置，Less没有输出设置，Sass提供4中输出选项：nested-compact-compressed-和-expanded。\" class=\"headerlink\" title=\"3.输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。\"></a>3.输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。</h4><p>输出样式的风格可以有四种选择，默认为nested<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nested：//嵌套缩进的css代码</span><br><span class=\"line\">expanded：//展开的多行css代码</span><br><span class=\"line\">compact：//简洁格式的css代码</span><br><span class=\"line\">compressed：//压缩后的css代码</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-Sass支持条件语句，可以使用if-else-for-循环等等。而Less不支持。\"><a href=\"#4-Sass支持条件语句，可以使用if-else-for-循环等等。而Less不支持。\" class=\"headerlink\" title=\"4.Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。\"></a>4.Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Sample Sass “if” statement */</span><br><span class=\"line\"></span><br><span class=\"line\">@if lightness($color) &gt; 30% &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; @else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Sample Sass “for” loop */</span><br><span class=\"line\"></span><br><span class=\"line\">@for $i from 1 to 10 &#123;</span><br><span class=\"line\">  .border-#&#123;$i&#125; &#123;</span><br><span class=\"line\">    border: #&#123;$i&#125;px solid blue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-引用外部CSS文件\"><a href=\"#5-引用外部CSS文件\" class=\"headerlink\" title=\"5. 引用外部CSS文件\"></a>5. 引用外部CSS文件</h4><p>css引用的外部文件命名必须以_开头, 如下例所示:其中_test1.scss、_test2.scss、<em>test3.scss文件分别设置的h1 h2 h3。文件名如果以下划线</em>开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源代码：</span><br><span class=\"line\">@import &quot;_test1.scss&quot;;</span><br><span class=\"line\">@import &quot;_test2.scss&quot;;</span><br><span class=\"line\">@import &quot;_test3.scss&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 编译后：</span><br><span class=\"line\">h1 &#123;</span><br><span class=\"line\">  font-size: 17px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">h2 &#123;</span><br><span class=\"line\">  font-size: 17px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">h3 &#123;</span><br><span class=\"line\">  font-size: 17px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Less引用外部文件和css中的@import没什么差异。</p>\n<p>Less还有其他强大的功能，比如雪碧图等等…</p>\n<h4 id=\"6-Sass和Less的工具库不同\"><a href=\"#6-Sass和Less的工具库不同\" class=\"headerlink\" title=\"6.Sass和Less的工具库不同\"></a>6.Sass和Less的工具库不同</h4><p>Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。</p>\n<p>Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。</p>\n<h3 id=\"十、-总结\"><a href=\"#十、-总结\" class=\"headerlink\" title=\"十、 总结\"></a>十、 总结</h3><p>不管是Sass，还是Less，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，Sass的功能比Less强大,基本可以说是一种真正的编程语言了，Less则相对清晰明了,易于上手,对编译环境要求比较宽松。考虑到编译Sass要安装Ruby,而Ruby官网在国内访问不了,个人在实际开发中更倾向于选择Less。<br>最后还有个stylu，其接触的不多，它相对于前两种学习难度大点，其规范少如果想了解可以找些相关资料，这里就不多说了~</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/07/31/14b7d54d9c92f52c211549ef418441de.png\" alt></p>\n<h2 id=\"一、什么是sass\"><a href=\"#一、什么是sass\" class=\"headerlink\" title=\"一、什么是sass\"></a>一、什么是sass</h2><p><font color=\"red\">Sass</font> 是对<font color=\"red\">CSS</font> 的扩展，让<font color=\"red\"> CSS </font>语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins、导入等众多功能， 并且完全兼容 <font color=\"red\">CSS</font> 语法。 <font color=\"red\">Sass</font> 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， 特别是在搭配 <font color=\"red\">Compass</font> 样式库一同使用时。</p>\n<h2 id=\"二、sass语法\"><a href=\"#二、sass语法\" class=\"headerlink\" title=\"二、sass语法\"></a>二、sass语法</h2><p><font color=\"red\">Sass</font> 有两种语法。 第一种被称为<font color=\"red\"> SCSS (Sassy CSS)</font>，是一个 <font color=\"red\">CSS3</font> 语法的扩充版本，这份参考资料使用的就是此语法。 也就是说，所有符合 <font color=\"red\">CSS3</font> 语法的样式表也都是具有相同语法意义的 <font color=\"red\">SCSS</font> 文件。 另外，<font color=\"red\">SCSS</font> 理解大多数 <font color=\"red\">CSS hacks</font> 以及浏览器专属语法，例如IE 古老的<font color=\"red\"> filter</font> 语法。 这种语种语法的样式表文件需要以 <font color=\"red\">.scss</font> 扩展名。</p>\n<p><font color=\"red\">SCSS </font>是<font color=\"red\"> Sass 3</font> 引入新的语法，其语法完全兼容<font color=\"red\"> CSS3</font>，并且继承了 <font color=\"red\">Sass</font> 的强大功能。也就是说，任何标准的<font color=\"red\"> CSS3</font> 样式表都是具有相同语义的有效的<font color=\"red\"> SCSS</font> 文件。另外，<font color=\"red\">SCSS </font>还能识别大部分 <font color=\"red\">CSS hacks</font>（一些 <font color=\"red\">CSS </font>小技巧）和特定于浏览器的语法</p>\n<p>第二种比较老的语法成为缩排语法（或者就称为 “<font color=\"red\">Sass</font>“）， 提供了一种更简洁的 <font color=\"red\">CSS</font> 书写方式。 它不使用花括号，而是通过缩排的方式来表达选择符的嵌套层级，I 而且也不使用分号，而是用换行符来分隔属性。 很多人认为这种格式比 <font color=\"red\">SCSS</font> 更容易阅读，书写也更快速。 缩排语法具有 <font color=\"red\">Sass</font> 的所有特色功能， 虽然有些语法上稍有差异；使用此种语法的样式表文件需要以 <font color=\"red\">.sass </font>作为扩展名。</p>\n<p>任一语法都可以导入另一种语法撰写的文件中。 只要使用 <font color=\"red\">sass-convert</font> 命令行工具，就可以将一种语法转换为另一种语法：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 将 <span class=\"selector-tag\">Sass</span> 转换为 <span class=\"selector-tag\">SCSS</span></span><br><span class=\"line\">$ sass-convert style.sass style.scss</span><br><span class=\"line\"></span><br><span class=\"line\"># 将 <span class=\"selector-tag\">SCSS</span> 转换为 <span class=\"selector-tag\">Sass</span></span><br><span class=\"line\">$ sass-convert style.scss style.sass</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三、sass安装及使用\"><a href=\"#三、sass安装及使用\" class=\"headerlink\" title=\"三、sass安装及使用\"></a>三、sass安装及使用</h2><p><font color=\"red\">SASS</font>是<font color=\"red\">Ruby</font>语言写的，但是两者的语法没有关系。不懂<font color=\"red\">Ruby</font>，照样使用。只是必须先安装<font color=\"red\">Ruby</font>，然后再安装<font color=\"red\">SASS</font>。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">gem</span> <span class=\"selector-tag\">install</span> <span class=\"selector-tag\">sass</span></span><br></pre></td></tr></table></figure></p>\n<p>如果你使用的是 <font color=\"red\">Windows</font>， 就需要先安装 <font color=\"red\">Ruby</font>,因为<font color=\"red\">sass</font>编译是基于<font color=\"red\">Ruby</font>环境的。</p>\n<p>如果要在命令行中运行 <font color=\"red\">Sass</font> ,只要输入<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">sass</span> <span class=\"selector-tag\">input</span><span class=\"selector-class\">.scss</span> <span class=\"selector-tag\">output</span><span class=\"selector-class\">.css</span></span><br></pre></td></tr></table></figure></p>\n<p>SASS提供四个编译风格的选项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nested：嵌套缩进的css代码，它是默认值。</span><br><span class=\"line\"></span><br><span class=\"line\">expanded：没有缩进的、扩展的css代码。</span><br><span class=\"line\"></span><br><span class=\"line\">compact：简洁格式的css代码。</span><br><span class=\"line\"></span><br><span class=\"line\">compressed：压缩后的css代码。</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass --style compressed test.sass test.css</span><br></pre></td></tr></table></figure>\n<p>你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// watch a file</span><br><span class=\"line\">sass --watch input.scss:output.css</span><br><span class=\"line\"></span><br><span class=\"line\">// watch a directory</span><br><span class=\"line\">sass --watch app/sass:public/stylesheets</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1、变量声明\"><a href=\"#1、变量声明\" class=\"headerlink\" title=\"1、变量声明\"></a>1、变量声明</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\">$nav-color: #F90;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  $width: 100px;</span><br><span class=\"line\">  width: $width;</span><br><span class=\"line\">  color: $nav-color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#F90</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，<font color=\"red\">$nav-color</font>这个变量定义在了规则块外边，相当于全局变量，所以在这个样式表中都可以像<font color=\"red\">nav</font>规则块那样引用它。<font color=\"red\">$width</font>这个变量定义在了<font color=\"red\">nav</font>的<font color=\"red\">{ }</font>规则块内，相当于局部变量，所以它只能在<font color=\"red\">nav</font>规则块内使用。这意味着是你可以在样式表的其他地方定义和使用<font color=\"red\">$width</font>变量，不会对这里造成影响。其变量名用中线和下划线<font color=\"red\">sass</font>不做强求且相互兼容。</p>\n<h3 id=\"2、嵌套CSS-规则\"><a href=\"#2、嵌套CSS-规则\" class=\"headerlink\" title=\"2、嵌套CSS 规则\"></a>2、嵌套CSS 规则</h3><h4 id=\"2-1、-父选择器的标识符-amp\"><a href=\"#2-1、-父选择器的标识符-amp\" class=\"headerlink\" title=\"2.1、 父选择器的标识符&amp;\"></a>2.1、 父选择器的标识符&amp;</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">  &amp;:hover &#123; color: red &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  body.ie &amp; &#123; color: green &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> &#123;</span><br><span class=\"line\">    &amp;-item &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">font-size</span>: <span class=\"selector-id\">#ff0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">color</span>: blue &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123;<span class=\"attribute\">color</span>: red&#125;;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.ie</span> <span class=\"selector-id\">#content</span> <span class=\"selector-tag\">aside</span> &#123; <span class=\"attribute\">color</span>: green &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#content-item</span> &#123; <span class=\"attribute\">font-size</span>: <span class=\"number\">#ff0</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>一般情况下，<font color=\"red\">sass</font>在解开一个嵌套规则时就会把父选择器通过一个空格连接到子选择器的前边，这种在<font color=\"red\">CSS</font>里边被称为后代选择器。但在有些情况下你却不会希望<font color=\"red\">sass</font>使用这种后代选择器的方式生成这种连接，这时候我们会用到’<font color=\"red\">&amp;</font>‘符号，它起到连接作用</p>\n<h4 id=\"2-2、群组选择器的嵌套\"><a href=\"#2-2、群组选择器的嵌套\" class=\"headerlink\" title=\"2.2、群组选择器的嵌套\"></a>2.2、群组选择器的嵌套</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  h1, h2, h3 &#123;margin-bottom: .8em&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span>, <span class=\"selector-tag\">aside</span> &#123;</span><br><span class=\"line\">  a &#123;color: blue&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-tag\">h1</span>, <span class=\"selector-class\">.container</span> <span class=\"selector-tag\">h2</span>, <span class=\"selector-class\">.container</span> <span class=\"selector-tag\">h3</span> &#123; <span class=\"attribute\">margin-bottom</span>: .<span class=\"number\">8em</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">a</span>, <span class=\"selector-tag\">aside</span> <span class=\"selector-tag\">a</span> &#123;<span class=\"attribute\">color</span>: blue&#125;</span><br></pre></td></tr></table></figure>\n<p>处理这种群组选择器规则嵌套上的强大能力，正是<font color=\"red\">sass</font>在减少重复敲写方面的贡献之一。尤其在当嵌套级别达到两层甚至三层以上时，与普通的<font color=\"red\">css</font>编写方式相比，只写一遍群组选择器大大减少了工作量。</p>\n<p>有利必有弊，你需要特别注意群组选择器的规则嵌套生成的<font color=\"red\">css</font>。虽然<font color=\"red\">sass</font>让你的样式表看上去很小，但实际生成的<font color=\"red\">css</font>却可能非常大，这会降低网站的速度。</p>\n<h4 id=\"2-3、子组合选择器和同层组合选择器：-gt-、-和\"><a href=\"#2-3、子组合选择器和同层组合选择器：-gt-、-和\" class=\"headerlink\" title=\"2.3、子组合选择器和同层组合选择器： &gt;、+和~\"></a>2.3、子组合选择器和同层组合选择器：<font color=\"red\"> &gt;、+</font>和<font color=\"red\">~</font></h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> &#123;</span><br><span class=\"line\">  ~ article &#123; border-top: 1px dashed #ccc &#125;</span><br><span class=\"line\">  &gt; <span class=\"selector-tag\">section</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span> &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">dl</span> &gt; &#123;</span><br><span class=\"line\">    dt &#123; color: #333 &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">dd</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#555</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">nav</span> + &amp; &#123; <span class=\"attribute\">margin-top</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> ~ <span class=\"selector-tag\">article</span> &#123; <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> dashed <span class=\"number\">#ccc</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> &gt; <span class=\"selector-tag\">footer</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">dl</span> &gt; <span class=\"selector-tag\">dt</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#333</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">article</span> <span class=\"selector-tag\">dl</span> &gt; <span class=\"selector-tag\">dd</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#555</span> &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> + <span class=\"selector-tag\">article</span> &#123; <span class=\"attribute\">margin-top</span>: <span class=\"number\">0</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>你可以用子组合选择器<font color=\"red\"> &gt; </font>选择一个元素的直接子元素。你可以用同层相邻组合选择器<font color=\"red\"> + </font>选择<font color=\"red\">nav</font>元素后紧跟的<font color=\"red\">article</font>元素。你还可以用同层全体组合选择器<font color=\"red\"> ~ </font>，选择所有跟在<font color=\"red\">article</font>后的同层<font color=\"red\">article</font>元素，不管它们之间隔了多少其他元素。</p>\n<p>在<font color=\"red\">sass</font>中，不仅仅<font color=\"red\">css</font>规则可以嵌套，对属性进行嵌套也可以减少很多重复性的工作。</p>\n<h4 id=\"2-4、嵌套属性\"><a href=\"#2-4、嵌套属性\" class=\"headerlink\" title=\"2.4、嵌套属性\"></a>2.4、嵌套属性</h4><p>在<font color=\"red\">sass</font>中，除了<font color=\"red\">CSS</font>选择器，属性也可以进行嵌套。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: &#123;</span><br><span class=\"line\">  style: solid;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>嵌套属性的规则是这样的<font color=\"red\">:</font>把属性名从中划线<font color=\"red\"> - </font>的地方断开，在根属性后边添加一个冒号<font color=\"red\"> : </font>，紧跟一个<font color=\"red\">{ }</font>块，把子属性部分写在这个<font color=\"red\">{ }</font>块中。就像<font color=\"red\">css</font>选择器嵌套一样，<font color=\"red\">sass</font>会把你的子属性一一解开，把根属性和子属性部分通过中划线<font color=\"red\"> - </font>连接起来，最后生成的效果与你手动一遍遍写的<font color=\"red\">css</font>样式一样:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于属性的缩写形式，你甚至可以像下边这样来嵌套，指明例外规则:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span> &#123;</span><br><span class=\"line\">  left: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。</p>\n<p>即便如此，随着你的样式表变得越来越大，这种写法也很难保持结构清晰。有时，处理这种大量样式的唯一方法就是把它们分拆到多个文件中。<font color=\"red\">sass</font>通过对<font color=\"red\">css</font>原有<font color=\"red\">@import</font>规则的改进直接支持了这一特性。</p>\n<h4 id=\"2-5、计算功能\"><a href=\"#2-5、计算功能\" class=\"headerlink\" title=\"2.5、计算功能\"></a>2.5、计算功能</h4><p><font color=\"red\">sass</font> 允许使用算式。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">2px</span> * <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: (<span class=\"number\">10px</span> / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">112px</span> - <span class=\"number\">12px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">12px</span> + <span class=\"number\">4px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">8px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三、导入SASS文件\"><a href=\"#三、导入SASS文件\" class=\"headerlink\" title=\"三、导入SASS文件\"></a>三、导入SASS文件</h3><p><font color=\"red\">css</font>有一个特别不常用的特性，即<font color=\"red\">@import</font>规则，它允许在一个<font color=\"red\">css</font>文件中导入其他<font color=\"red\">css</font>文件。然而，后果是只有执行到<font color=\"red\">@import</font>时，浏览器才会去下载其他<font color=\"red\">css</font>文件，这导致页面加载起来特别慢。</p>\n<p><font color=\"red\">sass</font>也有一个<font color=\"red\">@import</font>规则，但不同的是，<font color=\"red\">sass</font>的<font color=\"red\">@import</font>规则在生成<font color=\"red\">css</font>文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个<font color=\"red\">css</font>文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器均可在导入文件中使用。</p>\n<p>使用<font color=\"red\">sass</font>的<font color=\"red\">@import</font>规则并不需要指明被导入文件的全名。你可以省略<font color=\"red\">.sass</font>或<font color=\"red\">.scss</font>文件后缀。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的<font color=\"red\">sass</font>样式文件语法，在<font color=\"red\">sass</font>和<font color=\"red\">scss</font>语法之间随意切换。举例来说，<font color=\"red\">@import”sidebar”</font>;这条命令将把<font color=\"red\">sidebar.scss</font>文件中所有样式添加到当前样式表中。</p>\n<h4 id=\"3-2、默认变量值\"><a href=\"#3-2、默认变量值\" class=\"headerlink\" title=\"3.2、默认变量值\"></a>3.2、默认变量值</h4><p>一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\">$link-color: blue;</span><br><span class=\"line\">$link-color: red;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: $link-color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上边的例子中，超链接的<font color=\"red\">color</font>会被设置为<font color=\"red\">red</font>。这可能并不是你想要的结果，假如你写了一个可被他人通过<font color=\"red\">@import</font>导入的<font color=\"red\">sass</font>库文件，你可能希望导入者可以定制修改<font color=\"red\">sass</font>库文件中的某些值。使用<font color=\"red\">sass</font>的<font color=\"red\">!default</font>标签可以实现这个目的。它很像<font color=\"red\">css</font>属性中<font color=\"red\">!important</font>标签的对立面，不同的是<font color=\"red\">!default</font>用于变量，含义是:如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译前</span><br><span class=\"line\">$link-color: red !default;</span><br><span class=\"line\"><span class=\"selector-class\">.a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: $link-color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-class\">.a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上例中，如果用户在导入你的<font color=\"red\">sass</font>局部文件之前声明了一个<font color=\"red\">$link-color</font>变量，那么你的局部文件中对<font color=\"red\">color</font>赋<font color=\"red\">red</font>的操作就无效。如果用户没有做这样的声明，则<font color=\"red\">$link-color</font>将默认为<font color=\"red\">red</font>。</p>\n<h4 id=\"3-3、嵌套导入\"><a href=\"#3-3、嵌套导入\" class=\"headerlink\" title=\"3.3、嵌套导入\"></a>3.3、嵌套导入</h4><p>跟原生的<font color=\"red\">css</font>不同，<font color=\"red\">sass</font>允许<font color=\"red\">@import</font>命令写在<font color=\"red\">css</font>规则内。这种导入方式下，生成对应的<font color=\"red\">css</font>文件时，局部文件会被直接插入到<font color=\"red\">css</font>规则内导入它的地方。举例说明，有一个名为<font color=\"red\">_blue-theme.scss</font>的局部文件，内容如下:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">aside</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: blue;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后把它导入到一个<font color=\"red\">CSS</font>规则内，如下所示:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.blue-theme</span> &#123;</span><br><span class=\"line\">    @import \"blue-theme\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.blue-theme</span> &#123;</span><br><span class=\"line\">  aside &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">blue</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">color</span>: <span class=\"selector-id\">#fff</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。</p>\n<p>有时，可用<font color=\"red\">css</font>原生的<font color=\"red\">@import</font>机制，在浏览器中下载必需的<font color=\"red\">css</font>文件。<font color=\"red\">sass</font>也提供了几种方法来达成这种需求。</p>\n<h3 id=\"四、混合器\"><a href=\"#四、混合器\" class=\"headerlink\" title=\"四、混合器\"></a>四、混合器</h3><p>如果你的整个网站中有几处小小的样式类似(例如一致的颜色和字体)，那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过<font color=\"red\">sass的</font>混合器实现大段样式的重用。</p>\n<p>下边的这段<font color=\"red\">sass</font>代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> rounded-corners &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">-moz-border-radius</span>: 5<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">-webkit-border-radius</span>: 5<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">border-radius</span>: 5<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后就可以在你的样式表中通过<font color=\"red\">@include</font>来使用这个混合器，放在你希望的任何地方。<font color=\"red\">@include</font>调用会把混合器中的所有样式提取出来放在<font color=\"red\">@include</font>被调用的地方。如果像下边这样写:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">notice</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#00aa00</span>;</span><br><span class=\"line\">  @include rounded-corners;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//编译后</span><br><span class=\"line\"><span class=\"selector-class\">.notice</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#00aa00</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-moz-border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一节将介绍使用混合器来避免重复。通过使用参数，你可以使用混合器把你样式中的通用样式抽离出来，然后轻松地在其他地方重用。实际上，混合器太好用了，一不小心你可能会过度使用。大量的重用可能会导致生成的样式表过大，导致加载缓慢。所以，首先我们将讨论混合器的使用场景，避免滥用。</p>\n<h4 id=\"4-1、混合器中的CSS规则\"><a href=\"#4-1、混合器中的CSS规则\" class=\"headerlink\" title=\"4.1、混合器中的CSS规则\"></a>4.1、混合器中的CSS规则</h4><p>混合器中不仅可以包含属性，也可以包含<font color=\"red\">css</font>规则，包含选择器和选择器中的属性，如下代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> no-bullets &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">list-style</span>: <span class=\"selector-tag\">none</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">list-style-image</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">list-style-type</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当一个包含<font color=\"red\">css</font>规则的混合器通过<font color=\"red\">@include</font>包含在一个父规则中时，在混合器中的规则最终会生成父规则中的嵌套规则。举个例子，看看下边的<font color=\"red\">sass</font>代码，这个例子中使用了<font color=\"red\">no-bullets</font>这个混合器:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span><span class=\"selector-class\">.plain</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#444</span>;</span><br><span class=\"line\">  @include no-bullets;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><font color=\"red\">sass</font>的<font color=\"red\">@include</font>指令会将引入混合器的那行代码替换成混合器里边的内容。最终，上边的例子如下代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span><span class=\"selector-class\">.plain</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#444</span>;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ul</span><span class=\"selector-class\">.plain</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">list-style-image</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">list-style-type</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>混合器中的规则甚至可以使用<font color=\"red\"> sass</font>的父选择器标识符<font color=\"red\">&amp;</font>。使用起来跟不用混合器时一样，<font color=\"red\">sass</font>解开嵌套规则时，用父规则中的选择器替代<font color=\"red\">&amp;</font>。</p>\n<p>如果一个混合器只包含<font color=\"red\">css</font>规则，不包含属性，那么这个混合器就可以在文档的顶部调用，写在所有的<font color=\"red\">css</font>规则之外。如果你只是为自己写一些混合器，这并没有什么大的用途，但是当你使用一个类似于<font color=\"red\">Compass</font>的库时，你会发现，这是提供样式的好方法，原因在于你可以选择是否使用这些样式。</p>\n<h4 id=\"4-2、给混合器传参\"><a href=\"#4-2、给混合器传参\" class=\"headerlink\" title=\"4.2、给混合器传参\"></a>4.2、给混合器传参</h4><p>混合器并不一定总得生成相同的样式。可以通过在<font color=\"red\">@include</font>混合器时给混合器传参，来定制混合器生成的精确样式。当<font color=\"red\">@include</font>混合器时，参数其实就是可以赋值给<font color=\"red\">css</font>属性值的变量。如果你写过<font color=\"red\">JavaScript</font>，这种方式跟<font color=\"red\">JavaScript</font>的<font color=\"red\">function</font>很像:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> link-colors($normal, $hover, $visited) &#123;</span><br><span class=\"line\">  color: $normal;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: $hover; &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:visited</span> &#123; <span class=\"attribute\">color</span>: $visited; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当混合器被<font color=\"red\">@include</font>时，你可以把它当作一个<font color=\"red\">css</font>函数来传参。如果你像下边这样写:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  @include link-colors(blue, red, green);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Sass最终生成的是:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">color</span>: blue; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: red; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:visited</span> &#123; <span class=\"attribute\">color</span>: green; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当你<font color=\"red\">@include</font>混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，<font color=\"red\">sass</font>允许通过语法<font color=\"red\">$name: value</font>的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    @include link-colors(</span><br><span class=\"line\">      $normal: blue,</span><br><span class=\"line\">      $visited: green,</span><br><span class=\"line\">      $hover: red</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>尽管给混合器加参数来实现定制很好，但是有时有些参数我们没有定制的需要，这时候也需要赋值一个变量就变成很痛苦的事情了。所以<font color=\"red\">sass</font>允许混合器声明时给参数赋默认值。</p>\n<h4 id=\"4-3、默认参数值\"><a href=\"#4-3、默认参数值\" class=\"headerlink\" title=\"4.3、默认参数值\"></a>4.3、默认参数值</h4><p>为了在<font color=\"red\">@include</font>混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用<font color=\"red\">$name: default-value</font>的声明形式，默认值可以是任何有效的<font color=\"red\">css</font>属性值，甚至是其他参数的引用，如下代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> link-colors(</span><br><span class=\"line\">    $normal,</span><br><span class=\"line\">    $hover: $normal,</span><br><span class=\"line\">    $visited: $normal</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  color: $normal;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: $hover; &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:visited</span> &#123; <span class=\"attribute\">color</span>: $visited; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果像下边这样调用:<font color=\"red\">@include link-colors(red) $hover</font>和<font color=\"red\">$visited</font>也会被自动赋值为<font color=\"red\">red</font>。</p>\n<p>混合器只是<font color=\"red\">sass</font>样式重用特性中的一个。我们已经了解到混合器主要用于样式展示层的重用，如果你想重用语义化的类呢？这就涉及<font color=\"red\">sass</font>的另一个重要的重用特性:选择器继承。</p>\n<h3 id=\"五、使用选择器继承来精简CSS\"><a href=\"#五、使用选择器继承来精简CSS\" class=\"headerlink\" title=\"五、使用选择器继承来精简CSS\"></a>五、使用选择器继承来精简CSS</h3><p>使用<font color=\"red\">sass</font>的时候，一个减少重复的主要特性就是选择器继承。选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过<font color=\"red\">@extend</font>语法实现，如下代码:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通过选择器继承继承样式</span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> red;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fdd</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.seriousError</span> &#123;</span><br><span class=\"line\">  @extend .error;</span><br><span class=\"line\">  <span class=\"selector-tag\">border-width</span>: 3<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>任何<font color=\"red\">css</font>规则都可以继承其他规则，几乎任何<font color=\"red\">css</font>规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个<font color=\"red\">html</font>元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对<font color=\"red\">html</font>元素添加的所有样式都会被继承。</p>\n<h3 id=\"六、sass扩展及更新\"><a href=\"#六、sass扩展及更新\" class=\"headerlink\" title=\"六、sass扩展及更新\"></a>六、sass扩展及更新</h3><h4 id=\"6-1、使用占位符选择器\"><a href=\"#6-1、使用占位符选择器\" class=\"headerlink\" title=\"6.1、使用占位符选择器 %\"></a>6.1、使用占位符选择器 %</h4><p>从<font color=\"red\">sass3.2.0</font>后，就可以定义占位选择器<font color=\"red\">%</font>，这个的优势在于，不调用不会有多余的<font color=\"red\">css</font>文件<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sass样式</span><br><span class=\"line\">%<span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    @extend %h1;</span><br><span class=\"line\">    <span class=\"selector-tag\">color</span><span class=\"selector-pseudo\">:red</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// css编译后样式</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-2、-content\"><a href=\"#6-2、-content\" class=\"headerlink\" title=\"6.2、@content\"></a>6.2、@content</h4><p>在<font color=\"red\">sass3.2.0</font>中引入， 可以用来解决<font color=\"red\">css3</font>中 <font color=\"red\">@meidia</font> 或者<font color=\"red\"> @keyframes</font> 带来的问题。它可以使<font color=\"red\">@mixin</font>接受一整块样式，接收的样式从<font color=\"red\">@content</font>开始<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sass 样式              </span><br><span class=\"line\">@<span class=\"keyword\">mixin</span> max-screen($res)&#123;</span><br><span class=\"line\">  @<span class=\"keyword\">media</span> only screen and ( max-width: $res )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">content</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">@<span class=\"keyword\">include</span> max-screen(<span class=\"number\">480px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">body</span> &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">//css 编译后样式</span><br><span class=\"line\">@<span class=\"keyword\">media</span> only screen and (max-width: <span class=\"number\">480px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">body</span> &#123; <span class=\"attribute\">color</span>: red &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用<font color=\"red\">@content</font>解决<font color=\"red\">@keyframes</font>关键帧的浏览器前缀问题<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 初始化变量</span><br><span class=\"line\">$browser: null;</span><br><span class=\"line\">// 设置关键帧</span><br><span class=\"line\">@<span class=\"keyword\">mixin</span> keyframes($name) &#123;</span><br><span class=\"line\">    @-webkit-keyframes #&#123;$name&#125; &#123;</span><br><span class=\"line\">        $browser: '-webkit-'; @content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @-moz-keyframes #&#123;$name&#125; &#123;</span><br><span class=\"line\">        $browser: '-moz-'; @content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @-o-keyframes #&#123;$name&#125; &#123;</span><br><span class=\"line\">        $browser: '-o-'; @content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @keyframes #&#123;$name&#125; &#123;</span><br><span class=\"line\">        $browser: ''; @content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// 引入</span><br><span class=\"line\">@<span class=\"keyword\">include</span> keyframes(scale) &#123;</span><br><span class=\"line\">    100% &#123;</span><br><span class=\"line\">        #&#123;$browser&#125;transform: scale(0.8);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// css编译后</span><br><span class=\"line\">@-<span class=\"keyword\">webkit</span>-<span class=\"keyword\">keyframes</span> scale &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">-webkit-transform</span>: <span class=\"selector-tag\">scale</span>(0<span class=\"selector-class\">.8</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@-<span class=\"keyword\">moz</span>-<span class=\"keyword\">keyframes</span> scale  &#123;</span><br><span class=\"line\">   <span class=\"selector-tag\">-moz-transform</span>: <span class=\"selector-tag\">scale</span>(0<span class=\"selector-class\">.8</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@-<span class=\"keyword\">o</span>-<span class=\"keyword\">keyframes</span> scale  &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">-o-transform</span>: <span class=\"selector-tag\">scale</span>(0<span class=\"selector-class\">.8</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> scale  &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scale</span>(0<span class=\"selector-class\">.8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-3、颜色函数\"><a href=\"#6-3、颜色函数\" class=\"headerlink\" title=\"6.3、颜色函数\"></a>6.3、颜色函数</h4><p><font color=\"red\">sass</font>提供了一些内置的颜色函数<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lighten(#cc3, 10%)　　  // #d6d65c</span><br><span class=\"line\">darken(#cc3, 10%) 　　　// #a3a329</span><br><span class=\"line\">grayscale(#cc3) 　　　　// #808080</span><br><span class=\"line\">complement(#cc3) 　　　// #33c</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"七、sass高级用发\"><a href=\"#七、sass高级用发\" class=\"headerlink\" title=\"七、sass高级用发\"></a>七、sass高级用发</h3><h4 id=\"7-1、函数-function\"><a href=\"#7-1、函数-function\" class=\"headerlink\" title=\"7.1、函数 function\"></a>7.1、函数 function</h4><p><font color=\"red\">sass</font>允许用户编写自己的函数，以<font color=\"red\">@function</font>开始<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// css编译前</span><br><span class=\"line\">$fontSize: 10px;</span><br><span class=\"line\">@<span class=\"keyword\">function</span> pxTorem($px) &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">return</span> $px / $fontSize * <span class=\"number\">1rem</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"built_in\">pxTorem</span>(16px);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// css编译后</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">1.6rem</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-2、if条件语句\"><a href=\"#7-2、if条件语句\" class=\"headerlink\" title=\"7.2、if条件语句\"></a>7.2、if条件语句</h4><p><font color=\"red\">@if</font>语句可以用来判断<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sass样式</span><br><span class=\"line\">$type: monster;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    @if $type == ocean &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">blue</span>;</span><br><span class=\"line\">    &#125; @<span class=\"keyword\">else</span> if $type == matador &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">red</span>;</span><br><span class=\"line\">    &#125; @<span class=\"keyword\">else</span> if $type == monster &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">green</span>;</span><br><span class=\"line\">    &#125; @<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">black</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// css编译后样式</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: green;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>三目判断：语法为 <font color=\"red\">if($condition, $if_true, $if_false)</font>。 三个参数分别表示： 条件，条件为真的值，条件为假的值<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true, 1px, 2px) =&gt; 1px</span><br><span class=\"line\">if(false, 1px, 2px) =&gt; 2px</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-3、循环语句\"><a href=\"#7-3、循环语句\" class=\"headerlink\" title=\"7.3、循环语句\"></a>7.3、循环语句</h4><p><font color=\"red\">for</font> 循环有两种形式，分别为：<font color=\"red\">@for $var from <start> through <end></end></start></font> 和 <font color=\"red\">@for $var from <start> to <end></end></start></font>。 <font color=\"red\">$var </font>表示变量，<font color=\"red\">start</font>表示开始值，end表示结束值，两种形式的区别在于 <font color=\"red\">through</font> 包括 <font color=\"red\">end</font> 的值，<font color=\"red\">to </font>不包括 <font color=\"red\">end</font> 值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sass样式</span><br><span class=\"line\">@<span class=\"keyword\">for</span> $i from <span class=\"number\">1</span> to <span class=\"number\">4</span> &#123;</span><br><span class=\"line\">    .item-#&#123;$i&#125; &#123;width: 2em * $i;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// css编译后样式</span><br><span class=\"line\"><span class=\"selector-class\">.item-1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">2em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item-2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">4em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item-3</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">6em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><font color=\"red\">while</font>循环<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sass样式</span><br><span class=\"line\">$i: 2;</span><br><span class=\"line\">@<span class=\"keyword\">while</span> $i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    .item-#&#123;$i&#125; &#123;width: 2em * $i;&#125;</span><br><span class=\"line\">    $i: $i - 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// css编译后样式</span><br><span class=\"line\"><span class=\"selector-class\">.item-2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">4em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item-1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">2em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><font color=\"red\">@each</font>循环：语法为<font color=\"red\">@each $var in <list or map></list></font>。 其中<font color=\"red\">$var</font>表示变量，而<font color=\"red\">list</font>和<font color=\"red\">map</font>表示数据类型，<font color=\"red\">sass3.3.0</font>新加入多字段循环和<font color=\"red\">map</font>数据循环</p>\n<p>单字段<font color=\"red\"> list </font>数据循环<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sass 样式</span><br><span class=\"line\">$animal-list: puma, sea-slug, egret;</span><br><span class=\"line\">@<span class=\"keyword\">each</span> $animal in $animal-list &#123;</span><br><span class=\"line\">  .#&#123;$animal&#125;-icon &#123;</span><br><span class=\"line\">    background-image: url('/images/#&#123;$animal&#125;.png');</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//css 编译后样式</span><br><span class=\"line\"><span class=\"selector-class\">.puma-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/puma.png'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.sea-slug-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/sea-slug.png'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.egret-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/egret.png'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>多字段<font color=\"red\">list</font>数据循环<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sass 样式</span><br><span class=\"line\">$animal-data: (puma, black, default),(sea-slug, blue, pointer);</span><br><span class=\"line\">@<span class=\"keyword\">each</span> $animal, $color, $cursor in $animal-data &#123;</span><br><span class=\"line\">  .#&#123;$animal&#125;-icon &#123;</span><br><span class=\"line\">    background-image: url('/images/#&#123;$animal&#125;.png');</span><br><span class=\"line\">    border: 2px solid $color;</span><br><span class=\"line\">    cursor: $cursor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//css 编译后样式</span><br><span class=\"line\"><span class=\"selector-class\">.puma-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/puma.png'</span>);</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: default;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.sea-slug-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'/images/sea-slug.png'</span>);</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid blue;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>多字段 <font color=\"red\">map</font> 数据循环<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//sass 样式</span><br><span class=\"line\">$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);</span><br><span class=\"line\">@<span class=\"keyword\">each</span> $header, $size in $headings &#123;</span><br><span class=\"line\">  #&#123;$header&#125; &#123;</span><br><span class=\"line\">    font-size: $size;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//css 编译后样式</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"八、compass用法\"><a href=\"#八、compass用法\" class=\"headerlink\" title=\"八、compass用法\"></a>八、compass用法</h3><p>前面介绍了Sass的用法。</p>\n<p>Sass是一种”CSS预处理器”，可以让CSS的开发变得简单和可维护。但是，只有搭配Compass，它才能显出真正的威力。学会了Compass，你的CSS开发效率会上一个台阶。</p>\n<h4 id=\"1、compass是什么？\"><a href=\"#1、compass是什么？\" class=\"headerlink\" title=\"1、compass是什么？\"></a>1、compass是什么？</h4><p>简单说，Compass是Sass的工具库（toolkit）。</p>\n<p>Sass本身只是一个编译器，Compass在它的基础上，封装了一系列有用的模块和模板，补充Sass的功能。它们之间的关系，有点像Javascript和jQuery关系。</p>\n<h4 id=\"2、安装\"><a href=\"#2、安装\" class=\"headerlink\" title=\"2、安装\"></a>2、安装</h4><p>Compass是用Ruby语言开发的，所以安装它之前，必须安装Ruby。</p>\n<p>假定你的机器（Linux或OS X）已经安装好Ruby，那么在命令行模式下键入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install compass</span><br></pre></td></tr></table></figure></p>\n<p>如果你用的是Windows系统，那么要省略前面的sudo。</p>\n<h4 id=\"3、项目初始化\"><a href=\"#3、项目初始化\" class=\"headerlink\" title=\"3、项目初始化\"></a>3、项目初始化</h4><p>接下来，要创建一个你的Compass项目，假定它的名字叫做myproject，然后进入该目录，命令行键入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass create myproject</span><br><span class=\"line\">cd myproject</span><br></pre></td></tr></table></figure></p>\n<p>然后你会看到，里面有一个config.rb文件，这是你的项目的配置文件。还有两个子目录sass和stylesheets，前者存放Sass源文件，后者存放编译后的css文件。</p>\n<h4 id=\"4、编译\"><a href=\"#4、编译\" class=\"headerlink\" title=\"4、编译\"></a>4、编译</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass compile</span><br></pre></td></tr></table></figure>\n<p>该命令在项目根目录下运行，会将sass子目录中的scss文件，编译成css文件，保存在stylesheets子目录中。</p>\n<p>默认状态下，编译出来的css文件带有大量的注释。但是，生产环境需要压缩后的css文件，这时要使用–output-style参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass compile --output-style compressed</span><br></pre></td></tr></table></figure></p>\n<p>Compass只编译发生变动的文件，如果你要重新编译未变动的文件，需要使用–force参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass compile --force</span><br></pre></td></tr></table></figure></p>\n<p>除了使用命令行参数，还可以在配置文件config.rb中指定编译模式。</p>\n<p>:expanded模式表示编译后保留原格式，其他值还包括:nested、:compact和:compressed。进入生产阶段后，就要改为:compressed模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output_style = :expanded</span><br><span class=\"line\">output_style = :compressed</span><br></pre></td></tr></table></figure></p>\n<p>也可以通过指定environment的值（:production或者:development），智能判断编译模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">environment = :development</span><br><span class=\"line\">output_style = (environment == :production) ? :compressed : :expanded</span><br></pre></td></tr></table></figure></p>\n<p>compass还有自动编译命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compass watch</span><br></pre></td></tr></table></figure></p>\n<p>运行该命令后，只要scss文件发生变化，就会被自动编译成css文件。</p>\n<h4 id=\"5、Compass的模块\"><a href=\"#5、Compass的模块\" class=\"headerlink\" title=\"5、Compass的模块\"></a>5、Compass的模块</h4><p>Compass采用模块结构，不同模块提供不同的功能。目前，它内置五个模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* reset</span><br><span class=\"line\">* css3</span><br><span class=\"line\">* layout</span><br><span class=\"line\">* typography</span><br><span class=\"line\">* utilities</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5-1、reset模块\"><a href=\"#5-1、reset模块\" class=\"headerlink\" title=\"5.1、reset模块\"></a>5.1、reset模块</h5><p>通常，编写自己的样式之前，有必要重置浏览器的默认样式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;compass/reset&quot;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5-2、css3模块\"><a href=\"#5-2、css3模块\" class=\"headerlink\" title=\"5.2、css3模块\"></a>5.2、css3模块</h5><p> 目前，该模块提供19种CSS3命令</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 圆角（border-radius）的写法</span><br><span class=\"line\"></span><br><span class=\"line\"> @import &quot;compass/css3&quot;;</span><br><span class=\"line\">.rounded &#123;</span><br><span class=\"line\">    @include border-radius(5px); //圆角</span><br><span class=\"line\">    //如果只需要左上角为圆角</span><br><span class=\"line\">    //@include border-corner-radius(top, left, 5px);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">.rounded &#123;</span><br><span class=\"line\">    -moz-border-radius: 5px;</span><br><span class=\"line\">    -webkit-border-radius: 5px;</span><br><span class=\"line\">    -o-border-radius: 5px;</span><br><span class=\"line\">    -ms-border-radius: 5px;</span><br><span class=\"line\">    -khtml-border-radius: 5px;</span><br><span class=\"line\">    border-radius: 5px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 透明（opacity）的写法为</span><br><span class=\"line\"> @import &quot;compass/css3&quot;;</span><br><span class=\"line\">#opacity &#123;</span><br><span class=\"line\">　@include opacity(0.5); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">#opacity &#123;</span><br><span class=\"line\">    filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=0.5);</span><br><span class=\"line\">　　opacity: 0.5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 行内区块（inline-block）的写法为</span><br><span class=\"line\">@import &quot;compass/css3&quot;;</span><br><span class=\"line\">#inline-block &#123;</span><br><span class=\"line\">    @include inline-block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">#inline-block &#123;</span><br><span class=\"line\">　　display: -moz-inline-stack;</span><br><span class=\"line\">　　display: inline-block;</span><br><span class=\"line\">　　vertical-align: middle;</span><br><span class=\"line\">　　*vertical-align: auto;</span><br><span class=\"line\">　　zoom: 1;</span><br><span class=\"line\">　　*display: inline;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"5-3、layout模块\"><a href=\"#5-3、layout模块\" class=\"headerlink\" title=\"5.3、layout模块\"></a>5.3、layout模块</h5><p> 该模块提供布局功能。</p>\n<p>比如，指定页面的footer部分总是出现在浏览器最底端：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @import &quot;compass/layout&quot;;</span><br><span class=\"line\">#footer &#123;</span><br><span class=\"line\">    @include sticky-footer(54px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>又比如，指定子元素占满父元素的空间：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;compass/layout&quot;;</span><br><span class=\"line\">#stretch-full &#123;</span><br><span class=\"line\">　　@include stretch; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5-4、typography模块\"><a href=\"#5-4、typography模块\" class=\"headerlink\" title=\"5.4、typography模块\"></a>5.4、typography模块</h5><p>该模块提供版式功能。</p>\n<p>比如，指定链接颜色的mixin为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">link-colors($normal, $hover, $active, $visited, $focus);</span><br><span class=\"line\"></span><br><span class=\"line\">//使用时写成</span><br><span class=\"line\"> @import &quot;compass/typography&quot;;</span><br><span class=\"line\">a &#123;</span><br><span class=\"line\">    @include link-colors(#00c, #0cc, #c0c, #ccc, #cc0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5-5、utilities模块\"><a href=\"#5-5、utilities模块\" class=\"headerlink\" title=\"5.5、utilities模块\"></a>5.5、utilities模块</h5><p>该模块提供某些不属于其他模块的功能。</p>\n<p>比如，清除浮动：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;compass/utilities/&quot;;</span><br><span class=\"line\">.clearfix &#123;</span><br><span class=\"line\">　　@include clearfix;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;compass/utilities&quot;;</span><br><span class=\"line\">table &#123;</span><br><span class=\"line\">    @include table-scaffolding;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\"></span><br><span class=\"line\">table th &#123;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">    font-weight: bold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">table td,</span><br><span class=\"line\">table th &#123;</span><br><span class=\"line\">    padding: 2px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">table td.numeric,</span><br><span class=\"line\">table th.numeric &#123;</span><br><span class=\"line\">    text-align: right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6、Helper函数\"><a href=\"#6、Helper函数\" class=\"headerlink\" title=\"6、Helper函数\"></a>6、Helper函数</h4><p>除了模块，Compass还提供一系列函数。</p>\n<p>有些函数非常有用，比如image-width()和image-height()返回图片的宽和高。</p>\n<p>再比如，inline-image()可以将图片转为data协议的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;compass&quot;;</span><br><span class=\"line\">.icon &#123; background-image: inline-image(&quot;icon.png&quot;);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">.icon &#123; background-image: url(&apos;data:image/png;base64,iBROR...QmCC&apos;);&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数与mixin的主要区别是，不需要使用@include命令，可以直接调用。</p>\n<h3 id=\"九、sass和less区别\"><a href=\"#九、sass和less区别\" class=\"headerlink\" title=\"九、sass和less区别\"></a>九、sass和less区别</h3><h4 id=\"1-编译环境不一样\"><a href=\"#1-编译环境不一样\" class=\"headerlink\" title=\"1.编译环境不一样\"></a>1.编译环境不一样</h4><p>Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。</p>\n<h4 id=\"2-变量符不一样，Less是-，而Scss是-，而且变量的作用域也不一样。\"><a href=\"#2-变量符不一样，Less是-，而Scss是-，而且变量的作用域也不一样。\" class=\"headerlink\" title=\"2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。\"></a>2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Less-作用域</span><br><span class=\"line\">@color: #00c; /* 蓝色 */</span><br><span class=\"line\">#header &#123;</span><br><span class=\"line\">  @color: #c00; /* red */</span><br><span class=\"line\">  border: 1px solid @color; /* 红色边框 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#footer &#123;</span><br><span class=\"line\">  border: 1px solid @color; /* 蓝色边框 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Less-作用域编译后</span><br><span class=\"line\">#header&#123;border:1px solid #cc0000;&#125;</span><br><span class=\"line\">#footer&#123;border:1px solid #0000cc;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//scss-作用域</span><br><span class=\"line\">$color: #00c; /* 蓝色 */</span><br><span class=\"line\"></span><br><span class=\"line\">#header &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  $color: #c00; /* red */</span><br><span class=\"line\">  border: 1px solid $color; /* 红色边框 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#footer &#123;</span><br><span class=\"line\">  border: 1px solid $color; /* 蓝色边框 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Sass-作用域编译后</span><br><span class=\"line\"></span><br><span class=\"line\">#header&#123;border:1px solid #c00&#125;</span><br><span class=\"line\">#footer&#123;border:1px solid #c00&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看出来，less和scss中的变量会随着作用域的变化而不一样。</p>\n<h4 id=\"3-输出设置，Less没有输出设置，Sass提供4中输出选项：nested-compact-compressed-和-expanded。\"><a href=\"#3-输出设置，Less没有输出设置，Sass提供4中输出选项：nested-compact-compressed-和-expanded。\" class=\"headerlink\" title=\"3.输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。\"></a>3.输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。</h4><p>输出样式的风格可以有四种选择，默认为nested<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nested：//嵌套缩进的css代码</span><br><span class=\"line\">expanded：//展开的多行css代码</span><br><span class=\"line\">compact：//简洁格式的css代码</span><br><span class=\"line\">compressed：//压缩后的css代码</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-Sass支持条件语句，可以使用if-else-for-循环等等。而Less不支持。\"><a href=\"#4-Sass支持条件语句，可以使用if-else-for-循环等等。而Less不支持。\" class=\"headerlink\" title=\"4.Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。\"></a>4.Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Sample Sass “if” statement */</span><br><span class=\"line\"></span><br><span class=\"line\">@if lightness($color) &gt; 30% &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; @else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Sample Sass “for” loop */</span><br><span class=\"line\"></span><br><span class=\"line\">@for $i from 1 to 10 &#123;</span><br><span class=\"line\">  .border-#&#123;$i&#125; &#123;</span><br><span class=\"line\">    border: #&#123;$i&#125;px solid blue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-引用外部CSS文件\"><a href=\"#5-引用外部CSS文件\" class=\"headerlink\" title=\"5. 引用外部CSS文件\"></a>5. 引用外部CSS文件</h4><p>css引用的外部文件命名必须以_开头, 如下例所示:其中_test1.scss、_test2.scss、<em>test3.scss文件分别设置的h1 h2 h3。文件名如果以下划线</em>开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源代码：</span><br><span class=\"line\">@import &quot;_test1.scss&quot;;</span><br><span class=\"line\">@import &quot;_test2.scss&quot;;</span><br><span class=\"line\">@import &quot;_test3.scss&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 编译后：</span><br><span class=\"line\">h1 &#123;</span><br><span class=\"line\">  font-size: 17px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">h2 &#123;</span><br><span class=\"line\">  font-size: 17px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">h3 &#123;</span><br><span class=\"line\">  font-size: 17px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Less引用外部文件和css中的@import没什么差异。</p>\n<p>Less还有其他强大的功能，比如雪碧图等等…</p>\n<h4 id=\"6-Sass和Less的工具库不同\"><a href=\"#6-Sass和Less的工具库不同\" class=\"headerlink\" title=\"6.Sass和Less的工具库不同\"></a>6.Sass和Less的工具库不同</h4><p>Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。</p>\n<p>Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。</p>\n<h3 id=\"十、-总结\"><a href=\"#十、-总结\" class=\"headerlink\" title=\"十、 总结\"></a>十、 总结</h3><p>不管是Sass，还是Less，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，Sass的功能比Less强大,基本可以说是一种真正的编程语言了，Less则相对清晰明了,易于上手,对编译环境要求比较宽松。考虑到编译Sass要安装Ruby,而Ruby官网在国内访问不了,个人在实际开发中更倾向于选择Less。<br>最后还有个stylu，其接触的不多，它相对于前两种学习难度大点，其规范少如果想了解可以找些相关资料，这里就不多说了~</p>\n"},{"title":"pdm系统框架介绍及开发总结","comments":1,"date":"2019-06-26T02:05:01.000Z","author":"jun.zhou","_content":"\n# 一、React管理系统框架\n\n#### React-dva:\nReact后端管理系统应用比较多的是dva框架\n通过 reducers, effects 和 subscriptions 组织 model,简化 redux.\u000b\n官网：[https://dvajs.com](https://dvajs.com)\n\n#### Dva-cli:\nDva脚手架安装简易便捷、使用方便\nui库：antd\n地址：[https://github.com/dvajs/dva-cli](https://github.com/dvajs/dva-cli)\n\n#### React-dva工作原理介绍:\n\n![](https://img.fengjr.com/image/2019/06/26/175b3d3b97ce0c843944d9e63cb96379.png)\n\n我简单的分析一下这个图：\n\n首先我们根据 url 访问相关的 Route-Component，在组件中我们通过 dispatch 发送 action 到 model 里面的 effect 或者直接 Reducer\n\n当我们将action发送给Effect，基本上是取服务器上面请求数据的，服务器返回数据之后，effect 会发送相应的 action 给 reducer，由唯一能改变 state 的 reducer 改变 state ，然后通过connect重新渲染组件。\n\n当我们将action发送给reducer，那直接由 reducer 改变 state，然后通过 connect 重新渲染组件。\n这样我们就能走完一个流程了。\n\n#### React-admin:\u000b\n响应式支持pc+移动端,redux-alita极简的redux2react工具\n脚手架：creact-react-app\n组件：antd、echarts\n\n<font color=\"red\">*之前移动端用的比较多的react脚手架是creact-react-app，而React-admin框架也是基于这开发的；ui组件库与pdm系统需求也比较吻合，所以最后我们选用这套框架。*</font>\n[GitHub地址](https://github.com/yezihaohao/react-admin) [预览地址](https://admiring-dijkstra-34cb29.netlify.com/#/login)\n\n# 二、React-admin介绍\n\n#### 依赖模块\n\n项目是用create-react-app创建的，主要还是列出新加的功能依赖包\n\n- react-router(react路由，4.x的版本，如果还使用3.x的版本，请切换分支（ps:分支不再维护）)\n- redux(基础用法，但是封装了通用action和reducer，demo中主要用于权限控制（ps：目前可以用16.x的context api代替），可以简单了解下)\n- antd(蚂蚁金服开源的react ui组件框架)\n- axios(http请求模块，可用于前端任何场景，很强大👍)\n- echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)\n- recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)\n- nprogress(顶部加载条，蛮好用👍)\n- react-draft-wysiwyg(别人基于react的富文本封装，如果找到其他更好的可以替换)\n- react-draggable(拖拽模块，找了个简单版的)\n- screenfull(全屏插件)\n- photoswipe(图片弹层查看插件，不依赖jQuery，还是蛮好用👍)\n- animate.css(css动画库)\n- react-loadable(代码拆分，按需加载，预加载，样样都行，具体见其文档，推荐使用)\n- redux-alita 极简的redux2react工具\n\n#### 功能模块\n备注：项目只引入了ant-design的部分组件，其他的组件antd官网有源码，可以直接复制到项目中使用，后续有时间补上全部组件。\n\n项目使用了antd的自定义主题功能-->黑色，若想替换其他颜色，具体操作请查看antd官网\n\n- **首页**\n  完整布局\n  换肤(全局功能，暂时只实现了顶部导航的换肤，后续加上其他模块)\n- **导航菜单**\n  顶部导航(菜单伸缩，全屏功能)\n  左边菜单(增加滚动条以及适配路由的active操作)\n- **UI模块**\n  按钮(antd组件)\n  图标(antd组件并增加彩色表情符)\n  加载中(antd组件并增加顶部加载条)\n  通知提醒框(antd组件)\n  标签页(antd组件)\n  轮播图(ant动效组件)\n  富文本\n  拖拽\n  画廊\n- **动画**\n  基础动画(animate.css所有动画)\n  动画案例\n- **表格**\n  基础表格(antd组件)\n  高级表格(antd组件)\n  异步表格(数据来自掘金酱的接口)\n- **表单**\n  基础表单(antd组件)\n- **图表**\n  echarts图表\n  recharts图表\n- **页面**\n  登录页面(包括GitHub第三方登录)\n  404页面\n\n#### redux-alita api\n\nReact-admin框架自己封装了一套redux模块，主要有四个api\n\n- **AlitaProvider**\n  provider component for root node\n- **connectAlita**\n  connect function (just prepared mapStateToProps and mapDispatchToProps)\n- **setAlitaState**\n  set redux data fucntion (after connect, you can use it in props)\n  funcParams -> { funcName, params, stateName = funcName, data }\n  only stateName and data for synchronous datas\n  funcName, params for asynchronous fetch apis\n- **setConfig**\n  register fetch functions before fetch usage\n\n# 三、Pdm开发遇到问题\n\n尝试应该一个新的框架，不可避免的会遇到一些坑。\n\n#### redux-alita 只能在 render(){} 才能获取到\n\n![](https://img.fengjr.com/image/2019/06/26/7534292b0e555a5c94fd49502f1ac09e.png)\n\n框架封装的redux模块在 componentDidMount() 里面取不到值，不知道为啥。\n解决办法就是在 render 里取然后 回调传值方式调用。\n\n#### 浏览器开多个窗口登录不同用户数据不统一\n\n解决办法: 路由变化时候加新旧缓存id对比\n\n![](https://img.fengjr.com/image/2019/06/26/b5f1d9368f7f7d87984aa55e1575495d.png)\n\n\n#### 首页echarts图标点击进入详情页方法\n![](https://img.fengjr.com/image/2019/06/26/c42209b8960d56ee694142732a89cb73.png)\n\n#### 角色权限设置级别问题\n\n权限树组件有级别区分，但接口返回没有级别\n![](https://img.fengjr.com/image/2019/06/26/a6a6ef09e7bd4325ab17368c1373752a.png)\n解决办法：提交时候存全部，接口返回时候多返一个子集。\n\n#### 角色权限设置级别问题\n权限树组件根据子集获取组装全部级别方法\n\n![](https://img.fengjr.com/image/2019/06/26/0e36624b2a677235f79565ca40c43500.png)\n\n#### Table组件编辑可获取到全部静态数据\n点编辑时候读缓存列表里的数据，不必多调用一次接口\n\n![](https://img.fengjr.com/image/2019/06/26/06f371ab175c974f4a2bb3a22ce48ce2.png)\n\n#### 插入变量获取文本框焦点位置\n先获取焦点对象，再获取焦点位置，然后重置值\n\n![](https://img.fengjr.com/image/2019/06/26/c19a786faeade91068b557c040e37d1d.png)\n\n# 四、技术调研\n\n[umijs](https://umijs.org/zh/guide/) 一个比较新的框架，dva脚手架也将向 umi 靠拢。\n\n![](https://img.fengjr.com/image/2019/06/26/3b68313f58e61a2077795dbd3d471cdc.png)\n\n看了一遍官方文档，搭建了一个小项目，个人感觉umi确实好用，更方便快捷的脚手架，完全工程化。\n\n\n\n\n\n\n\n","source":"_posts/2019-06-26-pdm-react-admin.md","raw":"---\ntitle: pdm系统框架介绍及开发总结\ncomments: true\ndate: 2019-06-26 10:05:01\ntags:\n- react\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n# 一、React管理系统框架\n\n#### React-dva:\nReact后端管理系统应用比较多的是dva框架\n通过 reducers, effects 和 subscriptions 组织 model,简化 redux.\u000b\n官网：[https://dvajs.com](https://dvajs.com)\n\n#### Dva-cli:\nDva脚手架安装简易便捷、使用方便\nui库：antd\n地址：[https://github.com/dvajs/dva-cli](https://github.com/dvajs/dva-cli)\n\n#### React-dva工作原理介绍:\n\n![](https://img.fengjr.com/image/2019/06/26/175b3d3b97ce0c843944d9e63cb96379.png)\n\n我简单的分析一下这个图：\n\n首先我们根据 url 访问相关的 Route-Component，在组件中我们通过 dispatch 发送 action 到 model 里面的 effect 或者直接 Reducer\n\n当我们将action发送给Effect，基本上是取服务器上面请求数据的，服务器返回数据之后，effect 会发送相应的 action 给 reducer，由唯一能改变 state 的 reducer 改变 state ，然后通过connect重新渲染组件。\n\n当我们将action发送给reducer，那直接由 reducer 改变 state，然后通过 connect 重新渲染组件。\n这样我们就能走完一个流程了。\n\n#### React-admin:\u000b\n响应式支持pc+移动端,redux-alita极简的redux2react工具\n脚手架：creact-react-app\n组件：antd、echarts\n\n<font color=\"red\">*之前移动端用的比较多的react脚手架是creact-react-app，而React-admin框架也是基于这开发的；ui组件库与pdm系统需求也比较吻合，所以最后我们选用这套框架。*</font>\n[GitHub地址](https://github.com/yezihaohao/react-admin) [预览地址](https://admiring-dijkstra-34cb29.netlify.com/#/login)\n\n# 二、React-admin介绍\n\n#### 依赖模块\n\n项目是用create-react-app创建的，主要还是列出新加的功能依赖包\n\n- react-router(react路由，4.x的版本，如果还使用3.x的版本，请切换分支（ps:分支不再维护）)\n- redux(基础用法，但是封装了通用action和reducer，demo中主要用于权限控制（ps：目前可以用16.x的context api代替），可以简单了解下)\n- antd(蚂蚁金服开源的react ui组件框架)\n- axios(http请求模块，可用于前端任何场景，很强大👍)\n- echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)\n- recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)\n- nprogress(顶部加载条，蛮好用👍)\n- react-draft-wysiwyg(别人基于react的富文本封装，如果找到其他更好的可以替换)\n- react-draggable(拖拽模块，找了个简单版的)\n- screenfull(全屏插件)\n- photoswipe(图片弹层查看插件，不依赖jQuery，还是蛮好用👍)\n- animate.css(css动画库)\n- react-loadable(代码拆分，按需加载，预加载，样样都行，具体见其文档，推荐使用)\n- redux-alita 极简的redux2react工具\n\n#### 功能模块\n备注：项目只引入了ant-design的部分组件，其他的组件antd官网有源码，可以直接复制到项目中使用，后续有时间补上全部组件。\n\n项目使用了antd的自定义主题功能-->黑色，若想替换其他颜色，具体操作请查看antd官网\n\n- **首页**\n  完整布局\n  换肤(全局功能，暂时只实现了顶部导航的换肤，后续加上其他模块)\n- **导航菜单**\n  顶部导航(菜单伸缩，全屏功能)\n  左边菜单(增加滚动条以及适配路由的active操作)\n- **UI模块**\n  按钮(antd组件)\n  图标(antd组件并增加彩色表情符)\n  加载中(antd组件并增加顶部加载条)\n  通知提醒框(antd组件)\n  标签页(antd组件)\n  轮播图(ant动效组件)\n  富文本\n  拖拽\n  画廊\n- **动画**\n  基础动画(animate.css所有动画)\n  动画案例\n- **表格**\n  基础表格(antd组件)\n  高级表格(antd组件)\n  异步表格(数据来自掘金酱的接口)\n- **表单**\n  基础表单(antd组件)\n- **图表**\n  echarts图表\n  recharts图表\n- **页面**\n  登录页面(包括GitHub第三方登录)\n  404页面\n\n#### redux-alita api\n\nReact-admin框架自己封装了一套redux模块，主要有四个api\n\n- **AlitaProvider**\n  provider component for root node\n- **connectAlita**\n  connect function (just prepared mapStateToProps and mapDispatchToProps)\n- **setAlitaState**\n  set redux data fucntion (after connect, you can use it in props)\n  funcParams -> { funcName, params, stateName = funcName, data }\n  only stateName and data for synchronous datas\n  funcName, params for asynchronous fetch apis\n- **setConfig**\n  register fetch functions before fetch usage\n\n# 三、Pdm开发遇到问题\n\n尝试应该一个新的框架，不可避免的会遇到一些坑。\n\n#### redux-alita 只能在 render(){} 才能获取到\n\n![](https://img.fengjr.com/image/2019/06/26/7534292b0e555a5c94fd49502f1ac09e.png)\n\n框架封装的redux模块在 componentDidMount() 里面取不到值，不知道为啥。\n解决办法就是在 render 里取然后 回调传值方式调用。\n\n#### 浏览器开多个窗口登录不同用户数据不统一\n\n解决办法: 路由变化时候加新旧缓存id对比\n\n![](https://img.fengjr.com/image/2019/06/26/b5f1d9368f7f7d87984aa55e1575495d.png)\n\n\n#### 首页echarts图标点击进入详情页方法\n![](https://img.fengjr.com/image/2019/06/26/c42209b8960d56ee694142732a89cb73.png)\n\n#### 角色权限设置级别问题\n\n权限树组件有级别区分，但接口返回没有级别\n![](https://img.fengjr.com/image/2019/06/26/a6a6ef09e7bd4325ab17368c1373752a.png)\n解决办法：提交时候存全部，接口返回时候多返一个子集。\n\n#### 角色权限设置级别问题\n权限树组件根据子集获取组装全部级别方法\n\n![](https://img.fengjr.com/image/2019/06/26/0e36624b2a677235f79565ca40c43500.png)\n\n#### Table组件编辑可获取到全部静态数据\n点编辑时候读缓存列表里的数据，不必多调用一次接口\n\n![](https://img.fengjr.com/image/2019/06/26/06f371ab175c974f4a2bb3a22ce48ce2.png)\n\n#### 插入变量获取文本框焦点位置\n先获取焦点对象，再获取焦点位置，然后重置值\n\n![](https://img.fengjr.com/image/2019/06/26/c19a786faeade91068b557c040e37d1d.png)\n\n# 四、技术调研\n\n[umijs](https://umijs.org/zh/guide/) 一个比较新的框架，dva脚手架也将向 umi 靠拢。\n\n![](https://img.fengjr.com/image/2019/06/26/3b68313f58e61a2077795dbd3d471cdc.png)\n\n看了一遍官方文档，搭建了一个小项目，个人感觉umi确实好用，更方便快捷的脚手架，完全工程化。\n\n\n\n\n\n\n\n","slug":"pdm-react-admin","published":1,"updated":"2020-06-10T06:02:00.590Z","_id":"ck2yl0qbf0000h6q6w8l3mao0","layout":"post","photos":[],"link":"","content":"<h1 id=\"一、React管理系统框架\"><a href=\"#一、React管理系统框架\" class=\"headerlink\" title=\"一、React管理系统框架\"></a>一、React管理系统框架</h1><h4 id=\"React-dva\"><a href=\"#React-dva\" class=\"headerlink\" title=\"React-dva:\"></a>React-dva:</h4><p>React后端管理系统应用比较多的是dva框架<br>通过 reducers, effects 和 subscriptions 组织 model,简化 redux.\u000b<br>官网：<a href=\"https://dvajs.com\" target=\"_blank\" rel=\"noopener\">https://dvajs.com</a></p>\n<h4 id=\"Dva-cli\"><a href=\"#Dva-cli\" class=\"headerlink\" title=\"Dva-cli:\"></a>Dva-cli:</h4><p>Dva脚手架安装简易便捷、使用方便<br>ui库：antd<br>地址：<a href=\"https://github.com/dvajs/dva-cli\" target=\"_blank\" rel=\"noopener\">https://github.com/dvajs/dva-cli</a></p>\n<h4 id=\"React-dva工作原理介绍\"><a href=\"#React-dva工作原理介绍\" class=\"headerlink\" title=\"React-dva工作原理介绍:\"></a>React-dva工作原理介绍:</h4><p><img src=\"https://img.fengjr.com/image/2019/06/26/175b3d3b97ce0c843944d9e63cb96379.png\" alt></p>\n<p>我简单的分析一下这个图：</p>\n<p>首先我们根据 url 访问相关的 Route-Component，在组件中我们通过 dispatch 发送 action 到 model 里面的 effect 或者直接 Reducer</p>\n<p>当我们将action发送给Effect，基本上是取服务器上面请求数据的，服务器返回数据之后，effect 会发送相应的 action 给 reducer，由唯一能改变 state 的 reducer 改变 state ，然后通过connect重新渲染组件。</p>\n<p>当我们将action发送给reducer，那直接由 reducer 改变 state，然后通过 connect 重新渲染组件。<br>这样我们就能走完一个流程了。</p>\n<h4 id=\"React-admin\"><a href=\"#React-admin\" class=\"headerlink\" title=\"React-admin:\u000b\"></a>React-admin:\u000b</h4><p>响应式支持pc+移动端,redux-alita极简的redux2react工具<br>脚手架：creact-react-app<br>组件：antd、echarts</p>\n<p><font color=\"red\"><em>之前移动端用的比较多的react脚手架是creact-react-app，而React-admin框架也是基于这开发的；ui组件库与pdm系统需求也比较吻合，所以最后我们选用这套框架。</em></font><br><a href=\"https://github.com/yezihaohao/react-admin\" target=\"_blank\" rel=\"noopener\">GitHub地址</a> <a href=\"https://admiring-dijkstra-34cb29.netlify.com/#/login\" target=\"_blank\" rel=\"noopener\">预览地址</a></p>\n<h1 id=\"二、React-admin介绍\"><a href=\"#二、React-admin介绍\" class=\"headerlink\" title=\"二、React-admin介绍\"></a>二、React-admin介绍</h1><h4 id=\"依赖模块\"><a href=\"#依赖模块\" class=\"headerlink\" title=\"依赖模块\"></a>依赖模块</h4><p>项目是用create-react-app创建的，主要还是列出新加的功能依赖包</p>\n<ul>\n<li>react-router(react路由，4.x的版本，如果还使用3.x的版本，请切换分支（ps:分支不再维护）)</li>\n<li>redux(基础用法，但是封装了通用action和reducer，demo中主要用于权限控制（ps：目前可以用16.x的context api代替），可以简单了解下)</li>\n<li>antd(蚂蚁金服开源的react ui组件框架)</li>\n<li>axios(http请求模块，可用于前端任何场景，很强大👍)</li>\n<li>echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)</li>\n<li>recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)</li>\n<li>nprogress(顶部加载条，蛮好用👍)</li>\n<li>react-draft-wysiwyg(别人基于react的富文本封装，如果找到其他更好的可以替换)</li>\n<li>react-draggable(拖拽模块，找了个简单版的)</li>\n<li>screenfull(全屏插件)</li>\n<li>photoswipe(图片弹层查看插件，不依赖jQuery，还是蛮好用👍)</li>\n<li>animate.css(css动画库)</li>\n<li>react-loadable(代码拆分，按需加载，预加载，样样都行，具体见其文档，推荐使用)</li>\n<li>redux-alita 极简的redux2react工具</li>\n</ul>\n<h4 id=\"功能模块\"><a href=\"#功能模块\" class=\"headerlink\" title=\"功能模块\"></a>功能模块</h4><p>备注：项目只引入了ant-design的部分组件，其他的组件antd官网有源码，可以直接复制到项目中使用，后续有时间补上全部组件。</p>\n<p>项目使用了antd的自定义主题功能–&gt;黑色，若想替换其他颜色，具体操作请查看antd官网</p>\n<ul>\n<li><strong>首页</strong><br>完整布局<br>换肤(全局功能，暂时只实现了顶部导航的换肤，后续加上其他模块)</li>\n<li><strong>导航菜单</strong><br>顶部导航(菜单伸缩，全屏功能)<br>左边菜单(增加滚动条以及适配路由的active操作)</li>\n<li><strong>UI模块</strong><br>按钮(antd组件)<br>图标(antd组件并增加彩色表情符)<br>加载中(antd组件并增加顶部加载条)<br>通知提醒框(antd组件)<br>标签页(antd组件)<br>轮播图(ant动效组件)<br>富文本<br>拖拽<br>画廊</li>\n<li><strong>动画</strong><br>基础动画(animate.css所有动画)<br>动画案例</li>\n<li><strong>表格</strong><br>基础表格(antd组件)<br>高级表格(antd组件)<br>异步表格(数据来自掘金酱的接口)</li>\n<li><strong>表单</strong><br>基础表单(antd组件)</li>\n<li><strong>图表</strong><br>echarts图表<br>recharts图表</li>\n<li><strong>页面</strong><br>登录页面(包括GitHub第三方登录)<br>404页面</li>\n</ul>\n<h4 id=\"redux-alita-api\"><a href=\"#redux-alita-api\" class=\"headerlink\" title=\"redux-alita api\"></a>redux-alita api</h4><p>React-admin框架自己封装了一套redux模块，主要有四个api</p>\n<ul>\n<li><strong>AlitaProvider</strong><br>provider component for root node</li>\n<li><strong>connectAlita</strong><br>connect function (just prepared mapStateToProps and mapDispatchToProps)</li>\n<li><strong>setAlitaState</strong><br>set redux data fucntion (after connect, you can use it in props)<br>funcParams -&gt; { funcName, params, stateName = funcName, data }<br>only stateName and data for synchronous datas<br>funcName, params for asynchronous fetch apis</li>\n<li><strong>setConfig</strong><br>register fetch functions before fetch usage</li>\n</ul>\n<h1 id=\"三、Pdm开发遇到问题\"><a href=\"#三、Pdm开发遇到问题\" class=\"headerlink\" title=\"三、Pdm开发遇到问题\"></a>三、Pdm开发遇到问题</h1><p>尝试应该一个新的框架，不可避免的会遇到一些坑。</p>\n<h4 id=\"redux-alita-只能在-render-才能获取到\"><a href=\"#redux-alita-只能在-render-才能获取到\" class=\"headerlink\" title=\"redux-alita 只能在 render(){} 才能获取到\"></a>redux-alita 只能在 render(){} 才能获取到</h4><p><img src=\"https://img.fengjr.com/image/2019/06/26/7534292b0e555a5c94fd49502f1ac09e.png\" alt></p>\n<p>框架封装的redux模块在 componentDidMount() 里面取不到值，不知道为啥。<br>解决办法就是在 render 里取然后 回调传值方式调用。</p>\n<h4 id=\"浏览器开多个窗口登录不同用户数据不统一\"><a href=\"#浏览器开多个窗口登录不同用户数据不统一\" class=\"headerlink\" title=\"浏览器开多个窗口登录不同用户数据不统一\"></a>浏览器开多个窗口登录不同用户数据不统一</h4><p>解决办法: 路由变化时候加新旧缓存id对比</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/b5f1d9368f7f7d87984aa55e1575495d.png\" alt></p>\n<h4 id=\"首页echarts图标点击进入详情页方法\"><a href=\"#首页echarts图标点击进入详情页方法\" class=\"headerlink\" title=\"首页echarts图标点击进入详情页方法\"></a>首页echarts图标点击进入详情页方法</h4><p><img src=\"https://img.fengjr.com/image/2019/06/26/c42209b8960d56ee694142732a89cb73.png\" alt></p>\n<h4 id=\"角色权限设置级别问题\"><a href=\"#角色权限设置级别问题\" class=\"headerlink\" title=\"角色权限设置级别问题\"></a>角色权限设置级别问题</h4><p>权限树组件有级别区分，但接口返回没有级别<br><img src=\"https://img.fengjr.com/image/2019/06/26/a6a6ef09e7bd4325ab17368c1373752a.png\" alt><br>解决办法：提交时候存全部，接口返回时候多返一个子集。</p>\n<h4 id=\"角色权限设置级别问题-1\"><a href=\"#角色权限设置级别问题-1\" class=\"headerlink\" title=\"角色权限设置级别问题\"></a>角色权限设置级别问题</h4><p>权限树组件根据子集获取组装全部级别方法</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/0e36624b2a677235f79565ca40c43500.png\" alt></p>\n<h4 id=\"Table组件编辑可获取到全部静态数据\"><a href=\"#Table组件编辑可获取到全部静态数据\" class=\"headerlink\" title=\"Table组件编辑可获取到全部静态数据\"></a>Table组件编辑可获取到全部静态数据</h4><p>点编辑时候读缓存列表里的数据，不必多调用一次接口</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/06f371ab175c974f4a2bb3a22ce48ce2.png\" alt></p>\n<h4 id=\"插入变量获取文本框焦点位置\"><a href=\"#插入变量获取文本框焦点位置\" class=\"headerlink\" title=\"插入变量获取文本框焦点位置\"></a>插入变量获取文本框焦点位置</h4><p>先获取焦点对象，再获取焦点位置，然后重置值</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/c19a786faeade91068b557c040e37d1d.png\" alt></p>\n<h1 id=\"四、技术调研\"><a href=\"#四、技术调研\" class=\"headerlink\" title=\"四、技术调研\"></a>四、技术调研</h1><p><a href=\"https://umijs.org/zh/guide/\" target=\"_blank\" rel=\"noopener\">umijs</a> 一个比较新的框架，dva脚手架也将向 umi 靠拢。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/3b68313f58e61a2077795dbd3d471cdc.png\" alt></p>\n<p>看了一遍官方文档，搭建了一个小项目，个人感觉umi确实好用，更方便快捷的脚手架，完全工程化。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、React管理系统框架\"><a href=\"#一、React管理系统框架\" class=\"headerlink\" title=\"一、React管理系统框架\"></a>一、React管理系统框架</h1><h4 id=\"React-dva\"><a href=\"#React-dva\" class=\"headerlink\" title=\"React-dva:\"></a>React-dva:</h4><p>React后端管理系统应用比较多的是dva框架<br>通过 reducers, effects 和 subscriptions 组织 model,简化 redux.\u000b<br>官网：<a href=\"https://dvajs.com\" target=\"_blank\" rel=\"noopener\">https://dvajs.com</a></p>\n<h4 id=\"Dva-cli\"><a href=\"#Dva-cli\" class=\"headerlink\" title=\"Dva-cli:\"></a>Dva-cli:</h4><p>Dva脚手架安装简易便捷、使用方便<br>ui库：antd<br>地址：<a href=\"https://github.com/dvajs/dva-cli\" target=\"_blank\" rel=\"noopener\">https://github.com/dvajs/dva-cli</a></p>\n<h4 id=\"React-dva工作原理介绍\"><a href=\"#React-dva工作原理介绍\" class=\"headerlink\" title=\"React-dva工作原理介绍:\"></a>React-dva工作原理介绍:</h4><p><img src=\"https://img.fengjr.com/image/2019/06/26/175b3d3b97ce0c843944d9e63cb96379.png\" alt></p>\n<p>我简单的分析一下这个图：</p>\n<p>首先我们根据 url 访问相关的 Route-Component，在组件中我们通过 dispatch 发送 action 到 model 里面的 effect 或者直接 Reducer</p>\n<p>当我们将action发送给Effect，基本上是取服务器上面请求数据的，服务器返回数据之后，effect 会发送相应的 action 给 reducer，由唯一能改变 state 的 reducer 改变 state ，然后通过connect重新渲染组件。</p>\n<p>当我们将action发送给reducer，那直接由 reducer 改变 state，然后通过 connect 重新渲染组件。<br>这样我们就能走完一个流程了。</p>\n<h4 id=\"React-admin\"><a href=\"#React-admin\" class=\"headerlink\" title=\"React-admin:\u000b\"></a>React-admin:\u000b</h4><p>响应式支持pc+移动端,redux-alita极简的redux2react工具<br>脚手架：creact-react-app<br>组件：antd、echarts</p>\n<p><font color=\"red\"><em>之前移动端用的比较多的react脚手架是creact-react-app，而React-admin框架也是基于这开发的；ui组件库与pdm系统需求也比较吻合，所以最后我们选用这套框架。</em></font><br><a href=\"https://github.com/yezihaohao/react-admin\" target=\"_blank\" rel=\"noopener\">GitHub地址</a> <a href=\"https://admiring-dijkstra-34cb29.netlify.com/#/login\" target=\"_blank\" rel=\"noopener\">预览地址</a></p>\n<h1 id=\"二、React-admin介绍\"><a href=\"#二、React-admin介绍\" class=\"headerlink\" title=\"二、React-admin介绍\"></a>二、React-admin介绍</h1><h4 id=\"依赖模块\"><a href=\"#依赖模块\" class=\"headerlink\" title=\"依赖模块\"></a>依赖模块</h4><p>项目是用create-react-app创建的，主要还是列出新加的功能依赖包</p>\n<ul>\n<li>react-router(react路由，4.x的版本，如果还使用3.x的版本，请切换分支（ps:分支不再维护）)</li>\n<li>redux(基础用法，但是封装了通用action和reducer，demo中主要用于权限控制（ps：目前可以用16.x的context api代替），可以简单了解下)</li>\n<li>antd(蚂蚁金服开源的react ui组件框架)</li>\n<li>axios(http请求模块，可用于前端任何场景，很强大👍)</li>\n<li>echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)</li>\n<li>recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)</li>\n<li>nprogress(顶部加载条，蛮好用👍)</li>\n<li>react-draft-wysiwyg(别人基于react的富文本封装，如果找到其他更好的可以替换)</li>\n<li>react-draggable(拖拽模块，找了个简单版的)</li>\n<li>screenfull(全屏插件)</li>\n<li>photoswipe(图片弹层查看插件，不依赖jQuery，还是蛮好用👍)</li>\n<li>animate.css(css动画库)</li>\n<li>react-loadable(代码拆分，按需加载，预加载，样样都行，具体见其文档，推荐使用)</li>\n<li>redux-alita 极简的redux2react工具</li>\n</ul>\n<h4 id=\"功能模块\"><a href=\"#功能模块\" class=\"headerlink\" title=\"功能模块\"></a>功能模块</h4><p>备注：项目只引入了ant-design的部分组件，其他的组件antd官网有源码，可以直接复制到项目中使用，后续有时间补上全部组件。</p>\n<p>项目使用了antd的自定义主题功能–&gt;黑色，若想替换其他颜色，具体操作请查看antd官网</p>\n<ul>\n<li><strong>首页</strong><br>完整布局<br>换肤(全局功能，暂时只实现了顶部导航的换肤，后续加上其他模块)</li>\n<li><strong>导航菜单</strong><br>顶部导航(菜单伸缩，全屏功能)<br>左边菜单(增加滚动条以及适配路由的active操作)</li>\n<li><strong>UI模块</strong><br>按钮(antd组件)<br>图标(antd组件并增加彩色表情符)<br>加载中(antd组件并增加顶部加载条)<br>通知提醒框(antd组件)<br>标签页(antd组件)<br>轮播图(ant动效组件)<br>富文本<br>拖拽<br>画廊</li>\n<li><strong>动画</strong><br>基础动画(animate.css所有动画)<br>动画案例</li>\n<li><strong>表格</strong><br>基础表格(antd组件)<br>高级表格(antd组件)<br>异步表格(数据来自掘金酱的接口)</li>\n<li><strong>表单</strong><br>基础表单(antd组件)</li>\n<li><strong>图表</strong><br>echarts图表<br>recharts图表</li>\n<li><strong>页面</strong><br>登录页面(包括GitHub第三方登录)<br>404页面</li>\n</ul>\n<h4 id=\"redux-alita-api\"><a href=\"#redux-alita-api\" class=\"headerlink\" title=\"redux-alita api\"></a>redux-alita api</h4><p>React-admin框架自己封装了一套redux模块，主要有四个api</p>\n<ul>\n<li><strong>AlitaProvider</strong><br>provider component for root node</li>\n<li><strong>connectAlita</strong><br>connect function (just prepared mapStateToProps and mapDispatchToProps)</li>\n<li><strong>setAlitaState</strong><br>set redux data fucntion (after connect, you can use it in props)<br>funcParams -&gt; { funcName, params, stateName = funcName, data }<br>only stateName and data for synchronous datas<br>funcName, params for asynchronous fetch apis</li>\n<li><strong>setConfig</strong><br>register fetch functions before fetch usage</li>\n</ul>\n<h1 id=\"三、Pdm开发遇到问题\"><a href=\"#三、Pdm开发遇到问题\" class=\"headerlink\" title=\"三、Pdm开发遇到问题\"></a>三、Pdm开发遇到问题</h1><p>尝试应该一个新的框架，不可避免的会遇到一些坑。</p>\n<h4 id=\"redux-alita-只能在-render-才能获取到\"><a href=\"#redux-alita-只能在-render-才能获取到\" class=\"headerlink\" title=\"redux-alita 只能在 render(){} 才能获取到\"></a>redux-alita 只能在 render(){} 才能获取到</h4><p><img src=\"https://img.fengjr.com/image/2019/06/26/7534292b0e555a5c94fd49502f1ac09e.png\" alt></p>\n<p>框架封装的redux模块在 componentDidMount() 里面取不到值，不知道为啥。<br>解决办法就是在 render 里取然后 回调传值方式调用。</p>\n<h4 id=\"浏览器开多个窗口登录不同用户数据不统一\"><a href=\"#浏览器开多个窗口登录不同用户数据不统一\" class=\"headerlink\" title=\"浏览器开多个窗口登录不同用户数据不统一\"></a>浏览器开多个窗口登录不同用户数据不统一</h4><p>解决办法: 路由变化时候加新旧缓存id对比</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/b5f1d9368f7f7d87984aa55e1575495d.png\" alt></p>\n<h4 id=\"首页echarts图标点击进入详情页方法\"><a href=\"#首页echarts图标点击进入详情页方法\" class=\"headerlink\" title=\"首页echarts图标点击进入详情页方法\"></a>首页echarts图标点击进入详情页方法</h4><p><img src=\"https://img.fengjr.com/image/2019/06/26/c42209b8960d56ee694142732a89cb73.png\" alt></p>\n<h4 id=\"角色权限设置级别问题\"><a href=\"#角色权限设置级别问题\" class=\"headerlink\" title=\"角色权限设置级别问题\"></a>角色权限设置级别问题</h4><p>权限树组件有级别区分，但接口返回没有级别<br><img src=\"https://img.fengjr.com/image/2019/06/26/a6a6ef09e7bd4325ab17368c1373752a.png\" alt><br>解决办法：提交时候存全部，接口返回时候多返一个子集。</p>\n<h4 id=\"角色权限设置级别问题-1\"><a href=\"#角色权限设置级别问题-1\" class=\"headerlink\" title=\"角色权限设置级别问题\"></a>角色权限设置级别问题</h4><p>权限树组件根据子集获取组装全部级别方法</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/0e36624b2a677235f79565ca40c43500.png\" alt></p>\n<h4 id=\"Table组件编辑可获取到全部静态数据\"><a href=\"#Table组件编辑可获取到全部静态数据\" class=\"headerlink\" title=\"Table组件编辑可获取到全部静态数据\"></a>Table组件编辑可获取到全部静态数据</h4><p>点编辑时候读缓存列表里的数据，不必多调用一次接口</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/06f371ab175c974f4a2bb3a22ce48ce2.png\" alt></p>\n<h4 id=\"插入变量获取文本框焦点位置\"><a href=\"#插入变量获取文本框焦点位置\" class=\"headerlink\" title=\"插入变量获取文本框焦点位置\"></a>插入变量获取文本框焦点位置</h4><p>先获取焦点对象，再获取焦点位置，然后重置值</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/c19a786faeade91068b557c040e37d1d.png\" alt></p>\n<h1 id=\"四、技术调研\"><a href=\"#四、技术调研\" class=\"headerlink\" title=\"四、技术调研\"></a>四、技术调研</h1><p><a href=\"https://umijs.org/zh/guide/\" target=\"_blank\" rel=\"noopener\">umijs</a> 一个比较新的框架，dva脚手架也将向 umi 靠拢。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/06/26/3b68313f58e61a2077795dbd3d471cdc.png\" alt></p>\n<p>看了一遍官方文档，搭建了一个小项目，个人感觉umi确实好用，更方便快捷的脚手架，完全工程化。</p>\n"},{"title":"使用verdaccio搭建私有npm仓库","comments":1,"date":"2019-07-10T06:31:54.000Z","author":"jun.zhou","_content":"# 使用verdaccio搭建私有npm仓库\n\n![verdaccio](https://img.fengjr.com/image/2019/07/10/c9bedb7017ab78b1bd2b76c6333ed947.png)\n\n## 项目背景\n\n熟悉前端开发的朋友肯定对npm都有了解，npm是node的包管理工具，我们开发项目的时候都会通过npm来下载开源的公共库，相当方便。我们组内部也有一些公用的代码块，各项目都需要引用这些代码，所以有两个项目就放在了npm源上，因为代码都是封装的一些公用的函数，不涉及任何公司的业务代码，所有就开源了。近期信息科技部在整理的时候发现这些代码，要求我们迁移到公司的私有源上，不能公开，所以有了接下来我们要做的事情 —— 搭建私有npm仓库。\n\n## 为什么选择verdaccio\n\n前期调研了一段时间，发现可选的方案有以下几种，下面介绍一下它们的主要区别：\n\n- [使用cnpm搭建npm私有仓库](https://www.jianshu.com/p/80b88104ec1f)，阿里的解决方案，缺点是需要搭建MySQL数据库，配置较麻烦，安装配置需要都切换到cnpm上，现有改动略大\n- 使用github作为私有仓库，原理是在项目里面引用另一个github仓库，有更新时，只需要要pull一下即可(pc目前有些是这么做的，不对的欢迎补充)，缺点就是两个项目有独立的分支，独立的github仓库，管理麻烦，仓库有更新，不仅需要`npm install`，还需要进入仓库目录`pull`另一个项目。\n- [使用verdaccio搭建私有npm仓库](https://juejin.im/entry/5c64db9851882562851b328f)，配置简单，安装非常容易，项目为sinopia的分支，用法和sinopia差不多\n\n最后决定用一个相对简单的verdaccio试试手，发现使用起来相当方便，还有web页面进行预览。接下来我教大家搭建的流程。\n\n## 服务器搭建\n\n### 1、安装node\n\n因为verdaccio 是基于node的，所有我们的服务器需要安装node。[下载node](https://nodejs.org/zh-cn/download/)\n\n因为选取的服务器是Centos7，我详细介绍一下在这个上面安装的教程。\n\n#### 使用EPEL安装node\n\nEPEL（Extra Packages for Enterprise Linux）企业版Linux的额外软件包，是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包\n\n```shell\n sudo yum install epel-release\n```\n\n安装完成之后，就可以使用yum安装node，node和npm一起安装。\n\n```shell\nsudo yum install nodejs\n```\n\n安装完成之后，验证node是否正确安装 `node -v`，如果输出以下版本，说明正常安装。\n\n```shell\nv6.1.7\n```\n\n发现安装的node版本过低，对于verdaccio 最新4.0版本的，node版本最低要求为8.0，所以我们需要更新node版本。更新和切换node版本还需要一个我们常用的库，nvm。\n\n#### 安装nvm\n\n```shell\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\n```\n\n安装完成后需要在对nvm配置环境变量，配置方法如下：\n\n进入bash_profile 文件\n\n\n```shell\nvi ~/.bash_profile\n```\n在末尾增加添加以下环境变量\n\n```bash\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n[ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\"  # This loads nvm bash_completion\n```\n添加完之后用以下命令使其生效\n\n```shell\nsource ~/.bash_profile\n```\n\n执行`nvm`命令查看是否安装成功\n\n#### nvm更新node版本\n\n因为node版本较低，接下来要使用nvm更新node版本\n\n```shell\nnvm install 8.11.1\nnvm use 8.11.1\n```\n\n### 2、安装verdaccio\n\n```shell\nnpm install -g verdaccio --unsafe-perm\n```\n\n加上--unsafe-perm选项是为了防止gyp ERR! permission denied权限问题报错，如下：\n\n```shell\ngyp ERR! configure error\ngyp ERR! stack Error: EACCES: permission denied, mkdir '/usr/local/lib/node_modules/verdaccio/node_modules/dtrace-provider/build'\ngyp ERR! System Linux 3.10.0-862.14.4.el7.x86_64\ngyp ERR! command \"/usr/local/bin/node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"\ngyp ERR! cwd /usr/local/lib/node_modules/verdaccio/node_modules/dtrace-provider\ngyp ERR! node -v v8.12.0\ngyp ERR! node-gyp -v v3.8.0\ngyp ERR! not ok\n```\n\n如果出现需要更新npm，执行 `npm install -g npm`即可\n\n### 3、启动verdaccio\n\n```shell\nverdaccio\n```\n\n执行结果如下\n\n```shell\nVerdaccio doesn't need superuser privileges. Don't run it under root.\n warn --- config file  - /root/.config/verdaccio/config.yaml\n warn --- Plugin successfully loaded: htpasswd\n warn --- Plugin successfully loaded: audit\n warn --- http address - http://localhost:4873/ - verdaccio/3.10.2\n```\n\n从控制台我们可以看到verdaccio的配置文件`config.yaml`和默认的访问地址`http://localhost:4873/`，我们需要在配置文件中添加 `listen: 0.0.0.0:4873`才能使4873的端口可以访问，看到web端的管理页面\n\n\n```bash\n# 进入verdaccio 目录\ncd /root/.config/verdaccio/\n\n# 查看该目录下的文件，该目录默认有两个文件，config.yaml和storage，config.yaml 是配置文件，storage是代码仓库，上传和下载的库都存放在这个文件夹下\nls\n> config.yaml  storage\n\n# 编辑配置文件\n\nvim config.yaml\n\n# 在配置文件末尾添加代码\n\nlisten: 0.0.0.0:4873\n\n```\n\n因为国内网络环境的原因，我们可能还需要将npm的源改为淘宝源，配置也在`config.yaml`中修改\n\n```yaml\n# a list of other known repositories we can talk to\nuplinks:\n  npmjs:\n    url: https://registry.npm.taobao.org/\n```\n\n### 4、使用pm2启动verdaccio\n\n为了使程序一直处于打开状态，我们用pm2来启动我们的程序。\n\n安装pm2\n\n```shell\nnpm install -g pm2 --unsafe-perm\n```\n\n使用pm2启动verdaccio\n\n```shell\npm2 start verdaccio\n```\n\n### 5、访问搭建好的私有仓库\n\n在浏览器中打开 http://localhost:4873， 如果能正常访问则说明已经搭建成功，如图：\n\n![](https://img.fengjr.com/image/2019/07/10/0bf4d65010fb8b329f91edee91f606e5.png)\n\n## 客户端上传npm到私有仓库\n\n搭建好服务器之后，接下来就是怎么使用客户端上传包到私有的仓库。\n\n首先需要这册一个npm账号，参考文章[如何开发一个npm包并发布到npm中央仓库](http://liaolongdong.com/2019/01/24/publish-public-npm.html)\n\n### 1、登陆\n\n```shell\nnpm adduser --registry  http://localhost:4873\n```\n\n输入npm账户名、密码和邮箱：\n\n```shell\nUsername: aaa\nPassword: \nEmail: (this IS public) aaa@qq.com\nLogged in as aaa on http:/localhost:4873/.\n```\n如果输出`Logged in as better1025 on http://localhost:4873/.`则代表aaa账号已经成功登陆到 `http://localhost:4873/` 的私有仓库\n\n### 2、发布npm包到私有仓库\n\n```shell\n# 生成npm包，npm version命令用于生成npm包的版本号，verison后可跟三个参数 patch 补丁版本；minor：这个是小修小改；major：是大版本\nnpm version patch\nnpm publish --registry http://localhost:4873\n```\n发布成功之后查看 http://localhost:4873 里已经有了该npm包的信息。\n\n## 如何使用npm私有仓库源\n\n将npm包放在了私有仓库之后，接下来我们还需要使用的时候将该仓库拉下来，\n\n### 1、更换npm源\n\n首先，我们需要切换npm源，切换到我们的私有源上\n\n```shell\nnpm set registry http://localhost:4873\n```\n\n### 2、下载npm包\n\n然后我们执行npm install命令下载上传的包\n\n```shell\nnpm install demo\n```\nverdaccio会优先找我们私有仓库下载的包，如果没有找到，则会从npm中央仓库下载。\n\n## 总结\n\n通过以上的步骤，我们已经成功的切换到了私有的npm上，我们可以发现使用verdaccio非常的简单，而且对于发布一些公司内部的公用包也很方便，跟npm体验一样，并且作用域只在公司内部，也避免了安全隐患。","source":"_posts/2019-07-10-verdaccio-course.md","raw":"---\ntitle: 使用verdaccio搭建私有npm仓库\ncomments: true\ndate: 2019-07-10 14:31:54\ntags:\n- npm\n- web\n- node\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n# 使用verdaccio搭建私有npm仓库\n\n![verdaccio](https://img.fengjr.com/image/2019/07/10/c9bedb7017ab78b1bd2b76c6333ed947.png)\n\n## 项目背景\n\n熟悉前端开发的朋友肯定对npm都有了解，npm是node的包管理工具，我们开发项目的时候都会通过npm来下载开源的公共库，相当方便。我们组内部也有一些公用的代码块，各项目都需要引用这些代码，所以有两个项目就放在了npm源上，因为代码都是封装的一些公用的函数，不涉及任何公司的业务代码，所有就开源了。近期信息科技部在整理的时候发现这些代码，要求我们迁移到公司的私有源上，不能公开，所以有了接下来我们要做的事情 —— 搭建私有npm仓库。\n\n## 为什么选择verdaccio\n\n前期调研了一段时间，发现可选的方案有以下几种，下面介绍一下它们的主要区别：\n\n- [使用cnpm搭建npm私有仓库](https://www.jianshu.com/p/80b88104ec1f)，阿里的解决方案，缺点是需要搭建MySQL数据库，配置较麻烦，安装配置需要都切换到cnpm上，现有改动略大\n- 使用github作为私有仓库，原理是在项目里面引用另一个github仓库，有更新时，只需要要pull一下即可(pc目前有些是这么做的，不对的欢迎补充)，缺点就是两个项目有独立的分支，独立的github仓库，管理麻烦，仓库有更新，不仅需要`npm install`，还需要进入仓库目录`pull`另一个项目。\n- [使用verdaccio搭建私有npm仓库](https://juejin.im/entry/5c64db9851882562851b328f)，配置简单，安装非常容易，项目为sinopia的分支，用法和sinopia差不多\n\n最后决定用一个相对简单的verdaccio试试手，发现使用起来相当方便，还有web页面进行预览。接下来我教大家搭建的流程。\n\n## 服务器搭建\n\n### 1、安装node\n\n因为verdaccio 是基于node的，所有我们的服务器需要安装node。[下载node](https://nodejs.org/zh-cn/download/)\n\n因为选取的服务器是Centos7，我详细介绍一下在这个上面安装的教程。\n\n#### 使用EPEL安装node\n\nEPEL（Extra Packages for Enterprise Linux）企业版Linux的额外软件包，是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包\n\n```shell\n sudo yum install epel-release\n```\n\n安装完成之后，就可以使用yum安装node，node和npm一起安装。\n\n```shell\nsudo yum install nodejs\n```\n\n安装完成之后，验证node是否正确安装 `node -v`，如果输出以下版本，说明正常安装。\n\n```shell\nv6.1.7\n```\n\n发现安装的node版本过低，对于verdaccio 最新4.0版本的，node版本最低要求为8.0，所以我们需要更新node版本。更新和切换node版本还需要一个我们常用的库，nvm。\n\n#### 安装nvm\n\n```shell\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\n```\n\n安装完成后需要在对nvm配置环境变量，配置方法如下：\n\n进入bash_profile 文件\n\n\n```shell\nvi ~/.bash_profile\n```\n在末尾增加添加以下环境变量\n\n```bash\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n[ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\"  # This loads nvm bash_completion\n```\n添加完之后用以下命令使其生效\n\n```shell\nsource ~/.bash_profile\n```\n\n执行`nvm`命令查看是否安装成功\n\n#### nvm更新node版本\n\n因为node版本较低，接下来要使用nvm更新node版本\n\n```shell\nnvm install 8.11.1\nnvm use 8.11.1\n```\n\n### 2、安装verdaccio\n\n```shell\nnpm install -g verdaccio --unsafe-perm\n```\n\n加上--unsafe-perm选项是为了防止gyp ERR! permission denied权限问题报错，如下：\n\n```shell\ngyp ERR! configure error\ngyp ERR! stack Error: EACCES: permission denied, mkdir '/usr/local/lib/node_modules/verdaccio/node_modules/dtrace-provider/build'\ngyp ERR! System Linux 3.10.0-862.14.4.el7.x86_64\ngyp ERR! command \"/usr/local/bin/node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"\ngyp ERR! cwd /usr/local/lib/node_modules/verdaccio/node_modules/dtrace-provider\ngyp ERR! node -v v8.12.0\ngyp ERR! node-gyp -v v3.8.0\ngyp ERR! not ok\n```\n\n如果出现需要更新npm，执行 `npm install -g npm`即可\n\n### 3、启动verdaccio\n\n```shell\nverdaccio\n```\n\n执行结果如下\n\n```shell\nVerdaccio doesn't need superuser privileges. Don't run it under root.\n warn --- config file  - /root/.config/verdaccio/config.yaml\n warn --- Plugin successfully loaded: htpasswd\n warn --- Plugin successfully loaded: audit\n warn --- http address - http://localhost:4873/ - verdaccio/3.10.2\n```\n\n从控制台我们可以看到verdaccio的配置文件`config.yaml`和默认的访问地址`http://localhost:4873/`，我们需要在配置文件中添加 `listen: 0.0.0.0:4873`才能使4873的端口可以访问，看到web端的管理页面\n\n\n```bash\n# 进入verdaccio 目录\ncd /root/.config/verdaccio/\n\n# 查看该目录下的文件，该目录默认有两个文件，config.yaml和storage，config.yaml 是配置文件，storage是代码仓库，上传和下载的库都存放在这个文件夹下\nls\n> config.yaml  storage\n\n# 编辑配置文件\n\nvim config.yaml\n\n# 在配置文件末尾添加代码\n\nlisten: 0.0.0.0:4873\n\n```\n\n因为国内网络环境的原因，我们可能还需要将npm的源改为淘宝源，配置也在`config.yaml`中修改\n\n```yaml\n# a list of other known repositories we can talk to\nuplinks:\n  npmjs:\n    url: https://registry.npm.taobao.org/\n```\n\n### 4、使用pm2启动verdaccio\n\n为了使程序一直处于打开状态，我们用pm2来启动我们的程序。\n\n安装pm2\n\n```shell\nnpm install -g pm2 --unsafe-perm\n```\n\n使用pm2启动verdaccio\n\n```shell\npm2 start verdaccio\n```\n\n### 5、访问搭建好的私有仓库\n\n在浏览器中打开 http://localhost:4873， 如果能正常访问则说明已经搭建成功，如图：\n\n![](https://img.fengjr.com/image/2019/07/10/0bf4d65010fb8b329f91edee91f606e5.png)\n\n## 客户端上传npm到私有仓库\n\n搭建好服务器之后，接下来就是怎么使用客户端上传包到私有的仓库。\n\n首先需要这册一个npm账号，参考文章[如何开发一个npm包并发布到npm中央仓库](http://liaolongdong.com/2019/01/24/publish-public-npm.html)\n\n### 1、登陆\n\n```shell\nnpm adduser --registry  http://localhost:4873\n```\n\n输入npm账户名、密码和邮箱：\n\n```shell\nUsername: aaa\nPassword: \nEmail: (this IS public) aaa@qq.com\nLogged in as aaa on http:/localhost:4873/.\n```\n如果输出`Logged in as better1025 on http://localhost:4873/.`则代表aaa账号已经成功登陆到 `http://localhost:4873/` 的私有仓库\n\n### 2、发布npm包到私有仓库\n\n```shell\n# 生成npm包，npm version命令用于生成npm包的版本号，verison后可跟三个参数 patch 补丁版本；minor：这个是小修小改；major：是大版本\nnpm version patch\nnpm publish --registry http://localhost:4873\n```\n发布成功之后查看 http://localhost:4873 里已经有了该npm包的信息。\n\n## 如何使用npm私有仓库源\n\n将npm包放在了私有仓库之后，接下来我们还需要使用的时候将该仓库拉下来，\n\n### 1、更换npm源\n\n首先，我们需要切换npm源，切换到我们的私有源上\n\n```shell\nnpm set registry http://localhost:4873\n```\n\n### 2、下载npm包\n\n然后我们执行npm install命令下载上传的包\n\n```shell\nnpm install demo\n```\nverdaccio会优先找我们私有仓库下载的包，如果没有找到，则会从npm中央仓库下载。\n\n## 总结\n\n通过以上的步骤，我们已经成功的切换到了私有的npm上，我们可以发现使用verdaccio非常的简单，而且对于发布一些公司内部的公用包也很方便，跟npm体验一样，并且作用域只在公司内部，也避免了安全隐患。","slug":"verdaccio-course","published":1,"updated":"2020-06-10T06:01:57.945Z","_id":"ck2yl0qbj0001h6q6tj3p6ktd","layout":"post","photos":[],"link":"","content":"<h1 id=\"使用verdaccio搭建私有npm仓库\"><a href=\"#使用verdaccio搭建私有npm仓库\" class=\"headerlink\" title=\"使用verdaccio搭建私有npm仓库\"></a>使用verdaccio搭建私有npm仓库</h1><p><img src=\"https://img.fengjr.com/image/2019/07/10/c9bedb7017ab78b1bd2b76c6333ed947.png\" alt=\"verdaccio\"></p>\n<h2 id=\"项目背景\"><a href=\"#项目背景\" class=\"headerlink\" title=\"项目背景\"></a>项目背景</h2><p>熟悉前端开发的朋友肯定对npm都有了解，npm是node的包管理工具，我们开发项目的时候都会通过npm来下载开源的公共库，相当方便。我们组内部也有一些公用的代码块，各项目都需要引用这些代码，所以有两个项目就放在了npm源上，因为代码都是封装的一些公用的函数，不涉及任何公司的业务代码，所有就开源了。近期信息科技部在整理的时候发现这些代码，要求我们迁移到公司的私有源上，不能公开，所以有了接下来我们要做的事情 —— 搭建私有npm仓库。</p>\n<h2 id=\"为什么选择verdaccio\"><a href=\"#为什么选择verdaccio\" class=\"headerlink\" title=\"为什么选择verdaccio\"></a>为什么选择verdaccio</h2><p>前期调研了一段时间，发现可选的方案有以下几种，下面介绍一下它们的主要区别：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/80b88104ec1f\" target=\"_blank\" rel=\"noopener\">使用cnpm搭建npm私有仓库</a>，阿里的解决方案，缺点是需要搭建MySQL数据库，配置较麻烦，安装配置需要都切换到cnpm上，现有改动略大</li>\n<li>使用github作为私有仓库，原理是在项目里面引用另一个github仓库，有更新时，只需要要pull一下即可(pc目前有些是这么做的，不对的欢迎补充)，缺点就是两个项目有独立的分支，独立的github仓库，管理麻烦，仓库有更新，不仅需要<code>npm install</code>，还需要进入仓库目录<code>pull</code>另一个项目。</li>\n<li><a href=\"https://juejin.im/entry/5c64db9851882562851b328f\" target=\"_blank\" rel=\"noopener\">使用verdaccio搭建私有npm仓库</a>，配置简单，安装非常容易，项目为sinopia的分支，用法和sinopia差不多</li>\n</ul>\n<p>最后决定用一个相对简单的verdaccio试试手，发现使用起来相当方便，还有web页面进行预览。接下来我教大家搭建的流程。</p>\n<h2 id=\"服务器搭建\"><a href=\"#服务器搭建\" class=\"headerlink\" title=\"服务器搭建\"></a>服务器搭建</h2><h3 id=\"1、安装node\"><a href=\"#1、安装node\" class=\"headerlink\" title=\"1、安装node\"></a>1、安装node</h3><p>因为verdaccio 是基于node的，所有我们的服务器需要安装node。<a href=\"https://nodejs.org/zh-cn/download/\" target=\"_blank\" rel=\"noopener\">下载node</a></p>\n<p>因为选取的服务器是Centos7，我详细介绍一下在这个上面安装的教程。</p>\n<h4 id=\"使用EPEL安装node\"><a href=\"#使用EPEL安装node\" class=\"headerlink\" title=\"使用EPEL安装node\"></a>使用EPEL安装node</h4><p>EPEL（Extra Packages for Enterprise Linux）企业版Linux的额外软件包，是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install epel-release</span><br></pre></td></tr></table></figure>\n<p>安装完成之后，就可以使用yum安装node，node和npm一起安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install nodejs</span><br></pre></td></tr></table></figure>\n<p>安装完成之后，验证node是否正确安装 <code>node -v</code>，如果输出以下版本，说明正常安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v6.1.7</span><br></pre></td></tr></table></figure>\n<p>发现安装的node版本过低，对于verdaccio 最新4.0版本的，node版本最低要求为8.0，所以我们需要更新node版本。更新和切换node版本还需要一个我们常用的库，nvm。</p>\n<h4 id=\"安装nvm\"><a href=\"#安装nvm\" class=\"headerlink\" title=\"安装nvm\"></a>安装nvm</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>安装完成后需要在对nvm配置环境变量，配置方法如下：</p>\n<p>进入bash_profile 文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>在末尾增加添加以下环境变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">\"<span class=\"variable\">$HOME</span>/.nvm\"</span></span><br><span class=\"line\">[ -s <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> ] &amp;&amp; \\. <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span>  <span class=\"comment\"># This loads nvm</span></span><br><span class=\"line\">[ -s <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/bash_completion\"</span> ] &amp;&amp; \\. <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/bash_completion\"</span>  <span class=\"comment\"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure>\n<p>添加完之后用以下命令使其生效</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>执行<code>nvm</code>命令查看是否安装成功</p>\n<h4 id=\"nvm更新node版本\"><a href=\"#nvm更新node版本\" class=\"headerlink\" title=\"nvm更新node版本\"></a>nvm更新node版本</h4><p>因为node版本较低，接下来要使用nvm更新node版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install 8.11.1</span><br><span class=\"line\">nvm use 8.11.1</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、安装verdaccio\"><a href=\"#2、安装verdaccio\" class=\"headerlink\" title=\"2、安装verdaccio\"></a>2、安装verdaccio</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g verdaccio --unsafe-perm</span><br></pre></td></tr></table></figure>\n<p>加上–unsafe-perm选项是为了防止gyp ERR! permission denied权限问题报错，如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gyp ERR! configure error</span><br><span class=\"line\">gyp ERR! stack Error: EACCES: permission denied, mkdir '/usr/local/lib/node_modules/verdaccio/node_modules/dtrace-provider/build'</span><br><span class=\"line\">gyp ERR! System Linux 3.10.0-862.14.4.el7.x86_64</span><br><span class=\"line\">gyp ERR! command \"/usr/local/bin/node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"</span><br><span class=\"line\">gyp ERR! cwd /usr/local/lib/node_modules/verdaccio/node_modules/dtrace-provider</span><br><span class=\"line\">gyp ERR! node -v v8.12.0</span><br><span class=\"line\">gyp ERR! node-gyp -v v3.8.0</span><br><span class=\"line\">gyp ERR! not ok</span><br></pre></td></tr></table></figure>\n<p>如果出现需要更新npm，执行 <code>npm install -g npm</code>即可</p>\n<h3 id=\"3、启动verdaccio\"><a href=\"#3、启动verdaccio\" class=\"headerlink\" title=\"3、启动verdaccio\"></a>3、启动verdaccio</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">verdaccio</span><br></pre></td></tr></table></figure>\n<p>执行结果如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Verdaccio doesn't need superuser privileges. Don't run it under root.</span><br><span class=\"line\"> warn --- config file  - /root/.config/verdaccio/config.yaml</span><br><span class=\"line\"> warn --- Plugin successfully loaded: htpasswd</span><br><span class=\"line\"> warn --- Plugin successfully loaded: audit</span><br><span class=\"line\"> warn --- http address - http://localhost:4873/ - verdaccio/3.10.2</span><br></pre></td></tr></table></figure>\n<p>从控制台我们可以看到verdaccio的配置文件<code>config.yaml</code>和默认的访问地址<code>http://localhost:4873/</code>，我们需要在配置文件中添加 <code>listen: 0.0.0.0:4873</code>才能使4873的端口可以访问，看到web端的管理页面</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入verdaccio 目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /root/.config/verdaccio/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看该目录下的文件，该目录默认有两个文件，config.yaml和storage，config.yaml 是配置文件，storage是代码仓库，上传和下载的库都存放在这个文件夹下</span></span><br><span class=\"line\">ls</span><br><span class=\"line\">&gt; config.yaml  storage</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑配置文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">vim config.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在配置文件末尾添加代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">listen: 0.0.0.0:4873</span><br></pre></td></tr></table></figure>\n<p>因为国内网络环境的原因，我们可能还需要将npm的源改为淘宝源，配置也在<code>config.yaml</code>中修改</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># a list of other known repositories we can talk to</span></span><br><span class=\"line\"><span class=\"attr\">uplinks:</span></span><br><span class=\"line\"><span class=\"attr\">  npmjs:</span></span><br><span class=\"line\"><span class=\"attr\">    url:</span> <span class=\"attr\">https://registry.npm.taobao.org/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4、使用pm2启动verdaccio\"><a href=\"#4、使用pm2启动verdaccio\" class=\"headerlink\" title=\"4、使用pm2启动verdaccio\"></a>4、使用pm2启动verdaccio</h3><p>为了使程序一直处于打开状态，我们用pm2来启动我们的程序。</p>\n<p>安装pm2</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g pm2 --unsafe-perm</span><br></pre></td></tr></table></figure>\n<p>使用pm2启动verdaccio</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start verdaccio</span><br></pre></td></tr></table></figure>\n<h3 id=\"5、访问搭建好的私有仓库\"><a href=\"#5、访问搭建好的私有仓库\" class=\"headerlink\" title=\"5、访问搭建好的私有仓库\"></a>5、访问搭建好的私有仓库</h3><p>在浏览器中打开 <a href=\"http://localhost:4873，\" target=\"_blank\" rel=\"noopener\">http://localhost:4873，</a> 如果能正常访问则说明已经搭建成功，如图：</p>\n<p><img src=\"https://img.fengjr.com/image/2019/07/10/0bf4d65010fb8b329f91edee91f606e5.png\" alt></p>\n<h2 id=\"客户端上传npm到私有仓库\"><a href=\"#客户端上传npm到私有仓库\" class=\"headerlink\" title=\"客户端上传npm到私有仓库\"></a>客户端上传npm到私有仓库</h2><p>搭建好服务器之后，接下来就是怎么使用客户端上传包到私有的仓库。</p>\n<p>首先需要这册一个npm账号，参考文章<a href=\"http://liaolongdong.com/2019/01/24/publish-public-npm.html\" target=\"_blank\" rel=\"noopener\">如何开发一个npm包并发布到npm中央仓库</a></p>\n<h3 id=\"1、登陆\"><a href=\"#1、登陆\" class=\"headerlink\" title=\"1、登陆\"></a>1、登陆</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm adduser --registry  http://localhost:4873</span><br></pre></td></tr></table></figure>\n<p>输入npm账户名、密码和邮箱：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Username: aaa</span><br><span class=\"line\">Password: </span><br><span class=\"line\">Email: (this IS public) aaa@qq.com</span><br><span class=\"line\">Logged in as aaa on http:/localhost:4873/.</span><br></pre></td></tr></table></figure>\n<p>如果输出<code>Logged in as better1025 on http://localhost:4873/.</code>则代表aaa账号已经成功登陆到 <code>http://localhost:4873/</code> 的私有仓库</p>\n<h3 id=\"2、发布npm包到私有仓库\"><a href=\"#2、发布npm包到私有仓库\" class=\"headerlink\" title=\"2、发布npm包到私有仓库\"></a>2、发布npm包到私有仓库</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 生成npm包，npm version命令用于生成npm包的版本号，verison后可跟三个参数 patch 补丁版本；minor：这个是小修小改；major：是大版本</span></span><br><span class=\"line\">npm version patch</span><br><span class=\"line\">npm publish --registry http://localhost:4873</span><br></pre></td></tr></table></figure>\n<p>发布成功之后查看 <a href=\"http://localhost:4873\" target=\"_blank\" rel=\"noopener\">http://localhost:4873</a> 里已经有了该npm包的信息。</p>\n<h2 id=\"如何使用npm私有仓库源\"><a href=\"#如何使用npm私有仓库源\" class=\"headerlink\" title=\"如何使用npm私有仓库源\"></a>如何使用npm私有仓库源</h2><p>将npm包放在了私有仓库之后，接下来我们还需要使用的时候将该仓库拉下来，</p>\n<h3 id=\"1、更换npm源\"><a href=\"#1、更换npm源\" class=\"headerlink\" title=\"1、更换npm源\"></a>1、更换npm源</h3><p>首先，我们需要切换npm源，切换到我们的私有源上</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm set registry http://localhost:4873</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、下载npm包\"><a href=\"#2、下载npm包\" class=\"headerlink\" title=\"2、下载npm包\"></a>2、下载npm包</h3><p>然后我们执行npm install命令下载上传的包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install demo</span><br></pre></td></tr></table></figure>\n<p>verdaccio会优先找我们私有仓库下载的包，如果没有找到，则会从npm中央仓库下载。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上的步骤，我们已经成功的切换到了私有的npm上，我们可以发现使用verdaccio非常的简单，而且对于发布一些公司内部的公用包也很方便，跟npm体验一样，并且作用域只在公司内部，也避免了安全隐患。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用verdaccio搭建私有npm仓库\"><a href=\"#使用verdaccio搭建私有npm仓库\" class=\"headerlink\" title=\"使用verdaccio搭建私有npm仓库\"></a>使用verdaccio搭建私有npm仓库</h1><p><img src=\"https://img.fengjr.com/image/2019/07/10/c9bedb7017ab78b1bd2b76c6333ed947.png\" alt=\"verdaccio\"></p>\n<h2 id=\"项目背景\"><a href=\"#项目背景\" class=\"headerlink\" title=\"项目背景\"></a>项目背景</h2><p>熟悉前端开发的朋友肯定对npm都有了解，npm是node的包管理工具，我们开发项目的时候都会通过npm来下载开源的公共库，相当方便。我们组内部也有一些公用的代码块，各项目都需要引用这些代码，所以有两个项目就放在了npm源上，因为代码都是封装的一些公用的函数，不涉及任何公司的业务代码，所有就开源了。近期信息科技部在整理的时候发现这些代码，要求我们迁移到公司的私有源上，不能公开，所以有了接下来我们要做的事情 —— 搭建私有npm仓库。</p>\n<h2 id=\"为什么选择verdaccio\"><a href=\"#为什么选择verdaccio\" class=\"headerlink\" title=\"为什么选择verdaccio\"></a>为什么选择verdaccio</h2><p>前期调研了一段时间，发现可选的方案有以下几种，下面介绍一下它们的主要区别：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/80b88104ec1f\" target=\"_blank\" rel=\"noopener\">使用cnpm搭建npm私有仓库</a>，阿里的解决方案，缺点是需要搭建MySQL数据库，配置较麻烦，安装配置需要都切换到cnpm上，现有改动略大</li>\n<li>使用github作为私有仓库，原理是在项目里面引用另一个github仓库，有更新时，只需要要pull一下即可(pc目前有些是这么做的，不对的欢迎补充)，缺点就是两个项目有独立的分支，独立的github仓库，管理麻烦，仓库有更新，不仅需要<code>npm install</code>，还需要进入仓库目录<code>pull</code>另一个项目。</li>\n<li><a href=\"https://juejin.im/entry/5c64db9851882562851b328f\" target=\"_blank\" rel=\"noopener\">使用verdaccio搭建私有npm仓库</a>，配置简单，安装非常容易，项目为sinopia的分支，用法和sinopia差不多</li>\n</ul>\n<p>最后决定用一个相对简单的verdaccio试试手，发现使用起来相当方便，还有web页面进行预览。接下来我教大家搭建的流程。</p>\n<h2 id=\"服务器搭建\"><a href=\"#服务器搭建\" class=\"headerlink\" title=\"服务器搭建\"></a>服务器搭建</h2><h3 id=\"1、安装node\"><a href=\"#1、安装node\" class=\"headerlink\" title=\"1、安装node\"></a>1、安装node</h3><p>因为verdaccio 是基于node的，所有我们的服务器需要安装node。<a href=\"https://nodejs.org/zh-cn/download/\" target=\"_blank\" rel=\"noopener\">下载node</a></p>\n<p>因为选取的服务器是Centos7，我详细介绍一下在这个上面安装的教程。</p>\n<h4 id=\"使用EPEL安装node\"><a href=\"#使用EPEL安装node\" class=\"headerlink\" title=\"使用EPEL安装node\"></a>使用EPEL安装node</h4><p>EPEL（Extra Packages for Enterprise Linux）企业版Linux的额外软件包，是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install epel-release</span><br></pre></td></tr></table></figure>\n<p>安装完成之后，就可以使用yum安装node，node和npm一起安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install nodejs</span><br></pre></td></tr></table></figure>\n<p>安装完成之后，验证node是否正确安装 <code>node -v</code>，如果输出以下版本，说明正常安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v6.1.7</span><br></pre></td></tr></table></figure>\n<p>发现安装的node版本过低，对于verdaccio 最新4.0版本的，node版本最低要求为8.0，所以我们需要更新node版本。更新和切换node版本还需要一个我们常用的库，nvm。</p>\n<h4 id=\"安装nvm\"><a href=\"#安装nvm\" class=\"headerlink\" title=\"安装nvm\"></a>安装nvm</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>安装完成后需要在对nvm配置环境变量，配置方法如下：</p>\n<p>进入bash_profile 文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>在末尾增加添加以下环境变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">\"<span class=\"variable\">$HOME</span>/.nvm\"</span></span><br><span class=\"line\">[ -s <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> ] &amp;&amp; \\. <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span>  <span class=\"comment\"># This loads nvm</span></span><br><span class=\"line\">[ -s <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/bash_completion\"</span> ] &amp;&amp; \\. <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/bash_completion\"</span>  <span class=\"comment\"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure>\n<p>添加完之后用以下命令使其生效</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>执行<code>nvm</code>命令查看是否安装成功</p>\n<h4 id=\"nvm更新node版本\"><a href=\"#nvm更新node版本\" class=\"headerlink\" title=\"nvm更新node版本\"></a>nvm更新node版本</h4><p>因为node版本较低，接下来要使用nvm更新node版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install 8.11.1</span><br><span class=\"line\">nvm use 8.11.1</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、安装verdaccio\"><a href=\"#2、安装verdaccio\" class=\"headerlink\" title=\"2、安装verdaccio\"></a>2、安装verdaccio</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g verdaccio --unsafe-perm</span><br></pre></td></tr></table></figure>\n<p>加上–unsafe-perm选项是为了防止gyp ERR! permission denied权限问题报错，如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gyp ERR! configure error</span><br><span class=\"line\">gyp ERR! stack Error: EACCES: permission denied, mkdir '/usr/local/lib/node_modules/verdaccio/node_modules/dtrace-provider/build'</span><br><span class=\"line\">gyp ERR! System Linux 3.10.0-862.14.4.el7.x86_64</span><br><span class=\"line\">gyp ERR! command \"/usr/local/bin/node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"</span><br><span class=\"line\">gyp ERR! cwd /usr/local/lib/node_modules/verdaccio/node_modules/dtrace-provider</span><br><span class=\"line\">gyp ERR! node -v v8.12.0</span><br><span class=\"line\">gyp ERR! node-gyp -v v3.8.0</span><br><span class=\"line\">gyp ERR! not ok</span><br></pre></td></tr></table></figure>\n<p>如果出现需要更新npm，执行 <code>npm install -g npm</code>即可</p>\n<h3 id=\"3、启动verdaccio\"><a href=\"#3、启动verdaccio\" class=\"headerlink\" title=\"3、启动verdaccio\"></a>3、启动verdaccio</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">verdaccio</span><br></pre></td></tr></table></figure>\n<p>执行结果如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Verdaccio doesn't need superuser privileges. Don't run it under root.</span><br><span class=\"line\"> warn --- config file  - /root/.config/verdaccio/config.yaml</span><br><span class=\"line\"> warn --- Plugin successfully loaded: htpasswd</span><br><span class=\"line\"> warn --- Plugin successfully loaded: audit</span><br><span class=\"line\"> warn --- http address - http://localhost:4873/ - verdaccio/3.10.2</span><br></pre></td></tr></table></figure>\n<p>从控制台我们可以看到verdaccio的配置文件<code>config.yaml</code>和默认的访问地址<code>http://localhost:4873/</code>，我们需要在配置文件中添加 <code>listen: 0.0.0.0:4873</code>才能使4873的端口可以访问，看到web端的管理页面</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入verdaccio 目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /root/.config/verdaccio/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看该目录下的文件，该目录默认有两个文件，config.yaml和storage，config.yaml 是配置文件，storage是代码仓库，上传和下载的库都存放在这个文件夹下</span></span><br><span class=\"line\">ls</span><br><span class=\"line\">&gt; config.yaml  storage</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑配置文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">vim config.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在配置文件末尾添加代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">listen: 0.0.0.0:4873</span><br></pre></td></tr></table></figure>\n<p>因为国内网络环境的原因，我们可能还需要将npm的源改为淘宝源，配置也在<code>config.yaml</code>中修改</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># a list of other known repositories we can talk to</span></span><br><span class=\"line\"><span class=\"attr\">uplinks:</span></span><br><span class=\"line\"><span class=\"attr\">  npmjs:</span></span><br><span class=\"line\"><span class=\"attr\">    url:</span> <span class=\"attr\">https://registry.npm.taobao.org/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4、使用pm2启动verdaccio\"><a href=\"#4、使用pm2启动verdaccio\" class=\"headerlink\" title=\"4、使用pm2启动verdaccio\"></a>4、使用pm2启动verdaccio</h3><p>为了使程序一直处于打开状态，我们用pm2来启动我们的程序。</p>\n<p>安装pm2</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g pm2 --unsafe-perm</span><br></pre></td></tr></table></figure>\n<p>使用pm2启动verdaccio</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start verdaccio</span><br></pre></td></tr></table></figure>\n<h3 id=\"5、访问搭建好的私有仓库\"><a href=\"#5、访问搭建好的私有仓库\" class=\"headerlink\" title=\"5、访问搭建好的私有仓库\"></a>5、访问搭建好的私有仓库</h3><p>在浏览器中打开 <a href=\"http://localhost:4873，\" target=\"_blank\" rel=\"noopener\">http://localhost:4873，</a> 如果能正常访问则说明已经搭建成功，如图：</p>\n<p><img src=\"https://img.fengjr.com/image/2019/07/10/0bf4d65010fb8b329f91edee91f606e5.png\" alt></p>\n<h2 id=\"客户端上传npm到私有仓库\"><a href=\"#客户端上传npm到私有仓库\" class=\"headerlink\" title=\"客户端上传npm到私有仓库\"></a>客户端上传npm到私有仓库</h2><p>搭建好服务器之后，接下来就是怎么使用客户端上传包到私有的仓库。</p>\n<p>首先需要这册一个npm账号，参考文章<a href=\"http://liaolongdong.com/2019/01/24/publish-public-npm.html\" target=\"_blank\" rel=\"noopener\">如何开发一个npm包并发布到npm中央仓库</a></p>\n<h3 id=\"1、登陆\"><a href=\"#1、登陆\" class=\"headerlink\" title=\"1、登陆\"></a>1、登陆</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm adduser --registry  http://localhost:4873</span><br></pre></td></tr></table></figure>\n<p>输入npm账户名、密码和邮箱：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Username: aaa</span><br><span class=\"line\">Password: </span><br><span class=\"line\">Email: (this IS public) aaa@qq.com</span><br><span class=\"line\">Logged in as aaa on http:/localhost:4873/.</span><br></pre></td></tr></table></figure>\n<p>如果输出<code>Logged in as better1025 on http://localhost:4873/.</code>则代表aaa账号已经成功登陆到 <code>http://localhost:4873/</code> 的私有仓库</p>\n<h3 id=\"2、发布npm包到私有仓库\"><a href=\"#2、发布npm包到私有仓库\" class=\"headerlink\" title=\"2、发布npm包到私有仓库\"></a>2、发布npm包到私有仓库</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 生成npm包，npm version命令用于生成npm包的版本号，verison后可跟三个参数 patch 补丁版本；minor：这个是小修小改；major：是大版本</span></span><br><span class=\"line\">npm version patch</span><br><span class=\"line\">npm publish --registry http://localhost:4873</span><br></pre></td></tr></table></figure>\n<p>发布成功之后查看 <a href=\"http://localhost:4873\" target=\"_blank\" rel=\"noopener\">http://localhost:4873</a> 里已经有了该npm包的信息。</p>\n<h2 id=\"如何使用npm私有仓库源\"><a href=\"#如何使用npm私有仓库源\" class=\"headerlink\" title=\"如何使用npm私有仓库源\"></a>如何使用npm私有仓库源</h2><p>将npm包放在了私有仓库之后，接下来我们还需要使用的时候将该仓库拉下来，</p>\n<h3 id=\"1、更换npm源\"><a href=\"#1、更换npm源\" class=\"headerlink\" title=\"1、更换npm源\"></a>1、更换npm源</h3><p>首先，我们需要切换npm源，切换到我们的私有源上</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm set registry http://localhost:4873</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、下载npm包\"><a href=\"#2、下载npm包\" class=\"headerlink\" title=\"2、下载npm包\"></a>2、下载npm包</h3><p>然后我们执行npm install命令下载上传的包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install demo</span><br></pre></td></tr></table></figure>\n<p>verdaccio会优先找我们私有仓库下载的包，如果没有找到，则会从npm中央仓库下载。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过以上的步骤，我们已经成功的切换到了私有的npm上，我们可以发现使用verdaccio非常的简单，而且对于发布一些公司内部的公用包也很方便，跟npm体验一样，并且作用域只在公司内部，也避免了安全隐患。</p>\n"},{"title":"Generator函数的特征及应用","comments":1,"date":"2019-07-12T08:20:11.000Z","author":"jun.zhou","_content":"\n\n![](https://img.fengjr.com/image/2019/07/12/65874791cbf960f60b71541ee3f5bff2.jpeg)\n\n# 一、Generator 函数简介\n\n1、Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\n2、Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n\n3、执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n\n# 二、Generator 函数特征\n\n#### 两个特征：\n1、function关键字与函数名之间有一个星号\n2、函数体内部使用yield表达式，定义不同的内部状态\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n\n```\n\n#### 调用方法：\n\n1、调用 Generator 函数后，该函数并不执行\n2、返回的也不是函数运行结果，而是一个指向内部状态的指针对象\n\n```\nhw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }\n\n```\n\n#### for...of 循环：\n\nfor...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。\n\n```\nfunction* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n\n```\n\n\n```\nfunction* numbers () {\n  yield 1\n  yield 2\n  return 3\n  yield 4\n}\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// Array.from 方法\nArray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) {\n  console.log(n)\n}\n// 1\n// 2\n\n```\n\n#### yield* 表达式：\n\n如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。\n\n```\nfunction* iterTree(tree) {\n  if (Array.isArray(tree)) {\n    for(let i=0; i < tree.length; i++) {\n      yield* iterTree(tree[i]);\n    }\n  } else {\n    yield tree;\n  }\n}\n\nconst tree = [ 'a', ['b', 'c'], ['d', 'e'] ];\n\nfor(let x of iterTree(tree)) {\n  console.log(x);\n}\n// a\n// b\n// c\n// d\n// e\n\n```\n\n# 三、Generator 函数应用\n\n#### 异步操作的同步化表达：\n\nGenerator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。\n\n```\nfunction* loadUI() {\n  showLoadingScreen();\n  yield loadUIDataAsynchronously();\n  hideLoadingScreen();\n}\nvar loader = loadUI();\n// 加载UI\nloader.next()\n\n// 卸载UI\nloader.next()\n\n```\n\n#### 控制流管理：\n\n如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。\n\n```\nstep1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // Do something with value4\n      });\n    });\n  });\n});\n\n```\n\n采用 Promise 改写上面的代码。\n\n```\nPromise.resolve(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(function (value4) {\n    // Do something with value4\n  }, function (error) {\n    // Handle any error from step1 through step4\n  })\n  .done();\n```\n\n上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。\n\n```\nfunction* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n```\n\n然后，使用一个函数，按次序自动执行所有步骤。\n\n```\nscheduler(longRunningTask(initialValue));\n\nfunction scheduler(task) {\n  var taskObj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!taskObj.done) {\n    task.value = taskObj.value\n    scheduler(task);\n  }\n}\n\n```\n\n#### async 函数：\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n```\nfunction timeout(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n\n```\n\n#### async 函数优点：\n\n1、**内置执行器**\nGenerator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。这完全不像 Generator 函数，需要调用next方法，才能真正执行，得到最后结果。\n\n2、**更好的语义**\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n3、**更广的适用性**\nyield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）\n\n4、**返回 Promise**\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n# 项目实例\n\n#### 抽奖\n\n```\n<button onclick=\"starts()\">抽奖</button>\n<script>\n  //定义一个普通函数,输出剩余次数\n  let draw = function (count) {\n      alert(`剩余 ${count} 次`)\n  }\n  //定义一个Generator函数，接收一个count参数，每次调用都减少1\n  let resize = function* (count) {\n      while (count > 0){\n          count -- ;\n          yield draw(count) //调用draw函数，输出count\n      }\n  }\n  //调用resize 函数，初始化count为5，此时resize 函数并不会执行。\n  let start = resize(5);\n  function starts() {\n      start.next()//通过点击按钮，调用resize 的next方法执行函数体，执行一次便暂停一次\n  }\n\n```\n\n#### 长轮训\n\n```\nlet ajax = function* () {\n    yield new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve({code:1})\n        },500)\n    })\n}\nlet pull = function () {\n    let genertaor = ajax();\n    let step = genertaor.next();\n    step.value.then(function (res) {\n        if(res.code != 0){\n            console.log(res)\n            setTimeout(function () {\n                pull();\n            },1000)\n        }else{\n            console.log(res)\n        }\n    })\n}\npull();\n\n```\n\n","source":"_posts/2019-07-12-generator.md","raw":"---\ntitle: Generator函数的特征及应用\ncomments: true\ndate: 2019-07-12 16:20:11\ntags:\n- es6\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n\n![](https://img.fengjr.com/image/2019/07/12/65874791cbf960f60b71541ee3f5bff2.jpeg)\n\n# 一、Generator 函数简介\n\n1、Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\n2、Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n\n3、执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n\n# 二、Generator 函数特征\n\n#### 两个特征：\n1、function关键字与函数名之间有一个星号\n2、函数体内部使用yield表达式，定义不同的内部状态\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n\n```\n\n#### 调用方法：\n\n1、调用 Generator 函数后，该函数并不执行\n2、返回的也不是函数运行结果，而是一个指向内部状态的指针对象\n\n```\nhw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }\n\n```\n\n#### for...of 循环：\n\nfor...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。\n\n```\nfunction* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n\n```\n\n\n```\nfunction* numbers () {\n  yield 1\n  yield 2\n  return 3\n  yield 4\n}\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// Array.from 方法\nArray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) {\n  console.log(n)\n}\n// 1\n// 2\n\n```\n\n#### yield* 表达式：\n\n如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。\n\n```\nfunction* iterTree(tree) {\n  if (Array.isArray(tree)) {\n    for(let i=0; i < tree.length; i++) {\n      yield* iterTree(tree[i]);\n    }\n  } else {\n    yield tree;\n  }\n}\n\nconst tree = [ 'a', ['b', 'c'], ['d', 'e'] ];\n\nfor(let x of iterTree(tree)) {\n  console.log(x);\n}\n// a\n// b\n// c\n// d\n// e\n\n```\n\n# 三、Generator 函数应用\n\n#### 异步操作的同步化表达：\n\nGenerator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。\n\n```\nfunction* loadUI() {\n  showLoadingScreen();\n  yield loadUIDataAsynchronously();\n  hideLoadingScreen();\n}\nvar loader = loadUI();\n// 加载UI\nloader.next()\n\n// 卸载UI\nloader.next()\n\n```\n\n#### 控制流管理：\n\n如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。\n\n```\nstep1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // Do something with value4\n      });\n    });\n  });\n});\n\n```\n\n采用 Promise 改写上面的代码。\n\n```\nPromise.resolve(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(function (value4) {\n    // Do something with value4\n  }, function (error) {\n    // Handle any error from step1 through step4\n  })\n  .done();\n```\n\n上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。\n\n```\nfunction* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n```\n\n然后，使用一个函数，按次序自动执行所有步骤。\n\n```\nscheduler(longRunningTask(initialValue));\n\nfunction scheduler(task) {\n  var taskObj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!taskObj.done) {\n    task.value = taskObj.value\n    scheduler(task);\n  }\n}\n\n```\n\n#### async 函数：\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n```\nfunction timeout(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n\n```\n\n#### async 函数优点：\n\n1、**内置执行器**\nGenerator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。这完全不像 Generator 函数，需要调用next方法，才能真正执行，得到最后结果。\n\n2、**更好的语义**\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n3、**更广的适用性**\nyield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）\n\n4、**返回 Promise**\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n# 项目实例\n\n#### 抽奖\n\n```\n<button onclick=\"starts()\">抽奖</button>\n<script>\n  //定义一个普通函数,输出剩余次数\n  let draw = function (count) {\n      alert(`剩余 ${count} 次`)\n  }\n  //定义一个Generator函数，接收一个count参数，每次调用都减少1\n  let resize = function* (count) {\n      while (count > 0){\n          count -- ;\n          yield draw(count) //调用draw函数，输出count\n      }\n  }\n  //调用resize 函数，初始化count为5，此时resize 函数并不会执行。\n  let start = resize(5);\n  function starts() {\n      start.next()//通过点击按钮，调用resize 的next方法执行函数体，执行一次便暂停一次\n  }\n\n```\n\n#### 长轮训\n\n```\nlet ajax = function* () {\n    yield new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve({code:1})\n        },500)\n    })\n}\nlet pull = function () {\n    let genertaor = ajax();\n    let step = genertaor.next();\n    step.value.then(function (res) {\n        if(res.code != 0){\n            console.log(res)\n            setTimeout(function () {\n                pull();\n            },1000)\n        }else{\n            console.log(res)\n        }\n    })\n}\npull();\n\n```\n\n","slug":"generator","published":1,"updated":"2020-06-10T06:01:57.015Z","_id":"ck2yl0qbl0003h6q66qt9tom5","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/07/12/65874791cbf960f60b71541ee3f5bff2.jpeg\" alt></p>\n<h1 id=\"一、Generator-函数简介\"><a href=\"#一、Generator-函数简介\" class=\"headerlink\" title=\"一、Generator 函数简介\"></a>一、Generator 函数简介</h1><p>1、Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>\n<p>2、Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>\n<p>3、执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>\n<h1 id=\"二、Generator-函数特征\"><a href=\"#二、Generator-函数特征\" class=\"headerlink\" title=\"二、Generator 函数特征\"></a>二、Generator 函数特征</h1><h4 id=\"两个特征：\"><a href=\"#两个特征：\" class=\"headerlink\" title=\"两个特征：\"></a>两个特征：</h4><p>1、function关键字与函数名之间有一个星号<br>2、函数体内部使用yield表达式，定义不同的内部状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloWorldGenerator() &#123;</span><br><span class=\"line\">  yield &apos;hello&apos;;</span><br><span class=\"line\">  yield &apos;world&apos;;</span><br><span class=\"line\">  return &apos;ending&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>\n<h4 id=\"调用方法：\"><a href=\"#调用方法：\" class=\"headerlink\" title=\"调用方法：\"></a>调用方法：</h4><p>1、调用 Generator 函数后，该函数并不执行<br>2、返回的也不是函数运行结果，而是一个指向内部状态的指针对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw.next()</span><br><span class=\"line\">// &#123; value: &apos;hello&apos;, done: false &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\">// &#123; value: &apos;world&apos;, done: false &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\">// &#123; value: &apos;ending&apos;, done: true &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\">// &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"for…of-循环：\"><a href=\"#for…of-循环：\" class=\"headerlink\" title=\"for…of 循环：\"></a>for…of 循环：</h4><p>for…of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* foo() &#123;</span><br><span class=\"line\">  yield 1;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">  yield 4;</span><br><span class=\"line\">  yield 5;</span><br><span class=\"line\">  return 6;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let v of foo()) &#123;</span><br><span class=\"line\">  console.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* numbers () &#123;</span><br><span class=\"line\">  yield 1</span><br><span class=\"line\">  yield 2</span><br><span class=\"line\">  return 3</span><br><span class=\"line\">  yield 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 扩展运算符</span><br><span class=\"line\">[...numbers()] // [1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">// Array.from 方法</span><br><span class=\"line\">Array.from(numbers()) // [1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">// 解构赋值</span><br><span class=\"line\">let [x, y] = numbers();</span><br><span class=\"line\">x // 1</span><br><span class=\"line\">y // 2</span><br><span class=\"line\"></span><br><span class=\"line\">// for...of 循环</span><br><span class=\"line\">for (let n of numbers()) &#123;</span><br><span class=\"line\">  console.log(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"yield-表达式：\"><a href=\"#yield-表达式：\" class=\"headerlink\" title=\"yield* 表达式：\"></a>yield* 表达式：</h4><p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* iterTree(tree) &#123;</span><br><span class=\"line\">  if (Array.isArray(tree)) &#123;</span><br><span class=\"line\">    for(let i=0; i &lt; tree.length; i++) &#123;</span><br><span class=\"line\">      yield* iterTree(tree[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    yield tree;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const tree = [ &apos;a&apos;, [&apos;b&apos;, &apos;c&apos;], [&apos;d&apos;, &apos;e&apos;] ];</span><br><span class=\"line\"></span><br><span class=\"line\">for(let x of iterTree(tree)) &#123;</span><br><span class=\"line\">  console.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// a</span><br><span class=\"line\">// b</span><br><span class=\"line\">// c</span><br><span class=\"line\">// d</span><br><span class=\"line\">// e</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、Generator-函数应用\"><a href=\"#三、Generator-函数应用\" class=\"headerlink\" title=\"三、Generator 函数应用\"></a>三、Generator 函数应用</h1><h4 id=\"异步操作的同步化表达：\"><a href=\"#异步操作的同步化表达：\" class=\"headerlink\" title=\"异步操作的同步化表达：\"></a>异步操作的同步化表达：</h4><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* loadUI() &#123;</span><br><span class=\"line\">  showLoadingScreen();</span><br><span class=\"line\">  yield loadUIDataAsynchronously();</span><br><span class=\"line\">  hideLoadingScreen();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var loader = loadUI();</span><br><span class=\"line\">// 加载UI</span><br><span class=\"line\">loader.next()</span><br><span class=\"line\"></span><br><span class=\"line\">// 卸载UI</span><br><span class=\"line\">loader.next()</span><br></pre></td></tr></table></figure>\n<h4 id=\"控制流管理：\"><a href=\"#控制流管理：\" class=\"headerlink\" title=\"控制流管理：\"></a>控制流管理：</h4><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1(function (value1) &#123;</span><br><span class=\"line\">  step2(value1, function(value2) &#123;</span><br><span class=\"line\">    step3(value2, function(value3) &#123;</span><br><span class=\"line\">      step4(value3, function(value4) &#123;</span><br><span class=\"line\">        // Do something with value4</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>采用 Promise 改写上面的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(step1)</span><br><span class=\"line\">  .then(step2)</span><br><span class=\"line\">  .then(step3)</span><br><span class=\"line\">  .then(step4)</span><br><span class=\"line\">  .then(function (value4) &#123;</span><br><span class=\"line\">    // Do something with value4</span><br><span class=\"line\">  &#125;, function (error) &#123;</span><br><span class=\"line\">    // Handle any error from step1 through step4</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .done();</span><br></pre></td></tr></table></figure>\n<p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* longRunningTask(value1) &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    var value2 = yield step1(value1);</span><br><span class=\"line\">    var value3 = yield step2(value2);</span><br><span class=\"line\">    var value4 = yield step3(value3);</span><br><span class=\"line\">    var value5 = yield step4(value4);</span><br><span class=\"line\">    // Do something with value4</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    // Handle any error from step1 through step4</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，使用一个函数，按次序自动执行所有步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheduler(longRunningTask(initialValue));</span><br><span class=\"line\"></span><br><span class=\"line\">function scheduler(task) &#123;</span><br><span class=\"line\">  var taskObj = task.next(task.value);</span><br><span class=\"line\">  // 如果Generator函数未结束，就继续调用</span><br><span class=\"line\">  if (!taskObj.done) &#123;</span><br><span class=\"line\">    task.value = taskObj.value</span><br><span class=\"line\">    scheduler(task);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"async-函数：\"><a href=\"#async-函数：\" class=\"headerlink\" title=\"async 函数：\"></a>async 函数：</h4><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function timeout(ms) &#123;</span><br><span class=\"line\">  return new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">async function asyncPrint(value, ms) &#123;</span><br><span class=\"line\">  await timeout(ms);</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(&apos;hello world&apos;, 50);</span><br></pre></td></tr></table></figure>\n<h4 id=\"async-函数优点：\"><a href=\"#async-函数优点：\" class=\"headerlink\" title=\"async 函数优点：\"></a>async 函数优点：</h4><p>1、<strong>内置执行器</strong><br>Generator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。这完全不像 Generator 函数，需要调用next方法，才能真正执行，得到最后结果。</p>\n<p>2、<strong>更好的语义</strong><br>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>\n<p>3、<strong>更广的适用性</strong><br>yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）</p>\n<p>4、<strong>返回 Promise</strong><br>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>\n<h1 id=\"项目实例\"><a href=\"#项目实例\" class=\"headerlink\" title=\"项目实例\"></a>项目实例</h1><h4 id=\"抽奖\"><a href=\"#抽奖\" class=\"headerlink\" title=\"抽奖\"></a>抽奖</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onclick=&quot;starts()&quot;&gt;抽奖&lt;/button&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  //定义一个普通函数,输出剩余次数</span><br><span class=\"line\">  let draw = function (count) &#123;</span><br><span class=\"line\">      alert(`剩余 $&#123;count&#125; 次`)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  //定义一个Generator函数，接收一个count参数，每次调用都减少1</span><br><span class=\"line\">  let resize = function* (count) &#123;</span><br><span class=\"line\">      while (count &gt; 0)&#123;</span><br><span class=\"line\">          count -- ;</span><br><span class=\"line\">          yield draw(count) //调用draw函数，输出count</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  //调用resize 函数，初始化count为5，此时resize 函数并不会执行。</span><br><span class=\"line\">  let start = resize(5);</span><br><span class=\"line\">  function starts() &#123;</span><br><span class=\"line\">      start.next()//通过点击按钮，调用resize 的next方法执行函数体，执行一次便暂停一次</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"长轮训\"><a href=\"#长轮训\" class=\"headerlink\" title=\"长轮训\"></a>长轮训</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ajax = function* () &#123;</span><br><span class=\"line\">    yield new Promise(function (resolve, reject) &#123;</span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">            resolve(&#123;code:1&#125;)</span><br><span class=\"line\">        &#125;,500)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let pull = function () &#123;</span><br><span class=\"line\">    let genertaor = ajax();</span><br><span class=\"line\">    let step = genertaor.next();</span><br><span class=\"line\">    step.value.then(function (res) &#123;</span><br><span class=\"line\">        if(res.code != 0)&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">            setTimeout(function () &#123;</span><br><span class=\"line\">                pull();</span><br><span class=\"line\">            &#125;,1000)</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pull();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/07/12/65874791cbf960f60b71541ee3f5bff2.jpeg\" alt></p>\n<h1 id=\"一、Generator-函数简介\"><a href=\"#一、Generator-函数简介\" class=\"headerlink\" title=\"一、Generator 函数简介\"></a>一、Generator 函数简介</h1><p>1、Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>\n<p>2、Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>\n<p>3、执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>\n<h1 id=\"二、Generator-函数特征\"><a href=\"#二、Generator-函数特征\" class=\"headerlink\" title=\"二、Generator 函数特征\"></a>二、Generator 函数特征</h1><h4 id=\"两个特征：\"><a href=\"#两个特征：\" class=\"headerlink\" title=\"两个特征：\"></a>两个特征：</h4><p>1、function关键字与函数名之间有一个星号<br>2、函数体内部使用yield表达式，定义不同的内部状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloWorldGenerator() &#123;</span><br><span class=\"line\">  yield &apos;hello&apos;;</span><br><span class=\"line\">  yield &apos;world&apos;;</span><br><span class=\"line\">  return &apos;ending&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>\n<h4 id=\"调用方法：\"><a href=\"#调用方法：\" class=\"headerlink\" title=\"调用方法：\"></a>调用方法：</h4><p>1、调用 Generator 函数后，该函数并不执行<br>2、返回的也不是函数运行结果，而是一个指向内部状态的指针对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw.next()</span><br><span class=\"line\">// &#123; value: &apos;hello&apos;, done: false &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\">// &#123; value: &apos;world&apos;, done: false &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\">// &#123; value: &apos;ending&apos;, done: true &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\">// &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"for…of-循环：\"><a href=\"#for…of-循环：\" class=\"headerlink\" title=\"for…of 循环：\"></a>for…of 循环：</h4><p>for…of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* foo() &#123;</span><br><span class=\"line\">  yield 1;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">  yield 4;</span><br><span class=\"line\">  yield 5;</span><br><span class=\"line\">  return 6;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let v of foo()) &#123;</span><br><span class=\"line\">  console.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* numbers () &#123;</span><br><span class=\"line\">  yield 1</span><br><span class=\"line\">  yield 2</span><br><span class=\"line\">  return 3</span><br><span class=\"line\">  yield 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 扩展运算符</span><br><span class=\"line\">[...numbers()] // [1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">// Array.from 方法</span><br><span class=\"line\">Array.from(numbers()) // [1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">// 解构赋值</span><br><span class=\"line\">let [x, y] = numbers();</span><br><span class=\"line\">x // 1</span><br><span class=\"line\">y // 2</span><br><span class=\"line\"></span><br><span class=\"line\">// for...of 循环</span><br><span class=\"line\">for (let n of numbers()) &#123;</span><br><span class=\"line\">  console.log(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"yield-表达式：\"><a href=\"#yield-表达式：\" class=\"headerlink\" title=\"yield* 表达式：\"></a>yield* 表达式：</h4><p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* iterTree(tree) &#123;</span><br><span class=\"line\">  if (Array.isArray(tree)) &#123;</span><br><span class=\"line\">    for(let i=0; i &lt; tree.length; i++) &#123;</span><br><span class=\"line\">      yield* iterTree(tree[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    yield tree;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const tree = [ &apos;a&apos;, [&apos;b&apos;, &apos;c&apos;], [&apos;d&apos;, &apos;e&apos;] ];</span><br><span class=\"line\"></span><br><span class=\"line\">for(let x of iterTree(tree)) &#123;</span><br><span class=\"line\">  console.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// a</span><br><span class=\"line\">// b</span><br><span class=\"line\">// c</span><br><span class=\"line\">// d</span><br><span class=\"line\">// e</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、Generator-函数应用\"><a href=\"#三、Generator-函数应用\" class=\"headerlink\" title=\"三、Generator 函数应用\"></a>三、Generator 函数应用</h1><h4 id=\"异步操作的同步化表达：\"><a href=\"#异步操作的同步化表达：\" class=\"headerlink\" title=\"异步操作的同步化表达：\"></a>异步操作的同步化表达：</h4><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* loadUI() &#123;</span><br><span class=\"line\">  showLoadingScreen();</span><br><span class=\"line\">  yield loadUIDataAsynchronously();</span><br><span class=\"line\">  hideLoadingScreen();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var loader = loadUI();</span><br><span class=\"line\">// 加载UI</span><br><span class=\"line\">loader.next()</span><br><span class=\"line\"></span><br><span class=\"line\">// 卸载UI</span><br><span class=\"line\">loader.next()</span><br></pre></td></tr></table></figure>\n<h4 id=\"控制流管理：\"><a href=\"#控制流管理：\" class=\"headerlink\" title=\"控制流管理：\"></a>控制流管理：</h4><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1(function (value1) &#123;</span><br><span class=\"line\">  step2(value1, function(value2) &#123;</span><br><span class=\"line\">    step3(value2, function(value3) &#123;</span><br><span class=\"line\">      step4(value3, function(value4) &#123;</span><br><span class=\"line\">        // Do something with value4</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>采用 Promise 改写上面的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(step1)</span><br><span class=\"line\">  .then(step2)</span><br><span class=\"line\">  .then(step3)</span><br><span class=\"line\">  .then(step4)</span><br><span class=\"line\">  .then(function (value4) &#123;</span><br><span class=\"line\">    // Do something with value4</span><br><span class=\"line\">  &#125;, function (error) &#123;</span><br><span class=\"line\">    // Handle any error from step1 through step4</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .done();</span><br></pre></td></tr></table></figure>\n<p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* longRunningTask(value1) &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    var value2 = yield step1(value1);</span><br><span class=\"line\">    var value3 = yield step2(value2);</span><br><span class=\"line\">    var value4 = yield step3(value3);</span><br><span class=\"line\">    var value5 = yield step4(value4);</span><br><span class=\"line\">    // Do something with value4</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    // Handle any error from step1 through step4</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，使用一个函数，按次序自动执行所有步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheduler(longRunningTask(initialValue));</span><br><span class=\"line\"></span><br><span class=\"line\">function scheduler(task) &#123;</span><br><span class=\"line\">  var taskObj = task.next(task.value);</span><br><span class=\"line\">  // 如果Generator函数未结束，就继续调用</span><br><span class=\"line\">  if (!taskObj.done) &#123;</span><br><span class=\"line\">    task.value = taskObj.value</span><br><span class=\"line\">    scheduler(task);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"async-函数：\"><a href=\"#async-函数：\" class=\"headerlink\" title=\"async 函数：\"></a>async 函数：</h4><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function timeout(ms) &#123;</span><br><span class=\"line\">  return new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">async function asyncPrint(value, ms) &#123;</span><br><span class=\"line\">  await timeout(ms);</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(&apos;hello world&apos;, 50);</span><br></pre></td></tr></table></figure>\n<h4 id=\"async-函数优点：\"><a href=\"#async-函数优点：\" class=\"headerlink\" title=\"async 函数优点：\"></a>async 函数优点：</h4><p>1、<strong>内置执行器</strong><br>Generator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。这完全不像 Generator 函数，需要调用next方法，才能真正执行，得到最后结果。</p>\n<p>2、<strong>更好的语义</strong><br>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>\n<p>3、<strong>更广的适用性</strong><br>yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）</p>\n<p>4、<strong>返回 Promise</strong><br>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>\n<h1 id=\"项目实例\"><a href=\"#项目实例\" class=\"headerlink\" title=\"项目实例\"></a>项目实例</h1><h4 id=\"抽奖\"><a href=\"#抽奖\" class=\"headerlink\" title=\"抽奖\"></a>抽奖</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onclick=&quot;starts()&quot;&gt;抽奖&lt;/button&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  //定义一个普通函数,输出剩余次数</span><br><span class=\"line\">  let draw = function (count) &#123;</span><br><span class=\"line\">      alert(`剩余 $&#123;count&#125; 次`)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  //定义一个Generator函数，接收一个count参数，每次调用都减少1</span><br><span class=\"line\">  let resize = function* (count) &#123;</span><br><span class=\"line\">      while (count &gt; 0)&#123;</span><br><span class=\"line\">          count -- ;</span><br><span class=\"line\">          yield draw(count) //调用draw函数，输出count</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  //调用resize 函数，初始化count为5，此时resize 函数并不会执行。</span><br><span class=\"line\">  let start = resize(5);</span><br><span class=\"line\">  function starts() &#123;</span><br><span class=\"line\">      start.next()//通过点击按钮，调用resize 的next方法执行函数体，执行一次便暂停一次</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"长轮训\"><a href=\"#长轮训\" class=\"headerlink\" title=\"长轮训\"></a>长轮训</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ajax = function* () &#123;</span><br><span class=\"line\">    yield new Promise(function (resolve, reject) &#123;</span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">            resolve(&#123;code:1&#125;)</span><br><span class=\"line\">        &#125;,500)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let pull = function () &#123;</span><br><span class=\"line\">    let genertaor = ajax();</span><br><span class=\"line\">    let step = genertaor.next();</span><br><span class=\"line\">    step.value.then(function (res) &#123;</span><br><span class=\"line\">        if(res.code != 0)&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">            setTimeout(function () &#123;</span><br><span class=\"line\">                pull();</span><br><span class=\"line\">            &#125;,1000)</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pull();</span><br></pre></td></tr></table></figure>\n"},{"title":"Flutter技术研究与应用","comments":1,"date":"2019-07-18T06:45:26.000Z","author":"jun.zhou","_content":"\n# Flutter技术研究与应用\n\n![Flutter](https://img.fengjr.com/image/2019/07/18/181fc116474931e5a98b71d7af165eb0.jpeg)\n\n## 什么是Flutter\n\n### 1、Flutter 的概念\n\nFlutter是Google推出并开源的移动应用开发框架 , 主打跨平台、高保真、高性能 . 开发者可以通过Dart语言开发APP , 一套代码同时运行在 ios 和 Android平台 . Flutter提供了丰富的组件、接口 , 开发者可以很快地为Flutter添加native扩展 . 同时Flutter还是用Native引擎渲染试图, 可以为用户提供良好的体验。\n \n### 2、跨平台自绘引擎\n\nFlutter与用于构建移动应用程序的其他大多数框架不同 , Flutter既不使用WebView , 也不使用操作系统的原生控件 .Flutter使用自己的高性能渲染引擎来绘制widget . 这样不仅可以保证在Android和ios上UI的一致性 , 而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本.\nFlutter使用Skia作为其2D渲染引擎 , Skia是Google的一个2D图形处理函数库 , 包含字型、坐标转换,以及点阵图都有高效能且简洁的表现 , Skia是跨平台的,并提供非常友好的API , 目前Google Chrome浏览器和Android均采用Skia作为其绘制引擎 .\n\n### 3、高性能\n\nFlutter高性能主要由两点来保证 , 首先 , Flutter APP采用Dart语言开发 . Dart在 JIT(即时编译)模式下 , 速度与javaScript基本持平 . 但是 Dart支持 AOT , 当以AOT模式运行时 , javascript便远远追不上 . 其次 , Flutter使用自己的渲染引擎来绘制UI , 布局数据等由Dart语言直接控制,所以在布局过程中不需要像RN那样要在javascript和Native之间通信 , 这在一些滑动和拖动的场景下具有明显优势 , 因为滑动和拖动过程往往都会引起布局变化 , 所以javascript需要和Native之间不停的同步布局信息 , 这和在浏览器中需要javascript频繁操作DOM所带来的问题是一样,都会带来比较可观的性能开销.\n\n### 4、采用Dart语言开发\n\nDart运行时和编译器支持Flutter两个关键特性的组合:\n\n1. 基于JIT的快速开发周期: Flutter在开发阶段采用JIT模式 , 这样就避免了每次改动都需要进行\t\t\t\t编译 , 极大的节省了开发时间;\n2. 基于AOT的发布包: Flutter在发布时可以通过AOT生成高效的ARM代码来确保应用的性能, 而\t\t\t  \t javaScript就不具备该能力.\n\t\t\t\n### 5、Flutter底层架构示意图\n![image](https://img.fengjr.com/image/2019/07/18/3382931996bd356421f0b85b29946c9a.png)\n\n### 6、Flutter Framework\n\n该库是由纯Dart语言实现的, 它实现了一套基础库 , 自底向上 .\n\n底下两层(Foundation 和 Animation 、Painting 、Gestures)在Google的一些视频中被合并为一个Dart UI层 , 对应的是Flutter中的 dart:ui 包 , 它是Flutter引擎暴漏的底层UI库, 提供动画、手势及绘制能留.\n\nRendering层 , 是一个抽象的布局层 , 它依赖dart UI 层 , Rendering层会构建一个UI树 , 当UI树有变化时 , 会计算出有变化的部分, 然后更新UI树 , 最终将UI树绘制到屏幕上 , 这个过程就类似于React中的虚拟DOM . Rendering层是Flutter UI 层框架最核心的部分 , 它除了确定每个Ui元素的位置、大小之外还要进行坐标转换、绘制(调用底层dart:ui).\n\nWidgets层是Flutter提供的一套基础组件库 , 在基础组件库之上 , Flutter还提供了Material和Cupertino两种视觉风格的组件库.\n\n### 7、Flutter Engine\n\n该层是有纯C++实现的SDK , 其中包括了Skia引擎、Dart运行时、文字排版引擎等, 在代码调用 dart:ui 库时, 调用最终会走到Engine层, 然后实现真正的绘制逻辑 . \n\n## 跨平台框架发展历史\n\n目前移动端主流平台主要就Android和iOS两大平台 .  iOS应用程序开发语言:  Object-c 、 Swift  , Android应用程序开发语言:  Java 、Kotlin . 所以开发一个兼顾两个平台的应用程序就得使用两套代码. 为了尽可能复用代码 、节约成本 , 跨平台技术就成了各大公司关注的焦点 . \n\n目前市面上主流的跨平台方案主要有: h5/js + webkit/webview 、 React Native (RN) 、Weex 、Flutter , 目前就凤金app来说已经使用了前两种跨平台技术. 未来我们计划会在财管app中使用Flutter跨平台技术.\n\n### 1、H5 + 原生混合开发\n\n这类框架主要原理是将APP中部分需要变动的内容通过H5来实现,通过原生网页控件加载webview(Android)或WKWebView (ios)来加载 . 这样,H5部分可以随时改变而不用发版,动态化需求能满足 ; 同时, 由于H5代码只需要一次开发,就能同时在Android 和 ios两个平台运行, 也可以减小开发成本 .\n\n由于H5代码主要运行在WebView中, 而WebView实质上就是一个浏览器内核 , 其javascript运行在一个权限受限的沙箱中, 所以对于大多数系统能力都没有访问权限 .对于H5不能实现的功能,就需要原生去做. 所以一般都会在原生代码中预先实现一些访问系统的API, 然后暴漏给WebView以供javaScript来调用.这样WebView就成了javascript与原生API之间通信的桥梁, 主要负责javascript与原生之间传递调用信息 .\n\n### 2、React Native (RN) 跨平台开发\n\nReact Native (RN) 是Facebook于2015年4月开源的跨品台移动应用框架 , 是Facebook 早先开源\n的Ui框架React在原生移动应用平台中的衍生产物 , 支持 iOS 和 Android 两大平台 . 它使用javaScript语言、以及类似于HTML的 JSX 和 CSS 来开发移动应用 , 因此熟悉Web前端开发的技术人员只需要很少的学习即可快速上手.\n\n### 3、Weex\n\nWeex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。\n\n## Flutter基础widget及小案例\n\nFlutter中几乎所有的对象都是Widget , 与原生开发中控件不同的是, Flutter中的Widget概念更加广泛 , 它不仅可以表示Ui元素 , 也可以表示一些功能性组件如:用于手势检测的GestureDetector widget、用于应用主题数据传递的Theme等.\n\n### 基础widgets\n\n`StatelessWidget`:  继承自Widget ,  用于不需要维护状态的场景 , 它通常在build方法中通过嵌套其他widget来构建UI, 在构建过程中会递归的构建其嵌套的Widget . 控件自身的状态不会改变,创建了就直接显示,不会有色值、大小或者其他属性的变化 .\n\n`StatefulWidget`: 同样继承自Widget , 并重写了createElement方法 , 不同的是返回的Element对象并不相同 ; \n\n#### 文本及样式:\n\n- Text: 用于显示简单样式文本,它包含一些控制文本显示样式的一些属性;\n- TextStyle: 用于指定文本显示的样式如颜色、字体、粗细、背景等;\n- TextSpan: Text中所有文本内容只能按同一个样式,如果需要对Text内容中不同部分按照不同样式显示,就需要使用TextSpan。\n\n#### 按钮: \n\n- RaisedButton： 漂浮按钮,默认带有阴影和灰色背景.按下后,阴影会变大。\n- FlatButton：扁平按钮,默认背景透明不带阴影 , 按下后会有背景色。\n- OutlineButton：默认有一个边框,不带阴影且背景透明.按下后 ,边框颜色会变亮、同时出现背景和阴影(较弱)\n- IconButton：是一个可点击的Icon,不包括文字、默认没有背景、点击会出现背景.\n\n#### 图片:       \n\n- ImageProvider：定义了图片数据获取接口load(). 从不同数据源获取图片需要实现不同的ImageProvider \n- AssetImage：加载本地工程目录下的图片\n- NetworkImage：用于加载、显示网络图片\n\n\n#### 单选框\n\nSwitch\n\n#### 复选框\n\nCheckbox\n\n#### 输入框\n\nTextField\n\n#### 表单\n\nForm\n\n### 布局类Widget\n\n布局类Widget都会包含一个或多个widget,不同布局类Widget对子Widget排版方式不同, 布局类Widget就是一个容器。\n\n#### 流式布局(Wrap)\n\n在介绍Row和Column时,如果子Widget超出屏幕范围, 会包溢出错误 . 这是因为超出屏幕不会折行. 我们把超出屏幕显示范围会自动折行的布局称为流式布局 . Flutter中通过Wrap和Flow来支持流式布局.\n\n#### 层叠布局\n\n层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。\n\n### 可滚动Widget\n\n当内容超过显示视口(ViewPort)时，如果没有特殊处理，Flutter则会提示Overflow错误。为此，Flutter提供了多种可滚动widget（Scrollable Widget）用于显示列表和长布局。\n\n#### SingleChildScrollView\n\n类似于Android中的ScrollView, 只能接收一个子Widget。\n\n#### ListView\n\n沿一个方向线性排布所有子Widget \n\n#### GridView\n\n可以构建一个二维网格列表\n\n#### CustomerScrollView\n\n可以包含多种滚动模型\n\n\n\n","source":"_posts/2019-07-18-flutter-introduction.md","raw":"---\ntitle: Flutter技术研究与应用\ncomments: true\ndate: 2019-07-18 14:45:26\ntags:\n- flutter\n- app\n- 跨平台\ncategories:\n- iOS/Android开发\nauthor: jun.zhou\n---\n\n# Flutter技术研究与应用\n\n![Flutter](https://img.fengjr.com/image/2019/07/18/181fc116474931e5a98b71d7af165eb0.jpeg)\n\n## 什么是Flutter\n\n### 1、Flutter 的概念\n\nFlutter是Google推出并开源的移动应用开发框架 , 主打跨平台、高保真、高性能 . 开发者可以通过Dart语言开发APP , 一套代码同时运行在 ios 和 Android平台 . Flutter提供了丰富的组件、接口 , 开发者可以很快地为Flutter添加native扩展 . 同时Flutter还是用Native引擎渲染试图, 可以为用户提供良好的体验。\n \n### 2、跨平台自绘引擎\n\nFlutter与用于构建移动应用程序的其他大多数框架不同 , Flutter既不使用WebView , 也不使用操作系统的原生控件 .Flutter使用自己的高性能渲染引擎来绘制widget . 这样不仅可以保证在Android和ios上UI的一致性 , 而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本.\nFlutter使用Skia作为其2D渲染引擎 , Skia是Google的一个2D图形处理函数库 , 包含字型、坐标转换,以及点阵图都有高效能且简洁的表现 , Skia是跨平台的,并提供非常友好的API , 目前Google Chrome浏览器和Android均采用Skia作为其绘制引擎 .\n\n### 3、高性能\n\nFlutter高性能主要由两点来保证 , 首先 , Flutter APP采用Dart语言开发 . Dart在 JIT(即时编译)模式下 , 速度与javaScript基本持平 . 但是 Dart支持 AOT , 当以AOT模式运行时 , javascript便远远追不上 . 其次 , Flutter使用自己的渲染引擎来绘制UI , 布局数据等由Dart语言直接控制,所以在布局过程中不需要像RN那样要在javascript和Native之间通信 , 这在一些滑动和拖动的场景下具有明显优势 , 因为滑动和拖动过程往往都会引起布局变化 , 所以javascript需要和Native之间不停的同步布局信息 , 这和在浏览器中需要javascript频繁操作DOM所带来的问题是一样,都会带来比较可观的性能开销.\n\n### 4、采用Dart语言开发\n\nDart运行时和编译器支持Flutter两个关键特性的组合:\n\n1. 基于JIT的快速开发周期: Flutter在开发阶段采用JIT模式 , 这样就避免了每次改动都需要进行\t\t\t\t编译 , 极大的节省了开发时间;\n2. 基于AOT的发布包: Flutter在发布时可以通过AOT生成高效的ARM代码来确保应用的性能, 而\t\t\t  \t javaScript就不具备该能力.\n\t\t\t\n### 5、Flutter底层架构示意图\n![image](https://img.fengjr.com/image/2019/07/18/3382931996bd356421f0b85b29946c9a.png)\n\n### 6、Flutter Framework\n\n该库是由纯Dart语言实现的, 它实现了一套基础库 , 自底向上 .\n\n底下两层(Foundation 和 Animation 、Painting 、Gestures)在Google的一些视频中被合并为一个Dart UI层 , 对应的是Flutter中的 dart:ui 包 , 它是Flutter引擎暴漏的底层UI库, 提供动画、手势及绘制能留.\n\nRendering层 , 是一个抽象的布局层 , 它依赖dart UI 层 , Rendering层会构建一个UI树 , 当UI树有变化时 , 会计算出有变化的部分, 然后更新UI树 , 最终将UI树绘制到屏幕上 , 这个过程就类似于React中的虚拟DOM . Rendering层是Flutter UI 层框架最核心的部分 , 它除了确定每个Ui元素的位置、大小之外还要进行坐标转换、绘制(调用底层dart:ui).\n\nWidgets层是Flutter提供的一套基础组件库 , 在基础组件库之上 , Flutter还提供了Material和Cupertino两种视觉风格的组件库.\n\n### 7、Flutter Engine\n\n该层是有纯C++实现的SDK , 其中包括了Skia引擎、Dart运行时、文字排版引擎等, 在代码调用 dart:ui 库时, 调用最终会走到Engine层, 然后实现真正的绘制逻辑 . \n\n## 跨平台框架发展历史\n\n目前移动端主流平台主要就Android和iOS两大平台 .  iOS应用程序开发语言:  Object-c 、 Swift  , Android应用程序开发语言:  Java 、Kotlin . 所以开发一个兼顾两个平台的应用程序就得使用两套代码. 为了尽可能复用代码 、节约成本 , 跨平台技术就成了各大公司关注的焦点 . \n\n目前市面上主流的跨平台方案主要有: h5/js + webkit/webview 、 React Native (RN) 、Weex 、Flutter , 目前就凤金app来说已经使用了前两种跨平台技术. 未来我们计划会在财管app中使用Flutter跨平台技术.\n\n### 1、H5 + 原生混合开发\n\n这类框架主要原理是将APP中部分需要变动的内容通过H5来实现,通过原生网页控件加载webview(Android)或WKWebView (ios)来加载 . 这样,H5部分可以随时改变而不用发版,动态化需求能满足 ; 同时, 由于H5代码只需要一次开发,就能同时在Android 和 ios两个平台运行, 也可以减小开发成本 .\n\n由于H5代码主要运行在WebView中, 而WebView实质上就是一个浏览器内核 , 其javascript运行在一个权限受限的沙箱中, 所以对于大多数系统能力都没有访问权限 .对于H5不能实现的功能,就需要原生去做. 所以一般都会在原生代码中预先实现一些访问系统的API, 然后暴漏给WebView以供javaScript来调用.这样WebView就成了javascript与原生API之间通信的桥梁, 主要负责javascript与原生之间传递调用信息 .\n\n### 2、React Native (RN) 跨平台开发\n\nReact Native (RN) 是Facebook于2015年4月开源的跨品台移动应用框架 , 是Facebook 早先开源\n的Ui框架React在原生移动应用平台中的衍生产物 , 支持 iOS 和 Android 两大平台 . 它使用javaScript语言、以及类似于HTML的 JSX 和 CSS 来开发移动应用 , 因此熟悉Web前端开发的技术人员只需要很少的学习即可快速上手.\n\n### 3、Weex\n\nWeex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。\n\n## Flutter基础widget及小案例\n\nFlutter中几乎所有的对象都是Widget , 与原生开发中控件不同的是, Flutter中的Widget概念更加广泛 , 它不仅可以表示Ui元素 , 也可以表示一些功能性组件如:用于手势检测的GestureDetector widget、用于应用主题数据传递的Theme等.\n\n### 基础widgets\n\n`StatelessWidget`:  继承自Widget ,  用于不需要维护状态的场景 , 它通常在build方法中通过嵌套其他widget来构建UI, 在构建过程中会递归的构建其嵌套的Widget . 控件自身的状态不会改变,创建了就直接显示,不会有色值、大小或者其他属性的变化 .\n\n`StatefulWidget`: 同样继承自Widget , 并重写了createElement方法 , 不同的是返回的Element对象并不相同 ; \n\n#### 文本及样式:\n\n- Text: 用于显示简单样式文本,它包含一些控制文本显示样式的一些属性;\n- TextStyle: 用于指定文本显示的样式如颜色、字体、粗细、背景等;\n- TextSpan: Text中所有文本内容只能按同一个样式,如果需要对Text内容中不同部分按照不同样式显示,就需要使用TextSpan。\n\n#### 按钮: \n\n- RaisedButton： 漂浮按钮,默认带有阴影和灰色背景.按下后,阴影会变大。\n- FlatButton：扁平按钮,默认背景透明不带阴影 , 按下后会有背景色。\n- OutlineButton：默认有一个边框,不带阴影且背景透明.按下后 ,边框颜色会变亮、同时出现背景和阴影(较弱)\n- IconButton：是一个可点击的Icon,不包括文字、默认没有背景、点击会出现背景.\n\n#### 图片:       \n\n- ImageProvider：定义了图片数据获取接口load(). 从不同数据源获取图片需要实现不同的ImageProvider \n- AssetImage：加载本地工程目录下的图片\n- NetworkImage：用于加载、显示网络图片\n\n\n#### 单选框\n\nSwitch\n\n#### 复选框\n\nCheckbox\n\n#### 输入框\n\nTextField\n\n#### 表单\n\nForm\n\n### 布局类Widget\n\n布局类Widget都会包含一个或多个widget,不同布局类Widget对子Widget排版方式不同, 布局类Widget就是一个容器。\n\n#### 流式布局(Wrap)\n\n在介绍Row和Column时,如果子Widget超出屏幕范围, 会包溢出错误 . 这是因为超出屏幕不会折行. 我们把超出屏幕显示范围会自动折行的布局称为流式布局 . Flutter中通过Wrap和Flow来支持流式布局.\n\n#### 层叠布局\n\n层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。\n\n### 可滚动Widget\n\n当内容超过显示视口(ViewPort)时，如果没有特殊处理，Flutter则会提示Overflow错误。为此，Flutter提供了多种可滚动widget（Scrollable Widget）用于显示列表和长布局。\n\n#### SingleChildScrollView\n\n类似于Android中的ScrollView, 只能接收一个子Widget。\n\n#### ListView\n\n沿一个方向线性排布所有子Widget \n\n#### GridView\n\n可以构建一个二维网格列表\n\n#### CustomerScrollView\n\n可以包含多种滚动模型\n\n\n\n","slug":"flutter-introduction","published":1,"updated":"2020-06-10T06:01:56.095Z","_id":"ck2yl0qby0005h6q6v1ybrp1z","layout":"post","photos":[],"link":"","content":"<h1 id=\"Flutter技术研究与应用\"><a href=\"#Flutter技术研究与应用\" class=\"headerlink\" title=\"Flutter技术研究与应用\"></a>Flutter技术研究与应用</h1><p><img src=\"https://img.fengjr.com/image/2019/07/18/181fc116474931e5a98b71d7af165eb0.jpeg\" alt=\"Flutter\"></p>\n<h2 id=\"什么是Flutter\"><a href=\"#什么是Flutter\" class=\"headerlink\" title=\"什么是Flutter\"></a>什么是Flutter</h2><h3 id=\"1、Flutter-的概念\"><a href=\"#1、Flutter-的概念\" class=\"headerlink\" title=\"1、Flutter 的概念\"></a>1、Flutter 的概念</h3><p>Flutter是Google推出并开源的移动应用开发框架 , 主打跨平台、高保真、高性能 . 开发者可以通过Dart语言开发APP , 一套代码同时运行在 ios 和 Android平台 . Flutter提供了丰富的组件、接口 , 开发者可以很快地为Flutter添加native扩展 . 同时Flutter还是用Native引擎渲染试图, 可以为用户提供良好的体验。</p>\n<h3 id=\"2、跨平台自绘引擎\"><a href=\"#2、跨平台自绘引擎\" class=\"headerlink\" title=\"2、跨平台自绘引擎\"></a>2、跨平台自绘引擎</h3><p>Flutter与用于构建移动应用程序的其他大多数框架不同 , Flutter既不使用WebView , 也不使用操作系统的原生控件 .Flutter使用自己的高性能渲染引擎来绘制widget . 这样不仅可以保证在Android和ios上UI的一致性 , 而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本.<br>Flutter使用Skia作为其2D渲染引擎 , Skia是Google的一个2D图形处理函数库 , 包含字型、坐标转换,以及点阵图都有高效能且简洁的表现 , Skia是跨平台的,并提供非常友好的API , 目前Google Chrome浏览器和Android均采用Skia作为其绘制引擎 .</p>\n<h3 id=\"3、高性能\"><a href=\"#3、高性能\" class=\"headerlink\" title=\"3、高性能\"></a>3、高性能</h3><p>Flutter高性能主要由两点来保证 , 首先 , Flutter APP采用Dart语言开发 . Dart在 JIT(即时编译)模式下 , 速度与javaScript基本持平 . 但是 Dart支持 AOT , 当以AOT模式运行时 , javascript便远远追不上 . 其次 , Flutter使用自己的渲染引擎来绘制UI , 布局数据等由Dart语言直接控制,所以在布局过程中不需要像RN那样要在javascript和Native之间通信 , 这在一些滑动和拖动的场景下具有明显优势 , 因为滑动和拖动过程往往都会引起布局变化 , 所以javascript需要和Native之间不停的同步布局信息 , 这和在浏览器中需要javascript频繁操作DOM所带来的问题是一样,都会带来比较可观的性能开销.</p>\n<h3 id=\"4、采用Dart语言开发\"><a href=\"#4、采用Dart语言开发\" class=\"headerlink\" title=\"4、采用Dart语言开发\"></a>4、采用Dart语言开发</h3><p>Dart运行时和编译器支持Flutter两个关键特性的组合:</p>\n<ol>\n<li>基于JIT的快速开发周期: Flutter在开发阶段采用JIT模式 , 这样就避免了每次改动都需要进行                编译 , 极大的节省了开发时间;</li>\n<li>基于AOT的发布包: Flutter在发布时可以通过AOT生成高效的ARM代码来确保应用的性能, 而                   javaScript就不具备该能力.</li>\n</ol>\n<h3 id=\"5、Flutter底层架构示意图\"><a href=\"#5、Flutter底层架构示意图\" class=\"headerlink\" title=\"5、Flutter底层架构示意图\"></a>5、Flutter底层架构示意图</h3><p><img src=\"https://img.fengjr.com/image/2019/07/18/3382931996bd356421f0b85b29946c9a.png\" alt=\"image\"></p>\n<h3 id=\"6、Flutter-Framework\"><a href=\"#6、Flutter-Framework\" class=\"headerlink\" title=\"6、Flutter Framework\"></a>6、Flutter Framework</h3><p>该库是由纯Dart语言实现的, 它实现了一套基础库 , 自底向上 .</p>\n<p>底下两层(Foundation 和 Animation 、Painting 、Gestures)在Google的一些视频中被合并为一个Dart UI层 , 对应的是Flutter中的 dart:ui 包 , 它是Flutter引擎暴漏的底层UI库, 提供动画、手势及绘制能留.</p>\n<p>Rendering层 , 是一个抽象的布局层 , 它依赖dart UI 层 , Rendering层会构建一个UI树 , 当UI树有变化时 , 会计算出有变化的部分, 然后更新UI树 , 最终将UI树绘制到屏幕上 , 这个过程就类似于React中的虚拟DOM . Rendering层是Flutter UI 层框架最核心的部分 , 它除了确定每个Ui元素的位置、大小之外还要进行坐标转换、绘制(调用底层dart:ui).</p>\n<p>Widgets层是Flutter提供的一套基础组件库 , 在基础组件库之上 , Flutter还提供了Material和Cupertino两种视觉风格的组件库.</p>\n<h3 id=\"7、Flutter-Engine\"><a href=\"#7、Flutter-Engine\" class=\"headerlink\" title=\"7、Flutter Engine\"></a>7、Flutter Engine</h3><p>该层是有纯C++实现的SDK , 其中包括了Skia引擎、Dart运行时、文字排版引擎等, 在代码调用 dart:ui 库时, 调用最终会走到Engine层, 然后实现真正的绘制逻辑 . </p>\n<h2 id=\"跨平台框架发展历史\"><a href=\"#跨平台框架发展历史\" class=\"headerlink\" title=\"跨平台框架发展历史\"></a>跨平台框架发展历史</h2><p>目前移动端主流平台主要就Android和iOS两大平台 .  iOS应用程序开发语言:  Object-c 、 Swift  , Android应用程序开发语言:  Java 、Kotlin . 所以开发一个兼顾两个平台的应用程序就得使用两套代码. 为了尽可能复用代码 、节约成本 , 跨平台技术就成了各大公司关注的焦点 . </p>\n<p>目前市面上主流的跨平台方案主要有: h5/js + webkit/webview 、 React Native (RN) 、Weex 、Flutter , 目前就凤金app来说已经使用了前两种跨平台技术. 未来我们计划会在财管app中使用Flutter跨平台技术.</p>\n<h3 id=\"1、H5-原生混合开发\"><a href=\"#1、H5-原生混合开发\" class=\"headerlink\" title=\"1、H5 + 原生混合开发\"></a>1、H5 + 原生混合开发</h3><p>这类框架主要原理是将APP中部分需要变动的内容通过H5来实现,通过原生网页控件加载webview(Android)或WKWebView (ios)来加载 . 这样,H5部分可以随时改变而不用发版,动态化需求能满足 ; 同时, 由于H5代码只需要一次开发,就能同时在Android 和 ios两个平台运行, 也可以减小开发成本 .</p>\n<p>由于H5代码主要运行在WebView中, 而WebView实质上就是一个浏览器内核 , 其javascript运行在一个权限受限的沙箱中, 所以对于大多数系统能力都没有访问权限 .对于H5不能实现的功能,就需要原生去做. 所以一般都会在原生代码中预先实现一些访问系统的API, 然后暴漏给WebView以供javaScript来调用.这样WebView就成了javascript与原生API之间通信的桥梁, 主要负责javascript与原生之间传递调用信息 .</p>\n<h3 id=\"2、React-Native-RN-跨平台开发\"><a href=\"#2、React-Native-RN-跨平台开发\" class=\"headerlink\" title=\"2、React Native (RN) 跨平台开发\"></a>2、React Native (RN) 跨平台开发</h3><p>React Native (RN) 是Facebook于2015年4月开源的跨品台移动应用框架 , 是Facebook 早先开源<br>的Ui框架React在原生移动应用平台中的衍生产物 , 支持 iOS 和 Android 两大平台 . 它使用javaScript语言、以及类似于HTML的 JSX 和 CSS 来开发移动应用 , 因此熟悉Web前端开发的技术人员只需要很少的学习即可快速上手.</p>\n<h3 id=\"3、Weex\"><a href=\"#3、Weex\" class=\"headerlink\" title=\"3、Weex\"></a>3、Weex</h3><p>Weex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。</p>\n<h2 id=\"Flutter基础widget及小案例\"><a href=\"#Flutter基础widget及小案例\" class=\"headerlink\" title=\"Flutter基础widget及小案例\"></a>Flutter基础widget及小案例</h2><p>Flutter中几乎所有的对象都是Widget , 与原生开发中控件不同的是, Flutter中的Widget概念更加广泛 , 它不仅可以表示Ui元素 , 也可以表示一些功能性组件如:用于手势检测的GestureDetector widget、用于应用主题数据传递的Theme等.</p>\n<h3 id=\"基础widgets\"><a href=\"#基础widgets\" class=\"headerlink\" title=\"基础widgets\"></a>基础widgets</h3><p><code>StatelessWidget</code>:  继承自Widget ,  用于不需要维护状态的场景 , 它通常在build方法中通过嵌套其他widget来构建UI, 在构建过程中会递归的构建其嵌套的Widget . 控件自身的状态不会改变,创建了就直接显示,不会有色值、大小或者其他属性的变化 .</p>\n<p><code>StatefulWidget</code>: 同样继承自Widget , 并重写了createElement方法 , 不同的是返回的Element对象并不相同 ; </p>\n<h4 id=\"文本及样式\"><a href=\"#文本及样式\" class=\"headerlink\" title=\"文本及样式:\"></a>文本及样式:</h4><ul>\n<li>Text: 用于显示简单样式文本,它包含一些控制文本显示样式的一些属性;</li>\n<li>TextStyle: 用于指定文本显示的样式如颜色、字体、粗细、背景等;</li>\n<li>TextSpan: Text中所有文本内容只能按同一个样式,如果需要对Text内容中不同部分按照不同样式显示,就需要使用TextSpan。</li>\n</ul>\n<h4 id=\"按钮\"><a href=\"#按钮\" class=\"headerlink\" title=\"按钮:\"></a>按钮:</h4><ul>\n<li>RaisedButton： 漂浮按钮,默认带有阴影和灰色背景.按下后,阴影会变大。</li>\n<li>FlatButton：扁平按钮,默认背景透明不带阴影 , 按下后会有背景色。</li>\n<li>OutlineButton：默认有一个边框,不带阴影且背景透明.按下后 ,边框颜色会变亮、同时出现背景和阴影(较弱)</li>\n<li>IconButton：是一个可点击的Icon,不包括文字、默认没有背景、点击会出现背景.</li>\n</ul>\n<h4 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片:\"></a>图片:</h4><ul>\n<li>ImageProvider：定义了图片数据获取接口load(). 从不同数据源获取图片需要实现不同的ImageProvider </li>\n<li>AssetImage：加载本地工程目录下的图片</li>\n<li>NetworkImage：用于加载、显示网络图片</li>\n</ul>\n<h4 id=\"单选框\"><a href=\"#单选框\" class=\"headerlink\" title=\"单选框\"></a>单选框</h4><p>Switch</p>\n<h4 id=\"复选框\"><a href=\"#复选框\" class=\"headerlink\" title=\"复选框\"></a>复选框</h4><p>Checkbox</p>\n<h4 id=\"输入框\"><a href=\"#输入框\" class=\"headerlink\" title=\"输入框\"></a>输入框</h4><p>TextField</p>\n<h4 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h4><p>Form</p>\n<h3 id=\"布局类Widget\"><a href=\"#布局类Widget\" class=\"headerlink\" title=\"布局类Widget\"></a>布局类Widget</h3><p>布局类Widget都会包含一个或多个widget,不同布局类Widget对子Widget排版方式不同, 布局类Widget就是一个容器。</p>\n<h4 id=\"流式布局-Wrap\"><a href=\"#流式布局-Wrap\" class=\"headerlink\" title=\"流式布局(Wrap)\"></a>流式布局(Wrap)</h4><p>在介绍Row和Column时,如果子Widget超出屏幕范围, 会包溢出错误 . 这是因为超出屏幕不会折行. 我们把超出屏幕显示范围会自动折行的布局称为流式布局 . Flutter中通过Wrap和Flow来支持流式布局.</p>\n<h4 id=\"层叠布局\"><a href=\"#层叠布局\" class=\"headerlink\" title=\"层叠布局\"></a>层叠布局</h4><p>层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。</p>\n<h3 id=\"可滚动Widget\"><a href=\"#可滚动Widget\" class=\"headerlink\" title=\"可滚动Widget\"></a>可滚动Widget</h3><p>当内容超过显示视口(ViewPort)时，如果没有特殊处理，Flutter则会提示Overflow错误。为此，Flutter提供了多种可滚动widget（Scrollable Widget）用于显示列表和长布局。</p>\n<h4 id=\"SingleChildScrollView\"><a href=\"#SingleChildScrollView\" class=\"headerlink\" title=\"SingleChildScrollView\"></a>SingleChildScrollView</h4><p>类似于Android中的ScrollView, 只能接收一个子Widget。</p>\n<h4 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h4><p>沿一个方向线性排布所有子Widget </p>\n<h4 id=\"GridView\"><a href=\"#GridView\" class=\"headerlink\" title=\"GridView\"></a>GridView</h4><p>可以构建一个二维网格列表</p>\n<h4 id=\"CustomerScrollView\"><a href=\"#CustomerScrollView\" class=\"headerlink\" title=\"CustomerScrollView\"></a>CustomerScrollView</h4><p>可以包含多种滚动模型</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Flutter技术研究与应用\"><a href=\"#Flutter技术研究与应用\" class=\"headerlink\" title=\"Flutter技术研究与应用\"></a>Flutter技术研究与应用</h1><p><img src=\"https://img.fengjr.com/image/2019/07/18/181fc116474931e5a98b71d7af165eb0.jpeg\" alt=\"Flutter\"></p>\n<h2 id=\"什么是Flutter\"><a href=\"#什么是Flutter\" class=\"headerlink\" title=\"什么是Flutter\"></a>什么是Flutter</h2><h3 id=\"1、Flutter-的概念\"><a href=\"#1、Flutter-的概念\" class=\"headerlink\" title=\"1、Flutter 的概念\"></a>1、Flutter 的概念</h3><p>Flutter是Google推出并开源的移动应用开发框架 , 主打跨平台、高保真、高性能 . 开发者可以通过Dart语言开发APP , 一套代码同时运行在 ios 和 Android平台 . Flutter提供了丰富的组件、接口 , 开发者可以很快地为Flutter添加native扩展 . 同时Flutter还是用Native引擎渲染试图, 可以为用户提供良好的体验。</p>\n<h3 id=\"2、跨平台自绘引擎\"><a href=\"#2、跨平台自绘引擎\" class=\"headerlink\" title=\"2、跨平台自绘引擎\"></a>2、跨平台自绘引擎</h3><p>Flutter与用于构建移动应用程序的其他大多数框架不同 , Flutter既不使用WebView , 也不使用操作系统的原生控件 .Flutter使用自己的高性能渲染引擎来绘制widget . 这样不仅可以保证在Android和ios上UI的一致性 , 而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本.<br>Flutter使用Skia作为其2D渲染引擎 , Skia是Google的一个2D图形处理函数库 , 包含字型、坐标转换,以及点阵图都有高效能且简洁的表现 , Skia是跨平台的,并提供非常友好的API , 目前Google Chrome浏览器和Android均采用Skia作为其绘制引擎 .</p>\n<h3 id=\"3、高性能\"><a href=\"#3、高性能\" class=\"headerlink\" title=\"3、高性能\"></a>3、高性能</h3><p>Flutter高性能主要由两点来保证 , 首先 , Flutter APP采用Dart语言开发 . Dart在 JIT(即时编译)模式下 , 速度与javaScript基本持平 . 但是 Dart支持 AOT , 当以AOT模式运行时 , javascript便远远追不上 . 其次 , Flutter使用自己的渲染引擎来绘制UI , 布局数据等由Dart语言直接控制,所以在布局过程中不需要像RN那样要在javascript和Native之间通信 , 这在一些滑动和拖动的场景下具有明显优势 , 因为滑动和拖动过程往往都会引起布局变化 , 所以javascript需要和Native之间不停的同步布局信息 , 这和在浏览器中需要javascript频繁操作DOM所带来的问题是一样,都会带来比较可观的性能开销.</p>\n<h3 id=\"4、采用Dart语言开发\"><a href=\"#4、采用Dart语言开发\" class=\"headerlink\" title=\"4、采用Dart语言开发\"></a>4、采用Dart语言开发</h3><p>Dart运行时和编译器支持Flutter两个关键特性的组合:</p>\n<ol>\n<li>基于JIT的快速开发周期: Flutter在开发阶段采用JIT模式 , 这样就避免了每次改动都需要进行                编译 , 极大的节省了开发时间;</li>\n<li>基于AOT的发布包: Flutter在发布时可以通过AOT生成高效的ARM代码来确保应用的性能, 而                   javaScript就不具备该能力.</li>\n</ol>\n<h3 id=\"5、Flutter底层架构示意图\"><a href=\"#5、Flutter底层架构示意图\" class=\"headerlink\" title=\"5、Flutter底层架构示意图\"></a>5、Flutter底层架构示意图</h3><p><img src=\"https://img.fengjr.com/image/2019/07/18/3382931996bd356421f0b85b29946c9a.png\" alt=\"image\"></p>\n<h3 id=\"6、Flutter-Framework\"><a href=\"#6、Flutter-Framework\" class=\"headerlink\" title=\"6、Flutter Framework\"></a>6、Flutter Framework</h3><p>该库是由纯Dart语言实现的, 它实现了一套基础库 , 自底向上 .</p>\n<p>底下两层(Foundation 和 Animation 、Painting 、Gestures)在Google的一些视频中被合并为一个Dart UI层 , 对应的是Flutter中的 dart:ui 包 , 它是Flutter引擎暴漏的底层UI库, 提供动画、手势及绘制能留.</p>\n<p>Rendering层 , 是一个抽象的布局层 , 它依赖dart UI 层 , Rendering层会构建一个UI树 , 当UI树有变化时 , 会计算出有变化的部分, 然后更新UI树 , 最终将UI树绘制到屏幕上 , 这个过程就类似于React中的虚拟DOM . Rendering层是Flutter UI 层框架最核心的部分 , 它除了确定每个Ui元素的位置、大小之外还要进行坐标转换、绘制(调用底层dart:ui).</p>\n<p>Widgets层是Flutter提供的一套基础组件库 , 在基础组件库之上 , Flutter还提供了Material和Cupertino两种视觉风格的组件库.</p>\n<h3 id=\"7、Flutter-Engine\"><a href=\"#7、Flutter-Engine\" class=\"headerlink\" title=\"7、Flutter Engine\"></a>7、Flutter Engine</h3><p>该层是有纯C++实现的SDK , 其中包括了Skia引擎、Dart运行时、文字排版引擎等, 在代码调用 dart:ui 库时, 调用最终会走到Engine层, 然后实现真正的绘制逻辑 . </p>\n<h2 id=\"跨平台框架发展历史\"><a href=\"#跨平台框架发展历史\" class=\"headerlink\" title=\"跨平台框架发展历史\"></a>跨平台框架发展历史</h2><p>目前移动端主流平台主要就Android和iOS两大平台 .  iOS应用程序开发语言:  Object-c 、 Swift  , Android应用程序开发语言:  Java 、Kotlin . 所以开发一个兼顾两个平台的应用程序就得使用两套代码. 为了尽可能复用代码 、节约成本 , 跨平台技术就成了各大公司关注的焦点 . </p>\n<p>目前市面上主流的跨平台方案主要有: h5/js + webkit/webview 、 React Native (RN) 、Weex 、Flutter , 目前就凤金app来说已经使用了前两种跨平台技术. 未来我们计划会在财管app中使用Flutter跨平台技术.</p>\n<h3 id=\"1、H5-原生混合开发\"><a href=\"#1、H5-原生混合开发\" class=\"headerlink\" title=\"1、H5 + 原生混合开发\"></a>1、H5 + 原生混合开发</h3><p>这类框架主要原理是将APP中部分需要变动的内容通过H5来实现,通过原生网页控件加载webview(Android)或WKWebView (ios)来加载 . 这样,H5部分可以随时改变而不用发版,动态化需求能满足 ; 同时, 由于H5代码只需要一次开发,就能同时在Android 和 ios两个平台运行, 也可以减小开发成本 .</p>\n<p>由于H5代码主要运行在WebView中, 而WebView实质上就是一个浏览器内核 , 其javascript运行在一个权限受限的沙箱中, 所以对于大多数系统能力都没有访问权限 .对于H5不能实现的功能,就需要原生去做. 所以一般都会在原生代码中预先实现一些访问系统的API, 然后暴漏给WebView以供javaScript来调用.这样WebView就成了javascript与原生API之间通信的桥梁, 主要负责javascript与原生之间传递调用信息 .</p>\n<h3 id=\"2、React-Native-RN-跨平台开发\"><a href=\"#2、React-Native-RN-跨平台开发\" class=\"headerlink\" title=\"2、React Native (RN) 跨平台开发\"></a>2、React Native (RN) 跨平台开发</h3><p>React Native (RN) 是Facebook于2015年4月开源的跨品台移动应用框架 , 是Facebook 早先开源<br>的Ui框架React在原生移动应用平台中的衍生产物 , 支持 iOS 和 Android 两大平台 . 它使用javaScript语言、以及类似于HTML的 JSX 和 CSS 来开发移动应用 , 因此熟悉Web前端开发的技术人员只需要很少的学习即可快速上手.</p>\n<h3 id=\"3、Weex\"><a href=\"#3、Weex\" class=\"headerlink\" title=\"3、Weex\"></a>3、Weex</h3><p>Weex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。</p>\n<h2 id=\"Flutter基础widget及小案例\"><a href=\"#Flutter基础widget及小案例\" class=\"headerlink\" title=\"Flutter基础widget及小案例\"></a>Flutter基础widget及小案例</h2><p>Flutter中几乎所有的对象都是Widget , 与原生开发中控件不同的是, Flutter中的Widget概念更加广泛 , 它不仅可以表示Ui元素 , 也可以表示一些功能性组件如:用于手势检测的GestureDetector widget、用于应用主题数据传递的Theme等.</p>\n<h3 id=\"基础widgets\"><a href=\"#基础widgets\" class=\"headerlink\" title=\"基础widgets\"></a>基础widgets</h3><p><code>StatelessWidget</code>:  继承自Widget ,  用于不需要维护状态的场景 , 它通常在build方法中通过嵌套其他widget来构建UI, 在构建过程中会递归的构建其嵌套的Widget . 控件自身的状态不会改变,创建了就直接显示,不会有色值、大小或者其他属性的变化 .</p>\n<p><code>StatefulWidget</code>: 同样继承自Widget , 并重写了createElement方法 , 不同的是返回的Element对象并不相同 ; </p>\n<h4 id=\"文本及样式\"><a href=\"#文本及样式\" class=\"headerlink\" title=\"文本及样式:\"></a>文本及样式:</h4><ul>\n<li>Text: 用于显示简单样式文本,它包含一些控制文本显示样式的一些属性;</li>\n<li>TextStyle: 用于指定文本显示的样式如颜色、字体、粗细、背景等;</li>\n<li>TextSpan: Text中所有文本内容只能按同一个样式,如果需要对Text内容中不同部分按照不同样式显示,就需要使用TextSpan。</li>\n</ul>\n<h4 id=\"按钮\"><a href=\"#按钮\" class=\"headerlink\" title=\"按钮:\"></a>按钮:</h4><ul>\n<li>RaisedButton： 漂浮按钮,默认带有阴影和灰色背景.按下后,阴影会变大。</li>\n<li>FlatButton：扁平按钮,默认背景透明不带阴影 , 按下后会有背景色。</li>\n<li>OutlineButton：默认有一个边框,不带阴影且背景透明.按下后 ,边框颜色会变亮、同时出现背景和阴影(较弱)</li>\n<li>IconButton：是一个可点击的Icon,不包括文字、默认没有背景、点击会出现背景.</li>\n</ul>\n<h4 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片:\"></a>图片:</h4><ul>\n<li>ImageProvider：定义了图片数据获取接口load(). 从不同数据源获取图片需要实现不同的ImageProvider </li>\n<li>AssetImage：加载本地工程目录下的图片</li>\n<li>NetworkImage：用于加载、显示网络图片</li>\n</ul>\n<h4 id=\"单选框\"><a href=\"#单选框\" class=\"headerlink\" title=\"单选框\"></a>单选框</h4><p>Switch</p>\n<h4 id=\"复选框\"><a href=\"#复选框\" class=\"headerlink\" title=\"复选框\"></a>复选框</h4><p>Checkbox</p>\n<h4 id=\"输入框\"><a href=\"#输入框\" class=\"headerlink\" title=\"输入框\"></a>输入框</h4><p>TextField</p>\n<h4 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h4><p>Form</p>\n<h3 id=\"布局类Widget\"><a href=\"#布局类Widget\" class=\"headerlink\" title=\"布局类Widget\"></a>布局类Widget</h3><p>布局类Widget都会包含一个或多个widget,不同布局类Widget对子Widget排版方式不同, 布局类Widget就是一个容器。</p>\n<h4 id=\"流式布局-Wrap\"><a href=\"#流式布局-Wrap\" class=\"headerlink\" title=\"流式布局(Wrap)\"></a>流式布局(Wrap)</h4><p>在介绍Row和Column时,如果子Widget超出屏幕范围, 会包溢出错误 . 这是因为超出屏幕不会折行. 我们把超出屏幕显示范围会自动折行的布局称为流式布局 . Flutter中通过Wrap和Flow来支持流式布局.</p>\n<h4 id=\"层叠布局\"><a href=\"#层叠布局\" class=\"headerlink\" title=\"层叠布局\"></a>层叠布局</h4><p>层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。</p>\n<h3 id=\"可滚动Widget\"><a href=\"#可滚动Widget\" class=\"headerlink\" title=\"可滚动Widget\"></a>可滚动Widget</h3><p>当内容超过显示视口(ViewPort)时，如果没有特殊处理，Flutter则会提示Overflow错误。为此，Flutter提供了多种可滚动widget（Scrollable Widget）用于显示列表和长布局。</p>\n<h4 id=\"SingleChildScrollView\"><a href=\"#SingleChildScrollView\" class=\"headerlink\" title=\"SingleChildScrollView\"></a>SingleChildScrollView</h4><p>类似于Android中的ScrollView, 只能接收一个子Widget。</p>\n<h4 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h4><p>沿一个方向线性排布所有子Widget </p>\n<h4 id=\"GridView\"><a href=\"#GridView\" class=\"headerlink\" title=\"GridView\"></a>GridView</h4><p>可以构建一个二维网格列表</p>\n<h4 id=\"CustomerScrollView\"><a href=\"#CustomerScrollView\" class=\"headerlink\" title=\"CustomerScrollView\"></a>CustomerScrollView</h4><p>可以包含多种滚动模型</p>\n"},{"title":"SVG入门介绍","comments":1,"date":"2019-07-26T03:21:54.000Z","author":"jun.zhou","_content":"\n# SVG入门介绍\n\n![SVG](https://img.fengjr.com/image/2019/07/25/2c9c7fc330d25bde7ca74245c3bc5669.png)\n## SVG的简介\n\n> SVG（英文：Scalable Vector Graphics）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式，SVG由W3C制定，是一个开放标准。\n\nSVG推出于1999年，由一组加入W3C的公司启动开发，与之前1998年提交给W3C的标准（PGML、VML）构成竞争。SVG从这两个格式吸取了经验。\n\nSVG允许3种图形对象类型：矢量图形、栅格图像以及文本。\n\n### 优点\n- 图像文件可读，易于修改和编辑（理论上如此，但实际上却是因为各种不同的SVG档编辑器而可能存储成不易解读的SVG文件）\n- 与现有技术可以互动融合。例如，SVG技术本身的动态部分（包括时序控制和动画）就是基于SMIL标准。另外，SVG文件还可嵌入JavaScript（严格地说，应该是ECMAScript）脚本来控制SVG对象\n- SVG图形格式可以方便的创建文字索引，从而实现基于内容的图像搜索\n- SVG图形格式支持多种滤镜和特殊效果，在不改变图像内容的前提下可以实现位图格式中类似文字阴影的效果。\n- SVG图形格式可以用来动态生成图形。例如，可用SVG动态生成具有交互功能的地图，嵌入网页中，并显示给终端用户。\n\n### 缺点\n\n- 由于原始的SVG档是遵从XML语法，导致数据采用未压缩的方式存放，因此相较于其他的矢量图形格式，同样的文件内容会比其他的文件格式稍大。Adobe因此使用gzip压缩开发出压缩的SVG档格式，附文件名为 .svgz， 但此种文件格式除了Adobe旗下的软件以外，未被广泛支持使用。\n- 旧版的SVG Viewer无法正确显示出使用新版SVG格式的矢量图形。\n- 只能做2维图形，没法做动画\n\n## SVG的语法\n\n目前所有的浏览器都支持SVG，但各浏览器是有差异的，因此很可能你制作了一个SVG，并且用一个工具调试正常后，却在另一个浏览器种无法显示，这是因为不同的浏览器支持的SVG标准的程度不同。\n\n使用SVG，你需要掌握，有几个重点要记住：\n\n- SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同）\n- SVG里的属性值必须用引号引起来，就算是数值也必须这样做。\n\n### SVG的标签\n\nsvg的代码都放在顶层标签`<svg>`中，下面是一个例子\n\n```HTMl\n<svg version=\"1.1\"\n     baseProfile=\"full\"\n     width=\"300\" height=\"300\"\n     viewBox=\"50 50 50 50\"\n     xmlns=\"http://www.w3.org/2000/svg\">\n  <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r=\"50\" />\n</svg>\n```\n\n**width**：SVG图形占据页面的宽度，除了相对单位，也可以使用绝对单位，不指定默认为 300px。\n\n**height**：SVG图形占据页面的高度，除了相对单位，也可以使用绝对单位，不指定默认为 150px。\n\n[**baseProfile**](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/baseProfile)：特性描述了作者认为正确渲染内容所需要的最小的 SVG 语言概述。这个特性不会说明任何处理限制，可以把它看作是元数据。 比如，这个特性的值可以被编辑工具用来在用户的修改超出所指定的基准概述范围时发出警告。\n\n**version**：该version属性用于指示SVG文档符合的规范。它只允许在根`<svg>`元素上。它纯粹是建议性的，对渲染或处理没有影响，只有两个有效的选择是当前`1.0`和`1.1`。\n\n**xmlns**：表明`<svg>`标签和它的字标签都属于 http://www.w3.org/2000/svg 这个命名空间，这个声明只需要在根结点声明一次即可，命名空间仅仅是一些字符串，并不是链接到某一个地址。\n\n**viewBox**：属性的值有四个数字，分别是左上角的横坐标和纵坐标、视口的宽度和高度。上面代码中，SVG 图像是150像素宽 x 50像素高，viewBox属性指定视口从(50, 50)这个点开始。所以，实际看到的是右下角的部分，视口必须适配所在的空间，上面代码中，视口大小是50 * 50，SVG图像是300 * 300，所以视口会去适配SVG的大小，意味着放大了6倍。\n\n下面我依次介绍一下SVG中几种基本图形的用法：\n\n### 矩形\n\n**rect**元素可以在屏幕上绘制一个矩形，只需要六个基本属性就可以控制它在屏幕上的位置和形状。\n\n```HTML\n<rect x=\"60\" y=\"10\" rx=\"10\" ry=\"10\" width=\"30\" height=\"30\"/>\n```\n\n**x**：矩形左上角的X位置\n\n**y**：矩形左上角的Y位置\n\n**width**：矩形的宽度\n\n**height**：矩形的高度\n\n**rx**：圆角X方位的半径\n\n**ry**：圆角Y方位的半径\n\n### 圆形\n\n**circle**元素可以在屏幕上绘制一个圆形，只需要三个基本属就可以设置圆形。\n\n```HTML\n<circle cx=\"25\" cy=\"75\" r=\"20\"/>\n```\n\n**cx**：圆心X的位置\n\n**cy**：圆心Y的位置\n\n**r**：圆的半径\n\n### 椭圆\n\nellipse 是circle元素更通用的形式，可以缩放圆的X半径和Y半径\n\n```HTML\n<ellipse cx=\"75\" cy=\"75\" rx=\"20\" ry=\"5\"/>\n```\n**rx**：椭圆的X半径\n\n**ry**：椭圆的Y半径\n\n**cx**：椭圆中心的X位置\n\n**cy**：椭圆中心的Y位置\n\n### 直线\n\nline 是用来绘制直线的，它取两个点的位置作为属性，指定这条线的起点和终点的位置。\n\n```HTML\n<line x1=\"10\" x2=\"50\" y1=\"110\" y2=\"150\"/>\n```\n**x1**：起点的X位置\n\n**y1**：起点的Y位置\n\n**x2**：终点的X位置\n\n**y2**：终点的Y位置\n\n### 折线\n\npolyline 是一组连接在一起的直线，因为它可以有很多的点，折线的所有点位置都放在一个points属性中：\n\n```HTMl\n<polyline points=\"60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145\"/>\n```\n\n**points**：点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。\n\n### 多边形\n\npolygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形\n\n```HTMl\n    <polygon points=\"50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180\"/>\n```\n\n**points**：点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。\n\n### 路径\n\npath可能是SVG中最常见的形状。你可以用path元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形，以及一些其他的形状，例如贝塞尔曲线、2次曲线等曲线。\n\n\n```HTML\n<path d=\"M 20 230 Q 40 205, 50 230 T 90 230\"/>\n```\n\n**d**：一个点集数列以及其它关于如何绘制路径的信息。\n\n由于path非常强大也非常的复杂，接下来我们重点学习一下path。\n\npath命令有两种表达方式：\n- 大写字母：表示采用绝对定位\n- 小写字母：表示采用相对定位，（例如，从上一个点的位置，向上移动10px等）\n\n#### 直线命令\n\n`<path>`元素里有5个画直线的命令，顾名思义，直线命令就是在两个点之间画直线。首先是“Move to”命令，M，它需要两个参数，分别是需要移动到的点的x轴和y轴的坐标。假设，你的画笔当前位于一个点，在使用M命令移动画笔后，只会移动画笔，但不会在两点之间画线。因为M命令仅仅是移动画笔，但不画线。所以M命令经常出现在路径的开始处，用来指明从何处开始画。\n\n##### M\n\n```\nM x y\n```\n\n```\nm dx dy\n```\n\n能够真正画线的命令有三个\n\n##### L\n\nL 表示的是 line to，有两个参数x和y，分别表示下一个点的x轴和y轴坐标，L将会在当前位置和新位置之间画一条线段\n\n```\nL x y (or l dx dy)\n```\n\n##### H\nH 表示绘制水平线，只有一个参数x，表示移动到x轴上该点位置的水平线。\n\n```\nH x (or h dx)\n```\n\n##### V\nV 表示绘制垂直线，只有一个参数y，表示移动到y轴上该点位置的垂直线。\n\n```\nV y (or v dy)\n```\n\n##### Z\n\nZ表示一个闭合路径的命令，会从当前点画一条直线到起点，经常放在路径的最后，Z命令不区分大小写。\n\n\n```\nZ（or z）\n```\n\n下面为总结的一个例子：\n\n```HTML\n<path d=\"M10 10 L 90 10 V 90 H 10 Z\" fill=\"transparent\" stroke=\"black\" stroke-width=\"5\"  />\n```\n\n#### 曲线命令\n\nSVG绘制平滑曲线的命令有三个，两个用来绘制贝塞尔曲线，另外一个用来绘制弧形或者说圆的一部分。\n\n##### 贝塞尔曲线\n\n我们从稍微复杂一点的三次贝塞尔曲线C入手，三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数：\n\n\n```\nC x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)\n```\n\n这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。如果你熟悉代数或者微积分的话，会更容易理解控制点，控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程。\n\n![image](https://img.fengjr.com/image/2019/07/25/a74c83f52a7b4be5ebe036b6a3e7a2bd.png)\n\n\n你可以将若干个贝塞尔曲线连起来，从而创建出一条很长的平滑曲线。通常情况下，一个点某一侧的控制点是它另一侧的控制点的对称（以保持斜率不变）。这样，你可以使用一个简写的贝塞尔曲线命令S，如下所示：\n\n```\nS x2 y2, x y (or s dx2 dy2, dx dy)\n```\n\nS命令可以用来创建与前面一样的贝塞尔曲线，但是，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或S命令，那当前点将作为第一个控制点。\n\n\n另一种可用的贝塞尔曲线是二次贝塞尔曲线Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。\n\n\n```\nQ x1 y1, x y (or q dx1 dy1, dx dy)\n```\n![image](https://img.fengjr.com/image/2019/07/25/5be989240c91dc86dc13102e23ced681.png)\n\n就像三次贝塞尔曲线有一个S命令，二次贝塞尔曲线有一个差不多的T命令，可以通过更简短的参数，延长二次贝塞尔曲线。\n\n\n```\nT x y (or t dx dy)\n```\n\n和之前一样，快捷命令T会通过前一个控制点，推断出一个新的控制点。这意味着，在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。\n\n##### 弧形\n\n弧形命令A是另一个创建SVG曲线的命令。基本上，弧形可以视为圆形或椭圆形的一部分。假设，已知椭圆形的长轴半径和短轴半径，并且已知两个点（在椭圆上），根据半径和两点，可以画出两个椭圆，在每个椭圆上根据两点都可以画出两种弧形。所以，仅仅根据半径和两点，可以画出四种弧形。为了保证创建的弧形唯一，A命令需要用到比较多的参数：\n\n\n```\nA rx ry x-axis-rotation large-arc-flag sweep-flag x y\na rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n```\n\n**rx**：椭圆弧的x轴半径\n**ry**：椭圆弧的y轴半径\n**x-axis-rotation**：椭圆弧的旋转角度\n**large-arc-flag**：椭圆弧的角度大小，决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。\n**sweep-flag**：椭圆弧的弧线方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧\n**x**：椭圆弧的终点x坐标\n**y**：椭圆弧终点y坐标\n\n示例图片：\n\n![image](https://img.fengjr.com/image/2019/07/26/2c526c035064a6ad18f39fb5a0f875ee.png)\n\n代码：\n\n```HTML\n<svg width=\"325px\" height=\"325px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M80 80\n           A 45 45, 0, 0, 0, 125 125\n           L 125 80 Z\" fill=\"green\"/>\n  <path d=\"M230 80\n           A 45 45, 0, 1, 0, 275 125\n           L 275 80 Z\" fill=\"red\"/>\n  <path d=\"M80 230\n           A 45 45, 0, 0, 1, 125 275\n           L 125 230 Z\" fill=\"purple\"/>\n  <path d=\"M230 230\n           A 45 45, 0, 1, 1, 275 275\n           L 275 230 Z\" fill=\"blue\"/>\n</svg>\n```\n\n## SVG的属性\n\n上面的例子我们可以看到，标签中很多写了fill和stroke属性的，这些是什么意思呢？\n\n### fill\n\nfill 属性设置对象内部的颜色，还有一个fill-opacity可以控制填充色的不透明度，浏览器也支持rgba属性来设置同样效果，但是有些浏览器不支持。\n\n### stroke\n\n除了颜色属性，stroke可以进行描边，stroke有以下几个属性：\n\n**stroke**：用来设置边框的颜色\n\n**stroke-width**：用来设置边框的宽度，描边是以路径为中心绘制的。\n\n**stroke-linecap**：用来绘制边框终点的形状，它有三个值：\n\n- `butt`用直边结束线段，它是常规做法，线段边界90度垂直于描边的方向、贯穿它的终点。\n- `square`的效果差不多，但是会稍微超出实际路径的范围，超出的大小由stroke-width控制。\n- `round`表示边框的终点是圆角，圆角的半径也是由stroke-width控制的。用直线结束线段\n\n![image](https://img.fengjr.com/image/2019/07/26/24c5fd2f693d1b91746dd7ba1c5ad0b7.png)\n\n\n**stroke-linejoin**：用来控制两条描边线段之间用什么方式连接。它有\n三个值：\n- `miter` 默认值，表示用方形画笔在连接出形成尖角。\n- `round` 表示用圆角连接，实现平滑效果。\n- `bevel` 连接处会形成一个斜接。\n\n![image](https://img.fengjr.com/image/2019/07/26/7f6908d0b8cb0b4c8c1d5809e8f5d80a.png)\n\n**stroke-dasharray**：可以将虚线应用在描边上。\n\n\n```HTML\n<svg width=\"200\" height=\"150\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <path d=\"M 10 75 Q 50 10 100 75 T 190 75\" stroke=\"black\"\n    stroke-linecap=\"round\" stroke-dasharray=\"5,10,5\" fill=\"none\"/>\n  <path d=\"M 10 75 L 190 75\" stroke=\"red\"\n    stroke-linecap=\"round\" stroke-width=\"1\" stroke-dasharray=\"5,5\" fill=\"none\"/>\n</svg>\n```\n\nstroke-dasharray属性的参数，是一组用逗号分割的数字组成的数列。注意，和path不一样，这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度。所以在上面的例子里，第二个路径会先做5个像素单位的填色，紧接着是5个空白单位，然后又是5个单位的填色。如果你想要更复杂的虚线模式，你可以定义更多的数字。第一个例子指定了3个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染5个填色单位，10个空白单位，5个填色单位，然后回头以这3个数字做一次循环，但是这次是创建5个空白单位，10个填色单位，5个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复。\n\n**fill-rule**：可以将虚线应用在描边于定义如何给图形重叠的区域上色。\n\n**stroke-dashoffset**：定义虚线开始的位置。\n","source":"_posts/2019-07-26-svg-course.md","raw":"---\ntitle: SVG入门介绍\ncomments: true\ndate: 2019-07-26 11:21:54\ntags:\n- svg\n- html\n- js\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n# SVG入门介绍\n\n![SVG](https://img.fengjr.com/image/2019/07/25/2c9c7fc330d25bde7ca74245c3bc5669.png)\n## SVG的简介\n\n> SVG（英文：Scalable Vector Graphics）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式，SVG由W3C制定，是一个开放标准。\n\nSVG推出于1999年，由一组加入W3C的公司启动开发，与之前1998年提交给W3C的标准（PGML、VML）构成竞争。SVG从这两个格式吸取了经验。\n\nSVG允许3种图形对象类型：矢量图形、栅格图像以及文本。\n\n### 优点\n- 图像文件可读，易于修改和编辑（理论上如此，但实际上却是因为各种不同的SVG档编辑器而可能存储成不易解读的SVG文件）\n- 与现有技术可以互动融合。例如，SVG技术本身的动态部分（包括时序控制和动画）就是基于SMIL标准。另外，SVG文件还可嵌入JavaScript（严格地说，应该是ECMAScript）脚本来控制SVG对象\n- SVG图形格式可以方便的创建文字索引，从而实现基于内容的图像搜索\n- SVG图形格式支持多种滤镜和特殊效果，在不改变图像内容的前提下可以实现位图格式中类似文字阴影的效果。\n- SVG图形格式可以用来动态生成图形。例如，可用SVG动态生成具有交互功能的地图，嵌入网页中，并显示给终端用户。\n\n### 缺点\n\n- 由于原始的SVG档是遵从XML语法，导致数据采用未压缩的方式存放，因此相较于其他的矢量图形格式，同样的文件内容会比其他的文件格式稍大。Adobe因此使用gzip压缩开发出压缩的SVG档格式，附文件名为 .svgz， 但此种文件格式除了Adobe旗下的软件以外，未被广泛支持使用。\n- 旧版的SVG Viewer无法正确显示出使用新版SVG格式的矢量图形。\n- 只能做2维图形，没法做动画\n\n## SVG的语法\n\n目前所有的浏览器都支持SVG，但各浏览器是有差异的，因此很可能你制作了一个SVG，并且用一个工具调试正常后，却在另一个浏览器种无法显示，这是因为不同的浏览器支持的SVG标准的程度不同。\n\n使用SVG，你需要掌握，有几个重点要记住：\n\n- SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同）\n- SVG里的属性值必须用引号引起来，就算是数值也必须这样做。\n\n### SVG的标签\n\nsvg的代码都放在顶层标签`<svg>`中，下面是一个例子\n\n```HTMl\n<svg version=\"1.1\"\n     baseProfile=\"full\"\n     width=\"300\" height=\"300\"\n     viewBox=\"50 50 50 50\"\n     xmlns=\"http://www.w3.org/2000/svg\">\n  <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r=\"50\" />\n</svg>\n```\n\n**width**：SVG图形占据页面的宽度，除了相对单位，也可以使用绝对单位，不指定默认为 300px。\n\n**height**：SVG图形占据页面的高度，除了相对单位，也可以使用绝对单位，不指定默认为 150px。\n\n[**baseProfile**](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/baseProfile)：特性描述了作者认为正确渲染内容所需要的最小的 SVG 语言概述。这个特性不会说明任何处理限制，可以把它看作是元数据。 比如，这个特性的值可以被编辑工具用来在用户的修改超出所指定的基准概述范围时发出警告。\n\n**version**：该version属性用于指示SVG文档符合的规范。它只允许在根`<svg>`元素上。它纯粹是建议性的，对渲染或处理没有影响，只有两个有效的选择是当前`1.0`和`1.1`。\n\n**xmlns**：表明`<svg>`标签和它的字标签都属于 http://www.w3.org/2000/svg 这个命名空间，这个声明只需要在根结点声明一次即可，命名空间仅仅是一些字符串，并不是链接到某一个地址。\n\n**viewBox**：属性的值有四个数字，分别是左上角的横坐标和纵坐标、视口的宽度和高度。上面代码中，SVG 图像是150像素宽 x 50像素高，viewBox属性指定视口从(50, 50)这个点开始。所以，实际看到的是右下角的部分，视口必须适配所在的空间，上面代码中，视口大小是50 * 50，SVG图像是300 * 300，所以视口会去适配SVG的大小，意味着放大了6倍。\n\n下面我依次介绍一下SVG中几种基本图形的用法：\n\n### 矩形\n\n**rect**元素可以在屏幕上绘制一个矩形，只需要六个基本属性就可以控制它在屏幕上的位置和形状。\n\n```HTML\n<rect x=\"60\" y=\"10\" rx=\"10\" ry=\"10\" width=\"30\" height=\"30\"/>\n```\n\n**x**：矩形左上角的X位置\n\n**y**：矩形左上角的Y位置\n\n**width**：矩形的宽度\n\n**height**：矩形的高度\n\n**rx**：圆角X方位的半径\n\n**ry**：圆角Y方位的半径\n\n### 圆形\n\n**circle**元素可以在屏幕上绘制一个圆形，只需要三个基本属就可以设置圆形。\n\n```HTML\n<circle cx=\"25\" cy=\"75\" r=\"20\"/>\n```\n\n**cx**：圆心X的位置\n\n**cy**：圆心Y的位置\n\n**r**：圆的半径\n\n### 椭圆\n\nellipse 是circle元素更通用的形式，可以缩放圆的X半径和Y半径\n\n```HTML\n<ellipse cx=\"75\" cy=\"75\" rx=\"20\" ry=\"5\"/>\n```\n**rx**：椭圆的X半径\n\n**ry**：椭圆的Y半径\n\n**cx**：椭圆中心的X位置\n\n**cy**：椭圆中心的Y位置\n\n### 直线\n\nline 是用来绘制直线的，它取两个点的位置作为属性，指定这条线的起点和终点的位置。\n\n```HTML\n<line x1=\"10\" x2=\"50\" y1=\"110\" y2=\"150\"/>\n```\n**x1**：起点的X位置\n\n**y1**：起点的Y位置\n\n**x2**：终点的X位置\n\n**y2**：终点的Y位置\n\n### 折线\n\npolyline 是一组连接在一起的直线，因为它可以有很多的点，折线的所有点位置都放在一个points属性中：\n\n```HTMl\n<polyline points=\"60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145\"/>\n```\n\n**points**：点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。\n\n### 多边形\n\npolygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形\n\n```HTMl\n    <polygon points=\"50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180\"/>\n```\n\n**points**：点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。\n\n### 路径\n\npath可能是SVG中最常见的形状。你可以用path元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形，以及一些其他的形状，例如贝塞尔曲线、2次曲线等曲线。\n\n\n```HTML\n<path d=\"M 20 230 Q 40 205, 50 230 T 90 230\"/>\n```\n\n**d**：一个点集数列以及其它关于如何绘制路径的信息。\n\n由于path非常强大也非常的复杂，接下来我们重点学习一下path。\n\npath命令有两种表达方式：\n- 大写字母：表示采用绝对定位\n- 小写字母：表示采用相对定位，（例如，从上一个点的位置，向上移动10px等）\n\n#### 直线命令\n\n`<path>`元素里有5个画直线的命令，顾名思义，直线命令就是在两个点之间画直线。首先是“Move to”命令，M，它需要两个参数，分别是需要移动到的点的x轴和y轴的坐标。假设，你的画笔当前位于一个点，在使用M命令移动画笔后，只会移动画笔，但不会在两点之间画线。因为M命令仅仅是移动画笔，但不画线。所以M命令经常出现在路径的开始处，用来指明从何处开始画。\n\n##### M\n\n```\nM x y\n```\n\n```\nm dx dy\n```\n\n能够真正画线的命令有三个\n\n##### L\n\nL 表示的是 line to，有两个参数x和y，分别表示下一个点的x轴和y轴坐标，L将会在当前位置和新位置之间画一条线段\n\n```\nL x y (or l dx dy)\n```\n\n##### H\nH 表示绘制水平线，只有一个参数x，表示移动到x轴上该点位置的水平线。\n\n```\nH x (or h dx)\n```\n\n##### V\nV 表示绘制垂直线，只有一个参数y，表示移动到y轴上该点位置的垂直线。\n\n```\nV y (or v dy)\n```\n\n##### Z\n\nZ表示一个闭合路径的命令，会从当前点画一条直线到起点，经常放在路径的最后，Z命令不区分大小写。\n\n\n```\nZ（or z）\n```\n\n下面为总结的一个例子：\n\n```HTML\n<path d=\"M10 10 L 90 10 V 90 H 10 Z\" fill=\"transparent\" stroke=\"black\" stroke-width=\"5\"  />\n```\n\n#### 曲线命令\n\nSVG绘制平滑曲线的命令有三个，两个用来绘制贝塞尔曲线，另外一个用来绘制弧形或者说圆的一部分。\n\n##### 贝塞尔曲线\n\n我们从稍微复杂一点的三次贝塞尔曲线C入手，三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数：\n\n\n```\nC x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)\n```\n\n这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。如果你熟悉代数或者微积分的话，会更容易理解控制点，控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程。\n\n![image](https://img.fengjr.com/image/2019/07/25/a74c83f52a7b4be5ebe036b6a3e7a2bd.png)\n\n\n你可以将若干个贝塞尔曲线连起来，从而创建出一条很长的平滑曲线。通常情况下，一个点某一侧的控制点是它另一侧的控制点的对称（以保持斜率不变）。这样，你可以使用一个简写的贝塞尔曲线命令S，如下所示：\n\n```\nS x2 y2, x y (or s dx2 dy2, dx dy)\n```\n\nS命令可以用来创建与前面一样的贝塞尔曲线，但是，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或S命令，那当前点将作为第一个控制点。\n\n\n另一种可用的贝塞尔曲线是二次贝塞尔曲线Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。\n\n\n```\nQ x1 y1, x y (or q dx1 dy1, dx dy)\n```\n![image](https://img.fengjr.com/image/2019/07/25/5be989240c91dc86dc13102e23ced681.png)\n\n就像三次贝塞尔曲线有一个S命令，二次贝塞尔曲线有一个差不多的T命令，可以通过更简短的参数，延长二次贝塞尔曲线。\n\n\n```\nT x y (or t dx dy)\n```\n\n和之前一样，快捷命令T会通过前一个控制点，推断出一个新的控制点。这意味着，在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。\n\n##### 弧形\n\n弧形命令A是另一个创建SVG曲线的命令。基本上，弧形可以视为圆形或椭圆形的一部分。假设，已知椭圆形的长轴半径和短轴半径，并且已知两个点（在椭圆上），根据半径和两点，可以画出两个椭圆，在每个椭圆上根据两点都可以画出两种弧形。所以，仅仅根据半径和两点，可以画出四种弧形。为了保证创建的弧形唯一，A命令需要用到比较多的参数：\n\n\n```\nA rx ry x-axis-rotation large-arc-flag sweep-flag x y\na rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n```\n\n**rx**：椭圆弧的x轴半径\n**ry**：椭圆弧的y轴半径\n**x-axis-rotation**：椭圆弧的旋转角度\n**large-arc-flag**：椭圆弧的角度大小，决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。\n**sweep-flag**：椭圆弧的弧线方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧\n**x**：椭圆弧的终点x坐标\n**y**：椭圆弧终点y坐标\n\n示例图片：\n\n![image](https://img.fengjr.com/image/2019/07/26/2c526c035064a6ad18f39fb5a0f875ee.png)\n\n代码：\n\n```HTML\n<svg width=\"325px\" height=\"325px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M80 80\n           A 45 45, 0, 0, 0, 125 125\n           L 125 80 Z\" fill=\"green\"/>\n  <path d=\"M230 80\n           A 45 45, 0, 1, 0, 275 125\n           L 275 80 Z\" fill=\"red\"/>\n  <path d=\"M80 230\n           A 45 45, 0, 0, 1, 125 275\n           L 125 230 Z\" fill=\"purple\"/>\n  <path d=\"M230 230\n           A 45 45, 0, 1, 1, 275 275\n           L 275 230 Z\" fill=\"blue\"/>\n</svg>\n```\n\n## SVG的属性\n\n上面的例子我们可以看到，标签中很多写了fill和stroke属性的，这些是什么意思呢？\n\n### fill\n\nfill 属性设置对象内部的颜色，还有一个fill-opacity可以控制填充色的不透明度，浏览器也支持rgba属性来设置同样效果，但是有些浏览器不支持。\n\n### stroke\n\n除了颜色属性，stroke可以进行描边，stroke有以下几个属性：\n\n**stroke**：用来设置边框的颜色\n\n**stroke-width**：用来设置边框的宽度，描边是以路径为中心绘制的。\n\n**stroke-linecap**：用来绘制边框终点的形状，它有三个值：\n\n- `butt`用直边结束线段，它是常规做法，线段边界90度垂直于描边的方向、贯穿它的终点。\n- `square`的效果差不多，但是会稍微超出实际路径的范围，超出的大小由stroke-width控制。\n- `round`表示边框的终点是圆角，圆角的半径也是由stroke-width控制的。用直线结束线段\n\n![image](https://img.fengjr.com/image/2019/07/26/24c5fd2f693d1b91746dd7ba1c5ad0b7.png)\n\n\n**stroke-linejoin**：用来控制两条描边线段之间用什么方式连接。它有\n三个值：\n- `miter` 默认值，表示用方形画笔在连接出形成尖角。\n- `round` 表示用圆角连接，实现平滑效果。\n- `bevel` 连接处会形成一个斜接。\n\n![image](https://img.fengjr.com/image/2019/07/26/7f6908d0b8cb0b4c8c1d5809e8f5d80a.png)\n\n**stroke-dasharray**：可以将虚线应用在描边上。\n\n\n```HTML\n<svg width=\"200\" height=\"150\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <path d=\"M 10 75 Q 50 10 100 75 T 190 75\" stroke=\"black\"\n    stroke-linecap=\"round\" stroke-dasharray=\"5,10,5\" fill=\"none\"/>\n  <path d=\"M 10 75 L 190 75\" stroke=\"red\"\n    stroke-linecap=\"round\" stroke-width=\"1\" stroke-dasharray=\"5,5\" fill=\"none\"/>\n</svg>\n```\n\nstroke-dasharray属性的参数，是一组用逗号分割的数字组成的数列。注意，和path不一样，这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度。所以在上面的例子里，第二个路径会先做5个像素单位的填色，紧接着是5个空白单位，然后又是5个单位的填色。如果你想要更复杂的虚线模式，你可以定义更多的数字。第一个例子指定了3个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染5个填色单位，10个空白单位，5个填色单位，然后回头以这3个数字做一次循环，但是这次是创建5个空白单位，10个填色单位，5个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复。\n\n**fill-rule**：可以将虚线应用在描边于定义如何给图形重叠的区域上色。\n\n**stroke-dashoffset**：定义虚线开始的位置。\n","slug":"svg-course","published":1,"updated":"2020-06-10T06:01:55.180Z","_id":"ck2yl0qc00007h6q6tf470ta0","layout":"post","photos":[],"link":"","content":"<h1 id=\"SVG入门介绍\"><a href=\"#SVG入门介绍\" class=\"headerlink\" title=\"SVG入门介绍\"></a>SVG入门介绍</h1><p><img src=\"https://img.fengjr.com/image/2019/07/25/2c9c7fc330d25bde7ca74245c3bc5669.png\" alt=\"SVG\"></p>\n<h2 id=\"SVG的简介\"><a href=\"#SVG的简介\" class=\"headerlink\" title=\"SVG的简介\"></a>SVG的简介</h2><blockquote>\n<p>SVG（英文：Scalable Vector Graphics）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式，SVG由W3C制定，是一个开放标准。</p>\n</blockquote>\n<p>SVG推出于1999年，由一组加入W3C的公司启动开发，与之前1998年提交给W3C的标准（PGML、VML）构成竞争。SVG从这两个格式吸取了经验。</p>\n<p>SVG允许3种图形对象类型：矢量图形、栅格图像以及文本。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>图像文件可读，易于修改和编辑（理论上如此，但实际上却是因为各种不同的SVG档编辑器而可能存储成不易解读的SVG文件）</li>\n<li>与现有技术可以互动融合。例如，SVG技术本身的动态部分（包括时序控制和动画）就是基于SMIL标准。另外，SVG文件还可嵌入JavaScript（严格地说，应该是ECMAScript）脚本来控制SVG对象</li>\n<li>SVG图形格式可以方便的创建文字索引，从而实现基于内容的图像搜索</li>\n<li>SVG图形格式支持多种滤镜和特殊效果，在不改变图像内容的前提下可以实现位图格式中类似文字阴影的效果。</li>\n<li>SVG图形格式可以用来动态生成图形。例如，可用SVG动态生成具有交互功能的地图，嵌入网页中，并显示给终端用户。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>由于原始的SVG档是遵从XML语法，导致数据采用未压缩的方式存放，因此相较于其他的矢量图形格式，同样的文件内容会比其他的文件格式稍大。Adobe因此使用gzip压缩开发出压缩的SVG档格式，附文件名为 .svgz， 但此种文件格式除了Adobe旗下的软件以外，未被广泛支持使用。</li>\n<li>旧版的SVG Viewer无法正确显示出使用新版SVG格式的矢量图形。</li>\n<li>只能做2维图形，没法做动画</li>\n</ul>\n<h2 id=\"SVG的语法\"><a href=\"#SVG的语法\" class=\"headerlink\" title=\"SVG的语法\"></a>SVG的语法</h2><p>目前所有的浏览器都支持SVG，但各浏览器是有差异的，因此很可能你制作了一个SVG，并且用一个工具调试正常后，却在另一个浏览器种无法显示，这是因为不同的浏览器支持的SVG标准的程度不同。</p>\n<p>使用SVG，你需要掌握，有几个重点要记住：</p>\n<ul>\n<li>SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同）</li>\n<li>SVG里的属性值必须用引号引起来，就算是数值也必须这样做。</li>\n</ul>\n<h3 id=\"SVG的标签\"><a href=\"#SVG的标签\" class=\"headerlink\" title=\"SVG的标签\"></a>SVG的标签</h3><p>svg的代码都放在顶层标签<code>&lt;svg&gt;</code>中，下面是一个例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">version</span>=<span class=\"string\">\"1.1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">baseProfile</span>=<span class=\"string\">\"full\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">width</span>=<span class=\"string\">\"300\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"300\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">viewBox</span>=<span class=\"string\">\"50 50 50 50\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">circle</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mycircle\"</span> <span class=\"attr\">cx</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">cy</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">r</span>=<span class=\"string\">\"50\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>width</strong>：SVG图形占据页面的宽度，除了相对单位，也可以使用绝对单位，不指定默认为 300px。</p>\n<p><strong>height</strong>：SVG图形占据页面的高度，除了相对单位，也可以使用绝对单位，不指定默认为 150px。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/baseProfile\" target=\"_blank\" rel=\"noopener\"><strong>baseProfile</strong></a>：特性描述了作者认为正确渲染内容所需要的最小的 SVG 语言概述。这个特性不会说明任何处理限制，可以把它看作是元数据。 比如，这个特性的值可以被编辑工具用来在用户的修改超出所指定的基准概述范围时发出警告。</p>\n<p><strong>version</strong>：该version属性用于指示SVG文档符合的规范。它只允许在根<code>&lt;svg&gt;</code>元素上。它纯粹是建议性的，对渲染或处理没有影响，只有两个有效的选择是当前<code>1.0</code>和<code>1.1</code>。</p>\n<p><strong>xmlns</strong>：表明<code>&lt;svg&gt;</code>标签和它的字标签都属于 <a href=\"http://www.w3.org/2000/svg\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/2000/svg</a> 这个命名空间，这个声明只需要在根结点声明一次即可，命名空间仅仅是一些字符串，并不是链接到某一个地址。</p>\n<p><strong>viewBox</strong>：属性的值有四个数字，分别是左上角的横坐标和纵坐标、视口的宽度和高度。上面代码中，SVG 图像是150像素宽 x 50像素高，viewBox属性指定视口从(50, 50)这个点开始。所以，实际看到的是右下角的部分，视口必须适配所在的空间，上面代码中，视口大小是50 <em> 50，SVG图像是300 </em> 300，所以视口会去适配SVG的大小，意味着放大了6倍。</p>\n<p>下面我依次介绍一下SVG中几种基本图形的用法：</p>\n<h3 id=\"矩形\"><a href=\"#矩形\" class=\"headerlink\" title=\"矩形\"></a>矩形</h3><p><strong>rect</strong>元素可以在屏幕上绘制一个矩形，只需要六个基本属性就可以控制它在屏幕上的位置和形状。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rect</span> <span class=\"attr\">x</span>=<span class=\"string\">\"60\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">rx</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">ry</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"30\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"30\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>x</strong>：矩形左上角的X位置</p>\n<p><strong>y</strong>：矩形左上角的Y位置</p>\n<p><strong>width</strong>：矩形的宽度</p>\n<p><strong>height</strong>：矩形的高度</p>\n<p><strong>rx</strong>：圆角X方位的半径</p>\n<p><strong>ry</strong>：圆角Y方位的半径</p>\n<h3 id=\"圆形\"><a href=\"#圆形\" class=\"headerlink\" title=\"圆形\"></a>圆形</h3><p><strong>circle</strong>元素可以在屏幕上绘制一个圆形，只需要三个基本属就可以设置圆形。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">circle</span> <span class=\"attr\">cx</span>=<span class=\"string\">\"25\"</span> <span class=\"attr\">cy</span>=<span class=\"string\">\"75\"</span> <span class=\"attr\">r</span>=<span class=\"string\">\"20\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>cx</strong>：圆心X的位置</p>\n<p><strong>cy</strong>：圆心Y的位置</p>\n<p><strong>r</strong>：圆的半径</p>\n<h3 id=\"椭圆\"><a href=\"#椭圆\" class=\"headerlink\" title=\"椭圆\"></a>椭圆</h3><p>ellipse 是circle元素更通用的形式，可以缩放圆的X半径和Y半径</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ellipse</span> <span class=\"attr\">cx</span>=<span class=\"string\">\"75\"</span> <span class=\"attr\">cy</span>=<span class=\"string\">\"75\"</span> <span class=\"attr\">rx</span>=<span class=\"string\">\"20\"</span> <span class=\"attr\">ry</span>=<span class=\"string\">\"5\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>rx</strong>：椭圆的X半径</p>\n<p><strong>ry</strong>：椭圆的Y半径</p>\n<p><strong>cx</strong>：椭圆中心的X位置</p>\n<p><strong>cy</strong>：椭圆中心的Y位置</p>\n<h3 id=\"直线\"><a href=\"#直线\" class=\"headerlink\" title=\"直线\"></a>直线</h3><p>line 是用来绘制直线的，它取两个点的位置作为属性，指定这条线的起点和终点的位置。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">line</span> <span class=\"attr\">x1</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">x2</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">y1</span>=<span class=\"string\">\"110\"</span> <span class=\"attr\">y2</span>=<span class=\"string\">\"150\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>x1</strong>：起点的X位置</p>\n<p><strong>y1</strong>：起点的Y位置</p>\n<p><strong>x2</strong>：终点的X位置</p>\n<p><strong>y2</strong>：终点的Y位置</p>\n<h3 id=\"折线\"><a href=\"#折线\" class=\"headerlink\" title=\"折线\"></a>折线</h3><p>polyline 是一组连接在一起的直线，因为它可以有很多的点，折线的所有点位置都放在一个points属性中：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">\"60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>points</strong>：点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。</p>\n<h3 id=\"多边形\"><a href=\"#多边形\" class=\"headerlink\" title=\"多边形\"></a>多边形</h3><p>polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">polygon</span> <span class=\"attr\">points</span>=<span class=\"string\">\"50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>points</strong>：点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。</p>\n<h3 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h3><p>path可能是SVG中最常见的形状。你可以用path元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形，以及一些其他的形状，例如贝塞尔曲线、2次曲线等曲线。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 20 230 Q 40 205, 50 230 T 90 230\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>d</strong>：一个点集数列以及其它关于如何绘制路径的信息。</p>\n<p>由于path非常强大也非常的复杂，接下来我们重点学习一下path。</p>\n<p>path命令有两种表达方式：</p>\n<ul>\n<li>大写字母：表示采用绝对定位</li>\n<li>小写字母：表示采用相对定位，（例如，从上一个点的位置，向上移动10px等）</li>\n</ul>\n<h4 id=\"直线命令\"><a href=\"#直线命令\" class=\"headerlink\" title=\"直线命令\"></a>直线命令</h4><p><code>&lt;path&gt;</code>元素里有5个画直线的命令，顾名思义，直线命令就是在两个点之间画直线。首先是“Move to”命令，M，它需要两个参数，分别是需要移动到的点的x轴和y轴的坐标。假设，你的画笔当前位于一个点，在使用M命令移动画笔后，只会移动画笔，但不会在两点之间画线。因为M命令仅仅是移动画笔，但不画线。所以M命令经常出现在路径的开始处，用来指明从何处开始画。</p>\n<h5 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">M x y</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m dx dy</span><br></pre></td></tr></table></figure>\n<p>能够真正画线的命令有三个</p>\n<h5 id=\"L\"><a href=\"#L\" class=\"headerlink\" title=\"L\"></a>L</h5><p>L 表示的是 line to，有两个参数x和y，分别表示下一个点的x轴和y轴坐标，L将会在当前位置和新位置之间画一条线段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L x y (or l dx dy)</span><br></pre></td></tr></table></figure>\n<h5 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h5><p>H 表示绘制水平线，只有一个参数x，表示移动到x轴上该点位置的水平线。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">H x (or h dx)</span><br></pre></td></tr></table></figure>\n<h5 id=\"V\"><a href=\"#V\" class=\"headerlink\" title=\"V\"></a>V</h5><p>V 表示绘制垂直线，只有一个参数y，表示移动到y轴上该点位置的垂直线。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">V y (or v dy)</span><br></pre></td></tr></table></figure>\n<h5 id=\"Z\"><a href=\"#Z\" class=\"headerlink\" title=\"Z\"></a>Z</h5><p>Z表示一个闭合路径的命令，会从当前点画一条直线到起点，经常放在路径的最后，Z命令不区分大小写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Z（or z）</span><br></pre></td></tr></table></figure>\n<p>下面为总结的一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M10 10 L 90 10 V 90 H 10 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"transparent\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"black\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"5\"</span>  /&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"曲线命令\"><a href=\"#曲线命令\" class=\"headerlink\" title=\"曲线命令\"></a>曲线命令</h4><p>SVG绘制平滑曲线的命令有三个，两个用来绘制贝塞尔曲线，另外一个用来绘制弧形或者说圆的一部分。</p>\n<h5 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h5><p>我们从稍微复杂一点的三次贝塞尔曲线C入手，三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)</span><br></pre></td></tr></table></figure>\n<p>这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。如果你熟悉代数或者微积分的话，会更容易理解控制点，控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/07/25/a74c83f52a7b4be5ebe036b6a3e7a2bd.png\" alt=\"image\"></p>\n<p>你可以将若干个贝塞尔曲线连起来，从而创建出一条很长的平滑曲线。通常情况下，一个点某一侧的控制点是它另一侧的控制点的对称（以保持斜率不变）。这样，你可以使用一个简写的贝塞尔曲线命令S，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S x2 y2, x y (or s dx2 dy2, dx dy)</span><br></pre></td></tr></table></figure>\n<p>S命令可以用来创建与前面一样的贝塞尔曲线，但是，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或S命令，那当前点将作为第一个控制点。</p>\n<p>另一种可用的贝塞尔曲线是二次贝塞尔曲线Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q x1 y1, x y (or q dx1 dy1, dx dy)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.fengjr.com/image/2019/07/25/5be989240c91dc86dc13102e23ced681.png\" alt=\"image\"></p>\n<p>就像三次贝塞尔曲线有一个S命令，二次贝塞尔曲线有一个差不多的T命令，可以通过更简短的参数，延长二次贝塞尔曲线。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T x y (or t dx dy)</span><br></pre></td></tr></table></figure>\n<p>和之前一样，快捷命令T会通过前一个控制点，推断出一个新的控制点。这意味着，在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。</p>\n<h5 id=\"弧形\"><a href=\"#弧形\" class=\"headerlink\" title=\"弧形\"></a>弧形</h5><p>弧形命令A是另一个创建SVG曲线的命令。基本上，弧形可以视为圆形或椭圆形的一部分。假设，已知椭圆形的长轴半径和短轴半径，并且已知两个点（在椭圆上），根据半径和两点，可以画出两个椭圆，在每个椭圆上根据两点都可以画出两种弧形。所以，仅仅根据半径和两点，可以画出四种弧形。为了保证创建的弧形唯一，A命令需要用到比较多的参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A rx ry x-axis-rotation large-arc-flag sweep-flag x y</span><br><span class=\"line\">a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</span><br></pre></td></tr></table></figure>\n<p><strong>rx</strong>：椭圆弧的x轴半径<br><strong>ry</strong>：椭圆弧的y轴半径<br><strong>x-axis-rotation</strong>：椭圆弧的旋转角度<br><strong>large-arc-flag</strong>：椭圆弧的角度大小，决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。<br><strong>sweep-flag</strong>：椭圆弧的弧线方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧<br><strong>x</strong>：椭圆弧的终点x坐标<br><strong>y</strong>：椭圆弧终点y坐标</p>\n<p>示例图片：</p>\n<p><img src=\"https://img.fengjr.com/image/2019/07/26/2c526c035064a6ad18f39fb5a0f875ee.png\" alt=\"image\"></p>\n<p>代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"325px\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"325px\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"1.1\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M80 80</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           A 45 45, 0, 0, 0, 125 125</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           L 125 80 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"green\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M230 80</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           A 45 45, 0, 1, 0, 275 125</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           L 275 80 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"red\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M80 230</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           A 45 45, 0, 0, 1, 125 275</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           L 125 230 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"purple\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M230 230</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           A 45 45, 0, 1, 1, 275 275</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           L 275 230 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"blue\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SVG的属性\"><a href=\"#SVG的属性\" class=\"headerlink\" title=\"SVG的属性\"></a>SVG的属性</h2><p>上面的例子我们可以看到，标签中很多写了fill和stroke属性的，这些是什么意思呢？</p>\n<h3 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill\"></a>fill</h3><p>fill 属性设置对象内部的颜色，还有一个fill-opacity可以控制填充色的不透明度，浏览器也支持rgba属性来设置同样效果，但是有些浏览器不支持。</p>\n<h3 id=\"stroke\"><a href=\"#stroke\" class=\"headerlink\" title=\"stroke\"></a>stroke</h3><p>除了颜色属性，stroke可以进行描边，stroke有以下几个属性：</p>\n<p><strong>stroke</strong>：用来设置边框的颜色</p>\n<p><strong>stroke-width</strong>：用来设置边框的宽度，描边是以路径为中心绘制的。</p>\n<p><strong>stroke-linecap</strong>：用来绘制边框终点的形状，它有三个值：</p>\n<ul>\n<li><code>butt</code>用直边结束线段，它是常规做法，线段边界90度垂直于描边的方向、贯穿它的终点。</li>\n<li><code>square</code>的效果差不多，但是会稍微超出实际路径的范围，超出的大小由stroke-width控制。</li>\n<li><code>round</code>表示边框的终点是圆角，圆角的半径也是由stroke-width控制的。用直线结束线段</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/07/26/24c5fd2f693d1b91746dd7ba1c5ad0b7.png\" alt=\"image\"></p>\n<p><strong>stroke-linejoin</strong>：用来控制两条描边线段之间用什么方式连接。它有<br>三个值：</p>\n<ul>\n<li><code>miter</code> 默认值，表示用方形画笔在连接出形成尖角。</li>\n<li><code>round</code> 表示用圆角连接，实现平滑效果。</li>\n<li><code>bevel</code> 连接处会形成一个斜接。</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/07/26/7f6908d0b8cb0b4c8c1d5809e8f5d80a.png\" alt=\"image\"></p>\n<p><strong>stroke-dasharray</strong>：可以将虚线应用在描边上。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"150\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"1.1\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 10 75 Q 50 10 100 75 T 190 75\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"black\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">stroke-linecap</span>=<span class=\"string\">\"round\"</span> <span class=\"attr\">stroke-dasharray</span>=<span class=\"string\">\"5,10,5\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 10 75 L 190 75\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"red\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">stroke-linecap</span>=<span class=\"string\">\"round\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">stroke-dasharray</span>=<span class=\"string\">\"5,5\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>stroke-dasharray属性的参数，是一组用逗号分割的数字组成的数列。注意，和path不一样，这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度。所以在上面的例子里，第二个路径会先做5个像素单位的填色，紧接着是5个空白单位，然后又是5个单位的填色。如果你想要更复杂的虚线模式，你可以定义更多的数字。第一个例子指定了3个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染5个填色单位，10个空白单位，5个填色单位，然后回头以这3个数字做一次循环，但是这次是创建5个空白单位，10个填色单位，5个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复。</p>\n<p><strong>fill-rule</strong>：可以将虚线应用在描边于定义如何给图形重叠的区域上色。</p>\n<p><strong>stroke-dashoffset</strong>：定义虚线开始的位置。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SVG入门介绍\"><a href=\"#SVG入门介绍\" class=\"headerlink\" title=\"SVG入门介绍\"></a>SVG入门介绍</h1><p><img src=\"https://img.fengjr.com/image/2019/07/25/2c9c7fc330d25bde7ca74245c3bc5669.png\" alt=\"SVG\"></p>\n<h2 id=\"SVG的简介\"><a href=\"#SVG的简介\" class=\"headerlink\" title=\"SVG的简介\"></a>SVG的简介</h2><blockquote>\n<p>SVG（英文：Scalable Vector Graphics）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式，SVG由W3C制定，是一个开放标准。</p>\n</blockquote>\n<p>SVG推出于1999年，由一组加入W3C的公司启动开发，与之前1998年提交给W3C的标准（PGML、VML）构成竞争。SVG从这两个格式吸取了经验。</p>\n<p>SVG允许3种图形对象类型：矢量图形、栅格图像以及文本。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>图像文件可读，易于修改和编辑（理论上如此，但实际上却是因为各种不同的SVG档编辑器而可能存储成不易解读的SVG文件）</li>\n<li>与现有技术可以互动融合。例如，SVG技术本身的动态部分（包括时序控制和动画）就是基于SMIL标准。另外，SVG文件还可嵌入JavaScript（严格地说，应该是ECMAScript）脚本来控制SVG对象</li>\n<li>SVG图形格式可以方便的创建文字索引，从而实现基于内容的图像搜索</li>\n<li>SVG图形格式支持多种滤镜和特殊效果，在不改变图像内容的前提下可以实现位图格式中类似文字阴影的效果。</li>\n<li>SVG图形格式可以用来动态生成图形。例如，可用SVG动态生成具有交互功能的地图，嵌入网页中，并显示给终端用户。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>由于原始的SVG档是遵从XML语法，导致数据采用未压缩的方式存放，因此相较于其他的矢量图形格式，同样的文件内容会比其他的文件格式稍大。Adobe因此使用gzip压缩开发出压缩的SVG档格式，附文件名为 .svgz， 但此种文件格式除了Adobe旗下的软件以外，未被广泛支持使用。</li>\n<li>旧版的SVG Viewer无法正确显示出使用新版SVG格式的矢量图形。</li>\n<li>只能做2维图形，没法做动画</li>\n</ul>\n<h2 id=\"SVG的语法\"><a href=\"#SVG的语法\" class=\"headerlink\" title=\"SVG的语法\"></a>SVG的语法</h2><p>目前所有的浏览器都支持SVG，但各浏览器是有差异的，因此很可能你制作了一个SVG，并且用一个工具调试正常后，却在另一个浏览器种无法显示，这是因为不同的浏览器支持的SVG标准的程度不同。</p>\n<p>使用SVG，你需要掌握，有几个重点要记住：</p>\n<ul>\n<li>SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同）</li>\n<li>SVG里的属性值必须用引号引起来，就算是数值也必须这样做。</li>\n</ul>\n<h3 id=\"SVG的标签\"><a href=\"#SVG的标签\" class=\"headerlink\" title=\"SVG的标签\"></a>SVG的标签</h3><p>svg的代码都放在顶层标签<code>&lt;svg&gt;</code>中，下面是一个例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">version</span>=<span class=\"string\">\"1.1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">baseProfile</span>=<span class=\"string\">\"full\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">width</span>=<span class=\"string\">\"300\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"300\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">viewBox</span>=<span class=\"string\">\"50 50 50 50\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">circle</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mycircle\"</span> <span class=\"attr\">cx</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">cy</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">r</span>=<span class=\"string\">\"50\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>width</strong>：SVG图形占据页面的宽度，除了相对单位，也可以使用绝对单位，不指定默认为 300px。</p>\n<p><strong>height</strong>：SVG图形占据页面的高度，除了相对单位，也可以使用绝对单位，不指定默认为 150px。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/baseProfile\" target=\"_blank\" rel=\"noopener\"><strong>baseProfile</strong></a>：特性描述了作者认为正确渲染内容所需要的最小的 SVG 语言概述。这个特性不会说明任何处理限制，可以把它看作是元数据。 比如，这个特性的值可以被编辑工具用来在用户的修改超出所指定的基准概述范围时发出警告。</p>\n<p><strong>version</strong>：该version属性用于指示SVG文档符合的规范。它只允许在根<code>&lt;svg&gt;</code>元素上。它纯粹是建议性的，对渲染或处理没有影响，只有两个有效的选择是当前<code>1.0</code>和<code>1.1</code>。</p>\n<p><strong>xmlns</strong>：表明<code>&lt;svg&gt;</code>标签和它的字标签都属于 <a href=\"http://www.w3.org/2000/svg\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/2000/svg</a> 这个命名空间，这个声明只需要在根结点声明一次即可，命名空间仅仅是一些字符串，并不是链接到某一个地址。</p>\n<p><strong>viewBox</strong>：属性的值有四个数字，分别是左上角的横坐标和纵坐标、视口的宽度和高度。上面代码中，SVG 图像是150像素宽 x 50像素高，viewBox属性指定视口从(50, 50)这个点开始。所以，实际看到的是右下角的部分，视口必须适配所在的空间，上面代码中，视口大小是50 <em> 50，SVG图像是300 </em> 300，所以视口会去适配SVG的大小，意味着放大了6倍。</p>\n<p>下面我依次介绍一下SVG中几种基本图形的用法：</p>\n<h3 id=\"矩形\"><a href=\"#矩形\" class=\"headerlink\" title=\"矩形\"></a>矩形</h3><p><strong>rect</strong>元素可以在屏幕上绘制一个矩形，只需要六个基本属性就可以控制它在屏幕上的位置和形状。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rect</span> <span class=\"attr\">x</span>=<span class=\"string\">\"60\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">rx</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">ry</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"30\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"30\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>x</strong>：矩形左上角的X位置</p>\n<p><strong>y</strong>：矩形左上角的Y位置</p>\n<p><strong>width</strong>：矩形的宽度</p>\n<p><strong>height</strong>：矩形的高度</p>\n<p><strong>rx</strong>：圆角X方位的半径</p>\n<p><strong>ry</strong>：圆角Y方位的半径</p>\n<h3 id=\"圆形\"><a href=\"#圆形\" class=\"headerlink\" title=\"圆形\"></a>圆形</h3><p><strong>circle</strong>元素可以在屏幕上绘制一个圆形，只需要三个基本属就可以设置圆形。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">circle</span> <span class=\"attr\">cx</span>=<span class=\"string\">\"25\"</span> <span class=\"attr\">cy</span>=<span class=\"string\">\"75\"</span> <span class=\"attr\">r</span>=<span class=\"string\">\"20\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>cx</strong>：圆心X的位置</p>\n<p><strong>cy</strong>：圆心Y的位置</p>\n<p><strong>r</strong>：圆的半径</p>\n<h3 id=\"椭圆\"><a href=\"#椭圆\" class=\"headerlink\" title=\"椭圆\"></a>椭圆</h3><p>ellipse 是circle元素更通用的形式，可以缩放圆的X半径和Y半径</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ellipse</span> <span class=\"attr\">cx</span>=<span class=\"string\">\"75\"</span> <span class=\"attr\">cy</span>=<span class=\"string\">\"75\"</span> <span class=\"attr\">rx</span>=<span class=\"string\">\"20\"</span> <span class=\"attr\">ry</span>=<span class=\"string\">\"5\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>rx</strong>：椭圆的X半径</p>\n<p><strong>ry</strong>：椭圆的Y半径</p>\n<p><strong>cx</strong>：椭圆中心的X位置</p>\n<p><strong>cy</strong>：椭圆中心的Y位置</p>\n<h3 id=\"直线\"><a href=\"#直线\" class=\"headerlink\" title=\"直线\"></a>直线</h3><p>line 是用来绘制直线的，它取两个点的位置作为属性，指定这条线的起点和终点的位置。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">line</span> <span class=\"attr\">x1</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">x2</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">y1</span>=<span class=\"string\">\"110\"</span> <span class=\"attr\">y2</span>=<span class=\"string\">\"150\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>x1</strong>：起点的X位置</p>\n<p><strong>y1</strong>：起点的Y位置</p>\n<p><strong>x2</strong>：终点的X位置</p>\n<p><strong>y2</strong>：终点的Y位置</p>\n<h3 id=\"折线\"><a href=\"#折线\" class=\"headerlink\" title=\"折线\"></a>折线</h3><p>polyline 是一组连接在一起的直线，因为它可以有很多的点，折线的所有点位置都放在一个points属性中：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">\"60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>points</strong>：点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。</p>\n<h3 id=\"多边形\"><a href=\"#多边形\" class=\"headerlink\" title=\"多边形\"></a>多边形</h3><p>polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">polygon</span> <span class=\"attr\">points</span>=<span class=\"string\">\"50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>points</strong>：点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。</p>\n<h3 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h3><p>path可能是SVG中最常见的形状。你可以用path元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形，以及一些其他的形状，例如贝塞尔曲线、2次曲线等曲线。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 20 230 Q 40 205, 50 230 T 90 230\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>d</strong>：一个点集数列以及其它关于如何绘制路径的信息。</p>\n<p>由于path非常强大也非常的复杂，接下来我们重点学习一下path。</p>\n<p>path命令有两种表达方式：</p>\n<ul>\n<li>大写字母：表示采用绝对定位</li>\n<li>小写字母：表示采用相对定位，（例如，从上一个点的位置，向上移动10px等）</li>\n</ul>\n<h4 id=\"直线命令\"><a href=\"#直线命令\" class=\"headerlink\" title=\"直线命令\"></a>直线命令</h4><p><code>&lt;path&gt;</code>元素里有5个画直线的命令，顾名思义，直线命令就是在两个点之间画直线。首先是“Move to”命令，M，它需要两个参数，分别是需要移动到的点的x轴和y轴的坐标。假设，你的画笔当前位于一个点，在使用M命令移动画笔后，只会移动画笔，但不会在两点之间画线。因为M命令仅仅是移动画笔，但不画线。所以M命令经常出现在路径的开始处，用来指明从何处开始画。</p>\n<h5 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">M x y</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m dx dy</span><br></pre></td></tr></table></figure>\n<p>能够真正画线的命令有三个</p>\n<h5 id=\"L\"><a href=\"#L\" class=\"headerlink\" title=\"L\"></a>L</h5><p>L 表示的是 line to，有两个参数x和y，分别表示下一个点的x轴和y轴坐标，L将会在当前位置和新位置之间画一条线段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L x y (or l dx dy)</span><br></pre></td></tr></table></figure>\n<h5 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h5><p>H 表示绘制水平线，只有一个参数x，表示移动到x轴上该点位置的水平线。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">H x (or h dx)</span><br></pre></td></tr></table></figure>\n<h5 id=\"V\"><a href=\"#V\" class=\"headerlink\" title=\"V\"></a>V</h5><p>V 表示绘制垂直线，只有一个参数y，表示移动到y轴上该点位置的垂直线。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">V y (or v dy)</span><br></pre></td></tr></table></figure>\n<h5 id=\"Z\"><a href=\"#Z\" class=\"headerlink\" title=\"Z\"></a>Z</h5><p>Z表示一个闭合路径的命令，会从当前点画一条直线到起点，经常放在路径的最后，Z命令不区分大小写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Z（or z）</span><br></pre></td></tr></table></figure>\n<p>下面为总结的一个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M10 10 L 90 10 V 90 H 10 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"transparent\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"black\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"5\"</span>  /&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"曲线命令\"><a href=\"#曲线命令\" class=\"headerlink\" title=\"曲线命令\"></a>曲线命令</h4><p>SVG绘制平滑曲线的命令有三个，两个用来绘制贝塞尔曲线，另外一个用来绘制弧形或者说圆的一部分。</p>\n<h5 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h5><p>我们从稍微复杂一点的三次贝塞尔曲线C入手，三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)</span><br></pre></td></tr></table></figure>\n<p>这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。如果你熟悉代数或者微积分的话，会更容易理解控制点，控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/07/25/a74c83f52a7b4be5ebe036b6a3e7a2bd.png\" alt=\"image\"></p>\n<p>你可以将若干个贝塞尔曲线连起来，从而创建出一条很长的平滑曲线。通常情况下，一个点某一侧的控制点是它另一侧的控制点的对称（以保持斜率不变）。这样，你可以使用一个简写的贝塞尔曲线命令S，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S x2 y2, x y (or s dx2 dy2, dx dy)</span><br></pre></td></tr></table></figure>\n<p>S命令可以用来创建与前面一样的贝塞尔曲线，但是，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或S命令，那当前点将作为第一个控制点。</p>\n<p>另一种可用的贝塞尔曲线是二次贝塞尔曲线Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q x1 y1, x y (or q dx1 dy1, dx dy)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.fengjr.com/image/2019/07/25/5be989240c91dc86dc13102e23ced681.png\" alt=\"image\"></p>\n<p>就像三次贝塞尔曲线有一个S命令，二次贝塞尔曲线有一个差不多的T命令，可以通过更简短的参数，延长二次贝塞尔曲线。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T x y (or t dx dy)</span><br></pre></td></tr></table></figure>\n<p>和之前一样，快捷命令T会通过前一个控制点，推断出一个新的控制点。这意味着，在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。</p>\n<h5 id=\"弧形\"><a href=\"#弧形\" class=\"headerlink\" title=\"弧形\"></a>弧形</h5><p>弧形命令A是另一个创建SVG曲线的命令。基本上，弧形可以视为圆形或椭圆形的一部分。假设，已知椭圆形的长轴半径和短轴半径，并且已知两个点（在椭圆上），根据半径和两点，可以画出两个椭圆，在每个椭圆上根据两点都可以画出两种弧形。所以，仅仅根据半径和两点，可以画出四种弧形。为了保证创建的弧形唯一，A命令需要用到比较多的参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A rx ry x-axis-rotation large-arc-flag sweep-flag x y</span><br><span class=\"line\">a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</span><br></pre></td></tr></table></figure>\n<p><strong>rx</strong>：椭圆弧的x轴半径<br><strong>ry</strong>：椭圆弧的y轴半径<br><strong>x-axis-rotation</strong>：椭圆弧的旋转角度<br><strong>large-arc-flag</strong>：椭圆弧的角度大小，决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。<br><strong>sweep-flag</strong>：椭圆弧的弧线方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧<br><strong>x</strong>：椭圆弧的终点x坐标<br><strong>y</strong>：椭圆弧终点y坐标</p>\n<p>示例图片：</p>\n<p><img src=\"https://img.fengjr.com/image/2019/07/26/2c526c035064a6ad18f39fb5a0f875ee.png\" alt=\"image\"></p>\n<p>代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"325px\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"325px\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"1.1\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M80 80</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           A 45 45, 0, 0, 0, 125 125</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           L 125 80 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"green\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M230 80</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           A 45 45, 0, 1, 0, 275 125</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           L 275 80 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"red\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M80 230</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           A 45 45, 0, 0, 1, 125 275</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           L 125 230 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"purple\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M230 230</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           A 45 45, 0, 1, 1, 275 275</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">           L 275 230 Z\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"blue\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SVG的属性\"><a href=\"#SVG的属性\" class=\"headerlink\" title=\"SVG的属性\"></a>SVG的属性</h2><p>上面的例子我们可以看到，标签中很多写了fill和stroke属性的，这些是什么意思呢？</p>\n<h3 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill\"></a>fill</h3><p>fill 属性设置对象内部的颜色，还有一个fill-opacity可以控制填充色的不透明度，浏览器也支持rgba属性来设置同样效果，但是有些浏览器不支持。</p>\n<h3 id=\"stroke\"><a href=\"#stroke\" class=\"headerlink\" title=\"stroke\"></a>stroke</h3><p>除了颜色属性，stroke可以进行描边，stroke有以下几个属性：</p>\n<p><strong>stroke</strong>：用来设置边框的颜色</p>\n<p><strong>stroke-width</strong>：用来设置边框的宽度，描边是以路径为中心绘制的。</p>\n<p><strong>stroke-linecap</strong>：用来绘制边框终点的形状，它有三个值：</p>\n<ul>\n<li><code>butt</code>用直边结束线段，它是常规做法，线段边界90度垂直于描边的方向、贯穿它的终点。</li>\n<li><code>square</code>的效果差不多，但是会稍微超出实际路径的范围，超出的大小由stroke-width控制。</li>\n<li><code>round</code>表示边框的终点是圆角，圆角的半径也是由stroke-width控制的。用直线结束线段</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/07/26/24c5fd2f693d1b91746dd7ba1c5ad0b7.png\" alt=\"image\"></p>\n<p><strong>stroke-linejoin</strong>：用来控制两条描边线段之间用什么方式连接。它有<br>三个值：</p>\n<ul>\n<li><code>miter</code> 默认值，表示用方形画笔在连接出形成尖角。</li>\n<li><code>round</code> 表示用圆角连接，实现平滑效果。</li>\n<li><code>bevel</code> 连接处会形成一个斜接。</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/07/26/7f6908d0b8cb0b4c8c1d5809e8f5d80a.png\" alt=\"image\"></p>\n<p><strong>stroke-dasharray</strong>：可以将虚线应用在描边上。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"150\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"1.1\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 10 75 Q 50 10 100 75 T 190 75\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"black\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">stroke-linecap</span>=<span class=\"string\">\"round\"</span> <span class=\"attr\">stroke-dasharray</span>=<span class=\"string\">\"5,10,5\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 10 75 L 190 75\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"red\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">stroke-linecap</span>=<span class=\"string\">\"round\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">stroke-dasharray</span>=<span class=\"string\">\"5,5\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>stroke-dasharray属性的参数，是一组用逗号分割的数字组成的数列。注意，和path不一样，这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度。所以在上面的例子里，第二个路径会先做5个像素单位的填色，紧接着是5个空白单位，然后又是5个单位的填色。如果你想要更复杂的虚线模式，你可以定义更多的数字。第一个例子指定了3个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染5个填色单位，10个空白单位，5个填色单位，然后回头以这3个数字做一次循环，但是这次是创建5个空白单位，10个填色单位，5个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复。</p>\n<p><strong>fill-rule</strong>：可以将虚线应用在描边于定义如何给图形重叠的区域上色。</p>\n<p><strong>stroke-dashoffset</strong>：定义虚线开始的位置。</p>\n"},{"title":"编码哪些事儿","comments":0,"date":"2019-07-26T02:58:28.000Z","updated":"2020-06-10T06:01:54.269Z","author":"jun.zhou","_content":"\n# 1 编码的发展历史\n## 1.1 几个概念\n### 什么是字符\n\n字符是一个信息单位，在计算机里面，一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号都是一个字符。\n\n### 什么是字库表\n\n一些字符放在一起形成的一个数据库。例如英语、汉语等所包含的所有字符。\n\n### 什么是编码字符集（字符集）\n\n在一个字库表中，每一个字符都有一个对应的二进制地址，而编码字符集就是这些地址的集合。通过对应关系可以实现字符和二进制数之间的转换。例如在ASCII码字符集中，字母A的序号（地址）是65，65的二进制就是01000001。\n\n### 什么是字符编码\n\n字符编码也称字集码，是把字符集中的字符编码为特定的二进制数，以便文本在计算机中存储和通过通信网络的传递。要完成编码需要三个关键元素：字库表、编码字符集、字符编码。字库表相当于所有字符的数据库，字库表决定了整个字符集的范围。编码字符集，即用一个编码值来表示一个字符在字库中的位置。字符编码，将编码字符集和实际存储数值之间的转换关系。用函数y=f(x)来表示，\n\n                          编码：二进制数字=字符编码（字符）\n\n                          解码：字符=字符编码（二进制数字）\n\n## 1.2 ASCII字符集\n常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。\n### ASCII 码\n我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。\n\nASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。\n![Ascii](https://img.fengjr.com/image/2019/07/26/74fab5831e99f021927d1ed058254f0f.png \"Ascii\")\n## 1.3 ASCII扩展\n英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的,当计算机传到了欧洲，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。\n\n后来国际标准化组织在ASCII的基础上进行了扩展，形成了ISO-8859标准，兼容ASCII，在高128个码位上有所区别。但是由于欧洲的语言环境十分复杂，所以根据各地区的语言又形成了很多子标准，ISO-8859-1、ISO-8859-2、ISO-8859-3、……、ISO-8859-16。\n## 1.4 GB2312\n对于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。\n\n简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。\n\n1981年5月1日开始实施的一套国家标准，标准号是GB 2312—1980\n\n基本集共收入汉字6763个和非汉字图形字符682个。整个字符集分成94个区，每区有94个位。每个区位上只有一个字符，因此可用所在的区和位来对汉字进行编码，称为区位码。\n![图](https://img.fengjr.com/image/2019/07/26/367a26051ab559f4057fa4ba682e88a9.jpg \"图\")\n## 1.5 BIG5\n又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五家软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。\n\nBig5字符集共收录13,053个中文字，该字符集在中国台湾使用。\n## 1.6 GBK\nGBK编码，是对GB2312编码的扩展，因此完全兼容GB2312-80标准。GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。共收录汉字和图形符号21886个，其中汉字（包括部首和构件）21003个，图形符号883个。\n\n      注： 0x7F表示删除符号，各种编码规范都应避开。\n\nGBK编码支持国际标准ISO/IEC10646-1和国家标准GB13000-1中的全部中日韩汉字，并包含了BIG5编码中的所有汉字。GBK编码方案于1995年12月15日正式发布。\n## 1.7 Unicode\n世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。要想打开一个文件，就必须知道编码方式，否则只能看到乱码。\n\n国际标准化组织(ISO)编纂了ISO10646来规范和整合字符集(被成为通用字符集 Universal Character Set，UCS )。统一码联盟(由各个大型企业及组织共同维护)发布了统一码(Unicode)项目。\n\n起初，UCS和Unicode各自为政，但1991年前后他们都发现：世界不需要两个不一样的“统一”、“通用”的字符集。所以他们联合起来维护一个字符集，现在他们的差别大概是发布新版本时使用什么字体。\n\nUCS和Unicode都使用最大32bit来存储字符，理论上可以表示42亿个字符，实际码位(字符数)只有1114112个，从0x00到0x10FFFF。\n目前的Unicode字符分为17组编排，0x000000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，目前只用了少数平面。\n\n零号平面( BMP)，0x0000-0xFFFF，共定义27973个汉字，范围0x4E00-0x9FA5。平面2中有43253个汉字。例如汉字的“汉”字，编码为0x6C49。\n## 1.8 UTF8\n使用32bit来存储字符看起来是一件一劳永逸的方式，但如果这32bit是定宽的(即任何字符都要使用完这32bit)的话就不可避免的造成空间的浪费，程序效率也会降低！\n\n能不能把UCS(Unicode)设计成“变宽”的呢？聪明的设计师想到了一个主意，他们发明了一种名为“统一码转换格式”即UTF来将字符对应的数字转化为多个字节来进行存储。\n\nUnicode是编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。常见的编码实现还有UTF-16、UTF-32。\n\nUTF-8是可变长度字符编码。编码规则如下：\n![图](https://img.fengjr.com/image/2019/07/26/2f3d1d3592ec94f1de0d05d10cf46321.jpg \"图\")\n\n“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。\n![图](https://img.fengjr.com/image/2019/07/26/8623511c7cf0e4a09c08cda5752157aa.jpg \"图\")\n## 1.9 UTF-16和UTF-32\n ![图](https://img.fengjr.com/image/2019/07/26/ebadcf8a655996c3dc908b5a1a97ddda.jpg \"图\")\n## 1.10 Emoji\n所谓Emoji（表情符号）就是一种在Unicode位于\\u01F601-\\u01F64F区段的字符。\n\nMYSQL中utf8只支持3个字节，即实现了0平面的编码范围\\u0000-\\uFFFF，utf8mb4是支持4个字节的，兼容utf8，因此mysql数据库中一定要用utfmb4编码。\n# 2 计算机文件\n计算机文件（或称文件、电脑档案、档案），是存储在某种长期储存设备上的一段数据流。所谓“长期储存设备”一般指磁盘、光盘、磁带等。其特点是所存信息可以长期、多次使用，不会因为断电而消失。\n\n一种重要的文件是文本文件，是由一些字符的串行组成的。二进制文件一般是指除了文本文件以外的文件。\n\n虽然一个文件表现为一个单一的流，但它经常在磁盘不同的位置存储为多个数据碎片（甚至是多个磁盘）。操作系统会将它们组织成文件系统，每个文件放在特定的文件夹或目录中。\n## 2.1 文本文件\n文本文件是一种计算机文件，它是一种典型的顺序文件，其文件的逻辑结构又属于流式文件。\n\n文本文件存在于计算机文件系统中。通常，通过在文本文件最后一行后放置文件结束标志来指明文件的结束。计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。\n\n简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值（可以看作是自定义编码）。\n ![](https://img.fengjr.com/image/2019/07/26/1c98a752254d31b3c34ca663e0c762f5.png \"图\")\n## 2.2 二进制文件\n![图](https://img.fengjr.com/image/2019/07/26/11b6841f8c002ba6dc52a7e213db7cbf.jpg \"图\")\n## 2.3 比较\n![](https://img.fengjr.com/image/2019/07/26/b1fdd2a20f97914c497c0801b736d374.jpg \"图\")\n\n# 3 数据传输中的编码\n通常上的理解，http协议中请求、响应都是以ASCII字符方式传输，如果要传输二进制需要经过BASE64或MIME等编码（因为HTTP协议pop3、smtp邮件协议都是针对文本的，而FTP支持传输二进制数据）\n\n如果直接使用http传输二进制(不经过base64编码)，可能会造成一下问题：\n\n 1) 不知道传输字节的具体长度。如将int类型的1234567转为char类型“1234567”，丢失掉了长度的信息，本来只有4个字节，但是转化成文本的是有7个字节，无法转换回去。\n\n 2) 对于一些数字，二进制传输Server是没法处理的。如int 1,二进制数据是0x00000001，按字节传输的时候，client能够正常发送，但是libevent收到以后，在抛给libevent_http层时，会把数据截断，前两位0x00是字符串的停止符。\n\nHTTP请求体可以是多种形式的。根据请求头/响应头中的content-type属性来处理。例如 Content-Type:image/gif 说明传输的是一个image对象（二进制数据），该对象为gif格式。\n## 3.1 Base64\nbase64 最早就是用来邮件传输协议中的，原因是邮件传输协议只支持 ascii 字符传递，因此如果要传输二进制文件，如：图片、视频是无法实现的。因此 base64 就可以用来将二进制文件内容编码为只包含 ascii 字符的内容。\n\nBase64常用于X.509公钥证书、 XML文本传输、 HTTP协议、电子邮件（SMTP协议）、图片base64编码。\n\nBase64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。\n\nBase64的原理很简单，首先，准备一个包含64个字符的数组：\n['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/’]\n然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit：\n![](https://img.fengjr.com/image/2019/07/26/762449f589daeec232f87ee37cac66ba.png \"图\")\n![](https://img.fengjr.com/image/2019/07/26/bb7aa5be3384b28432e4bd178edf00a6.png \"图\")\n## 3.2 URL编码\n![](https://img.fengjr.com/image/2019/07/26/5461599f6a44163821d2bd0e1b60307b.png \"图\")\n![](https://img.fengjr.com/image/2019/07/26/de1bc5942fcbde2867eac9ec1dd913c8.png \"图\")\n![](https://img.fengjr.com/image/2019/07/26/f2a00f22bf4b2506ec83a25b7730d808.png \"图\")\n\n\n\n\n\n","source":"_posts/2019-07-26-编码问题.md","raw":"---\ntitle: 编码哪些事儿\ncomments: false\ndate: 2019-07-26 10:58:28\ntags:\n- js\nupdated:\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n# 1 编码的发展历史\n## 1.1 几个概念\n### 什么是字符\n\n字符是一个信息单位，在计算机里面，一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号都是一个字符。\n\n### 什么是字库表\n\n一些字符放在一起形成的一个数据库。例如英语、汉语等所包含的所有字符。\n\n### 什么是编码字符集（字符集）\n\n在一个字库表中，每一个字符都有一个对应的二进制地址，而编码字符集就是这些地址的集合。通过对应关系可以实现字符和二进制数之间的转换。例如在ASCII码字符集中，字母A的序号（地址）是65，65的二进制就是01000001。\n\n### 什么是字符编码\n\n字符编码也称字集码，是把字符集中的字符编码为特定的二进制数，以便文本在计算机中存储和通过通信网络的传递。要完成编码需要三个关键元素：字库表、编码字符集、字符编码。字库表相当于所有字符的数据库，字库表决定了整个字符集的范围。编码字符集，即用一个编码值来表示一个字符在字库中的位置。字符编码，将编码字符集和实际存储数值之间的转换关系。用函数y=f(x)来表示，\n\n                          编码：二进制数字=字符编码（字符）\n\n                          解码：字符=字符编码（二进制数字）\n\n## 1.2 ASCII字符集\n常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。\n### ASCII 码\n我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。\n\nASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。\n![Ascii](https://img.fengjr.com/image/2019/07/26/74fab5831e99f021927d1ed058254f0f.png \"Ascii\")\n## 1.3 ASCII扩展\n英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的,当计算机传到了欧洲，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。\n\n后来国际标准化组织在ASCII的基础上进行了扩展，形成了ISO-8859标准，兼容ASCII，在高128个码位上有所区别。但是由于欧洲的语言环境十分复杂，所以根据各地区的语言又形成了很多子标准，ISO-8859-1、ISO-8859-2、ISO-8859-3、……、ISO-8859-16。\n## 1.4 GB2312\n对于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。\n\n简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。\n\n1981年5月1日开始实施的一套国家标准，标准号是GB 2312—1980\n\n基本集共收入汉字6763个和非汉字图形字符682个。整个字符集分成94个区，每区有94个位。每个区位上只有一个字符，因此可用所在的区和位来对汉字进行编码，称为区位码。\n![图](https://img.fengjr.com/image/2019/07/26/367a26051ab559f4057fa4ba682e88a9.jpg \"图\")\n## 1.5 BIG5\n又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五家软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。\n\nBig5字符集共收录13,053个中文字，该字符集在中国台湾使用。\n## 1.6 GBK\nGBK编码，是对GB2312编码的扩展，因此完全兼容GB2312-80标准。GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。共收录汉字和图形符号21886个，其中汉字（包括部首和构件）21003个，图形符号883个。\n\n      注： 0x7F表示删除符号，各种编码规范都应避开。\n\nGBK编码支持国际标准ISO/IEC10646-1和国家标准GB13000-1中的全部中日韩汉字，并包含了BIG5编码中的所有汉字。GBK编码方案于1995年12月15日正式发布。\n## 1.7 Unicode\n世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。要想打开一个文件，就必须知道编码方式，否则只能看到乱码。\n\n国际标准化组织(ISO)编纂了ISO10646来规范和整合字符集(被成为通用字符集 Universal Character Set，UCS )。统一码联盟(由各个大型企业及组织共同维护)发布了统一码(Unicode)项目。\n\n起初，UCS和Unicode各自为政，但1991年前后他们都发现：世界不需要两个不一样的“统一”、“通用”的字符集。所以他们联合起来维护一个字符集，现在他们的差别大概是发布新版本时使用什么字体。\n\nUCS和Unicode都使用最大32bit来存储字符，理论上可以表示42亿个字符，实际码位(字符数)只有1114112个，从0x00到0x10FFFF。\n目前的Unicode字符分为17组编排，0x000000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，目前只用了少数平面。\n\n零号平面( BMP)，0x0000-0xFFFF，共定义27973个汉字，范围0x4E00-0x9FA5。平面2中有43253个汉字。例如汉字的“汉”字，编码为0x6C49。\n## 1.8 UTF8\n使用32bit来存储字符看起来是一件一劳永逸的方式，但如果这32bit是定宽的(即任何字符都要使用完这32bit)的话就不可避免的造成空间的浪费，程序效率也会降低！\n\n能不能把UCS(Unicode)设计成“变宽”的呢？聪明的设计师想到了一个主意，他们发明了一种名为“统一码转换格式”即UTF来将字符对应的数字转化为多个字节来进行存储。\n\nUnicode是编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。常见的编码实现还有UTF-16、UTF-32。\n\nUTF-8是可变长度字符编码。编码规则如下：\n![图](https://img.fengjr.com/image/2019/07/26/2f3d1d3592ec94f1de0d05d10cf46321.jpg \"图\")\n\n“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。\n![图](https://img.fengjr.com/image/2019/07/26/8623511c7cf0e4a09c08cda5752157aa.jpg \"图\")\n## 1.9 UTF-16和UTF-32\n ![图](https://img.fengjr.com/image/2019/07/26/ebadcf8a655996c3dc908b5a1a97ddda.jpg \"图\")\n## 1.10 Emoji\n所谓Emoji（表情符号）就是一种在Unicode位于\\u01F601-\\u01F64F区段的字符。\n\nMYSQL中utf8只支持3个字节，即实现了0平面的编码范围\\u0000-\\uFFFF，utf8mb4是支持4个字节的，兼容utf8，因此mysql数据库中一定要用utfmb4编码。\n# 2 计算机文件\n计算机文件（或称文件、电脑档案、档案），是存储在某种长期储存设备上的一段数据流。所谓“长期储存设备”一般指磁盘、光盘、磁带等。其特点是所存信息可以长期、多次使用，不会因为断电而消失。\n\n一种重要的文件是文本文件，是由一些字符的串行组成的。二进制文件一般是指除了文本文件以外的文件。\n\n虽然一个文件表现为一个单一的流，但它经常在磁盘不同的位置存储为多个数据碎片（甚至是多个磁盘）。操作系统会将它们组织成文件系统，每个文件放在特定的文件夹或目录中。\n## 2.1 文本文件\n文本文件是一种计算机文件，它是一种典型的顺序文件，其文件的逻辑结构又属于流式文件。\n\n文本文件存在于计算机文件系统中。通常，通过在文本文件最后一行后放置文件结束标志来指明文件的结束。计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。\n\n简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值（可以看作是自定义编码）。\n ![](https://img.fengjr.com/image/2019/07/26/1c98a752254d31b3c34ca663e0c762f5.png \"图\")\n## 2.2 二进制文件\n![图](https://img.fengjr.com/image/2019/07/26/11b6841f8c002ba6dc52a7e213db7cbf.jpg \"图\")\n## 2.3 比较\n![](https://img.fengjr.com/image/2019/07/26/b1fdd2a20f97914c497c0801b736d374.jpg \"图\")\n\n# 3 数据传输中的编码\n通常上的理解，http协议中请求、响应都是以ASCII字符方式传输，如果要传输二进制需要经过BASE64或MIME等编码（因为HTTP协议pop3、smtp邮件协议都是针对文本的，而FTP支持传输二进制数据）\n\n如果直接使用http传输二进制(不经过base64编码)，可能会造成一下问题：\n\n 1) 不知道传输字节的具体长度。如将int类型的1234567转为char类型“1234567”，丢失掉了长度的信息，本来只有4个字节，但是转化成文本的是有7个字节，无法转换回去。\n\n 2) 对于一些数字，二进制传输Server是没法处理的。如int 1,二进制数据是0x00000001，按字节传输的时候，client能够正常发送，但是libevent收到以后，在抛给libevent_http层时，会把数据截断，前两位0x00是字符串的停止符。\n\nHTTP请求体可以是多种形式的。根据请求头/响应头中的content-type属性来处理。例如 Content-Type:image/gif 说明传输的是一个image对象（二进制数据），该对象为gif格式。\n## 3.1 Base64\nbase64 最早就是用来邮件传输协议中的，原因是邮件传输协议只支持 ascii 字符传递，因此如果要传输二进制文件，如：图片、视频是无法实现的。因此 base64 就可以用来将二进制文件内容编码为只包含 ascii 字符的内容。\n\nBase64常用于X.509公钥证书、 XML文本传输、 HTTP协议、电子邮件（SMTP协议）、图片base64编码。\n\nBase64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。\n\nBase64的原理很简单，首先，准备一个包含64个字符的数组：\n['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/’]\n然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit：\n![](https://img.fengjr.com/image/2019/07/26/762449f589daeec232f87ee37cac66ba.png \"图\")\n![](https://img.fengjr.com/image/2019/07/26/bb7aa5be3384b28432e4bd178edf00a6.png \"图\")\n## 3.2 URL编码\n![](https://img.fengjr.com/image/2019/07/26/5461599f6a44163821d2bd0e1b60307b.png \"图\")\n![](https://img.fengjr.com/image/2019/07/26/de1bc5942fcbde2867eac9ec1dd913c8.png \"图\")\n![](https://img.fengjr.com/image/2019/07/26/f2a00f22bf4b2506ec83a25b7730d808.png \"图\")\n\n\n\n\n\n","slug":"编码问题","published":1,"_id":"ck2yl0qc2000ah6q6mxz6ahdo","layout":"post","photos":[],"link":"","content":"<h1 id=\"1-编码的发展历史\"><a href=\"#1-编码的发展历史\" class=\"headerlink\" title=\"1 编码的发展历史\"></a>1 编码的发展历史</h1><h2 id=\"1-1-几个概念\"><a href=\"#1-1-几个概念\" class=\"headerlink\" title=\"1.1 几个概念\"></a>1.1 几个概念</h2><h3 id=\"什么是字符\"><a href=\"#什么是字符\" class=\"headerlink\" title=\"什么是字符\"></a>什么是字符</h3><p>字符是一个信息单位，在计算机里面，一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号都是一个字符。</p>\n<h3 id=\"什么是字库表\"><a href=\"#什么是字库表\" class=\"headerlink\" title=\"什么是字库表\"></a>什么是字库表</h3><p>一些字符放在一起形成的一个数据库。例如英语、汉语等所包含的所有字符。</p>\n<h3 id=\"什么是编码字符集（字符集）\"><a href=\"#什么是编码字符集（字符集）\" class=\"headerlink\" title=\"什么是编码字符集（字符集）\"></a>什么是编码字符集（字符集）</h3><p>在一个字库表中，每一个字符都有一个对应的二进制地址，而编码字符集就是这些地址的集合。通过对应关系可以实现字符和二进制数之间的转换。例如在ASCII码字符集中，字母A的序号（地址）是65，65的二进制就是01000001。</p>\n<h3 id=\"什么是字符编码\"><a href=\"#什么是字符编码\" class=\"headerlink\" title=\"什么是字符编码\"></a>什么是字符编码</h3><p>字符编码也称字集码，是把字符集中的字符编码为特定的二进制数，以便文本在计算机中存储和通过通信网络的传递。要完成编码需要三个关键元素：字库表、编码字符集、字符编码。字库表相当于所有字符的数据库，字库表决定了整个字符集的范围。编码字符集，即用一个编码值来表示一个字符在字库中的位置。字符编码，将编码字符集和实际存储数值之间的转换关系。用函数y=f(x)来表示，</p>\n<pre><code>编码：二进制数字=字符编码（字符）\n\n解码：字符=字符编码（二进制数字）\n</code></pre><h2 id=\"1-2-ASCII字符集\"><a href=\"#1-2-ASCII字符集\" class=\"headerlink\" title=\"1.2 ASCII字符集\"></a>1.2 ASCII字符集</h2><p>常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</p>\n<p>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。<br><img src=\"https://img.fengjr.com/image/2019/07/26/74fab5831e99f021927d1ed058254f0f.png\" alt=\"Ascii\" title=\"Ascii\"></p>\n<h2 id=\"1-3-ASCII扩展\"><a href=\"#1-3-ASCII扩展\" class=\"headerlink\" title=\"1.3 ASCII扩展\"></a>1.3 ASCII扩展</h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的,当计算机传到了欧洲，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。</p>\n<p>后来国际标准化组织在ASCII的基础上进行了扩展，形成了ISO-8859标准，兼容ASCII，在高128个码位上有所区别。但是由于欧洲的语言环境十分复杂，所以根据各地区的语言又形成了很多子标准，ISO-8859-1、ISO-8859-2、ISO-8859-3、……、ISO-8859-16。</p>\n<h2 id=\"1-4-GB2312\"><a href=\"#1-4-GB2312\" class=\"headerlink\" title=\"1.4 GB2312\"></a>1.4 GB2312</h2><p>对于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。</p>\n<p>简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p>\n<p>1981年5月1日开始实施的一套国家标准，标准号是GB 2312—1980</p>\n<p>基本集共收入汉字6763个和非汉字图形字符682个。整个字符集分成94个区，每区有94个位。每个区位上只有一个字符，因此可用所在的区和位来对汉字进行编码，称为区位码。<br><img src=\"https://img.fengjr.com/image/2019/07/26/367a26051ab559f4057fa4ba682e88a9.jpg\" alt=\"图\" title=\"图\"></p>\n<h2 id=\"1-5-BIG5\"><a href=\"#1-5-BIG5\" class=\"headerlink\" title=\"1.5 BIG5\"></a>1.5 BIG5</h2><p>又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五家软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。</p>\n<p>Big5字符集共收录13,053个中文字，该字符集在中国台湾使用。</p>\n<h2 id=\"1-6-GBK\"><a href=\"#1-6-GBK\" class=\"headerlink\" title=\"1.6 GBK\"></a>1.6 GBK</h2><p>GBK编码，是对GB2312编码的扩展，因此完全兼容GB2312-80标准。GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。共收录汉字和图形符号21886个，其中汉字（包括部首和构件）21003个，图形符号883个。</p>\n<pre><code>注： 0x7F表示删除符号，各种编码规范都应避开。\n</code></pre><p>GBK编码支持国际标准ISO/IEC10646-1和国家标准GB13000-1中的全部中日韩汉字，并包含了BIG5编码中的所有汉字。GBK编码方案于1995年12月15日正式发布。</p>\n<h2 id=\"1-7-Unicode\"><a href=\"#1-7-Unicode\" class=\"headerlink\" title=\"1.7 Unicode\"></a>1.7 Unicode</h2><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。要想打开一个文件，就必须知道编码方式，否则只能看到乱码。</p>\n<p>国际标准化组织(ISO)编纂了ISO10646来规范和整合字符集(被成为通用字符集 Universal Character Set，UCS )。统一码联盟(由各个大型企业及组织共同维护)发布了统一码(Unicode)项目。</p>\n<p>起初，UCS和Unicode各自为政，但1991年前后他们都发现：世界不需要两个不一样的“统一”、“通用”的字符集。所以他们联合起来维护一个字符集，现在他们的差别大概是发布新版本时使用什么字体。</p>\n<p>UCS和Unicode都使用最大32bit来存储字符，理论上可以表示42亿个字符，实际码位(字符数)只有1114112个，从0x00到0x10FFFF。<br>目前的Unicode字符分为17组编排，0x000000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，目前只用了少数平面。</p>\n<p>零号平面( BMP)，0x0000-0xFFFF，共定义27973个汉字，范围0x4E00-0x9FA5。平面2中有43253个汉字。例如汉字的“汉”字，编码为0x6C49。</p>\n<h2 id=\"1-8-UTF8\"><a href=\"#1-8-UTF8\" class=\"headerlink\" title=\"1.8 UTF8\"></a>1.8 UTF8</h2><p>使用32bit来存储字符看起来是一件一劳永逸的方式，但如果这32bit是定宽的(即任何字符都要使用完这32bit)的话就不可避免的造成空间的浪费，程序效率也会降低！</p>\n<p>能不能把UCS(Unicode)设计成“变宽”的呢？聪明的设计师想到了一个主意，他们发明了一种名为“统一码转换格式”即UTF来将字符对应的数字转化为多个字节来进行存储。</p>\n<p>Unicode是编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。常见的编码实现还有UTF-16、UTF-32。</p>\n<p>UTF-8是可变长度字符编码。编码规则如下：<br><img src=\"https://img.fengjr.com/image/2019/07/26/2f3d1d3592ec94f1de0d05d10cf46321.jpg\" alt=\"图\" title=\"图\"></p>\n<p>“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。<br><img src=\"https://img.fengjr.com/image/2019/07/26/8623511c7cf0e4a09c08cda5752157aa.jpg\" alt=\"图\" title=\"图\"></p>\n<h2 id=\"1-9-UTF-16和UTF-32\"><a href=\"#1-9-UTF-16和UTF-32\" class=\"headerlink\" title=\"1.9 UTF-16和UTF-32\"></a>1.9 UTF-16和UTF-32</h2><p> <img src=\"https://img.fengjr.com/image/2019/07/26/ebadcf8a655996c3dc908b5a1a97ddda.jpg\" alt=\"图\" title=\"图\"></p>\n<h2 id=\"1-10-Emoji\"><a href=\"#1-10-Emoji\" class=\"headerlink\" title=\"1.10 Emoji\"></a>1.10 Emoji</h2><p>所谓Emoji（表情符号）就是一种在Unicode位于\\u01F601-\\u01F64F区段的字符。</p>\n<p>MYSQL中utf8只支持3个字节，即实现了0平面的编码范围\\u0000-\\uFFFF，utf8mb4是支持4个字节的，兼容utf8，因此mysql数据库中一定要用utfmb4编码。</p>\n<h1 id=\"2-计算机文件\"><a href=\"#2-计算机文件\" class=\"headerlink\" title=\"2 计算机文件\"></a>2 计算机文件</h1><p>计算机文件（或称文件、电脑档案、档案），是存储在某种长期储存设备上的一段数据流。所谓“长期储存设备”一般指磁盘、光盘、磁带等。其特点是所存信息可以长期、多次使用，不会因为断电而消失。</p>\n<p>一种重要的文件是文本文件，是由一些字符的串行组成的。二进制文件一般是指除了文本文件以外的文件。</p>\n<p>虽然一个文件表现为一个单一的流，但它经常在磁盘不同的位置存储为多个数据碎片（甚至是多个磁盘）。操作系统会将它们组织成文件系统，每个文件放在特定的文件夹或目录中。</p>\n<h2 id=\"2-1-文本文件\"><a href=\"#2-1-文本文件\" class=\"headerlink\" title=\"2.1 文本文件\"></a>2.1 文本文件</h2><p>文本文件是一种计算机文件，它是一种典型的顺序文件，其文件的逻辑结构又属于流式文件。</p>\n<p>文本文件存在于计算机文件系统中。通常，通过在文本文件最后一行后放置文件结束标志来指明文件的结束。计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。</p>\n<p>简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值（可以看作是自定义编码）。<br> <img src=\"https://img.fengjr.com/image/2019/07/26/1c98a752254d31b3c34ca663e0c762f5.png\" alt title=\"图\"></p>\n<h2 id=\"2-2-二进制文件\"><a href=\"#2-2-二进制文件\" class=\"headerlink\" title=\"2.2 二进制文件\"></a>2.2 二进制文件</h2><p><img src=\"https://img.fengjr.com/image/2019/07/26/11b6841f8c002ba6dc52a7e213db7cbf.jpg\" alt=\"图\" title=\"图\"></p>\n<h2 id=\"2-3-比较\"><a href=\"#2-3-比较\" class=\"headerlink\" title=\"2.3 比较\"></a>2.3 比较</h2><p><img src=\"https://img.fengjr.com/image/2019/07/26/b1fdd2a20f97914c497c0801b736d374.jpg\" alt title=\"图\"></p>\n<h1 id=\"3-数据传输中的编码\"><a href=\"#3-数据传输中的编码\" class=\"headerlink\" title=\"3 数据传输中的编码\"></a>3 数据传输中的编码</h1><p>通常上的理解，http协议中请求、响应都是以ASCII字符方式传输，如果要传输二进制需要经过BASE64或MIME等编码（因为HTTP协议pop3、smtp邮件协议都是针对文本的，而FTP支持传输二进制数据）</p>\n<p>如果直接使用http传输二进制(不经过base64编码)，可能会造成一下问题：</p>\n<p> 1) 不知道传输字节的具体长度。如将int类型的1234567转为char类型“1234567”，丢失掉了长度的信息，本来只有4个字节，但是转化成文本的是有7个字节，无法转换回去。</p>\n<p> 2) 对于一些数字，二进制传输Server是没法处理的。如int 1,二进制数据是0x00000001，按字节传输的时候，client能够正常发送，但是libevent收到以后，在抛给libevent_http层时，会把数据截断，前两位0x00是字符串的停止符。</p>\n<p>HTTP请求体可以是多种形式的。根据请求头/响应头中的content-type属性来处理。例如 Content-Type:image/gif 说明传输的是一个image对象（二进制数据），该对象为gif格式。</p>\n<h2 id=\"3-1-Base64\"><a href=\"#3-1-Base64\" class=\"headerlink\" title=\"3.1 Base64\"></a>3.1 Base64</h2><p>base64 最早就是用来邮件传输协议中的，原因是邮件传输协议只支持 ascii 字符传递，因此如果要传输二进制文件，如：图片、视频是无法实现的。因此 base64 就可以用来将二进制文件内容编码为只包含 ascii 字符的内容。</p>\n<p>Base64常用于X.509公钥证书、 XML文本传输、 HTTP协议、电子邮件（SMTP协议）、图片base64编码。</p>\n<p>Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。</p>\n<p>Base64的原理很简单，首先，准备一个包含64个字符的数组：<br>[‘A’, ‘B’, ‘C’, … ‘a’, ‘b’, ‘c’, … ‘0’, ‘1’, … ‘+’, ‘/’]<br>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit：<br><img src=\"https://img.fengjr.com/image/2019/07/26/762449f589daeec232f87ee37cac66ba.png\" alt title=\"图\"><br><img src=\"https://img.fengjr.com/image/2019/07/26/bb7aa5be3384b28432e4bd178edf00a6.png\" alt title=\"图\"></p>\n<h2 id=\"3-2-URL编码\"><a href=\"#3-2-URL编码\" class=\"headerlink\" title=\"3.2 URL编码\"></a>3.2 URL编码</h2><p><img src=\"https://img.fengjr.com/image/2019/07/26/5461599f6a44163821d2bd0e1b60307b.png\" alt title=\"图\"><br><img src=\"https://img.fengjr.com/image/2019/07/26/de1bc5942fcbde2867eac9ec1dd913c8.png\" alt title=\"图\"><br><img src=\"https://img.fengjr.com/image/2019/07/26/f2a00f22bf4b2506ec83a25b7730d808.png\" alt title=\"图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-编码的发展历史\"><a href=\"#1-编码的发展历史\" class=\"headerlink\" title=\"1 编码的发展历史\"></a>1 编码的发展历史</h1><h2 id=\"1-1-几个概念\"><a href=\"#1-1-几个概念\" class=\"headerlink\" title=\"1.1 几个概念\"></a>1.1 几个概念</h2><h3 id=\"什么是字符\"><a href=\"#什么是字符\" class=\"headerlink\" title=\"什么是字符\"></a>什么是字符</h3><p>字符是一个信息单位，在计算机里面，一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号都是一个字符。</p>\n<h3 id=\"什么是字库表\"><a href=\"#什么是字库表\" class=\"headerlink\" title=\"什么是字库表\"></a>什么是字库表</h3><p>一些字符放在一起形成的一个数据库。例如英语、汉语等所包含的所有字符。</p>\n<h3 id=\"什么是编码字符集（字符集）\"><a href=\"#什么是编码字符集（字符集）\" class=\"headerlink\" title=\"什么是编码字符集（字符集）\"></a>什么是编码字符集（字符集）</h3><p>在一个字库表中，每一个字符都有一个对应的二进制地址，而编码字符集就是这些地址的集合。通过对应关系可以实现字符和二进制数之间的转换。例如在ASCII码字符集中，字母A的序号（地址）是65，65的二进制就是01000001。</p>\n<h3 id=\"什么是字符编码\"><a href=\"#什么是字符编码\" class=\"headerlink\" title=\"什么是字符编码\"></a>什么是字符编码</h3><p>字符编码也称字集码，是把字符集中的字符编码为特定的二进制数，以便文本在计算机中存储和通过通信网络的传递。要完成编码需要三个关键元素：字库表、编码字符集、字符编码。字库表相当于所有字符的数据库，字库表决定了整个字符集的范围。编码字符集，即用一个编码值来表示一个字符在字库中的位置。字符编码，将编码字符集和实际存储数值之间的转换关系。用函数y=f(x)来表示，</p>\n<pre><code>编码：二进制数字=字符编码（字符）\n\n解码：字符=字符编码（二进制数字）\n</code></pre><h2 id=\"1-2-ASCII字符集\"><a href=\"#1-2-ASCII字符集\" class=\"headerlink\" title=\"1.2 ASCII字符集\"></a>1.2 ASCII字符集</h2><p>常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>\n<h3 id=\"ASCII-码\"><a href=\"#ASCII-码\" class=\"headerlink\" title=\"ASCII 码\"></a>ASCII 码</h3><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</p>\n<p>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。<br><img src=\"https://img.fengjr.com/image/2019/07/26/74fab5831e99f021927d1ed058254f0f.png\" alt=\"Ascii\" title=\"Ascii\"></p>\n<h2 id=\"1-3-ASCII扩展\"><a href=\"#1-3-ASCII扩展\" class=\"headerlink\" title=\"1.3 ASCII扩展\"></a>1.3 ASCII扩展</h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的,当计算机传到了欧洲，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。</p>\n<p>后来国际标准化组织在ASCII的基础上进行了扩展，形成了ISO-8859标准，兼容ASCII，在高128个码位上有所区别。但是由于欧洲的语言环境十分复杂，所以根据各地区的语言又形成了很多子标准，ISO-8859-1、ISO-8859-2、ISO-8859-3、……、ISO-8859-16。</p>\n<h2 id=\"1-4-GB2312\"><a href=\"#1-4-GB2312\" class=\"headerlink\" title=\"1.4 GB2312\"></a>1.4 GB2312</h2><p>对于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。</p>\n<p>简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p>\n<p>1981年5月1日开始实施的一套国家标准，标准号是GB 2312—1980</p>\n<p>基本集共收入汉字6763个和非汉字图形字符682个。整个字符集分成94个区，每区有94个位。每个区位上只有一个字符，因此可用所在的区和位来对汉字进行编码，称为区位码。<br><img src=\"https://img.fengjr.com/image/2019/07/26/367a26051ab559f4057fa4ba682e88a9.jpg\" alt=\"图\" title=\"图\"></p>\n<h2 id=\"1-5-BIG5\"><a href=\"#1-5-BIG5\" class=\"headerlink\" title=\"1.5 BIG5\"></a>1.5 BIG5</h2><p>又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五家软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。</p>\n<p>Big5字符集共收录13,053个中文字，该字符集在中国台湾使用。</p>\n<h2 id=\"1-6-GBK\"><a href=\"#1-6-GBK\" class=\"headerlink\" title=\"1.6 GBK\"></a>1.6 GBK</h2><p>GBK编码，是对GB2312编码的扩展，因此完全兼容GB2312-80标准。GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。共收录汉字和图形符号21886个，其中汉字（包括部首和构件）21003个，图形符号883个。</p>\n<pre><code>注： 0x7F表示删除符号，各种编码规范都应避开。\n</code></pre><p>GBK编码支持国际标准ISO/IEC10646-1和国家标准GB13000-1中的全部中日韩汉字，并包含了BIG5编码中的所有汉字。GBK编码方案于1995年12月15日正式发布。</p>\n<h2 id=\"1-7-Unicode\"><a href=\"#1-7-Unicode\" class=\"headerlink\" title=\"1.7 Unicode\"></a>1.7 Unicode</h2><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。要想打开一个文件，就必须知道编码方式，否则只能看到乱码。</p>\n<p>国际标准化组织(ISO)编纂了ISO10646来规范和整合字符集(被成为通用字符集 Universal Character Set，UCS )。统一码联盟(由各个大型企业及组织共同维护)发布了统一码(Unicode)项目。</p>\n<p>起初，UCS和Unicode各自为政，但1991年前后他们都发现：世界不需要两个不一样的“统一”、“通用”的字符集。所以他们联合起来维护一个字符集，现在他们的差别大概是发布新版本时使用什么字体。</p>\n<p>UCS和Unicode都使用最大32bit来存储字符，理论上可以表示42亿个字符，实际码位(字符数)只有1114112个，从0x00到0x10FFFF。<br>目前的Unicode字符分为17组编排，0x000000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，目前只用了少数平面。</p>\n<p>零号平面( BMP)，0x0000-0xFFFF，共定义27973个汉字，范围0x4E00-0x9FA5。平面2中有43253个汉字。例如汉字的“汉”字，编码为0x6C49。</p>\n<h2 id=\"1-8-UTF8\"><a href=\"#1-8-UTF8\" class=\"headerlink\" title=\"1.8 UTF8\"></a>1.8 UTF8</h2><p>使用32bit来存储字符看起来是一件一劳永逸的方式，但如果这32bit是定宽的(即任何字符都要使用完这32bit)的话就不可避免的造成空间的浪费，程序效率也会降低！</p>\n<p>能不能把UCS(Unicode)设计成“变宽”的呢？聪明的设计师想到了一个主意，他们发明了一种名为“统一码转换格式”即UTF来将字符对应的数字转化为多个字节来进行存储。</p>\n<p>Unicode是编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。常见的编码实现还有UTF-16、UTF-32。</p>\n<p>UTF-8是可变长度字符编码。编码规则如下：<br><img src=\"https://img.fengjr.com/image/2019/07/26/2f3d1d3592ec94f1de0d05d10cf46321.jpg\" alt=\"图\" title=\"图\"></p>\n<p>“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。<br><img src=\"https://img.fengjr.com/image/2019/07/26/8623511c7cf0e4a09c08cda5752157aa.jpg\" alt=\"图\" title=\"图\"></p>\n<h2 id=\"1-9-UTF-16和UTF-32\"><a href=\"#1-9-UTF-16和UTF-32\" class=\"headerlink\" title=\"1.9 UTF-16和UTF-32\"></a>1.9 UTF-16和UTF-32</h2><p> <img src=\"https://img.fengjr.com/image/2019/07/26/ebadcf8a655996c3dc908b5a1a97ddda.jpg\" alt=\"图\" title=\"图\"></p>\n<h2 id=\"1-10-Emoji\"><a href=\"#1-10-Emoji\" class=\"headerlink\" title=\"1.10 Emoji\"></a>1.10 Emoji</h2><p>所谓Emoji（表情符号）就是一种在Unicode位于\\u01F601-\\u01F64F区段的字符。</p>\n<p>MYSQL中utf8只支持3个字节，即实现了0平面的编码范围\\u0000-\\uFFFF，utf8mb4是支持4个字节的，兼容utf8，因此mysql数据库中一定要用utfmb4编码。</p>\n<h1 id=\"2-计算机文件\"><a href=\"#2-计算机文件\" class=\"headerlink\" title=\"2 计算机文件\"></a>2 计算机文件</h1><p>计算机文件（或称文件、电脑档案、档案），是存储在某种长期储存设备上的一段数据流。所谓“长期储存设备”一般指磁盘、光盘、磁带等。其特点是所存信息可以长期、多次使用，不会因为断电而消失。</p>\n<p>一种重要的文件是文本文件，是由一些字符的串行组成的。二进制文件一般是指除了文本文件以外的文件。</p>\n<p>虽然一个文件表现为一个单一的流，但它经常在磁盘不同的位置存储为多个数据碎片（甚至是多个磁盘）。操作系统会将它们组织成文件系统，每个文件放在特定的文件夹或目录中。</p>\n<h2 id=\"2-1-文本文件\"><a href=\"#2-1-文本文件\" class=\"headerlink\" title=\"2.1 文本文件\"></a>2.1 文本文件</h2><p>文本文件是一种计算机文件，它是一种典型的顺序文件，其文件的逻辑结构又属于流式文件。</p>\n<p>文本文件存在于计算机文件系统中。通常，通过在文本文件最后一行后放置文件结束标志来指明文件的结束。计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。</p>\n<p>简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值（可以看作是自定义编码）。<br> <img src=\"https://img.fengjr.com/image/2019/07/26/1c98a752254d31b3c34ca663e0c762f5.png\" alt title=\"图\"></p>\n<h2 id=\"2-2-二进制文件\"><a href=\"#2-2-二进制文件\" class=\"headerlink\" title=\"2.2 二进制文件\"></a>2.2 二进制文件</h2><p><img src=\"https://img.fengjr.com/image/2019/07/26/11b6841f8c002ba6dc52a7e213db7cbf.jpg\" alt=\"图\" title=\"图\"></p>\n<h2 id=\"2-3-比较\"><a href=\"#2-3-比较\" class=\"headerlink\" title=\"2.3 比较\"></a>2.3 比较</h2><p><img src=\"https://img.fengjr.com/image/2019/07/26/b1fdd2a20f97914c497c0801b736d374.jpg\" alt title=\"图\"></p>\n<h1 id=\"3-数据传输中的编码\"><a href=\"#3-数据传输中的编码\" class=\"headerlink\" title=\"3 数据传输中的编码\"></a>3 数据传输中的编码</h1><p>通常上的理解，http协议中请求、响应都是以ASCII字符方式传输，如果要传输二进制需要经过BASE64或MIME等编码（因为HTTP协议pop3、smtp邮件协议都是针对文本的，而FTP支持传输二进制数据）</p>\n<p>如果直接使用http传输二进制(不经过base64编码)，可能会造成一下问题：</p>\n<p> 1) 不知道传输字节的具体长度。如将int类型的1234567转为char类型“1234567”，丢失掉了长度的信息，本来只有4个字节，但是转化成文本的是有7个字节，无法转换回去。</p>\n<p> 2) 对于一些数字，二进制传输Server是没法处理的。如int 1,二进制数据是0x00000001，按字节传输的时候，client能够正常发送，但是libevent收到以后，在抛给libevent_http层时，会把数据截断，前两位0x00是字符串的停止符。</p>\n<p>HTTP请求体可以是多种形式的。根据请求头/响应头中的content-type属性来处理。例如 Content-Type:image/gif 说明传输的是一个image对象（二进制数据），该对象为gif格式。</p>\n<h2 id=\"3-1-Base64\"><a href=\"#3-1-Base64\" class=\"headerlink\" title=\"3.1 Base64\"></a>3.1 Base64</h2><p>base64 最早就是用来邮件传输协议中的，原因是邮件传输协议只支持 ascii 字符传递，因此如果要传输二进制文件，如：图片、视频是无法实现的。因此 base64 就可以用来将二进制文件内容编码为只包含 ascii 字符的内容。</p>\n<p>Base64常用于X.509公钥证书、 XML文本传输、 HTTP协议、电子邮件（SMTP协议）、图片base64编码。</p>\n<p>Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。</p>\n<p>Base64的原理很简单，首先，准备一个包含64个字符的数组：<br>[‘A’, ‘B’, ‘C’, … ‘a’, ‘b’, ‘c’, … ‘0’, ‘1’, … ‘+’, ‘/’]<br>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit：<br><img src=\"https://img.fengjr.com/image/2019/07/26/762449f589daeec232f87ee37cac66ba.png\" alt title=\"图\"><br><img src=\"https://img.fengjr.com/image/2019/07/26/bb7aa5be3384b28432e4bd178edf00a6.png\" alt title=\"图\"></p>\n<h2 id=\"3-2-URL编码\"><a href=\"#3-2-URL编码\" class=\"headerlink\" title=\"3.2 URL编码\"></a>3.2 URL编码</h2><p><img src=\"https://img.fengjr.com/image/2019/07/26/5461599f6a44163821d2bd0e1b60307b.png\" alt title=\"图\"><br><img src=\"https://img.fengjr.com/image/2019/07/26/de1bc5942fcbde2867eac9ec1dd913c8.png\" alt title=\"图\"><br><img src=\"https://img.fengjr.com/image/2019/07/26/f2a00f22bf4b2506ec83a25b7730d808.png\" alt title=\"图\"></p>\n"},{"title":"js正则表达式","comments":1,"date":"2019-08-05T05:17:16.000Z","author":"jun.zhou","_content":"\n\n![](https://img.fengjr.com/image/2019/08/05/3ca32cba0192d540ad69a8046670740d.jpg)\n\n# 一、js正则简介\n\n正则表达式是对字符串执行模式匹配的强大工具。\n\n#### 创建一个正则\n\n第一种：字面量创建，将正则表达式直接当做对象使用。\n\n```\nvar cc = /[a-z]/;\n```\n\n第二种：实例化RegExp对象方式\n\n```\nvar cc = new RegExp('[a-z]');\n```\n#### 前例\n\n十八位身份证校验：\n\n前六位：[1-9]\\d{5}\n年份（1900-2099）(19|20)\\d{2}\n月日（例子上的是闰年，如果平年的话把后面的02(0[1-9]|[1-2][0-9])改成02(0[1-9]|1[0-9]|2[0-8])即可）：( (01|03|05|07|08|10|12)(0[1-9]|[1,2][0-9]|3[0-1]) | (04|06|07|11)(0[1-9]|[1,2][0-9]|30) | 02(0[1-9]|[1-2][0-9]) )\n三位顺序码：[0-9]{3}\n校验码（0-9或者X或者x）:[0-9Xx]\n\n```\nvar pattern = /^[1-9]\\d{5}(19|20)\\d{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|07|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]{3}[0-9Xx]$/;\nvar str = '23333319990223283X';\npattern.test(str); //true\n```\n\n# 二、js正则基础知识点\n\n#### 修饰符\n\ni : 执行对大小写不敏感的匹配。\n\n```\nnew RegExp(\"regexp\",\"i\")\n/regexp/i\n```\n```\nvar str = \"Visit W3School\";\nvar patt1 = /w3school/i;\nstr.match(patt1); //W3School\n```\n\ng : 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。\n\n对 \"is\" 进行全局搜索：\n```\nvar str=\"Is this all there is?\";\nvar patt1=/is/g;\nstr.match(patt1); //is,is\n```\n\n对 \"is\" 进行全局且大小写不敏感的搜索：\n```\nvar str=\"Is this all there is?\";\nvar patt1=/is/gi;\nstr.match(patt1); //Is,is,is\n```\n\n#### 方括号\n\n方括号用于查找某个范围内的字符：\n\n[abc] : 查找方括号之间的任何字符。\n```\nvar str=\"Is this all there is?\";\nvar patt1=/[a-h]/g;\nstr.match(patt1); //h,a,h,e,e\n```\n\n[^abc] : 查找任何不在方括号之间的字符。\n```\nvar str=\"Is this all there is?\";\nvar patt1=/[^a-h]/g;\nstr.match(patt1); //I,s, ,t,i,s, ,l,l, ,t,r, ,i,s,?\n```\n[0-9] : 查找任何从 0 至 9 的数字。\n[a-z] : 查找任何从小写 a 到小写 z 的字符。\n[A-Z] : 查找任何从大写 A 到大写 Z 的字符。\n[A-z] : 查找任何从大写 A 到小写 z 的字符。\n(red|blue|green) : 查找任何指定的选项。\n\n```\nvar str=\"Is this all there is?\";\nvar patt1=/[ah]/g;\nvar patt2=/(a|h)/g;\nstr.match(patt1); //h,a,h\nstr.match(patt2); //h,a,h\n```\n\n#### 元字符\n\n元字符（Metacharacter）是拥有特殊含义的字符：\n\n. : 查找单个字符，除了换行和行结束符。\n```\nvar str=\"That's hot!\";\nvar patt1=/h.t/g;\nstr.match(patt1); //hat,hot\n```\n\n\\w : 查找单词字符。\n```\nvar str=\"Give 100%!\"; \nvar patt1=/\\w/g;\nstr.match(patt1); //G,i,v,e,1,0,0\n```\n穿插小例子: 邮箱验证\n```\nvar re=/^\\w+@[a-z0-9]+\\.[a-z]+$/i; //邮箱不区分大小写\nre.test('aa@12.com'); //true\nre.test('a.a@12.com'); //false\n```\n\n\\W : 查找非单词字符。\n```\nvar str=\"Give 100%!\"; \nvar patt1=/\\W/g;\nstr.match(patt1); // ,%,!\n```\n\n\\d : 查找数字。\n```\nvar str=\"Give 100%!\"; \nvar patt1=/\\d/g;\nstr.match(patt1); //1,0,0\n```\n\n\\D : 查找非数字字符。\n```\nvar str=\"Give 100%!\"; \nvar patt1=/\\D/g;\nstr.match(patt1); //G,i,v,e, ,%,!\n```\n\\s : 查找空白字符。\n\\S : 查找非空白字符。\n\n穿插小例子: a标签的匹配\n```\nvar pattern = /<a\\b[^>]+\\bhref=\"([^\"]*)\"[^>]*>([\\s\\S]*?)<\\/a>/\nvar str = '<a title=\"title\" href=\"//www.baidu.com\" class=\"hh\"></a>';\npattern.test(str); //true\n```\n\n解释一下，其中\n\n<a\\b 表示匹配a标签的开始，\n[^>]+ 匹配非>字符的一到多个任意字符\n\\bhref=\"([^\"]*)\" 匹配href的值，并且将匹配到的值捕获到分组中\n[^>]* 匹配href后除了>字符0到多个任意字符\n([\\s\\S]*?) 匹配任意字符并捕获到组中（包含空格和非空格字符，非贪婪匹配，也可以用.?但是.不能包含空行）\n\n\\b : 匹配单词边界。\n```\nvar str=\"moon\"; \nvar patt1=/\\bm/;\nvar patt2=/oo\\b/;\nvar patt3=/oon\\b/;\nvar patt4=/\\w\\b\\w/;\n\nstr.match(patt1); //m\nstr.match(patt2); //null\nstr.match(patt3); //oon\nstr.match(patt4); //null\n```\n说明：\n/\\bm/ 匹配 \"moon\" 中的 'm'；\n/oo\\b/ 不匹配 \"moon\" 中的 'oo'，因为 'oo' 后面的 'n' 是一个单词字符；\n/oon\\b/ 匹配 \"moon\" 中的 'oon'，因为 'oon' 位于字符串的末端，后面没有单词字符；\n/\\w\\b\\w/ 不匹配任何字符，因为单词字符之后绝不会同时紧跟着非单词字符和单词字符。\n\n\\B : 匹配非单词边界。\n对字符串中不位于单词开头或结尾的 \"School\" 进行全局搜索：\n```\nvar str=\"Visit W3School\"; \nvar patt1=/\\BSchool/g;\nstr.match(patt1); //School\n```\n\n\\n : 查找换行符。\n```\nvar str=\"Visit W3School.\\n Learn JavaScript.\"; \nvar patt1=/\\n/g;\nstr.search(patt1); //15\n```\n\n\\uxxxx : 查找以十六进制数 xxxx 规定的 Unicode 字符。\n对字符串中的十六进制 0057 (W) 进行全局搜索：\n```\nvar str=\"Visit W3School. Hello World!\"; \nvar patt1=/\\u0057/g;\nstr.match(patt1); //W,W\n```\n\n#### 量词\n\nn+ : 匹配任何包含至少一个 n 的字符串。\n```\nvar str=\"Hellooo World! Hello W3School!\"; \nvar patt1=/o+/g;\nstr.match(patt1); //ooo,o,o,oo\n```\n\n穿插小例子：Email地址\n```\n/^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*$/\n```\n\nn* : 匹配任何包含零个或多个 n 的字符串。\n```\nvar str=\"Hellooo World! Hello W3School!\"; \nvar patt1=/lo*/g;\nstr.match(patt1); //l,looo,l,l,lo,l\n```\n\nn? : 匹配任何包含零个或一个 n 的字符串。\n```\nvar str=\"1, 100 or 1000?\"; \nvar patt1=/10?/g;\nstr.match(patt1); //1,10,10\n```\n\nn{X} : 匹配包含 X 个 n 的序列的字符串。\n对包含四位数字序列的子串进行全局搜索：\n```\nvar str=\"100, 1000 or 10000?\";\nvar patt1=/\\d{4}/g; \nstr.match(patt1); //1000,1000\n```\n\nn{X,Y} : 匹配包含 X 至 Y 个 n 的序列的字符串。\n```\nvar str=\"100, 1000 or 10000?\";\nvar patt1=/\\d{3,4}/g; \nstr.match(patt1); //100,1000,1000\n```\n\nn{X,} : 匹配包含至少 X 个 n 的序列的字符串。\n```\nvar str=\"100, 1000 or 10000?\";\nvar patt1=/\\d{3,}/g; \nstr.match(patt1); //100,1000,10000\n```\n\nn$ : 匹配任何结尾为 n 的字符串。\n```\nvar str=\"Is this his\";\nvar patt1=/is$/g;\nstr.match(patt1); // is\npatt1.test(str); //true\n```\n\n^n : 匹配任何开头为 n 的字符串。\n```\nvar str=\"Is this his\";\nvar patt1=/^Is/g;\nstr.match(patt1); //Is\npatt1.test(str); //true\n```\n\n?=n : 匹配任何其后紧接指定字符串 n 的字符串。\n对其后紧跟 \"all\" 的 \"is\" 进行全局搜索：\n```\nvar str=\"Is this all there is\";\nvar patt1=/is(?= all)/;\nstr.match(patt1); //is\n```\n\n穿插小例子：密码强度正则\n```\n// 必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。\n/^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$/.test(\"weeeeeeeW2\");\n//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符\n/^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/.test(\"diaoD123#\");\n//输出 true\n```\n\n?!n : 匹配任何其后没有紧接指定字符串 n 的字符串。\n```\nvar str=\"Is this all there is\";\nvar patt1=/is(?! all)/gi;\nstr.match(patt1); //Is,is\n/^(?!0)\\d{4}$/.test('2019'); //true\n/^(?!0)\\d{4}$/.test('0019'); //false\n```\n\n#### 对象方法\n\ncompile : 编译正则表达式。\n\n在字符串中全局搜索 \"man\"，并用 \"person\" 替换。然后通过 compile() 方法，改变正则表达式，用 \"person\" 替换 \"man\" 或 \"woman\" :\n```\nvar str=\"Every man in the world! Every woman on earth!\";\n\npatt=/man/g;\nstr2=str.replace(patt,\"person\");\ndocument.write(str2+\"<br />\");\n\npatt=/(wo)?man/g;\npatt.compile(patt); //改变正则表达式\nstr2=str.replace(patt,\"person\");\ndocument.write(str2);\n//输出\nEvery person in the world! Every woperson on earth!\nEvery person in the world! Every person on earth!\n```\n\nexec : 检索字符串中指定的值。返回找到的值，并确定其位置。\n```\nvar str = \"Visit W3School, W3School is a place to study web technology.\"; \nvar patt = new RegExp(\"W3School\",\"g\");\nvar result;\n\nwhile ((result = patt.exec(str)) != null)  {\n  console.log(result);\n  console.log(patt.lastIndex);\n }\n//输出\nW3School\n14\nW3School\n24\n```\n\ntest : 检索字符串中指定的值。返回 true 或 false。\n```\nvar pattern = /[hf]ello/g,\n    str = 'hello';\npattern.test(str); //true\npattern = /[ef]ello/g;\npattern.test(str); //false\n```\n\n#### String 对象的方法\n\nsearch : 检索与正则表达式相匹配的值。\n```\nvar str=\"Hello world!\"\nstr.search(\"world\"); //6\nstr.search(\"World\"); //-1\nstr.search(\"woorld\"); //-1\n```\n说明:search() 方法不执行全局匹配，它将忽略标志 g。\n\nmatch : 找到一个或多个正则表达式的匹配。\n```\nvar str=\"Hello world!\"\nstr.match(\"world\"); //world\nstr.match(\"World\"); //null\n```\n\nreplace : 替换与正则表达式匹配的子串。\n```\nvar str=\"Visit Microsoft!\"\nstr.replace(/Microsoft/,\"W3School\"); //Visit W3School!\n```\n$1、$2、...、$99 : 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。\n```\nname = \"Doe, John\";\nname.replace(/(\\w+)\\s*, \\s*(\\w+)/, \"$2 $1\"); //John Doe\n```\n穿插小例子: 找重复项最多的字符和个数\n```\nvar str = 'sassdfdfffdasdffffffsdsdddsss';\nvar arr = str.split('');//先把字符串分割为字符串数组\nstr = arr.sort().join('');\nvar value = '';\nvar index = 0;\nvar re = /(\\w)\\1+/g;\nstr.replace(re,function($0,$1){\n    if(index<$0.length){\n      index = $0.length;\n      value = $1;\n    }\n});\nconsole.log('最多的字符：'+ value +' ,重复的次数：'+index);\n//最多的字符：f ,重复的次数：10\n```\n说明：\\1 是捕获组，就是第一个小括号内的值（从左向→）\n\n\nsplit : 把字符串分割为字符串数组。\n```\nvar str = \"How are you doing today?\";\nstr.split(' '); //[\"How\", \"are\", \"you\", \"doing\", \"today?\"]\nstr.split(' ', 3); //[\"How\", \"are\", \"you\"]\n```\n\n对象属性lastIndex : 一个整数，标示开始下一次匹配的字符位置。\n```\nvar str = \"The rain in Spain stays mainly in the plain\";\nvar patt1 = new RegExp(\"ain\", \"g\");\n\nfor(i = 0; i < 4; i++) \n{\n  patt1.test(str)\n  console.log(patt1.lastIndex);\n}\n//输出\n8\n17\n28\n43\n```\n例子1：\n```\nvar str=\"I love antzone ,this is animate\";\nvar reg=/an/g;\nconsole.log(reg.exec(str)); //[\"an\", index: 7, input: \"I love antzone ,this is animate\", groups: undefined]\nconsole.log(reg.exec(str)); // [\"an\", index: 24, input: \"I love antzone ,this is animate\", groups: undefined]\n```\n例子2：\n```\nvar str=\"I love antzone ,this is animate\";\nvar reg=/an/g;\nreg.lastIndex = 20\nconsole.log(reg.exec(str)); // [\"an\", index: 24, input: \"I love antzone ,this is animate\", groups: undefined]\n```\n\n\n#### 等价的正则表达式\n\n常规等价：\n/\\d/ = /[0-9]/ = /[0123456789]//\\D/ = /[^\\d]/ = /^[0-9]/\n/\\s/ 匹配一个空白字符，等价于/[\\n\\r\\f\\t\\v] \n/\\S/ 匹配一个非空白字符，等价于/[^\\n\\f\\r\\t\\v]\n/\\w/ 任何单字字符, 等价于/[a-zA-Z0-9_]//\\W/ 任何非单字字符,等价于/[^a-zA-Z0-9_]/\n// ? 匹配前一项0次或1次,也就是说前一项是可选的. 等价于 {0, 1}\n// + 匹配前一项1次或多次,等价于{1,}\n// * 匹配前一项0次或多次.等价于{0,}\n\n其它等价：\n/^[ab]cd$/.test(\"abc\"); //true \n等价于/^(a|b)cd$/.test(\"abc\")\n\n转义：'/', '\\', '.' ,'?'等需要被转义字符都符合[char] = \\char\n/^[.]abc/.test(\"a.abc\")//true \n等价于/^\\.abc/.test(\".abc\")　\n\n\n# 三、js正则常用实例\n\n#### 用户名正则\n```\n//用户名正则，4到16位（字母，数字，下划线，减号）\n/^[a-zA-Z0-9_-]{4,16}$/.test(\"diaodiao\");\n//输出 true\n```\n\n#### 整数正则\n```\n/^\\d+$/.test(\"42\");    //正整数正则  -> 输出 true\n/^-\\d+$/.test(\"-42\");  //负整数正则  -> 输出 true\n/^-?\\d+$/.test(\"-42\"); //整数正则  -> 输出 true\n/^[0-9]+$/.test(25.5455) //正整数正则  -> 输出 false\n```\n\n#### 数字正则\n可以是整数也可以是浮点数\n```\n/^\\d*\\.?\\d+$/.test(\"42.2\");     //正数正则  -> 输出 true\n/^-\\d*\\.?\\d+$/.test(\"-42.2\");   //负数正则 -> 输出 true\n/^-?\\d*\\.?\\d+$/.test(\"-42.2\");  //数字正则 -> 输出 true\n```\n\n#### Email正则\n```\n//Email正则\n/^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/.test(\"wowohoo@qq.com\");\n//输出 true\n```\n\n#### 传真号码\n```\n// 国家代码(2到3位)-区号(2到3位)-电话号码(7到8位)-分机号(3位)\n/^(([0\\+]\\d{2,3}-)?(0\\d{2,3})-)(\\d{7,8})(-(\\d{3,}))?$/.test('021-5055455')\n```\n\n#### 手机号码正则\n```\n//手机号正则\n/^1[34578]\\d{9}$/.test(\"13611778887\");\n//输出 true\n\n//* 国际码 如：中国(+86)\n/^((\\+?[0-9]{1,4})|(\\(\\+86\\)))?(13[0-9]|14[57]|15[012356789]|17[03678]|18[0-9])\\d{8}$/.test(\"13611778887\");\n```\n\n#### 颜色值校验\n```\n/^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(\"#ccb2b2\")\n```\n\n#### 清除字符串前后空格的正则表达式\n```\nString.prototype.trim = function(){return this.replace(/(^\\s*)|(\\s*$)/g, \"\");}\nvar str2 = \" hi space \"//这里前后共有两个空格\nconsole.log(str2.length);//14\nconsole.log(str2.trim().length);//8\nconsole.log(str2.trim());//hi space\n```\n\n#### 获取网址url参数转化为键值对\n```\n(function parseURL(url=window.location.href){/*es6语法直接设置默认值*/\n　　const search = url.substr(url.indexOf('?')+1);\n　　const obj={};\n　　search.replace(/([^&=]+)=([^&=]*)/g,function(rs,$1,$2){\n\t\tconsole.log(rs)\n　　　　obj[decodeURIComponent($1)]=decodeURIComponent($2)\n\n　　})\n　　return obj\n})()\n```","source":"_posts/2019-08-05-javascript-regexp.md","raw":"---\ntitle: js正则表达式\ncomments: true\ndate: 2019-08-05 13:17:16\ntags:\n- js\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n\n![](https://img.fengjr.com/image/2019/08/05/3ca32cba0192d540ad69a8046670740d.jpg)\n\n# 一、js正则简介\n\n正则表达式是对字符串执行模式匹配的强大工具。\n\n#### 创建一个正则\n\n第一种：字面量创建，将正则表达式直接当做对象使用。\n\n```\nvar cc = /[a-z]/;\n```\n\n第二种：实例化RegExp对象方式\n\n```\nvar cc = new RegExp('[a-z]');\n```\n#### 前例\n\n十八位身份证校验：\n\n前六位：[1-9]\\d{5}\n年份（1900-2099）(19|20)\\d{2}\n月日（例子上的是闰年，如果平年的话把后面的02(0[1-9]|[1-2][0-9])改成02(0[1-9]|1[0-9]|2[0-8])即可）：( (01|03|05|07|08|10|12)(0[1-9]|[1,2][0-9]|3[0-1]) | (04|06|07|11)(0[1-9]|[1,2][0-9]|30) | 02(0[1-9]|[1-2][0-9]) )\n三位顺序码：[0-9]{3}\n校验码（0-9或者X或者x）:[0-9Xx]\n\n```\nvar pattern = /^[1-9]\\d{5}(19|20)\\d{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|07|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]{3}[0-9Xx]$/;\nvar str = '23333319990223283X';\npattern.test(str); //true\n```\n\n# 二、js正则基础知识点\n\n#### 修饰符\n\ni : 执行对大小写不敏感的匹配。\n\n```\nnew RegExp(\"regexp\",\"i\")\n/regexp/i\n```\n```\nvar str = \"Visit W3School\";\nvar patt1 = /w3school/i;\nstr.match(patt1); //W3School\n```\n\ng : 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。\n\n对 \"is\" 进行全局搜索：\n```\nvar str=\"Is this all there is?\";\nvar patt1=/is/g;\nstr.match(patt1); //is,is\n```\n\n对 \"is\" 进行全局且大小写不敏感的搜索：\n```\nvar str=\"Is this all there is?\";\nvar patt1=/is/gi;\nstr.match(patt1); //Is,is,is\n```\n\n#### 方括号\n\n方括号用于查找某个范围内的字符：\n\n[abc] : 查找方括号之间的任何字符。\n```\nvar str=\"Is this all there is?\";\nvar patt1=/[a-h]/g;\nstr.match(patt1); //h,a,h,e,e\n```\n\n[^abc] : 查找任何不在方括号之间的字符。\n```\nvar str=\"Is this all there is?\";\nvar patt1=/[^a-h]/g;\nstr.match(patt1); //I,s, ,t,i,s, ,l,l, ,t,r, ,i,s,?\n```\n[0-9] : 查找任何从 0 至 9 的数字。\n[a-z] : 查找任何从小写 a 到小写 z 的字符。\n[A-Z] : 查找任何从大写 A 到大写 Z 的字符。\n[A-z] : 查找任何从大写 A 到小写 z 的字符。\n(red|blue|green) : 查找任何指定的选项。\n\n```\nvar str=\"Is this all there is?\";\nvar patt1=/[ah]/g;\nvar patt2=/(a|h)/g;\nstr.match(patt1); //h,a,h\nstr.match(patt2); //h,a,h\n```\n\n#### 元字符\n\n元字符（Metacharacter）是拥有特殊含义的字符：\n\n. : 查找单个字符，除了换行和行结束符。\n```\nvar str=\"That's hot!\";\nvar patt1=/h.t/g;\nstr.match(patt1); //hat,hot\n```\n\n\\w : 查找单词字符。\n```\nvar str=\"Give 100%!\"; \nvar patt1=/\\w/g;\nstr.match(patt1); //G,i,v,e,1,0,0\n```\n穿插小例子: 邮箱验证\n```\nvar re=/^\\w+@[a-z0-9]+\\.[a-z]+$/i; //邮箱不区分大小写\nre.test('aa@12.com'); //true\nre.test('a.a@12.com'); //false\n```\n\n\\W : 查找非单词字符。\n```\nvar str=\"Give 100%!\"; \nvar patt1=/\\W/g;\nstr.match(patt1); // ,%,!\n```\n\n\\d : 查找数字。\n```\nvar str=\"Give 100%!\"; \nvar patt1=/\\d/g;\nstr.match(patt1); //1,0,0\n```\n\n\\D : 查找非数字字符。\n```\nvar str=\"Give 100%!\"; \nvar patt1=/\\D/g;\nstr.match(patt1); //G,i,v,e, ,%,!\n```\n\\s : 查找空白字符。\n\\S : 查找非空白字符。\n\n穿插小例子: a标签的匹配\n```\nvar pattern = /<a\\b[^>]+\\bhref=\"([^\"]*)\"[^>]*>([\\s\\S]*?)<\\/a>/\nvar str = '<a title=\"title\" href=\"//www.baidu.com\" class=\"hh\"></a>';\npattern.test(str); //true\n```\n\n解释一下，其中\n\n<a\\b 表示匹配a标签的开始，\n[^>]+ 匹配非>字符的一到多个任意字符\n\\bhref=\"([^\"]*)\" 匹配href的值，并且将匹配到的值捕获到分组中\n[^>]* 匹配href后除了>字符0到多个任意字符\n([\\s\\S]*?) 匹配任意字符并捕获到组中（包含空格和非空格字符，非贪婪匹配，也可以用.?但是.不能包含空行）\n\n\\b : 匹配单词边界。\n```\nvar str=\"moon\"; \nvar patt1=/\\bm/;\nvar patt2=/oo\\b/;\nvar patt3=/oon\\b/;\nvar patt4=/\\w\\b\\w/;\n\nstr.match(patt1); //m\nstr.match(patt2); //null\nstr.match(patt3); //oon\nstr.match(patt4); //null\n```\n说明：\n/\\bm/ 匹配 \"moon\" 中的 'm'；\n/oo\\b/ 不匹配 \"moon\" 中的 'oo'，因为 'oo' 后面的 'n' 是一个单词字符；\n/oon\\b/ 匹配 \"moon\" 中的 'oon'，因为 'oon' 位于字符串的末端，后面没有单词字符；\n/\\w\\b\\w/ 不匹配任何字符，因为单词字符之后绝不会同时紧跟着非单词字符和单词字符。\n\n\\B : 匹配非单词边界。\n对字符串中不位于单词开头或结尾的 \"School\" 进行全局搜索：\n```\nvar str=\"Visit W3School\"; \nvar patt1=/\\BSchool/g;\nstr.match(patt1); //School\n```\n\n\\n : 查找换行符。\n```\nvar str=\"Visit W3School.\\n Learn JavaScript.\"; \nvar patt1=/\\n/g;\nstr.search(patt1); //15\n```\n\n\\uxxxx : 查找以十六进制数 xxxx 规定的 Unicode 字符。\n对字符串中的十六进制 0057 (W) 进行全局搜索：\n```\nvar str=\"Visit W3School. Hello World!\"; \nvar patt1=/\\u0057/g;\nstr.match(patt1); //W,W\n```\n\n#### 量词\n\nn+ : 匹配任何包含至少一个 n 的字符串。\n```\nvar str=\"Hellooo World! Hello W3School!\"; \nvar patt1=/o+/g;\nstr.match(patt1); //ooo,o,o,oo\n```\n\n穿插小例子：Email地址\n```\n/^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*$/\n```\n\nn* : 匹配任何包含零个或多个 n 的字符串。\n```\nvar str=\"Hellooo World! Hello W3School!\"; \nvar patt1=/lo*/g;\nstr.match(patt1); //l,looo,l,l,lo,l\n```\n\nn? : 匹配任何包含零个或一个 n 的字符串。\n```\nvar str=\"1, 100 or 1000?\"; \nvar patt1=/10?/g;\nstr.match(patt1); //1,10,10\n```\n\nn{X} : 匹配包含 X 个 n 的序列的字符串。\n对包含四位数字序列的子串进行全局搜索：\n```\nvar str=\"100, 1000 or 10000?\";\nvar patt1=/\\d{4}/g; \nstr.match(patt1); //1000,1000\n```\n\nn{X,Y} : 匹配包含 X 至 Y 个 n 的序列的字符串。\n```\nvar str=\"100, 1000 or 10000?\";\nvar patt1=/\\d{3,4}/g; \nstr.match(patt1); //100,1000,1000\n```\n\nn{X,} : 匹配包含至少 X 个 n 的序列的字符串。\n```\nvar str=\"100, 1000 or 10000?\";\nvar patt1=/\\d{3,}/g; \nstr.match(patt1); //100,1000,10000\n```\n\nn$ : 匹配任何结尾为 n 的字符串。\n```\nvar str=\"Is this his\";\nvar patt1=/is$/g;\nstr.match(patt1); // is\npatt1.test(str); //true\n```\n\n^n : 匹配任何开头为 n 的字符串。\n```\nvar str=\"Is this his\";\nvar patt1=/^Is/g;\nstr.match(patt1); //Is\npatt1.test(str); //true\n```\n\n?=n : 匹配任何其后紧接指定字符串 n 的字符串。\n对其后紧跟 \"all\" 的 \"is\" 进行全局搜索：\n```\nvar str=\"Is this all there is\";\nvar patt1=/is(?= all)/;\nstr.match(patt1); //is\n```\n\n穿插小例子：密码强度正则\n```\n// 必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。\n/^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$/.test(\"weeeeeeeW2\");\n//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符\n/^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/.test(\"diaoD123#\");\n//输出 true\n```\n\n?!n : 匹配任何其后没有紧接指定字符串 n 的字符串。\n```\nvar str=\"Is this all there is\";\nvar patt1=/is(?! all)/gi;\nstr.match(patt1); //Is,is\n/^(?!0)\\d{4}$/.test('2019'); //true\n/^(?!0)\\d{4}$/.test('0019'); //false\n```\n\n#### 对象方法\n\ncompile : 编译正则表达式。\n\n在字符串中全局搜索 \"man\"，并用 \"person\" 替换。然后通过 compile() 方法，改变正则表达式，用 \"person\" 替换 \"man\" 或 \"woman\" :\n```\nvar str=\"Every man in the world! Every woman on earth!\";\n\npatt=/man/g;\nstr2=str.replace(patt,\"person\");\ndocument.write(str2+\"<br />\");\n\npatt=/(wo)?man/g;\npatt.compile(patt); //改变正则表达式\nstr2=str.replace(patt,\"person\");\ndocument.write(str2);\n//输出\nEvery person in the world! Every woperson on earth!\nEvery person in the world! Every person on earth!\n```\n\nexec : 检索字符串中指定的值。返回找到的值，并确定其位置。\n```\nvar str = \"Visit W3School, W3School is a place to study web technology.\"; \nvar patt = new RegExp(\"W3School\",\"g\");\nvar result;\n\nwhile ((result = patt.exec(str)) != null)  {\n  console.log(result);\n  console.log(patt.lastIndex);\n }\n//输出\nW3School\n14\nW3School\n24\n```\n\ntest : 检索字符串中指定的值。返回 true 或 false。\n```\nvar pattern = /[hf]ello/g,\n    str = 'hello';\npattern.test(str); //true\npattern = /[ef]ello/g;\npattern.test(str); //false\n```\n\n#### String 对象的方法\n\nsearch : 检索与正则表达式相匹配的值。\n```\nvar str=\"Hello world!\"\nstr.search(\"world\"); //6\nstr.search(\"World\"); //-1\nstr.search(\"woorld\"); //-1\n```\n说明:search() 方法不执行全局匹配，它将忽略标志 g。\n\nmatch : 找到一个或多个正则表达式的匹配。\n```\nvar str=\"Hello world!\"\nstr.match(\"world\"); //world\nstr.match(\"World\"); //null\n```\n\nreplace : 替换与正则表达式匹配的子串。\n```\nvar str=\"Visit Microsoft!\"\nstr.replace(/Microsoft/,\"W3School\"); //Visit W3School!\n```\n$1、$2、...、$99 : 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。\n```\nname = \"Doe, John\";\nname.replace(/(\\w+)\\s*, \\s*(\\w+)/, \"$2 $1\"); //John Doe\n```\n穿插小例子: 找重复项最多的字符和个数\n```\nvar str = 'sassdfdfffdasdffffffsdsdddsss';\nvar arr = str.split('');//先把字符串分割为字符串数组\nstr = arr.sort().join('');\nvar value = '';\nvar index = 0;\nvar re = /(\\w)\\1+/g;\nstr.replace(re,function($0,$1){\n    if(index<$0.length){\n      index = $0.length;\n      value = $1;\n    }\n});\nconsole.log('最多的字符：'+ value +' ,重复的次数：'+index);\n//最多的字符：f ,重复的次数：10\n```\n说明：\\1 是捕获组，就是第一个小括号内的值（从左向→）\n\n\nsplit : 把字符串分割为字符串数组。\n```\nvar str = \"How are you doing today?\";\nstr.split(' '); //[\"How\", \"are\", \"you\", \"doing\", \"today?\"]\nstr.split(' ', 3); //[\"How\", \"are\", \"you\"]\n```\n\n对象属性lastIndex : 一个整数，标示开始下一次匹配的字符位置。\n```\nvar str = \"The rain in Spain stays mainly in the plain\";\nvar patt1 = new RegExp(\"ain\", \"g\");\n\nfor(i = 0; i < 4; i++) \n{\n  patt1.test(str)\n  console.log(patt1.lastIndex);\n}\n//输出\n8\n17\n28\n43\n```\n例子1：\n```\nvar str=\"I love antzone ,this is animate\";\nvar reg=/an/g;\nconsole.log(reg.exec(str)); //[\"an\", index: 7, input: \"I love antzone ,this is animate\", groups: undefined]\nconsole.log(reg.exec(str)); // [\"an\", index: 24, input: \"I love antzone ,this is animate\", groups: undefined]\n```\n例子2：\n```\nvar str=\"I love antzone ,this is animate\";\nvar reg=/an/g;\nreg.lastIndex = 20\nconsole.log(reg.exec(str)); // [\"an\", index: 24, input: \"I love antzone ,this is animate\", groups: undefined]\n```\n\n\n#### 等价的正则表达式\n\n常规等价：\n/\\d/ = /[0-9]/ = /[0123456789]//\\D/ = /[^\\d]/ = /^[0-9]/\n/\\s/ 匹配一个空白字符，等价于/[\\n\\r\\f\\t\\v] \n/\\S/ 匹配一个非空白字符，等价于/[^\\n\\f\\r\\t\\v]\n/\\w/ 任何单字字符, 等价于/[a-zA-Z0-9_]//\\W/ 任何非单字字符,等价于/[^a-zA-Z0-9_]/\n// ? 匹配前一项0次或1次,也就是说前一项是可选的. 等价于 {0, 1}\n// + 匹配前一项1次或多次,等价于{1,}\n// * 匹配前一项0次或多次.等价于{0,}\n\n其它等价：\n/^[ab]cd$/.test(\"abc\"); //true \n等价于/^(a|b)cd$/.test(\"abc\")\n\n转义：'/', '\\', '.' ,'?'等需要被转义字符都符合[char] = \\char\n/^[.]abc/.test(\"a.abc\")//true \n等价于/^\\.abc/.test(\".abc\")　\n\n\n# 三、js正则常用实例\n\n#### 用户名正则\n```\n//用户名正则，4到16位（字母，数字，下划线，减号）\n/^[a-zA-Z0-9_-]{4,16}$/.test(\"diaodiao\");\n//输出 true\n```\n\n#### 整数正则\n```\n/^\\d+$/.test(\"42\");    //正整数正则  -> 输出 true\n/^-\\d+$/.test(\"-42\");  //负整数正则  -> 输出 true\n/^-?\\d+$/.test(\"-42\"); //整数正则  -> 输出 true\n/^[0-9]+$/.test(25.5455) //正整数正则  -> 输出 false\n```\n\n#### 数字正则\n可以是整数也可以是浮点数\n```\n/^\\d*\\.?\\d+$/.test(\"42.2\");     //正数正则  -> 输出 true\n/^-\\d*\\.?\\d+$/.test(\"-42.2\");   //负数正则 -> 输出 true\n/^-?\\d*\\.?\\d+$/.test(\"-42.2\");  //数字正则 -> 输出 true\n```\n\n#### Email正则\n```\n//Email正则\n/^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/.test(\"wowohoo@qq.com\");\n//输出 true\n```\n\n#### 传真号码\n```\n// 国家代码(2到3位)-区号(2到3位)-电话号码(7到8位)-分机号(3位)\n/^(([0\\+]\\d{2,3}-)?(0\\d{2,3})-)(\\d{7,8})(-(\\d{3,}))?$/.test('021-5055455')\n```\n\n#### 手机号码正则\n```\n//手机号正则\n/^1[34578]\\d{9}$/.test(\"13611778887\");\n//输出 true\n\n//* 国际码 如：中国(+86)\n/^((\\+?[0-9]{1,4})|(\\(\\+86\\)))?(13[0-9]|14[57]|15[012356789]|17[03678]|18[0-9])\\d{8}$/.test(\"13611778887\");\n```\n\n#### 颜色值校验\n```\n/^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(\"#ccb2b2\")\n```\n\n#### 清除字符串前后空格的正则表达式\n```\nString.prototype.trim = function(){return this.replace(/(^\\s*)|(\\s*$)/g, \"\");}\nvar str2 = \" hi space \"//这里前后共有两个空格\nconsole.log(str2.length);//14\nconsole.log(str2.trim().length);//8\nconsole.log(str2.trim());//hi space\n```\n\n#### 获取网址url参数转化为键值对\n```\n(function parseURL(url=window.location.href){/*es6语法直接设置默认值*/\n　　const search = url.substr(url.indexOf('?')+1);\n　　const obj={};\n　　search.replace(/([^&=]+)=([^&=]*)/g,function(rs,$1,$2){\n\t\tconsole.log(rs)\n　　　　obj[decodeURIComponent($1)]=decodeURIComponent($2)\n\n　　})\n　　return obj\n})()\n```","slug":"javascript-regexp","published":1,"updated":"2020-06-10T06:01:52.327Z","_id":"ck2yl0qc3000dh6q6c9o2jtc6","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/08/05/3ca32cba0192d540ad69a8046670740d.jpg\" alt></p>\n<h1 id=\"一、js正则简介\"><a href=\"#一、js正则简介\" class=\"headerlink\" title=\"一、js正则简介\"></a>一、js正则简介</h1><p>正则表达式是对字符串执行模式匹配的强大工具。</p>\n<h4 id=\"创建一个正则\"><a href=\"#创建一个正则\" class=\"headerlink\" title=\"创建一个正则\"></a>创建一个正则</h4><p>第一种：字面量创建，将正则表达式直接当做对象使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cc = /[a-z]/;</span><br></pre></td></tr></table></figure>\n<p>第二种：实例化RegExp对象方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cc = new RegExp(&apos;[a-z]&apos;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"前例\"><a href=\"#前例\" class=\"headerlink\" title=\"前例\"></a>前例</h4><p>十八位身份证校验：</p>\n<p>前六位：[1-9]\\d{5}<br>年份（1900-2099）(19|20)\\d{2}<br>月日（例子上的是闰年，如果平年的话把后面的02(0[1-9]|[1-2][0-9])改成02(0[1-9]|1[0-9]|2[0-8])即可）：( (01|03|05|07|08|10|12)(0[1-9]|[1,2][0-9]|3[0-1]) | (04|06|07|11)(0[1-9]|[1,2][0-9]|30) | 02(0[1-9]|[1-2][0-9]) )<br>三位顺序码：[0-9]{3}<br>校验码（0-9或者X或者x）:[0-9Xx]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /^[1-9]\\d&#123;5&#125;(19|20)\\d&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|07|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;[0-9Xx]$/;</span><br><span class=\"line\">var str = &apos;23333319990223283X&apos;;</span><br><span class=\"line\">pattern.test(str); //true</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、js正则基础知识点\"><a href=\"#二、js正则基础知识点\" class=\"headerlink\" title=\"二、js正则基础知识点\"></a>二、js正则基础知识点</h1><h4 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h4><p>i : 执行对大小写不敏感的匹配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new RegExp(&quot;regexp&quot;,&quot;i&quot;)</span><br><span class=\"line\">/regexp/i</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;Visit W3School&quot;;</span><br><span class=\"line\">var patt1 = /w3school/i;</span><br><span class=\"line\">str.match(patt1); //W3School</span><br></pre></td></tr></table></figure>\n<p>g : 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</p>\n<p>对 “is” 进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/is/g;</span><br><span class=\"line\">str.match(patt1); //is,is</span><br></pre></td></tr></table></figure></p>\n<p>对 “is” 进行全局且大小写不敏感的搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/is/gi;</span><br><span class=\"line\">str.match(patt1); //Is,is,is</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"方括号\"><a href=\"#方括号\" class=\"headerlink\" title=\"方括号\"></a>方括号</h4><p>方括号用于查找某个范围内的字符：</p>\n<p>[abc] : 查找方括号之间的任何字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/[a-h]/g;</span><br><span class=\"line\">str.match(patt1); //h,a,h,e,e</span><br></pre></td></tr></table></figure></p>\n<p>[^abc] : 查找任何不在方括号之间的字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/[^a-h]/g;</span><br><span class=\"line\">str.match(patt1); //I,s, ,t,i,s, ,l,l, ,t,r, ,i,s,?</span><br></pre></td></tr></table></figure></p>\n<p>[0-9] : 查找任何从 0 至 9 的数字。<br>[a-z] : 查找任何从小写 a 到小写 z 的字符。<br>[A-Z] : 查找任何从大写 A 到大写 Z 的字符。<br>[A-z] : 查找任何从大写 A 到小写 z 的字符。<br>(red|blue|green) : 查找任何指定的选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/[ah]/g;</span><br><span class=\"line\">var patt2=/(a|h)/g;</span><br><span class=\"line\">str.match(patt1); //h,a,h</span><br><span class=\"line\">str.match(patt2); //h,a,h</span><br></pre></td></tr></table></figure>\n<h4 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h4><p>元字符（Metacharacter）是拥有特殊含义的字符：</p>\n<p>. : 查找单个字符，除了换行和行结束符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;That&apos;s hot!&quot;;</span><br><span class=\"line\">var patt1=/h.t/g;</span><br><span class=\"line\">str.match(patt1); //hat,hot</span><br></pre></td></tr></table></figure></p>\n<p>\\w : 查找单词字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Give 100%!&quot;; </span><br><span class=\"line\">var patt1=/\\w/g;</span><br><span class=\"line\">str.match(patt1); //G,i,v,e,1,0,0</span><br></pre></td></tr></table></figure></p>\n<p>穿插小例子: 邮箱验证<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re=/^\\w+@[a-z0-9]+\\.[a-z]+$/i; //邮箱不区分大小写</span><br><span class=\"line\">re.test(&apos;aa@12.com&apos;); //true</span><br><span class=\"line\">re.test(&apos;a.a@12.com&apos;); //false</span><br></pre></td></tr></table></figure></p>\n<p>\\W : 查找非单词字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Give 100%!&quot;; </span><br><span class=\"line\">var patt1=/\\W/g;</span><br><span class=\"line\">str.match(patt1); // ,%,!</span><br></pre></td></tr></table></figure></p>\n<p>\\d : 查找数字。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Give 100%!&quot;; </span><br><span class=\"line\">var patt1=/\\d/g;</span><br><span class=\"line\">str.match(patt1); //1,0,0</span><br></pre></td></tr></table></figure></p>\n<p>\\D : 查找非数字字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Give 100%!&quot;; </span><br><span class=\"line\">var patt1=/\\D/g;</span><br><span class=\"line\">str.match(patt1); //G,i,v,e, ,%,!</span><br></pre></td></tr></table></figure></p>\n<p>\\s : 查找空白字符。<br>\\S : 查找非空白字符。</p>\n<p>穿插小例子: a标签的匹配<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /&lt;a\\b[^&gt;]+\\bhref=&quot;([^&quot;]*)&quot;[^&gt;]*&gt;([\\s\\S]*?)&lt;\\/a&gt;/</span><br><span class=\"line\">var str = &apos;&lt;a title=&quot;title&quot; href=&quot;//www.baidu.com&quot; class=&quot;hh&quot;&gt;&lt;/a&gt;&apos;;</span><br><span class=\"line\">pattern.test(str); //true</span><br></pre></td></tr></table></figure></p>\n<p>解释一下，其中</p>\n<p>&lt;a\\b 表示匹配a标签的开始，<br>[^&gt;]+ 匹配非&gt;字符的一到多个任意字符<br>\\bhref=”([^”]<em>)” 匹配href的值，并且将匹配到的值捕获到分组中<br>[^&gt;]</em> 匹配href后除了&gt;字符0到多个任意字符<br>([\\s\\S]*?) 匹配任意字符并捕获到组中（包含空格和非空格字符，非贪婪匹配，也可以用.?但是.不能包含空行）</p>\n<p>\\b : 匹配单词边界。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;moon&quot;; </span><br><span class=\"line\">var patt1=/\\bm/;</span><br><span class=\"line\">var patt2=/oo\\b/;</span><br><span class=\"line\">var patt3=/oon\\b/;</span><br><span class=\"line\">var patt4=/\\w\\b\\w/;</span><br><span class=\"line\"></span><br><span class=\"line\">str.match(patt1); //m</span><br><span class=\"line\">str.match(patt2); //null</span><br><span class=\"line\">str.match(patt3); //oon</span><br><span class=\"line\">str.match(patt4); //null</span><br></pre></td></tr></table></figure></p>\n<p>说明：<br>/\\bm/ 匹配 “moon” 中的 ‘m’；<br>/oo\\b/ 不匹配 “moon” 中的 ‘oo’，因为 ‘oo’ 后面的 ‘n’ 是一个单词字符；<br>/oon\\b/ 匹配 “moon” 中的 ‘oon’，因为 ‘oon’ 位于字符串的末端，后面没有单词字符；<br>/\\w\\b\\w/ 不匹配任何字符，因为单词字符之后绝不会同时紧跟着非单词字符和单词字符。</p>\n<p>\\B : 匹配非单词边界。<br>对字符串中不位于单词开头或结尾的 “School” 进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Visit W3School&quot;; </span><br><span class=\"line\">var patt1=/\\BSchool/g;</span><br><span class=\"line\">str.match(patt1); //School</span><br></pre></td></tr></table></figure></p>\n<p>\\n : 查找换行符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Visit W3School.\\n Learn JavaScript.&quot;; </span><br><span class=\"line\">var patt1=/\\n/g;</span><br><span class=\"line\">str.search(patt1); //15</span><br></pre></td></tr></table></figure></p>\n<p>\\uxxxx : 查找以十六进制数 xxxx 规定的 Unicode 字符。<br>对字符串中的十六进制 0057 (W) 进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Visit W3School. Hello World!&quot;; </span><br><span class=\"line\">var patt1=/\\u0057/g;</span><br><span class=\"line\">str.match(patt1); //W,W</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h4><p>n+ : 匹配任何包含至少一个 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Hellooo World! Hello W3School!&quot;; </span><br><span class=\"line\">var patt1=/o+/g;</span><br><span class=\"line\">str.match(patt1); //ooo,o,o,oo</span><br></pre></td></tr></table></figure></p>\n<p>穿插小例子：Email地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*$/</span><br></pre></td></tr></table></figure></p>\n<p>n* : 匹配任何包含零个或多个 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Hellooo World! Hello W3School!&quot;; </span><br><span class=\"line\">var patt1=/lo*/g;</span><br><span class=\"line\">str.match(patt1); //l,looo,l,l,lo,l</span><br></pre></td></tr></table></figure></p>\n<p>n? : 匹配任何包含零个或一个 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;1, 100 or 1000?&quot;; </span><br><span class=\"line\">var patt1=/10?/g;</span><br><span class=\"line\">str.match(patt1); //1,10,10</span><br></pre></td></tr></table></figure></p>\n<p>n{X} : 匹配包含 X 个 n 的序列的字符串。<br>对包含四位数字序列的子串进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;100, 1000 or 10000?&quot;;</span><br><span class=\"line\">var patt1=/\\d&#123;4&#125;/g; </span><br><span class=\"line\">str.match(patt1); //1000,1000</span><br></pre></td></tr></table></figure></p>\n<p>n{X,Y} : 匹配包含 X 至 Y 个 n 的序列的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;100, 1000 or 10000?&quot;;</span><br><span class=\"line\">var patt1=/\\d&#123;3,4&#125;/g; </span><br><span class=\"line\">str.match(patt1); //100,1000,1000</span><br></pre></td></tr></table></figure></p>\n<p>n{X,} : 匹配包含至少 X 个 n 的序列的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;100, 1000 or 10000?&quot;;</span><br><span class=\"line\">var patt1=/\\d&#123;3,&#125;/g; </span><br><span class=\"line\">str.match(patt1); //100,1000,10000</span><br></pre></td></tr></table></figure></p>\n<p>n$ : 匹配任何结尾为 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this his&quot;;</span><br><span class=\"line\">var patt1=/is$/g;</span><br><span class=\"line\">str.match(patt1); // is</span><br><span class=\"line\">patt1.test(str); //true</span><br></pre></td></tr></table></figure></p>\n<p>^n : 匹配任何开头为 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this his&quot;;</span><br><span class=\"line\">var patt1=/^Is/g;</span><br><span class=\"line\">str.match(patt1); //Is</span><br><span class=\"line\">patt1.test(str); //true</span><br></pre></td></tr></table></figure></p>\n<p>?=n : 匹配任何其后紧接指定字符串 n 的字符串。<br>对其后紧跟 “all” 的 “is” 进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is&quot;;</span><br><span class=\"line\">var patt1=/is(?= all)/;</span><br><span class=\"line\">str.match(patt1); //is</span><br></pre></td></tr></table></figure></p>\n<p>穿插小例子：密码强度正则<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</span><br><span class=\"line\">/^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$/.test(&quot;weeeeeeeW2&quot;);</span><br><span class=\"line\">//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</span><br><span class=\"line\">/^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/.test(&quot;diaoD123#&quot;);</span><br><span class=\"line\">//输出 true</span><br></pre></td></tr></table></figure></p>\n<p>?!n : 匹配任何其后没有紧接指定字符串 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is&quot;;</span><br><span class=\"line\">var patt1=/is(?! all)/gi;</span><br><span class=\"line\">str.match(patt1); //Is,is</span><br><span class=\"line\">/^(?!0)\\d&#123;4&#125;$/.test(&apos;2019&apos;); //true</span><br><span class=\"line\">/^(?!0)\\d&#123;4&#125;$/.test(&apos;0019&apos;); //false</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"对象方法\"><a href=\"#对象方法\" class=\"headerlink\" title=\"对象方法\"></a>对象方法</h4><p>compile : 编译正则表达式。</p>\n<p>在字符串中全局搜索 “man”，并用 “person” 替换。然后通过 compile() 方法，改变正则表达式，用 “person” 替换 “man” 或 “woman” :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Every man in the world! Every woman on earth!&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">patt=/man/g;</span><br><span class=\"line\">str2=str.replace(patt,&quot;person&quot;);</span><br><span class=\"line\">document.write(str2+&quot;&lt;br /&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">patt=/(wo)?man/g;</span><br><span class=\"line\">patt.compile(patt); //改变正则表达式</span><br><span class=\"line\">str2=str.replace(patt,&quot;person&quot;);</span><br><span class=\"line\">document.write(str2);</span><br><span class=\"line\">//输出</span><br><span class=\"line\">Every person in the world! Every woperson on earth!</span><br><span class=\"line\">Every person in the world! Every person on earth!</span><br></pre></td></tr></table></figure></p>\n<p>exec : 检索字符串中指定的值。返回找到的值，并确定其位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;Visit W3School, W3School is a place to study web technology.&quot;; </span><br><span class=\"line\">var patt = new RegExp(&quot;W3School&quot;,&quot;g&quot;);</span><br><span class=\"line\">var result;</span><br><span class=\"line\"></span><br><span class=\"line\">while ((result = patt.exec(str)) != null)  &#123;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">  console.log(patt.lastIndex);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">//输出</span><br><span class=\"line\">W3School</span><br><span class=\"line\">14</span><br><span class=\"line\">W3School</span><br><span class=\"line\">24</span><br></pre></td></tr></table></figure></p>\n<p>test : 检索字符串中指定的值。返回 true 或 false。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /[hf]ello/g,</span><br><span class=\"line\">    str = &apos;hello&apos;;</span><br><span class=\"line\">pattern.test(str); //true</span><br><span class=\"line\">pattern = /[ef]ello/g;</span><br><span class=\"line\">pattern.test(str); //false</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"String-对象的方法\"><a href=\"#String-对象的方法\" class=\"headerlink\" title=\"String 对象的方法\"></a>String 对象的方法</h4><p>search : 检索与正则表达式相匹配的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Hello world!&quot;</span><br><span class=\"line\">str.search(&quot;world&quot;); //6</span><br><span class=\"line\">str.search(&quot;World&quot;); //-1</span><br><span class=\"line\">str.search(&quot;woorld&quot;); //-1</span><br></pre></td></tr></table></figure></p>\n<p>说明:search() 方法不执行全局匹配，它将忽略标志 g。</p>\n<p>match : 找到一个或多个正则表达式的匹配。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Hello world!&quot;</span><br><span class=\"line\">str.match(&quot;world&quot;); //world</span><br><span class=\"line\">str.match(&quot;World&quot;); //null</span><br></pre></td></tr></table></figure></p>\n<p>replace : 替换与正则表达式匹配的子串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Visit Microsoft!&quot;</span><br><span class=\"line\">str.replace(/Microsoft/,&quot;W3School&quot;); //Visit W3School!</span><br></pre></td></tr></table></figure></p>\n<p>$1、$2、…、$99 : 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &quot;Doe, John&quot;;</span><br><span class=\"line\">name.replace(/(\\w+)\\s*, \\s*(\\w+)/, &quot;$2 $1&quot;); //John Doe</span><br></pre></td></tr></table></figure></p>\n<p>穿插小例子: 找重复项最多的字符和个数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;sassdfdfffdasdffffffsdsdddsss&apos;;</span><br><span class=\"line\">var arr = str.split(&apos;&apos;);//先把字符串分割为字符串数组</span><br><span class=\"line\">str = arr.sort().join(&apos;&apos;);</span><br><span class=\"line\">var value = &apos;&apos;;</span><br><span class=\"line\">var index = 0;</span><br><span class=\"line\">var re = /(\\w)\\1+/g;</span><br><span class=\"line\">str.replace(re,function($0,$1)&#123;</span><br><span class=\"line\">    if(index&lt;$0.length)&#123;</span><br><span class=\"line\">      index = $0.length;</span><br><span class=\"line\">      value = $1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&apos;最多的字符：&apos;+ value +&apos; ,重复的次数：&apos;+index);</span><br><span class=\"line\">//最多的字符：f ,重复的次数：10</span><br></pre></td></tr></table></figure></p>\n<p>说明：\\1 是捕获组，就是第一个小括号内的值（从左向→）</p>\n<p>split : 把字符串分割为字符串数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;How are you doing today?&quot;;</span><br><span class=\"line\">str.split(&apos; &apos;); //[&quot;How&quot;, &quot;are&quot;, &quot;you&quot;, &quot;doing&quot;, &quot;today?&quot;]</span><br><span class=\"line\">str.split(&apos; &apos;, 3); //[&quot;How&quot;, &quot;are&quot;, &quot;you&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>对象属性lastIndex : 一个整数，标示开始下一次匹配的字符位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;The rain in Spain stays mainly in the plain&quot;;</span><br><span class=\"line\">var patt1 = new RegExp(&quot;ain&quot;, &quot;g&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">for(i = 0; i &lt; 4; i++) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  patt1.test(str)</span><br><span class=\"line\">  console.log(patt1.lastIndex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//输出</span><br><span class=\"line\">8</span><br><span class=\"line\">17</span><br><span class=\"line\">28</span><br><span class=\"line\">43</span><br></pre></td></tr></table></figure></p>\n<p>例子1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;I love antzone ,this is animate&quot;;</span><br><span class=\"line\">var reg=/an/g;</span><br><span class=\"line\">console.log(reg.exec(str)); //[&quot;an&quot;, index: 7, input: &quot;I love antzone ,this is animate&quot;, groups: undefined]</span><br><span class=\"line\">console.log(reg.exec(str)); // [&quot;an&quot;, index: 24, input: &quot;I love antzone ,this is animate&quot;, groups: undefined]</span><br></pre></td></tr></table></figure></p>\n<p>例子2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;I love antzone ,this is animate&quot;;</span><br><span class=\"line\">var reg=/an/g;</span><br><span class=\"line\">reg.lastIndex = 20</span><br><span class=\"line\">console.log(reg.exec(str)); // [&quot;an&quot;, index: 24, input: &quot;I love antzone ,this is animate&quot;, groups: undefined]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"等价的正则表达式\"><a href=\"#等价的正则表达式\" class=\"headerlink\" title=\"等价的正则表达式\"></a>等价的正则表达式</h4><p>常规等价：<br>/\\d/ = /[0-9]/ = /[0123456789]//\\D/ = /[^\\d]/ = /^[0-9]/<br>/\\s/ 匹配一个空白字符，等价于/[\\n\\r\\f\\t\\v]<br>/\\S/ 匹配一个非空白字符，等价于/[^\\n\\f\\r\\t\\v]<br>/\\w/ 任何单字字符, 等价于/[a-zA-Z0-9_]//\\W/ 任何非单字字符,等价于/[^a-zA-Z0-9_]/<br>// ? 匹配前一项0次或1次,也就是说前一项是可选的. 等价于 {0, 1}<br>// + 匹配前一项1次或多次,等价于{1,}<br>// * 匹配前一项0次或多次.等价于{0,}</p>\n<p>其它等价：<br>/^[ab]cd$/.test(“abc”); //true<br>等价于/^(a|b)cd$/.test(“abc”)</p>\n<p>转义：’/‘, ‘\\’, ‘.’ ,’?’等需要被转义字符都符合[char] = \\char<br>/^[.]abc/.test(“a.abc”)//true<br>等价于/^.abc/.test(“.abc”)　</p>\n<h1 id=\"三、js正则常用实例\"><a href=\"#三、js正则常用实例\" class=\"headerlink\" title=\"三、js正则常用实例\"></a>三、js正则常用实例</h1><h4 id=\"用户名正则\"><a href=\"#用户名正则\" class=\"headerlink\" title=\"用户名正则\"></a>用户名正则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用户名正则，4到16位（字母，数字，下划线，减号）</span><br><span class=\"line\">/^[a-zA-Z0-9_-]&#123;4,16&#125;$/.test(&quot;diaodiao&quot;);</span><br><span class=\"line\">//输出 true</span><br></pre></td></tr></table></figure>\n<h4 id=\"整数正则\"><a href=\"#整数正则\" class=\"headerlink\" title=\"整数正则\"></a>整数正则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^\\d+$/.test(&quot;42&quot;);    //正整数正则  -&gt; 输出 true</span><br><span class=\"line\">/^-\\d+$/.test(&quot;-42&quot;);  //负整数正则  -&gt; 输出 true</span><br><span class=\"line\">/^-?\\d+$/.test(&quot;-42&quot;); //整数正则  -&gt; 输出 true</span><br><span class=\"line\">/^[0-9]+$/.test(25.5455) //正整数正则  -&gt; 输出 false</span><br></pre></td></tr></table></figure>\n<h4 id=\"数字正则\"><a href=\"#数字正则\" class=\"headerlink\" title=\"数字正则\"></a>数字正则</h4><p>可以是整数也可以是浮点数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^\\d*\\.?\\d+$/.test(&quot;42.2&quot;);     //正数正则  -&gt; 输出 true</span><br><span class=\"line\">/^-\\d*\\.?\\d+$/.test(&quot;-42.2&quot;);   //负数正则 -&gt; 输出 true</span><br><span class=\"line\">/^-?\\d*\\.?\\d+$/.test(&quot;-42.2&quot;);  //数字正则 -&gt; 输出 true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Email正则\"><a href=\"#Email正则\" class=\"headerlink\" title=\"Email正则\"></a>Email正则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Email正则</span><br><span class=\"line\">/^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;)$/.test(&quot;wowohoo@qq.com&quot;);</span><br><span class=\"line\">//输出 true</span><br></pre></td></tr></table></figure>\n<h4 id=\"传真号码\"><a href=\"#传真号码\" class=\"headerlink\" title=\"传真号码\"></a>传真号码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 国家代码(2到3位)-区号(2到3位)-电话号码(7到8位)-分机号(3位)</span><br><span class=\"line\">/^(([0\\+]\\d&#123;2,3&#125;-)?(0\\d&#123;2,3&#125;)-)(\\d&#123;7,8&#125;)(-(\\d&#123;3,&#125;))?$/.test(&apos;021-5055455&apos;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"手机号码正则\"><a href=\"#手机号码正则\" class=\"headerlink\" title=\"手机号码正则\"></a>手机号码正则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//手机号正则</span><br><span class=\"line\">/^1[34578]\\d&#123;9&#125;$/.test(&quot;13611778887&quot;);</span><br><span class=\"line\">//输出 true</span><br><span class=\"line\"></span><br><span class=\"line\">//* 国际码 如：中国(+86)</span><br><span class=\"line\">/^((\\+?[0-9]&#123;1,4&#125;)|(\\(\\+86\\)))?(13[0-9]|14[57]|15[012356789]|17[03678]|18[0-9])\\d&#123;8&#125;$/.test(&quot;13611778887&quot;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"颜色值校验\"><a href=\"#颜色值校验\" class=\"headerlink\" title=\"颜色值校验\"></a>颜色值校验</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^#?([0-9a-fA-F]&#123;3&#125;|[0-9a-fA-F]&#123;6&#125;)$/.test(&quot;#ccb2b2&quot;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"清除字符串前后空格的正则表达式\"><a href=\"#清除字符串前后空格的正则表达式\" class=\"headerlink\" title=\"清除字符串前后空格的正则表达式\"></a>清除字符串前后空格的正则表达式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.trim = function()&#123;return this.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;);&#125;</span><br><span class=\"line\">var str2 = &quot; hi space &quot;//这里前后共有两个空格</span><br><span class=\"line\">console.log(str2.length);//14</span><br><span class=\"line\">console.log(str2.trim().length);//8</span><br><span class=\"line\">console.log(str2.trim());//hi space</span><br></pre></td></tr></table></figure>\n<h4 id=\"获取网址url参数转化为键值对\"><a href=\"#获取网址url参数转化为键值对\" class=\"headerlink\" title=\"获取网址url参数转化为键值对\"></a>获取网址url参数转化为键值对</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function parseURL(url=window.location.href)&#123;/*es6语法直接设置默认值*/</span><br><span class=\"line\">　　const search = url.substr(url.indexOf(&apos;?&apos;)+1);</span><br><span class=\"line\">　　const obj=&#123;&#125;;</span><br><span class=\"line\">　　search.replace(/([^&amp;=]+)=([^&amp;=]*)/g,function(rs,$1,$2)&#123;</span><br><span class=\"line\">\t\tconsole.log(rs)</span><br><span class=\"line\">　　　　obj[decodeURIComponent($1)]=decodeURIComponent($2)</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;)</span><br><span class=\"line\">　　return obj</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/08/05/3ca32cba0192d540ad69a8046670740d.jpg\" alt></p>\n<h1 id=\"一、js正则简介\"><a href=\"#一、js正则简介\" class=\"headerlink\" title=\"一、js正则简介\"></a>一、js正则简介</h1><p>正则表达式是对字符串执行模式匹配的强大工具。</p>\n<h4 id=\"创建一个正则\"><a href=\"#创建一个正则\" class=\"headerlink\" title=\"创建一个正则\"></a>创建一个正则</h4><p>第一种：字面量创建，将正则表达式直接当做对象使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cc = /[a-z]/;</span><br></pre></td></tr></table></figure>\n<p>第二种：实例化RegExp对象方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cc = new RegExp(&apos;[a-z]&apos;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"前例\"><a href=\"#前例\" class=\"headerlink\" title=\"前例\"></a>前例</h4><p>十八位身份证校验：</p>\n<p>前六位：[1-9]\\d{5}<br>年份（1900-2099）(19|20)\\d{2}<br>月日（例子上的是闰年，如果平年的话把后面的02(0[1-9]|[1-2][0-9])改成02(0[1-9]|1[0-9]|2[0-8])即可）：( (01|03|05|07|08|10|12)(0[1-9]|[1,2][0-9]|3[0-1]) | (04|06|07|11)(0[1-9]|[1,2][0-9]|30) | 02(0[1-9]|[1-2][0-9]) )<br>三位顺序码：[0-9]{3}<br>校验码（0-9或者X或者x）:[0-9Xx]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /^[1-9]\\d&#123;5&#125;(19|20)\\d&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|07|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;[0-9Xx]$/;</span><br><span class=\"line\">var str = &apos;23333319990223283X&apos;;</span><br><span class=\"line\">pattern.test(str); //true</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、js正则基础知识点\"><a href=\"#二、js正则基础知识点\" class=\"headerlink\" title=\"二、js正则基础知识点\"></a>二、js正则基础知识点</h1><h4 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h4><p>i : 执行对大小写不敏感的匹配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new RegExp(&quot;regexp&quot;,&quot;i&quot;)</span><br><span class=\"line\">/regexp/i</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;Visit W3School&quot;;</span><br><span class=\"line\">var patt1 = /w3school/i;</span><br><span class=\"line\">str.match(patt1); //W3School</span><br></pre></td></tr></table></figure>\n<p>g : 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</p>\n<p>对 “is” 进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/is/g;</span><br><span class=\"line\">str.match(patt1); //is,is</span><br></pre></td></tr></table></figure></p>\n<p>对 “is” 进行全局且大小写不敏感的搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/is/gi;</span><br><span class=\"line\">str.match(patt1); //Is,is,is</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"方括号\"><a href=\"#方括号\" class=\"headerlink\" title=\"方括号\"></a>方括号</h4><p>方括号用于查找某个范围内的字符：</p>\n<p>[abc] : 查找方括号之间的任何字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/[a-h]/g;</span><br><span class=\"line\">str.match(patt1); //h,a,h,e,e</span><br></pre></td></tr></table></figure></p>\n<p>[^abc] : 查找任何不在方括号之间的字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/[^a-h]/g;</span><br><span class=\"line\">str.match(patt1); //I,s, ,t,i,s, ,l,l, ,t,r, ,i,s,?</span><br></pre></td></tr></table></figure></p>\n<p>[0-9] : 查找任何从 0 至 9 的数字。<br>[a-z] : 查找任何从小写 a 到小写 z 的字符。<br>[A-Z] : 查找任何从大写 A 到大写 Z 的字符。<br>[A-z] : 查找任何从大写 A 到小写 z 的字符。<br>(red|blue|green) : 查找任何指定的选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is?&quot;;</span><br><span class=\"line\">var patt1=/[ah]/g;</span><br><span class=\"line\">var patt2=/(a|h)/g;</span><br><span class=\"line\">str.match(patt1); //h,a,h</span><br><span class=\"line\">str.match(patt2); //h,a,h</span><br></pre></td></tr></table></figure>\n<h4 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h4><p>元字符（Metacharacter）是拥有特殊含义的字符：</p>\n<p>. : 查找单个字符，除了换行和行结束符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;That&apos;s hot!&quot;;</span><br><span class=\"line\">var patt1=/h.t/g;</span><br><span class=\"line\">str.match(patt1); //hat,hot</span><br></pre></td></tr></table></figure></p>\n<p>\\w : 查找单词字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Give 100%!&quot;; </span><br><span class=\"line\">var patt1=/\\w/g;</span><br><span class=\"line\">str.match(patt1); //G,i,v,e,1,0,0</span><br></pre></td></tr></table></figure></p>\n<p>穿插小例子: 邮箱验证<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re=/^\\w+@[a-z0-9]+\\.[a-z]+$/i; //邮箱不区分大小写</span><br><span class=\"line\">re.test(&apos;aa@12.com&apos;); //true</span><br><span class=\"line\">re.test(&apos;a.a@12.com&apos;); //false</span><br></pre></td></tr></table></figure></p>\n<p>\\W : 查找非单词字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Give 100%!&quot;; </span><br><span class=\"line\">var patt1=/\\W/g;</span><br><span class=\"line\">str.match(patt1); // ,%,!</span><br></pre></td></tr></table></figure></p>\n<p>\\d : 查找数字。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Give 100%!&quot;; </span><br><span class=\"line\">var patt1=/\\d/g;</span><br><span class=\"line\">str.match(patt1); //1,0,0</span><br></pre></td></tr></table></figure></p>\n<p>\\D : 查找非数字字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Give 100%!&quot;; </span><br><span class=\"line\">var patt1=/\\D/g;</span><br><span class=\"line\">str.match(patt1); //G,i,v,e, ,%,!</span><br></pre></td></tr></table></figure></p>\n<p>\\s : 查找空白字符。<br>\\S : 查找非空白字符。</p>\n<p>穿插小例子: a标签的匹配<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /&lt;a\\b[^&gt;]+\\bhref=&quot;([^&quot;]*)&quot;[^&gt;]*&gt;([\\s\\S]*?)&lt;\\/a&gt;/</span><br><span class=\"line\">var str = &apos;&lt;a title=&quot;title&quot; href=&quot;//www.baidu.com&quot; class=&quot;hh&quot;&gt;&lt;/a&gt;&apos;;</span><br><span class=\"line\">pattern.test(str); //true</span><br></pre></td></tr></table></figure></p>\n<p>解释一下，其中</p>\n<p>&lt;a\\b 表示匹配a标签的开始，<br>[^&gt;]+ 匹配非&gt;字符的一到多个任意字符<br>\\bhref=”([^”]<em>)” 匹配href的值，并且将匹配到的值捕获到分组中<br>[^&gt;]</em> 匹配href后除了&gt;字符0到多个任意字符<br>([\\s\\S]*?) 匹配任意字符并捕获到组中（包含空格和非空格字符，非贪婪匹配，也可以用.?但是.不能包含空行）</p>\n<p>\\b : 匹配单词边界。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;moon&quot;; </span><br><span class=\"line\">var patt1=/\\bm/;</span><br><span class=\"line\">var patt2=/oo\\b/;</span><br><span class=\"line\">var patt3=/oon\\b/;</span><br><span class=\"line\">var patt4=/\\w\\b\\w/;</span><br><span class=\"line\"></span><br><span class=\"line\">str.match(patt1); //m</span><br><span class=\"line\">str.match(patt2); //null</span><br><span class=\"line\">str.match(patt3); //oon</span><br><span class=\"line\">str.match(patt4); //null</span><br></pre></td></tr></table></figure></p>\n<p>说明：<br>/\\bm/ 匹配 “moon” 中的 ‘m’；<br>/oo\\b/ 不匹配 “moon” 中的 ‘oo’，因为 ‘oo’ 后面的 ‘n’ 是一个单词字符；<br>/oon\\b/ 匹配 “moon” 中的 ‘oon’，因为 ‘oon’ 位于字符串的末端，后面没有单词字符；<br>/\\w\\b\\w/ 不匹配任何字符，因为单词字符之后绝不会同时紧跟着非单词字符和单词字符。</p>\n<p>\\B : 匹配非单词边界。<br>对字符串中不位于单词开头或结尾的 “School” 进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Visit W3School&quot;; </span><br><span class=\"line\">var patt1=/\\BSchool/g;</span><br><span class=\"line\">str.match(patt1); //School</span><br></pre></td></tr></table></figure></p>\n<p>\\n : 查找换行符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Visit W3School.\\n Learn JavaScript.&quot;; </span><br><span class=\"line\">var patt1=/\\n/g;</span><br><span class=\"line\">str.search(patt1); //15</span><br></pre></td></tr></table></figure></p>\n<p>\\uxxxx : 查找以十六进制数 xxxx 规定的 Unicode 字符。<br>对字符串中的十六进制 0057 (W) 进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Visit W3School. Hello World!&quot;; </span><br><span class=\"line\">var patt1=/\\u0057/g;</span><br><span class=\"line\">str.match(patt1); //W,W</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h4><p>n+ : 匹配任何包含至少一个 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Hellooo World! Hello W3School!&quot;; </span><br><span class=\"line\">var patt1=/o+/g;</span><br><span class=\"line\">str.match(patt1); //ooo,o,o,oo</span><br></pre></td></tr></table></figure></p>\n<p>穿插小例子：Email地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*$/</span><br></pre></td></tr></table></figure></p>\n<p>n* : 匹配任何包含零个或多个 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Hellooo World! Hello W3School!&quot;; </span><br><span class=\"line\">var patt1=/lo*/g;</span><br><span class=\"line\">str.match(patt1); //l,looo,l,l,lo,l</span><br></pre></td></tr></table></figure></p>\n<p>n? : 匹配任何包含零个或一个 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;1, 100 or 1000?&quot;; </span><br><span class=\"line\">var patt1=/10?/g;</span><br><span class=\"line\">str.match(patt1); //1,10,10</span><br></pre></td></tr></table></figure></p>\n<p>n{X} : 匹配包含 X 个 n 的序列的字符串。<br>对包含四位数字序列的子串进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;100, 1000 or 10000?&quot;;</span><br><span class=\"line\">var patt1=/\\d&#123;4&#125;/g; </span><br><span class=\"line\">str.match(patt1); //1000,1000</span><br></pre></td></tr></table></figure></p>\n<p>n{X,Y} : 匹配包含 X 至 Y 个 n 的序列的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;100, 1000 or 10000?&quot;;</span><br><span class=\"line\">var patt1=/\\d&#123;3,4&#125;/g; </span><br><span class=\"line\">str.match(patt1); //100,1000,1000</span><br></pre></td></tr></table></figure></p>\n<p>n{X,} : 匹配包含至少 X 个 n 的序列的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;100, 1000 or 10000?&quot;;</span><br><span class=\"line\">var patt1=/\\d&#123;3,&#125;/g; </span><br><span class=\"line\">str.match(patt1); //100,1000,10000</span><br></pre></td></tr></table></figure></p>\n<p>n$ : 匹配任何结尾为 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this his&quot;;</span><br><span class=\"line\">var patt1=/is$/g;</span><br><span class=\"line\">str.match(patt1); // is</span><br><span class=\"line\">patt1.test(str); //true</span><br></pre></td></tr></table></figure></p>\n<p>^n : 匹配任何开头为 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this his&quot;;</span><br><span class=\"line\">var patt1=/^Is/g;</span><br><span class=\"line\">str.match(patt1); //Is</span><br><span class=\"line\">patt1.test(str); //true</span><br></pre></td></tr></table></figure></p>\n<p>?=n : 匹配任何其后紧接指定字符串 n 的字符串。<br>对其后紧跟 “all” 的 “is” 进行全局搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is&quot;;</span><br><span class=\"line\">var patt1=/is(?= all)/;</span><br><span class=\"line\">str.match(patt1); //is</span><br></pre></td></tr></table></figure></p>\n<p>穿插小例子：密码强度正则<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</span><br><span class=\"line\">/^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$/.test(&quot;weeeeeeeW2&quot;);</span><br><span class=\"line\">//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</span><br><span class=\"line\">/^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/.test(&quot;diaoD123#&quot;);</span><br><span class=\"line\">//输出 true</span><br></pre></td></tr></table></figure></p>\n<p>?!n : 匹配任何其后没有紧接指定字符串 n 的字符串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Is this all there is&quot;;</span><br><span class=\"line\">var patt1=/is(?! all)/gi;</span><br><span class=\"line\">str.match(patt1); //Is,is</span><br><span class=\"line\">/^(?!0)\\d&#123;4&#125;$/.test(&apos;2019&apos;); //true</span><br><span class=\"line\">/^(?!0)\\d&#123;4&#125;$/.test(&apos;0019&apos;); //false</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"对象方法\"><a href=\"#对象方法\" class=\"headerlink\" title=\"对象方法\"></a>对象方法</h4><p>compile : 编译正则表达式。</p>\n<p>在字符串中全局搜索 “man”，并用 “person” 替换。然后通过 compile() 方法，改变正则表达式，用 “person” 替换 “man” 或 “woman” :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Every man in the world! Every woman on earth!&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">patt=/man/g;</span><br><span class=\"line\">str2=str.replace(patt,&quot;person&quot;);</span><br><span class=\"line\">document.write(str2+&quot;&lt;br /&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">patt=/(wo)?man/g;</span><br><span class=\"line\">patt.compile(patt); //改变正则表达式</span><br><span class=\"line\">str2=str.replace(patt,&quot;person&quot;);</span><br><span class=\"line\">document.write(str2);</span><br><span class=\"line\">//输出</span><br><span class=\"line\">Every person in the world! Every woperson on earth!</span><br><span class=\"line\">Every person in the world! Every person on earth!</span><br></pre></td></tr></table></figure></p>\n<p>exec : 检索字符串中指定的值。返回找到的值，并确定其位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;Visit W3School, W3School is a place to study web technology.&quot;; </span><br><span class=\"line\">var patt = new RegExp(&quot;W3School&quot;,&quot;g&quot;);</span><br><span class=\"line\">var result;</span><br><span class=\"line\"></span><br><span class=\"line\">while ((result = patt.exec(str)) != null)  &#123;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">  console.log(patt.lastIndex);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">//输出</span><br><span class=\"line\">W3School</span><br><span class=\"line\">14</span><br><span class=\"line\">W3School</span><br><span class=\"line\">24</span><br></pre></td></tr></table></figure></p>\n<p>test : 检索字符串中指定的值。返回 true 或 false。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = /[hf]ello/g,</span><br><span class=\"line\">    str = &apos;hello&apos;;</span><br><span class=\"line\">pattern.test(str); //true</span><br><span class=\"line\">pattern = /[ef]ello/g;</span><br><span class=\"line\">pattern.test(str); //false</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"String-对象的方法\"><a href=\"#String-对象的方法\" class=\"headerlink\" title=\"String 对象的方法\"></a>String 对象的方法</h4><p>search : 检索与正则表达式相匹配的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Hello world!&quot;</span><br><span class=\"line\">str.search(&quot;world&quot;); //6</span><br><span class=\"line\">str.search(&quot;World&quot;); //-1</span><br><span class=\"line\">str.search(&quot;woorld&quot;); //-1</span><br></pre></td></tr></table></figure></p>\n<p>说明:search() 方法不执行全局匹配，它将忽略标志 g。</p>\n<p>match : 找到一个或多个正则表达式的匹配。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Hello world!&quot;</span><br><span class=\"line\">str.match(&quot;world&quot;); //world</span><br><span class=\"line\">str.match(&quot;World&quot;); //null</span><br></pre></td></tr></table></figure></p>\n<p>replace : 替换与正则表达式匹配的子串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;Visit Microsoft!&quot;</span><br><span class=\"line\">str.replace(/Microsoft/,&quot;W3School&quot;); //Visit W3School!</span><br></pre></td></tr></table></figure></p>\n<p>$1、$2、…、$99 : 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &quot;Doe, John&quot;;</span><br><span class=\"line\">name.replace(/(\\w+)\\s*, \\s*(\\w+)/, &quot;$2 $1&quot;); //John Doe</span><br></pre></td></tr></table></figure></p>\n<p>穿插小例子: 找重复项最多的字符和个数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;sassdfdfffdasdffffffsdsdddsss&apos;;</span><br><span class=\"line\">var arr = str.split(&apos;&apos;);//先把字符串分割为字符串数组</span><br><span class=\"line\">str = arr.sort().join(&apos;&apos;);</span><br><span class=\"line\">var value = &apos;&apos;;</span><br><span class=\"line\">var index = 0;</span><br><span class=\"line\">var re = /(\\w)\\1+/g;</span><br><span class=\"line\">str.replace(re,function($0,$1)&#123;</span><br><span class=\"line\">    if(index&lt;$0.length)&#123;</span><br><span class=\"line\">      index = $0.length;</span><br><span class=\"line\">      value = $1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&apos;最多的字符：&apos;+ value +&apos; ,重复的次数：&apos;+index);</span><br><span class=\"line\">//最多的字符：f ,重复的次数：10</span><br></pre></td></tr></table></figure></p>\n<p>说明：\\1 是捕获组，就是第一个小括号内的值（从左向→）</p>\n<p>split : 把字符串分割为字符串数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;How are you doing today?&quot;;</span><br><span class=\"line\">str.split(&apos; &apos;); //[&quot;How&quot;, &quot;are&quot;, &quot;you&quot;, &quot;doing&quot;, &quot;today?&quot;]</span><br><span class=\"line\">str.split(&apos; &apos;, 3); //[&quot;How&quot;, &quot;are&quot;, &quot;you&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>对象属性lastIndex : 一个整数，标示开始下一次匹配的字符位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;The rain in Spain stays mainly in the plain&quot;;</span><br><span class=\"line\">var patt1 = new RegExp(&quot;ain&quot;, &quot;g&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">for(i = 0; i &lt; 4; i++) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  patt1.test(str)</span><br><span class=\"line\">  console.log(patt1.lastIndex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//输出</span><br><span class=\"line\">8</span><br><span class=\"line\">17</span><br><span class=\"line\">28</span><br><span class=\"line\">43</span><br></pre></td></tr></table></figure></p>\n<p>例子1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;I love antzone ,this is animate&quot;;</span><br><span class=\"line\">var reg=/an/g;</span><br><span class=\"line\">console.log(reg.exec(str)); //[&quot;an&quot;, index: 7, input: &quot;I love antzone ,this is animate&quot;, groups: undefined]</span><br><span class=\"line\">console.log(reg.exec(str)); // [&quot;an&quot;, index: 24, input: &quot;I love antzone ,this is animate&quot;, groups: undefined]</span><br></pre></td></tr></table></figure></p>\n<p>例子2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;I love antzone ,this is animate&quot;;</span><br><span class=\"line\">var reg=/an/g;</span><br><span class=\"line\">reg.lastIndex = 20</span><br><span class=\"line\">console.log(reg.exec(str)); // [&quot;an&quot;, index: 24, input: &quot;I love antzone ,this is animate&quot;, groups: undefined]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"等价的正则表达式\"><a href=\"#等价的正则表达式\" class=\"headerlink\" title=\"等价的正则表达式\"></a>等价的正则表达式</h4><p>常规等价：<br>/\\d/ = /[0-9]/ = /[0123456789]//\\D/ = /[^\\d]/ = /^[0-9]/<br>/\\s/ 匹配一个空白字符，等价于/[\\n\\r\\f\\t\\v]<br>/\\S/ 匹配一个非空白字符，等价于/[^\\n\\f\\r\\t\\v]<br>/\\w/ 任何单字字符, 等价于/[a-zA-Z0-9_]//\\W/ 任何非单字字符,等价于/[^a-zA-Z0-9_]/<br>// ? 匹配前一项0次或1次,也就是说前一项是可选的. 等价于 {0, 1}<br>// + 匹配前一项1次或多次,等价于{1,}<br>// * 匹配前一项0次或多次.等价于{0,}</p>\n<p>其它等价：<br>/^[ab]cd$/.test(“abc”); //true<br>等价于/^(a|b)cd$/.test(“abc”)</p>\n<p>转义：’/‘, ‘\\’, ‘.’ ,’?’等需要被转义字符都符合[char] = \\char<br>/^[.]abc/.test(“a.abc”)//true<br>等价于/^.abc/.test(“.abc”)　</p>\n<h1 id=\"三、js正则常用实例\"><a href=\"#三、js正则常用实例\" class=\"headerlink\" title=\"三、js正则常用实例\"></a>三、js正则常用实例</h1><h4 id=\"用户名正则\"><a href=\"#用户名正则\" class=\"headerlink\" title=\"用户名正则\"></a>用户名正则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用户名正则，4到16位（字母，数字，下划线，减号）</span><br><span class=\"line\">/^[a-zA-Z0-9_-]&#123;4,16&#125;$/.test(&quot;diaodiao&quot;);</span><br><span class=\"line\">//输出 true</span><br></pre></td></tr></table></figure>\n<h4 id=\"整数正则\"><a href=\"#整数正则\" class=\"headerlink\" title=\"整数正则\"></a>整数正则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^\\d+$/.test(&quot;42&quot;);    //正整数正则  -&gt; 输出 true</span><br><span class=\"line\">/^-\\d+$/.test(&quot;-42&quot;);  //负整数正则  -&gt; 输出 true</span><br><span class=\"line\">/^-?\\d+$/.test(&quot;-42&quot;); //整数正则  -&gt; 输出 true</span><br><span class=\"line\">/^[0-9]+$/.test(25.5455) //正整数正则  -&gt; 输出 false</span><br></pre></td></tr></table></figure>\n<h4 id=\"数字正则\"><a href=\"#数字正则\" class=\"headerlink\" title=\"数字正则\"></a>数字正则</h4><p>可以是整数也可以是浮点数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^\\d*\\.?\\d+$/.test(&quot;42.2&quot;);     //正数正则  -&gt; 输出 true</span><br><span class=\"line\">/^-\\d*\\.?\\d+$/.test(&quot;-42.2&quot;);   //负数正则 -&gt; 输出 true</span><br><span class=\"line\">/^-?\\d*\\.?\\d+$/.test(&quot;-42.2&quot;);  //数字正则 -&gt; 输出 true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Email正则\"><a href=\"#Email正则\" class=\"headerlink\" title=\"Email正则\"></a>Email正则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Email正则</span><br><span class=\"line\">/^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;)$/.test(&quot;wowohoo@qq.com&quot;);</span><br><span class=\"line\">//输出 true</span><br></pre></td></tr></table></figure>\n<h4 id=\"传真号码\"><a href=\"#传真号码\" class=\"headerlink\" title=\"传真号码\"></a>传真号码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 国家代码(2到3位)-区号(2到3位)-电话号码(7到8位)-分机号(3位)</span><br><span class=\"line\">/^(([0\\+]\\d&#123;2,3&#125;-)?(0\\d&#123;2,3&#125;)-)(\\d&#123;7,8&#125;)(-(\\d&#123;3,&#125;))?$/.test(&apos;021-5055455&apos;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"手机号码正则\"><a href=\"#手机号码正则\" class=\"headerlink\" title=\"手机号码正则\"></a>手机号码正则</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//手机号正则</span><br><span class=\"line\">/^1[34578]\\d&#123;9&#125;$/.test(&quot;13611778887&quot;);</span><br><span class=\"line\">//输出 true</span><br><span class=\"line\"></span><br><span class=\"line\">//* 国际码 如：中国(+86)</span><br><span class=\"line\">/^((\\+?[0-9]&#123;1,4&#125;)|(\\(\\+86\\)))?(13[0-9]|14[57]|15[012356789]|17[03678]|18[0-9])\\d&#123;8&#125;$/.test(&quot;13611778887&quot;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"颜色值校验\"><a href=\"#颜色值校验\" class=\"headerlink\" title=\"颜色值校验\"></a>颜色值校验</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^#?([0-9a-fA-F]&#123;3&#125;|[0-9a-fA-F]&#123;6&#125;)$/.test(&quot;#ccb2b2&quot;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"清除字符串前后空格的正则表达式\"><a href=\"#清除字符串前后空格的正则表达式\" class=\"headerlink\" title=\"清除字符串前后空格的正则表达式\"></a>清除字符串前后空格的正则表达式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.trim = function()&#123;return this.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;);&#125;</span><br><span class=\"line\">var str2 = &quot; hi space &quot;//这里前后共有两个空格</span><br><span class=\"line\">console.log(str2.length);//14</span><br><span class=\"line\">console.log(str2.trim().length);//8</span><br><span class=\"line\">console.log(str2.trim());//hi space</span><br></pre></td></tr></table></figure>\n<h4 id=\"获取网址url参数转化为键值对\"><a href=\"#获取网址url参数转化为键值对\" class=\"headerlink\" title=\"获取网址url参数转化为键值对\"></a>获取网址url参数转化为键值对</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function parseURL(url=window.location.href)&#123;/*es6语法直接设置默认值*/</span><br><span class=\"line\">　　const search = url.substr(url.indexOf(&apos;?&apos;)+1);</span><br><span class=\"line\">　　const obj=&#123;&#125;;</span><br><span class=\"line\">　　search.replace(/([^&amp;=]+)=([^&amp;=]*)/g,function(rs,$1,$2)&#123;</span><br><span class=\"line\">\t\tconsole.log(rs)</span><br><span class=\"line\">　　　　obj[decodeURIComponent($1)]=decodeURIComponent($2)</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;)</span><br><span class=\"line\">　　return obj</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>"},{"title":"Promise原理及实现","comments":0,"date":"2019-08-09T02:58:28.000Z","updated":"2020-06-10T06:01:51.401Z","author":"jun.zhou","_content":"\n### 主要内容：\n  ##### 1 Promise 用法\n  ##### 2 Promise 标准\n  ##### 3 Promise 实现\n  ##### 4 关于执行的顺序\n\n# 1 Promise 用法\n<font color=#c7254e >Promise</font> 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。\n\n- **<font color=#c7254e >语法</font>**\n```Javascript\nnew Promise( function(resolve, reject) {...} /* executor */  );\n```\n- **<font color=#c7254e >参数</font>**\n\n<font color=#c7254e >executor 执行器</font>\n&emsp;&emsp;executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数，resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。\n&emsp;&emsp;resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。\n&emsp;&emsp;resolve 和 reject 函数可以接受一个参数，来为Promise赋值，这个值可以是一个未来的值，比如一个ajax的请求结果。\n&emsp;&emsp;executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。\n&emsp;&emsp;executor函数的返回值被忽略。\n\n- **<font color=#c7254e >方法</font>**\n 1. 静态方法\nPromise.all(iterable)\nPromise.race(iterable)\nPromise.reject(reason)\nPromise.resolve(value)\n 2. 原型方法\nPromise.prototype.catch(onRejected)\nPromise.prototype.then(onFulfilled, onRejected)\nPromise.prototype.finally(onFinally)\n\n# 2 Promise 标准\n+ <font color=#c7254e >Promise</font> 规范 中文版规范: [Promises/A+规范(中文)](http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/)\n\n+ <font color=#c7254e >Promise</font> 标准解读\n\n 1.  一个<font color=#c7254e >promise</font>的当前状态只能是<font color=#c7254e >pending</font>、<font color=#c7254e >fulfilled</font>和<font color=#c7254e >rejected</font>三种之一。状态改变只能是<font color=#c7254e >pending</font>到<font color=#c7254e >fulfilled</font>或者<font color=#c7254e >pending</font>到<font color=#c7254e >rejected</font>。状态改变不可逆。\n\n 2.  <font color=#c7254e >promise</font>的<font color=#c7254e >then</font>方法接收两个可选参数，表示该<font color=#c7254e >promise</font>状态改变时的回调<font color=#c7254e >(promise.then(onFulfilled, onRejected))</font>。<font color=#c7254e >then</font>方法返回一个<font color=#c7254e >promise</font>。<font color=#c7254e >then</font> 方法可以被同一个 <font color=#c7254e >promise</font> 调用多次。\n\n\n# 3 Promise的实现\n下面我们定义一个 <font color=#c7254e >MyPromise</font> 的 <font color=#c7254e >Class</font>来进行实现。\n```Javascript\n// 判断变量否为function\nconst isFunction = variable => typeof variable === 'function'\n\nclass MyPromise {\n  constructor (executor) {\n    if (!isFunction(executor)) {\n      throw new Error('MyPromise must accept a function as a parameter')\n    }\n  }\n}\n```\n接下来是状态变化，我们先定义状态常量\n```Javascript\n// 定义Promise的三种状态常量\nconst PENDING = 'PENDING'\nconst FULFILLED = 'FULFILLED'\nconst REJECTED = 'REJECTED'\n```\n\n根据状态转换规则，实现构造函数逻辑\n```Javascript\nclass MyPromise {\n  constructor (executor) {\n    if (!isFunction(executor)) {\n      throw new Error('MyPromise must accept a function as a parameter')\n    }\n    // 记录状态\n    this._status = PENDING\n    // 记录值\n    this._value = undefined\n    // 执行executor\n    try {\n      executor(this._resolve.bind(this), this._reject.bind(this))\n    } catch (err) {\n      this._reject(err)\n    }\n  }\n  // resovle执行时状态由pending到fulfilled\n  _resolve (val) {\n    if (this._status !== PENDING) return\n    this._status = FULFILLED\n    this._value = val\n  }\n  // reject执行时状态改由pending到rejected\n  _reject (err) {\n    if (this._status !== PENDING) return\n    this._status = REJECTED\n    this._value = err\n  }\n}\n```\n\n下面说一说 <font color=#c7254e >Promise</font> 的核心:<font color=#c7254e >then</font>  方法。\n<font color=#c7254e >then</font>主要是用来获取Promise的值的。\n```Javascript\npromise.then(onFulfilled, onRejected)\n```\n+ **<font color=#c7254e >参数可选</font>**\nonFulfilled 和 onRejected 都是可选参数。如果不是函数，其必须被忽略。\n+ **<font color=#c7254e >参数特性</font>**\n  1. 在 promise 状态改变前其不可被调用\n  2. 其调用次数不可超过一次\n  3. onFulfilled函数在promise状态变为成功时必须被调用，其第一个参数为 promise 成功状态传入的值\n  4. onRejected 函数在promise状态变为失败时必须被调用，其第一个参数为 promise 失败状态传入的值\n+ **<font color=#c7254e >多次调用</font>**\n  then 方法可以被同一个 promise 对象调用多次\n+ **<font color=#c7254e >返回值</font>**\n  then 方法必须返回一个新的 promise 对象\n  ```Javascript\n  promise2 = promise1.then(onFulfilled, onRejected);\n  ```\n  **这里面有一个“值的传递”和“错误捕获”的问题：**\n  &emsp;&emsp;通过then方法进行链式调用，上一个Promise的最终值需要通过onFulfilled或者onRejected的返回值来进行传递，且返回值的类型有多种。\n\n  (1). **如果 onFulfilled 或者 onRejected 返回值为X**\n    若x不为Promise ，是一个普通对象，则使 x 直接作为新返回的 Promise 对象的值。\n    若x 为Promise ，这时后一个回调函数，就会等待该 Promise（即x） 对象的状态发生变化，才会被调用，并且新的Promise状态和 x 的状态相同\n\n  **<font color=#c7254e >例1</font>**\n   ```Javascript\n   let promise1=new Promise((resolve,reject)=>{\n                   setTimeout(()=>{\n                     resolve();\n                   },1000);\n               });\n       let promise2=promise1.then(res=>{\n                   return '返回普通值'\n               });\n       promise2.then(res=>{\n           console.log(res);//返回普通值\n       });\n   ```\n   **<font color=#c7254e >例2</font>**\n  ```Javascript\n  let promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve()\n    }, 1000)\n  })\n  promise2 = promise1.then(res => {\n    // 返回一个Promise对象\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n       resolve('这里返回一个Promise')\n      }, 2000)\n    })\n  })\n  promise2.then(res => {\n    console.log(res) //3秒后打印出：这里返回一个Promise\n  })\n  ```\n  (2) 如果 onFulfilled 或者onRejected 抛出一个异常 e ，则 promise2 必须变为失败（Rejected），并返回失败的值 e，\n  ```Javascript\n  let promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('success')\n    }, 1000)\n  })\n  promise2 = promise1.then(res => {\n    throw new Error('这里抛出一个异常e')\n  })\n  promise2.then(res => {\n    console.log(res)\n  }, err => {\n    console.log(err) //1秒后打印出：这里抛出一个异常e\n  })\n  ```\n  (3) 如果onFulfilled 不是函数且 promise1 状态为成功（Fulfilled）， promise2 必须变为成功（Fulfilled）并返回 promise1 成功的值，例如：\n  ```Javascript\n  let promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('success')\n    }, 1000)\n  })\n  promise2 = promise1.then('这里的onFulfilled本来是一个函数，但现在不是')\n  promise2.then(res => {\n    console.log(res) // 1秒后打印出：success\n  }, err => {\n    console.log(err)\n  })\n  ```\n  (4) 如果 onRejected 不是函数且 promise1 状态为失败（Rejected），promise2必须变为失败（Rejected） 并返回 promise1 失败的值，例如：\n  ```Javascript\n  let promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject('fail')\n    }, 1000)\n  })\n  promise2 = promise1.then(res => res, '这里的onRejected本来是一个函数，但现在不是')\n  promise2.then(res => {\n    console.log(res)\n  }, err => {\n    console.log(err)  // 1秒后打印出：fail\n  })\n  ```\n  **注意**：不论 promise1 被 reject 还是被 resolve， promise2 都会被 resolve，只有出现异常时才会被 rejected。\n\n  **根据上面的规则，我们来完善 MyPromise**\n\n  修改 constructor : 增加执行队列\n  由于 then 方法支持多次调用，我们可以维护两个数组，将每次 then 方法注册时的回调函数添加到数组中，等待执行。\n  ```Javascript\n  constructor (executor) {\n    if (!isFunction(executor)) {\n      throw new Error('MyPromise must accept a function as a parameter')\n    }\n    // 添加状态\n    this._status = PENDING\n    // 添加状态\n    this._value = undefined\n    // 添加成功回调函数队列\n    this._fulfilledQueues = []\n    // 添加失败回调函数队列\n    this._rejectedQueues = []\n    // 执行executor\n    try {\n      executor(this._resolve.bind(this), this._reject.bind(this))\n    } catch (err) {\n      this._reject(err)\n    }\n  }\n  ```\n\n  **添加then方法**\n\n  首先，then 返回一个新的 Promise 对象，并且需要将回调函数加入到执行队列中\n\n  ```Javascript\n  // 添加then方法\n  then (onFulfilled, onRejected) {\n    const { _value, _status } = this\n    // 返回一个新的Promise对象\n    return new MyPromise((onFulfilledNext, onRejectedNext) => {\n       switch (_status) {\n          // 当状态为pending时，将then方法回调函数加入执行队列等待执行\n          case PENDING:\n            this._fulfilledQueues.push(onFulfilled)\n            this._rejectedQueues.push(onRejected)\n            break\n          // 当状态已经改变时，立即执行对应的回调函数\n          case FULFILLED:\n            onFulfilled(_value)\n            break\n          case REJECTED:\n            onRejected(_value)\n            break\n        }\n    })\n  }\n  ```\n  那返回的新的<font color=#c7254e >Promise</font>  对象什么时候改变状态？改变为哪种状态呢？\n  根据上文中<font color=#c7254e >then</font>  方法的规则，我们知道返回的新的<font color=#c7254e >Promise</font>  对象的状态依赖于当前 <font color=#c7254e >then</font> 方法回调函数执行的情况以及返回值。\n  例如<font color=#c7254e >then</font> 的参数是否为一个函数、回调函数执行是否出错、返回值是否为<font color=#c7254e >Promise</font> 对象。\n  **我们来进一步完善 then 方法:**\n  ```Javascript\n  // 添加then方法\n  then (onFulfilled, onRejected) {\n    const { _value, _status } = this\n    // 返回一个新的Promise对象\n    return new MyPromise((onFulfilledNext, onRejectedNext) => {\n      // 封装一个成功时执行的函数\n      let fulfilled = value => {\n        try {\n          if (!isFunction(onFulfilled)) {\n            onFulfilledNext(value)\n          } else {\n            let res =  onFulfilled(value);\n            if (res instanceof MyPromise) {\n              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调\n              res.then(onFulfilledNext, onRejectedNext)\n            } else {\n              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数\n              onFulfilledNext(res)\n            }\n          }\n        } catch (err) {\n          // 如果函数执行出错，新的Promise对象的状态为失败\n          onRejectedNext(err)\n        }\n      }\n      // 封装一个失败时执行的函数\n      let rejected = error => {\n        try {\n          if (!isFunction(onRejected)) {\n            onRejectedNext(error)\n          } else {\n              let res = onRejected(error);\n              if (res instanceof MyPromise) {\n                // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调\n                res.then(onFulfilledNext, onRejectedNext)\n              } else {\n                //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数\n                onFulfilledNext(res)\n              }\n          }\n        } catch (err) {\n          // 如果函数执行出错，新的Promise对象的状态为失败\n          onRejectedNext(err)\n        }\n      }\n      switch (_status) {\n        // 当状态为pending时，将then方法回调函数加入执行队列等待执行\n        case PENDING:\n          this._fulfilledQueues.push(fulfilled)\n          this._rejectedQueues.push(rejected)\n          break\n        // 当状态已经改变时，立即执行对应的回调函数\n        case FULFILLED:\n          fulfilled(_value)\n          break\n        case REJECTED:\n          rejected(_value)\n          break\n      }\n    })\n  }\n  ```\n\n  **接着修改 _resolve 和 _reject ：依次执行队列中的函数**\n\n  当 resolve 或  reject 方法执行时，我们依次提取成功或失败任务队列当中的函数开始执行，并清空队列，从而实现 then 方法的多次调用，实现的代码如下：\n  ```javascript\n  // 添加resovle时执行的函数\n  _resolve (val) {\n    if (this._status !== PENDING) return\n    // 依次执行成功队列中的函数，并清空队列\n    const run = () => {\n      this._status = FULFILLED\n      this._value = val\n      let cb;\n      while (cb = this._fulfilledQueues.shift()) {\n        cb(val)\n      }\n    }\n    // 为了支持同步的Promise，这里采用异步调用\n    setTimeout(() => run(), 0)\n  }\n  // 添加reject时执行的函数\n  _reject (err) {\n    if (this._status !== PENDING) return\n    // 依次执行失败队列中的函数，并清空队列\n    const run = () => {\n      this._status = REJECTED\n      this._value = err\n      let cb;\n      while (cb = this._rejectedQueues.shift()) {\n        cb(err)\n      }\n    }\n    // 为了支持同步的Promise，这里采用异步调用\n    setTimeout(run, 0)\n  }\n  ```\n  这是一个Promise的基本实现，当然还有一下细节需要处理。\n  **<font color=#c7254e >catch</font> 方法**\n  相当于调用 then 方法, 但只传入 Rejected 状态的回调函数\n  ```javascript\n  // 添加catch方法\n  catch (onRejected) {\n    return this.then(undefined, onRejected)\n  }\n  ```\n  **静态 <font color=#c7254e >resolve</font> 方法**\n  ```javascript\n  // 添加静态reject方法\n  static reject (value) {\n    return new MyPromise((resolve ,reject) => reject(value))\n  }\n  ```\n\n  **总结：**\n  **&emsp;&emsp;<font color=#c7254e >Promise</font>表示了状态和值，异步操作完成之后，由用户通过resolve和reject方法来修改状态和值，且一旦发生改变，则永久保持。\n  &emsp;&emsp;<font color=#c7254e >Promise</font>的值的获取是通过then方法的onFulfilled函数的参数返回的，多次调用同一个<font color=#c7254e >Promise</font>的then方法，获取的值相同。\n  &emsp;&emsp;then方法返回了一个新的<font color=#c7254e >Promise</font>，then方法主要处理了<font color=#c7254e >新Promise</font>的状态变化问题。<font color=#c7254e >新Promise</font>的值是onFulfilled或onRejected的返回值，如果返回值是<font color=#c7254e >Promise</font>，则是<font color=#c7254e >Promise</font>的值。**\n\n# 4 执行顺序\n  猜一下下面这个例子的执行结果：\n  ```JavaScript\n    setTimeout(function(){\n        console.log('1')\n    });\n\n    new Promise(function(resolve){\n        console.log('2');\n        resolve();\n    }).then(function(){\n        console.log('3')\n    });\n\n    console.log('4');\n  ```\n  **执行结果**：<font color=#fff >2 4 3 1 </font>。\n\n  我们都知道事件任务分为同步和异步，实际上还可以更精细的定义：\n\n  - <font color=#c7254e >macro-task(宏任务)</font>：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.\n  - <font color=#c7254e >micro-task(微任务)</font>：process.nextTick （node.js中进程相关的对象）, Promise, Object.observer, MutationObserver\n\n  **在浏览器的 Event Loop机制中，整个流程可以用张图来表示一下：**\n  ![](https://img.fengjr.com/image/2019/08/14/b81bcac936f778c63dbd58b2382ec368.jpg)\n\n  这张图中可以看到：\n    * 微任务队列（micro tasks）只会有一个\n    * 宏任务队列（macro tasks）可以有多个\n    * click ajax 等回调方法都会进入到宏任务队列（macro tasks）中\n\n&emsp;&emsp;不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。\n&emsp;&emsp;**事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。\n&emsp;&emsp;即：执行完一个宏任务后，立即执行所有微任务，然后开始下一个循环。**\n\n\n\n\n参考资料：\n1 [Promise实现原理（附源码）](https://www.jianshu.com/p/43de678e918a)\n2 [js 异步、栈、事件循环、任务队列](https://www.cnblogs.com/oicb/p/10615592.html)\n\n\n\n","source":"_posts/2019-08-09-Promise实现.md","raw":"---\ntitle: Promise原理及实现\ncomments: false\ndate: 2019-08-09 10:58:28\ntags:\n- js\nupdated:\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n### 主要内容：\n  ##### 1 Promise 用法\n  ##### 2 Promise 标准\n  ##### 3 Promise 实现\n  ##### 4 关于执行的顺序\n\n# 1 Promise 用法\n<font color=#c7254e >Promise</font> 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。\n\n- **<font color=#c7254e >语法</font>**\n```Javascript\nnew Promise( function(resolve, reject) {...} /* executor */  );\n```\n- **<font color=#c7254e >参数</font>**\n\n<font color=#c7254e >executor 执行器</font>\n&emsp;&emsp;executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数，resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。\n&emsp;&emsp;resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。\n&emsp;&emsp;resolve 和 reject 函数可以接受一个参数，来为Promise赋值，这个值可以是一个未来的值，比如一个ajax的请求结果。\n&emsp;&emsp;executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。\n&emsp;&emsp;executor函数的返回值被忽略。\n\n- **<font color=#c7254e >方法</font>**\n 1. 静态方法\nPromise.all(iterable)\nPromise.race(iterable)\nPromise.reject(reason)\nPromise.resolve(value)\n 2. 原型方法\nPromise.prototype.catch(onRejected)\nPromise.prototype.then(onFulfilled, onRejected)\nPromise.prototype.finally(onFinally)\n\n# 2 Promise 标准\n+ <font color=#c7254e >Promise</font> 规范 中文版规范: [Promises/A+规范(中文)](http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/)\n\n+ <font color=#c7254e >Promise</font> 标准解读\n\n 1.  一个<font color=#c7254e >promise</font>的当前状态只能是<font color=#c7254e >pending</font>、<font color=#c7254e >fulfilled</font>和<font color=#c7254e >rejected</font>三种之一。状态改变只能是<font color=#c7254e >pending</font>到<font color=#c7254e >fulfilled</font>或者<font color=#c7254e >pending</font>到<font color=#c7254e >rejected</font>。状态改变不可逆。\n\n 2.  <font color=#c7254e >promise</font>的<font color=#c7254e >then</font>方法接收两个可选参数，表示该<font color=#c7254e >promise</font>状态改变时的回调<font color=#c7254e >(promise.then(onFulfilled, onRejected))</font>。<font color=#c7254e >then</font>方法返回一个<font color=#c7254e >promise</font>。<font color=#c7254e >then</font> 方法可以被同一个 <font color=#c7254e >promise</font> 调用多次。\n\n\n# 3 Promise的实现\n下面我们定义一个 <font color=#c7254e >MyPromise</font> 的 <font color=#c7254e >Class</font>来进行实现。\n```Javascript\n// 判断变量否为function\nconst isFunction = variable => typeof variable === 'function'\n\nclass MyPromise {\n  constructor (executor) {\n    if (!isFunction(executor)) {\n      throw new Error('MyPromise must accept a function as a parameter')\n    }\n  }\n}\n```\n接下来是状态变化，我们先定义状态常量\n```Javascript\n// 定义Promise的三种状态常量\nconst PENDING = 'PENDING'\nconst FULFILLED = 'FULFILLED'\nconst REJECTED = 'REJECTED'\n```\n\n根据状态转换规则，实现构造函数逻辑\n```Javascript\nclass MyPromise {\n  constructor (executor) {\n    if (!isFunction(executor)) {\n      throw new Error('MyPromise must accept a function as a parameter')\n    }\n    // 记录状态\n    this._status = PENDING\n    // 记录值\n    this._value = undefined\n    // 执行executor\n    try {\n      executor(this._resolve.bind(this), this._reject.bind(this))\n    } catch (err) {\n      this._reject(err)\n    }\n  }\n  // resovle执行时状态由pending到fulfilled\n  _resolve (val) {\n    if (this._status !== PENDING) return\n    this._status = FULFILLED\n    this._value = val\n  }\n  // reject执行时状态改由pending到rejected\n  _reject (err) {\n    if (this._status !== PENDING) return\n    this._status = REJECTED\n    this._value = err\n  }\n}\n```\n\n下面说一说 <font color=#c7254e >Promise</font> 的核心:<font color=#c7254e >then</font>  方法。\n<font color=#c7254e >then</font>主要是用来获取Promise的值的。\n```Javascript\npromise.then(onFulfilled, onRejected)\n```\n+ **<font color=#c7254e >参数可选</font>**\nonFulfilled 和 onRejected 都是可选参数。如果不是函数，其必须被忽略。\n+ **<font color=#c7254e >参数特性</font>**\n  1. 在 promise 状态改变前其不可被调用\n  2. 其调用次数不可超过一次\n  3. onFulfilled函数在promise状态变为成功时必须被调用，其第一个参数为 promise 成功状态传入的值\n  4. onRejected 函数在promise状态变为失败时必须被调用，其第一个参数为 promise 失败状态传入的值\n+ **<font color=#c7254e >多次调用</font>**\n  then 方法可以被同一个 promise 对象调用多次\n+ **<font color=#c7254e >返回值</font>**\n  then 方法必须返回一个新的 promise 对象\n  ```Javascript\n  promise2 = promise1.then(onFulfilled, onRejected);\n  ```\n  **这里面有一个“值的传递”和“错误捕获”的问题：**\n  &emsp;&emsp;通过then方法进行链式调用，上一个Promise的最终值需要通过onFulfilled或者onRejected的返回值来进行传递，且返回值的类型有多种。\n\n  (1). **如果 onFulfilled 或者 onRejected 返回值为X**\n    若x不为Promise ，是一个普通对象，则使 x 直接作为新返回的 Promise 对象的值。\n    若x 为Promise ，这时后一个回调函数，就会等待该 Promise（即x） 对象的状态发生变化，才会被调用，并且新的Promise状态和 x 的状态相同\n\n  **<font color=#c7254e >例1</font>**\n   ```Javascript\n   let promise1=new Promise((resolve,reject)=>{\n                   setTimeout(()=>{\n                     resolve();\n                   },1000);\n               });\n       let promise2=promise1.then(res=>{\n                   return '返回普通值'\n               });\n       promise2.then(res=>{\n           console.log(res);//返回普通值\n       });\n   ```\n   **<font color=#c7254e >例2</font>**\n  ```Javascript\n  let promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve()\n    }, 1000)\n  })\n  promise2 = promise1.then(res => {\n    // 返回一个Promise对象\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n       resolve('这里返回一个Promise')\n      }, 2000)\n    })\n  })\n  promise2.then(res => {\n    console.log(res) //3秒后打印出：这里返回一个Promise\n  })\n  ```\n  (2) 如果 onFulfilled 或者onRejected 抛出一个异常 e ，则 promise2 必须变为失败（Rejected），并返回失败的值 e，\n  ```Javascript\n  let promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('success')\n    }, 1000)\n  })\n  promise2 = promise1.then(res => {\n    throw new Error('这里抛出一个异常e')\n  })\n  promise2.then(res => {\n    console.log(res)\n  }, err => {\n    console.log(err) //1秒后打印出：这里抛出一个异常e\n  })\n  ```\n  (3) 如果onFulfilled 不是函数且 promise1 状态为成功（Fulfilled）， promise2 必须变为成功（Fulfilled）并返回 promise1 成功的值，例如：\n  ```Javascript\n  let promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('success')\n    }, 1000)\n  })\n  promise2 = promise1.then('这里的onFulfilled本来是一个函数，但现在不是')\n  promise2.then(res => {\n    console.log(res) // 1秒后打印出：success\n  }, err => {\n    console.log(err)\n  })\n  ```\n  (4) 如果 onRejected 不是函数且 promise1 状态为失败（Rejected），promise2必须变为失败（Rejected） 并返回 promise1 失败的值，例如：\n  ```Javascript\n  let promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject('fail')\n    }, 1000)\n  })\n  promise2 = promise1.then(res => res, '这里的onRejected本来是一个函数，但现在不是')\n  promise2.then(res => {\n    console.log(res)\n  }, err => {\n    console.log(err)  // 1秒后打印出：fail\n  })\n  ```\n  **注意**：不论 promise1 被 reject 还是被 resolve， promise2 都会被 resolve，只有出现异常时才会被 rejected。\n\n  **根据上面的规则，我们来完善 MyPromise**\n\n  修改 constructor : 增加执行队列\n  由于 then 方法支持多次调用，我们可以维护两个数组，将每次 then 方法注册时的回调函数添加到数组中，等待执行。\n  ```Javascript\n  constructor (executor) {\n    if (!isFunction(executor)) {\n      throw new Error('MyPromise must accept a function as a parameter')\n    }\n    // 添加状态\n    this._status = PENDING\n    // 添加状态\n    this._value = undefined\n    // 添加成功回调函数队列\n    this._fulfilledQueues = []\n    // 添加失败回调函数队列\n    this._rejectedQueues = []\n    // 执行executor\n    try {\n      executor(this._resolve.bind(this), this._reject.bind(this))\n    } catch (err) {\n      this._reject(err)\n    }\n  }\n  ```\n\n  **添加then方法**\n\n  首先，then 返回一个新的 Promise 对象，并且需要将回调函数加入到执行队列中\n\n  ```Javascript\n  // 添加then方法\n  then (onFulfilled, onRejected) {\n    const { _value, _status } = this\n    // 返回一个新的Promise对象\n    return new MyPromise((onFulfilledNext, onRejectedNext) => {\n       switch (_status) {\n          // 当状态为pending时，将then方法回调函数加入执行队列等待执行\n          case PENDING:\n            this._fulfilledQueues.push(onFulfilled)\n            this._rejectedQueues.push(onRejected)\n            break\n          // 当状态已经改变时，立即执行对应的回调函数\n          case FULFILLED:\n            onFulfilled(_value)\n            break\n          case REJECTED:\n            onRejected(_value)\n            break\n        }\n    })\n  }\n  ```\n  那返回的新的<font color=#c7254e >Promise</font>  对象什么时候改变状态？改变为哪种状态呢？\n  根据上文中<font color=#c7254e >then</font>  方法的规则，我们知道返回的新的<font color=#c7254e >Promise</font>  对象的状态依赖于当前 <font color=#c7254e >then</font> 方法回调函数执行的情况以及返回值。\n  例如<font color=#c7254e >then</font> 的参数是否为一个函数、回调函数执行是否出错、返回值是否为<font color=#c7254e >Promise</font> 对象。\n  **我们来进一步完善 then 方法:**\n  ```Javascript\n  // 添加then方法\n  then (onFulfilled, onRejected) {\n    const { _value, _status } = this\n    // 返回一个新的Promise对象\n    return new MyPromise((onFulfilledNext, onRejectedNext) => {\n      // 封装一个成功时执行的函数\n      let fulfilled = value => {\n        try {\n          if (!isFunction(onFulfilled)) {\n            onFulfilledNext(value)\n          } else {\n            let res =  onFulfilled(value);\n            if (res instanceof MyPromise) {\n              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调\n              res.then(onFulfilledNext, onRejectedNext)\n            } else {\n              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数\n              onFulfilledNext(res)\n            }\n          }\n        } catch (err) {\n          // 如果函数执行出错，新的Promise对象的状态为失败\n          onRejectedNext(err)\n        }\n      }\n      // 封装一个失败时执行的函数\n      let rejected = error => {\n        try {\n          if (!isFunction(onRejected)) {\n            onRejectedNext(error)\n          } else {\n              let res = onRejected(error);\n              if (res instanceof MyPromise) {\n                // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调\n                res.then(onFulfilledNext, onRejectedNext)\n              } else {\n                //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数\n                onFulfilledNext(res)\n              }\n          }\n        } catch (err) {\n          // 如果函数执行出错，新的Promise对象的状态为失败\n          onRejectedNext(err)\n        }\n      }\n      switch (_status) {\n        // 当状态为pending时，将then方法回调函数加入执行队列等待执行\n        case PENDING:\n          this._fulfilledQueues.push(fulfilled)\n          this._rejectedQueues.push(rejected)\n          break\n        // 当状态已经改变时，立即执行对应的回调函数\n        case FULFILLED:\n          fulfilled(_value)\n          break\n        case REJECTED:\n          rejected(_value)\n          break\n      }\n    })\n  }\n  ```\n\n  **接着修改 _resolve 和 _reject ：依次执行队列中的函数**\n\n  当 resolve 或  reject 方法执行时，我们依次提取成功或失败任务队列当中的函数开始执行，并清空队列，从而实现 then 方法的多次调用，实现的代码如下：\n  ```javascript\n  // 添加resovle时执行的函数\n  _resolve (val) {\n    if (this._status !== PENDING) return\n    // 依次执行成功队列中的函数，并清空队列\n    const run = () => {\n      this._status = FULFILLED\n      this._value = val\n      let cb;\n      while (cb = this._fulfilledQueues.shift()) {\n        cb(val)\n      }\n    }\n    // 为了支持同步的Promise，这里采用异步调用\n    setTimeout(() => run(), 0)\n  }\n  // 添加reject时执行的函数\n  _reject (err) {\n    if (this._status !== PENDING) return\n    // 依次执行失败队列中的函数，并清空队列\n    const run = () => {\n      this._status = REJECTED\n      this._value = err\n      let cb;\n      while (cb = this._rejectedQueues.shift()) {\n        cb(err)\n      }\n    }\n    // 为了支持同步的Promise，这里采用异步调用\n    setTimeout(run, 0)\n  }\n  ```\n  这是一个Promise的基本实现，当然还有一下细节需要处理。\n  **<font color=#c7254e >catch</font> 方法**\n  相当于调用 then 方法, 但只传入 Rejected 状态的回调函数\n  ```javascript\n  // 添加catch方法\n  catch (onRejected) {\n    return this.then(undefined, onRejected)\n  }\n  ```\n  **静态 <font color=#c7254e >resolve</font> 方法**\n  ```javascript\n  // 添加静态reject方法\n  static reject (value) {\n    return new MyPromise((resolve ,reject) => reject(value))\n  }\n  ```\n\n  **总结：**\n  **&emsp;&emsp;<font color=#c7254e >Promise</font>表示了状态和值，异步操作完成之后，由用户通过resolve和reject方法来修改状态和值，且一旦发生改变，则永久保持。\n  &emsp;&emsp;<font color=#c7254e >Promise</font>的值的获取是通过then方法的onFulfilled函数的参数返回的，多次调用同一个<font color=#c7254e >Promise</font>的then方法，获取的值相同。\n  &emsp;&emsp;then方法返回了一个新的<font color=#c7254e >Promise</font>，then方法主要处理了<font color=#c7254e >新Promise</font>的状态变化问题。<font color=#c7254e >新Promise</font>的值是onFulfilled或onRejected的返回值，如果返回值是<font color=#c7254e >Promise</font>，则是<font color=#c7254e >Promise</font>的值。**\n\n# 4 执行顺序\n  猜一下下面这个例子的执行结果：\n  ```JavaScript\n    setTimeout(function(){\n        console.log('1')\n    });\n\n    new Promise(function(resolve){\n        console.log('2');\n        resolve();\n    }).then(function(){\n        console.log('3')\n    });\n\n    console.log('4');\n  ```\n  **执行结果**：<font color=#fff >2 4 3 1 </font>。\n\n  我们都知道事件任务分为同步和异步，实际上还可以更精细的定义：\n\n  - <font color=#c7254e >macro-task(宏任务)</font>：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.\n  - <font color=#c7254e >micro-task(微任务)</font>：process.nextTick （node.js中进程相关的对象）, Promise, Object.observer, MutationObserver\n\n  **在浏览器的 Event Loop机制中，整个流程可以用张图来表示一下：**\n  ![](https://img.fengjr.com/image/2019/08/14/b81bcac936f778c63dbd58b2382ec368.jpg)\n\n  这张图中可以看到：\n    * 微任务队列（micro tasks）只会有一个\n    * 宏任务队列（macro tasks）可以有多个\n    * click ajax 等回调方法都会进入到宏任务队列（macro tasks）中\n\n&emsp;&emsp;不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。\n&emsp;&emsp;**事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。\n&emsp;&emsp;即：执行完一个宏任务后，立即执行所有微任务，然后开始下一个循环。**\n\n\n\n\n参考资料：\n1 [Promise实现原理（附源码）](https://www.jianshu.com/p/43de678e918a)\n2 [js 异步、栈、事件循环、任务队列](https://www.cnblogs.com/oicb/p/10615592.html)\n\n\n\n","slug":"Promise实现","published":1,"_id":"ck2yl0qc4000fh6q6d0n36ewm","layout":"post","photos":[],"link":"","content":"<h3 id=\"主要内容：\"><a href=\"#主要内容：\" class=\"headerlink\" title=\"主要内容：\"></a>主要内容：</h3><h5 id=\"1-Promise-用法\"><a href=\"#1-Promise-用法\" class=\"headerlink\" title=\"1 Promise 用法\"></a>1 Promise 用法</h5><h5 id=\"2-Promise-标准\"><a href=\"#2-Promise-标准\" class=\"headerlink\" title=\"2 Promise 标准\"></a>2 Promise 标准</h5><h5 id=\"3-Promise-实现\"><a href=\"#3-Promise-实现\" class=\"headerlink\" title=\"3 Promise 实现\"></a>3 Promise 实现</h5><h5 id=\"4-关于执行的顺序\"><a href=\"#4-关于执行的顺序\" class=\"headerlink\" title=\"4 关于执行的顺序\"></a>4 关于执行的顺序</h5><h1 id=\"1-Promise-用法-1\"><a href=\"#1-Promise-用法-1\" class=\"headerlink\" title=\"1 Promise 用法\"></a>1 Promise 用法</h1><p><font color=\"#c7254e\">Promise</font> 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。</p>\n<ul>\n<li><p><strong><font color=\"#c7254e\">语法</font></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;...&#125; <span class=\"comment\">/* executor */</span>  );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong><font color=\"#c7254e\">参数</font></strong></p>\n</li>\n</ul>\n<p><font color=\"#c7254e\">executor 执行器</font><br>&emsp;&emsp;executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数，resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。<br>&emsp;&emsp;resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。<br>&emsp;&emsp;resolve 和 reject 函数可以接受一个参数，来为Promise赋值，这个值可以是一个未来的值，比如一个ajax的请求结果。<br>&emsp;&emsp;executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。<br>&emsp;&emsp;executor函数的返回值被忽略。</p>\n<ul>\n<li><strong><font color=\"#c7254e\">方法</font></strong><ol>\n<li>静态方法<br>Promise.all(iterable)<br>Promise.race(iterable)<br>Promise.reject(reason)<br>Promise.resolve(value)</li>\n<li>原型方法<br>Promise.prototype.catch(onRejected)<br>Promise.prototype.then(onFulfilled, onRejected)<br>Promise.prototype.finally(onFinally)</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"2-Promise-标准-1\"><a href=\"#2-Promise-标准-1\" class=\"headerlink\" title=\"2 Promise 标准\"></a>2 Promise 标准</h1><ul>\n<li><p><font color=\"#c7254e\">Promise</font> 规范 中文版规范: <a href=\"http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/\" target=\"_blank\" rel=\"noopener\">Promises/A+规范(中文)</a></p>\n</li>\n<li><p><font color=\"#c7254e\">Promise</font> 标准解读</p>\n<ol>\n<li><p>一个<font color=\"#c7254e\">promise</font>的当前状态只能是<font color=\"#c7254e\">pending</font>、<font color=\"#c7254e\">fulfilled</font>和<font color=\"#c7254e\">rejected</font>三种之一。状态改变只能是<font color=\"#c7254e\">pending</font>到<font color=\"#c7254e\">fulfilled</font>或者<font color=\"#c7254e\">pending</font>到<font color=\"#c7254e\">rejected</font>。状态改变不可逆。</p>\n</li>\n<li><p><font color=\"#c7254e\">promise</font>的<font color=\"#c7254e\">then</font>方法接收两个可选参数，表示该<font color=\"#c7254e\">promise</font>状态改变时的回调<font color=\"#c7254e\">(promise.then(onFulfilled, onRejected))</font>。<font color=\"#c7254e\">then</font>方法返回一个<font color=\"#c7254e\">promise</font>。<font color=\"#c7254e\">then</font> 方法可以被同一个 <font color=\"#c7254e\">promise</font> 调用多次。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"3-Promise的实现\"><a href=\"#3-Promise的实现\" class=\"headerlink\" title=\"3 Promise的实现\"></a>3 Promise的实现</h1><p>下面我们定义一个 <font color=\"#c7254e\">MyPromise</font> 的 <font color=\"#c7254e\">Class</font>来进行实现。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断变量否为function</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isFunction = <span class=\"function\"><span class=\"params\">variable</span> =&gt;</span> <span class=\"keyword\">typeof</span> variable === <span class=\"string\">'function'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPromise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (executor) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isFunction(executor)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'MyPromise must accept a function as a parameter'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来是状态变化，我们先定义状态常量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义Promise的三种状态常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'PENDING'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FULFILLED = <span class=\"string\">'FULFILLED'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'REJECTED'</span></span><br></pre></td></tr></table></figure></p>\n<p>根据状态转换规则，实现构造函数逻辑<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPromise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (executor) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isFunction(executor)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'MyPromise must accept a function as a parameter'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 记录状态</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = PENDING</span><br><span class=\"line\">    <span class=\"comment\">// 记录值</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行executor</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      executor(<span class=\"keyword\">this</span>._resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._reject.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._reject(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// resovle执行时状态由pending到fulfilled</span></span><br><span class=\"line\">  _resolve (val) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = FULFILLED</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = val</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// reject执行时状态改由pending到rejected</span></span><br><span class=\"line\">  _reject (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = REJECTED</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面说一说 <font color=\"#c7254e\">Promise</font> 的核心:<font color=\"#c7254e\">then</font>  方法。</p>\n<p><font color=\"#c7254e\">then</font>主要是用来获取Promise的值的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong><font color=\"#c7254e\">参数可选</font></strong><br>onFulfilled 和 onRejected 都是可选参数。如果不是函数，其必须被忽略。</li>\n<li><strong><font color=\"#c7254e\">参数特性</font></strong><ol>\n<li>在 promise 状态改变前其不可被调用</li>\n<li>其调用次数不可超过一次</li>\n<li>onFulfilled函数在promise状态变为成功时必须被调用，其第一个参数为 promise 成功状态传入的值</li>\n<li>onRejected 函数在promise状态变为失败时必须被调用，其第一个参数为 promise 失败状态传入的值</li>\n</ol>\n</li>\n<li><strong><font color=\"#c7254e\">多次调用</font></strong><br>then 方法可以被同一个 promise 对象调用多次</li>\n<li><p><strong><font color=\"#c7254e\">返回值</font></strong><br>then 方法必须返回一个新的 promise 对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>\n<p><strong>这里面有一个“值的传递”和“错误捕获”的问题：</strong><br>&emsp;&emsp;通过then方法进行链式调用，上一个Promise的最终值需要通过onFulfilled或者onRejected的返回值来进行传递，且返回值的类型有多种。</p>\n<p>(1). <strong>如果 onFulfilled 或者 onRejected 返回值为X</strong><br>  若x不为Promise ，是一个普通对象，则使 x 直接作为新返回的 Promise 对象的值。<br>  若x 为Promise ，这时后一个回调函数，就会等待该 Promise（即x） 对象的状态发生变化，才会被调用，并且新的Promise状态和 x 的状态相同</p>\n<p><strong><font color=\"#c7254e\">例1</font></strong></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1=<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">                setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">                  resolve();</span><br><span class=\"line\">                &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> promise2=promise1.then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">'返回普通值'</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    promise2.then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res);<span class=\"comment\">//返回普通值</span></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p> <strong><font color=\"#c7254e\">例2</font></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2 = promise1.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个Promise对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">     resolve(<span class=\"string\">'这里返回一个Promise'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">//3秒后打印出：这里返回一个Promise</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>(2) 如果 onFulfilled 或者onRejected 抛出一个异常 e ，则 promise2 必须变为失败（Rejected），并返回失败的值 e，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'success'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2 = promise1.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'这里抛出一个异常e'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err) <span class=\"comment\">//1秒后打印出：这里抛出一个异常e</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>(3) 如果onFulfilled 不是函数且 promise1 状态为成功（Fulfilled）， promise2 必须变为成功（Fulfilled）并返回 promise1 成功的值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'success'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2 = promise1.then(<span class=\"string\">'这里的onFulfilled本来是一个函数，但现在不是'</span>)</span><br><span class=\"line\">promise2.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// 1秒后打印出：success</span></span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>(4) 如果 onRejected 不是函数且 promise1 状态为失败（Rejected），promise2必须变为失败（Rejected） 并返回 promise1 失败的值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'fail'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2 = promise1.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res, <span class=\"string\">'这里的onRejected本来是一个函数，但现在不是'</span>)</span><br><span class=\"line\">promise2.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)  <span class=\"comment\">// 1秒后打印出：fail</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：不论 promise1 被 reject 还是被 resolve， promise2 都会被 resolve，只有出现异常时才会被 rejected。</p>\n<p><strong>根据上面的规则，我们来完善 MyPromise</strong></p>\n<p>修改 constructor : 增加执行队列<br>由于 then 方法支持多次调用，我们可以维护两个数组，将每次 then 方法注册时的回调函数添加到数组中，等待执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span> (executor) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isFunction(executor)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'MyPromise must accept a function as a parameter'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加状态</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._status = PENDING</span><br><span class=\"line\">  <span class=\"comment\">// 添加状态</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._value = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  <span class=\"comment\">// 添加成功回调函数队列</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._fulfilledQueues = []</span><br><span class=\"line\">  <span class=\"comment\">// 添加失败回调函数队列</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._rejectedQueues = []</span><br><span class=\"line\">  <span class=\"comment\">// 执行executor</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    executor(<span class=\"keyword\">this</span>._resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._reject.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._reject(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>添加then方法</strong></p>\n<p>首先，then 返回一个新的 Promise 对象，并且需要将回调函数加入到执行队列中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加then方法</span></span><br><span class=\"line\">then (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; _value, _status &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个新的Promise对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">switch</span> (_status) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> PENDING:</span><br><span class=\"line\">          <span class=\"keyword\">this</span>._fulfilledQueues.push(onFulfilled)</span><br><span class=\"line\">          <span class=\"keyword\">this</span>._rejectedQueues.push(onRejected)</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"comment\">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> FULFILLED:</span><br><span class=\"line\">          onFulfilled(_value)</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> REJECTED:</span><br><span class=\"line\">          onRejected(_value)</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那返回的新的<font color=\"#c7254e\">Promise</font>  对象什么时候改变状态？改变为哪种状态呢？<br>根据上文中<font color=\"#c7254e\">then</font>  方法的规则，我们知道返回的新的<font color=\"#c7254e\">Promise</font>  对象的状态依赖于当前 <font color=\"#c7254e\">then</font> 方法回调函数执行的情况以及返回值。<br>例如<font color=\"#c7254e\">then</font> 的参数是否为一个函数、回调函数执行是否出错、返回值是否为<font color=\"#c7254e\">Promise</font> 对象。<br><strong>我们来进一步完善 then 方法:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加then方法</span></span><br><span class=\"line\">then (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; _value, _status &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个新的Promise对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 封装一个成功时执行的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fulfilled = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class=\"line\">          onFulfilledNext(value)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> res =  onFulfilled(value);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (res <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class=\"line\">            res.then(onFulfilledNext, onRejectedNext)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class=\"line\">            onFulfilledNext(res)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class=\"line\">        onRejectedNext(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 封装一个失败时执行的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> rejected = <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isFunction(onRejected)) &#123;</span><br><span class=\"line\">          onRejectedNext(error)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> res = onRejected(error);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class=\"line\">              res.then(onFulfilledNext, onRejectedNext)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class=\"line\">              onFulfilledNext(res)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class=\"line\">        onRejectedNext(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (_status) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> PENDING:</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._fulfilledQueues.push(fulfilled)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._rejectedQueues.push(rejected)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"comment\">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> FULFILLED:</span><br><span class=\"line\">        fulfilled(_value)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> REJECTED:</span><br><span class=\"line\">        rejected(_value)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>接着修改 _resolve 和 _reject ：依次执行队列中的函数</strong></p>\n<p>当 resolve 或  reject 方法执行时，我们依次提取成功或失败任务队列当中的函数开始执行，并清空队列，从而实现 then 方法的多次调用，实现的代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加resovle时执行的函数</span></span><br><span class=\"line\">_resolve (val) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"comment\">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> run = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = FULFILLED</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = val</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cb;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._fulfilledQueues.shift()) &#123;</span><br><span class=\"line\">      cb(val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> run(), <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加reject时执行的函数</span></span><br><span class=\"line\">_reject (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"comment\">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> run = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = REJECTED</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = err</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cb;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._rejectedQueues.shift()) &#123;</span><br><span class=\"line\">      cb(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class=\"line\">  setTimeout(run, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个Promise的基本实现，当然还有一下细节需要处理。<br><strong><font color=\"#c7254e\">catch</font> 方法</strong><br>相当于调用 then 方法, 但只传入 Rejected 状态的回调函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加catch方法</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span> (onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">undefined</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>静态 <font color=\"#c7254e\">resolve</font> 方法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加静态reject方法</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> reject (value) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve ,reject</span>) =&gt;</span> reject(value))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>总结：</strong><br><strong>&emsp;&emsp;<font color=\"#c7254e\">Promise</font>表示了状态和值，异步操作完成之后，由用户通过resolve和reject方法来修改状态和值，且一旦发生改变，则永久保持。<br>&emsp;&emsp;<font color=\"#c7254e\">Promise</font>的值的获取是通过then方法的onFulfilled函数的参数返回的，多次调用同一个<font color=\"#c7254e\">Promise</font>的then方法，获取的值相同。<br>&emsp;&emsp;then方法返回了一个新的<font color=\"#c7254e\">Promise</font>，then方法主要处理了<font color=\"#c7254e\">新Promise</font>的状态变化问题。<font color=\"#c7254e\">新Promise</font>的值是onFulfilled或onRejected的返回值，如果返回值是<font color=\"#c7254e\">Promise</font>，则是<font color=\"#c7254e\">Promise</font>的值。</strong></p>\n</li>\n</ul>\n<h1 id=\"4-执行顺序\"><a href=\"#4-执行顺序\" class=\"headerlink\" title=\"4 执行顺序\"></a>4 执行顺序</h1><p>  猜一下下面这个例子的执行结果：<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'3'</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'4'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>执行结果</strong>：<font color=\"#fff\">2 4 3 1 </font>。</p>\n<p>  我们都知道事件任务分为同步和异步，实际上还可以更精细的定义：</p>\n<ul>\n<li><font color=\"#c7254e\">macro-task(宏任务)</font>：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.</li>\n<li><p><font color=\"#c7254e\">micro-task(微任务)</font>：process.nextTick （node.js中进程相关的对象）, Promise, Object.observer, MutationObserver</p>\n<p><strong>在浏览器的 Event Loop机制中，整个流程可以用张图来表示一下：</strong><br><img src=\"https://img.fengjr.com/image/2019/08/14/b81bcac936f778c63dbd58b2382ec368.jpg\" alt></p>\n<p>这张图中可以看到：</p>\n<ul>\n<li>微任务队列（micro tasks）只会有一个</li>\n<li>宏任务队列（macro tasks）可以有多个</li>\n<li>click ajax 等回调方法都会进入到宏任务队列（macro tasks）中</li>\n</ul>\n</li>\n</ul>\n<p>&emsp;&emsp;不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。<br>&emsp;&emsp;<strong>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。<br>&emsp;&emsp;即：执行完一个宏任务后，立即执行所有微任务，然后开始下一个循环。</strong></p>\n<p>参考资料：<br>1 <a href=\"https://www.jianshu.com/p/43de678e918a\" target=\"_blank\" rel=\"noopener\">Promise实现原理（附源码）</a><br>2 <a href=\"https://www.cnblogs.com/oicb/p/10615592.html\" target=\"_blank\" rel=\"noopener\">js 异步、栈、事件循环、任务队列</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"主要内容：\"><a href=\"#主要内容：\" class=\"headerlink\" title=\"主要内容：\"></a>主要内容：</h3><h5 id=\"1-Promise-用法\"><a href=\"#1-Promise-用法\" class=\"headerlink\" title=\"1 Promise 用法\"></a>1 Promise 用法</h5><h5 id=\"2-Promise-标准\"><a href=\"#2-Promise-标准\" class=\"headerlink\" title=\"2 Promise 标准\"></a>2 Promise 标准</h5><h5 id=\"3-Promise-实现\"><a href=\"#3-Promise-实现\" class=\"headerlink\" title=\"3 Promise 实现\"></a>3 Promise 实现</h5><h5 id=\"4-关于执行的顺序\"><a href=\"#4-关于执行的顺序\" class=\"headerlink\" title=\"4 关于执行的顺序\"></a>4 关于执行的顺序</h5><h1 id=\"1-Promise-用法-1\"><a href=\"#1-Promise-用法-1\" class=\"headerlink\" title=\"1 Promise 用法\"></a>1 Promise 用法</h1><p><font color=\"#c7254e\">Promise</font> 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。</p>\n<ul>\n<li><p><strong><font color=\"#c7254e\">语法</font></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;...&#125; <span class=\"comment\">/* executor */</span>  );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong><font color=\"#c7254e\">参数</font></strong></p>\n</li>\n</ul>\n<p><font color=\"#c7254e\">executor 执行器</font><br>&emsp;&emsp;executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数，resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。<br>&emsp;&emsp;resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。<br>&emsp;&emsp;resolve 和 reject 函数可以接受一个参数，来为Promise赋值，这个值可以是一个未来的值，比如一个ajax的请求结果。<br>&emsp;&emsp;executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。<br>&emsp;&emsp;executor函数的返回值被忽略。</p>\n<ul>\n<li><strong><font color=\"#c7254e\">方法</font></strong><ol>\n<li>静态方法<br>Promise.all(iterable)<br>Promise.race(iterable)<br>Promise.reject(reason)<br>Promise.resolve(value)</li>\n<li>原型方法<br>Promise.prototype.catch(onRejected)<br>Promise.prototype.then(onFulfilled, onRejected)<br>Promise.prototype.finally(onFinally)</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"2-Promise-标准-1\"><a href=\"#2-Promise-标准-1\" class=\"headerlink\" title=\"2 Promise 标准\"></a>2 Promise 标准</h1><ul>\n<li><p><font color=\"#c7254e\">Promise</font> 规范 中文版规范: <a href=\"http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/\" target=\"_blank\" rel=\"noopener\">Promises/A+规范(中文)</a></p>\n</li>\n<li><p><font color=\"#c7254e\">Promise</font> 标准解读</p>\n<ol>\n<li><p>一个<font color=\"#c7254e\">promise</font>的当前状态只能是<font color=\"#c7254e\">pending</font>、<font color=\"#c7254e\">fulfilled</font>和<font color=\"#c7254e\">rejected</font>三种之一。状态改变只能是<font color=\"#c7254e\">pending</font>到<font color=\"#c7254e\">fulfilled</font>或者<font color=\"#c7254e\">pending</font>到<font color=\"#c7254e\">rejected</font>。状态改变不可逆。</p>\n</li>\n<li><p><font color=\"#c7254e\">promise</font>的<font color=\"#c7254e\">then</font>方法接收两个可选参数，表示该<font color=\"#c7254e\">promise</font>状态改变时的回调<font color=\"#c7254e\">(promise.then(onFulfilled, onRejected))</font>。<font color=\"#c7254e\">then</font>方法返回一个<font color=\"#c7254e\">promise</font>。<font color=\"#c7254e\">then</font> 方法可以被同一个 <font color=\"#c7254e\">promise</font> 调用多次。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"3-Promise的实现\"><a href=\"#3-Promise的实现\" class=\"headerlink\" title=\"3 Promise的实现\"></a>3 Promise的实现</h1><p>下面我们定义一个 <font color=\"#c7254e\">MyPromise</font> 的 <font color=\"#c7254e\">Class</font>来进行实现。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断变量否为function</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isFunction = <span class=\"function\"><span class=\"params\">variable</span> =&gt;</span> <span class=\"keyword\">typeof</span> variable === <span class=\"string\">'function'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPromise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (executor) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isFunction(executor)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'MyPromise must accept a function as a parameter'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来是状态变化，我们先定义状态常量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义Promise的三种状态常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'PENDING'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FULFILLED = <span class=\"string\">'FULFILLED'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'REJECTED'</span></span><br></pre></td></tr></table></figure></p>\n<p>根据状态转换规则，实现构造函数逻辑<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPromise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (executor) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isFunction(executor)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'MyPromise must accept a function as a parameter'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 记录状态</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = PENDING</span><br><span class=\"line\">    <span class=\"comment\">// 记录值</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行executor</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      executor(<span class=\"keyword\">this</span>._resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._reject.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._reject(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// resovle执行时状态由pending到fulfilled</span></span><br><span class=\"line\">  _resolve (val) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = FULFILLED</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = val</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// reject执行时状态改由pending到rejected</span></span><br><span class=\"line\">  _reject (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = REJECTED</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面说一说 <font color=\"#c7254e\">Promise</font> 的核心:<font color=\"#c7254e\">then</font>  方法。</p>\n<p><font color=\"#c7254e\">then</font>主要是用来获取Promise的值的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong><font color=\"#c7254e\">参数可选</font></strong><br>onFulfilled 和 onRejected 都是可选参数。如果不是函数，其必须被忽略。</li>\n<li><strong><font color=\"#c7254e\">参数特性</font></strong><ol>\n<li>在 promise 状态改变前其不可被调用</li>\n<li>其调用次数不可超过一次</li>\n<li>onFulfilled函数在promise状态变为成功时必须被调用，其第一个参数为 promise 成功状态传入的值</li>\n<li>onRejected 函数在promise状态变为失败时必须被调用，其第一个参数为 promise 失败状态传入的值</li>\n</ol>\n</li>\n<li><strong><font color=\"#c7254e\">多次调用</font></strong><br>then 方法可以被同一个 promise 对象调用多次</li>\n<li><p><strong><font color=\"#c7254e\">返回值</font></strong><br>then 方法必须返回一个新的 promise 对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>\n<p><strong>这里面有一个“值的传递”和“错误捕获”的问题：</strong><br>&emsp;&emsp;通过then方法进行链式调用，上一个Promise的最终值需要通过onFulfilled或者onRejected的返回值来进行传递，且返回值的类型有多种。</p>\n<p>(1). <strong>如果 onFulfilled 或者 onRejected 返回值为X</strong><br>  若x不为Promise ，是一个普通对象，则使 x 直接作为新返回的 Promise 对象的值。<br>  若x 为Promise ，这时后一个回调函数，就会等待该 Promise（即x） 对象的状态发生变化，才会被调用，并且新的Promise状态和 x 的状态相同</p>\n<p><strong><font color=\"#c7254e\">例1</font></strong></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1=<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">                setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">                  resolve();</span><br><span class=\"line\">                &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> promise2=promise1.then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">'返回普通值'</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    promise2.then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res);<span class=\"comment\">//返回普通值</span></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p> <strong><font color=\"#c7254e\">例2</font></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2 = promise1.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个Promise对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">     resolve(<span class=\"string\">'这里返回一个Promise'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">//3秒后打印出：这里返回一个Promise</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>(2) 如果 onFulfilled 或者onRejected 抛出一个异常 e ，则 promise2 必须变为失败（Rejected），并返回失败的值 e，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'success'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2 = promise1.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'这里抛出一个异常e'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err) <span class=\"comment\">//1秒后打印出：这里抛出一个异常e</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>(3) 如果onFulfilled 不是函数且 promise1 状态为成功（Fulfilled）， promise2 必须变为成功（Fulfilled）并返回 promise1 成功的值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'success'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2 = promise1.then(<span class=\"string\">'这里的onFulfilled本来是一个函数，但现在不是'</span>)</span><br><span class=\"line\">promise2.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// 1秒后打印出：success</span></span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>(4) 如果 onRejected 不是函数且 promise1 状态为失败（Rejected），promise2必须变为失败（Rejected） 并返回 promise1 失败的值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'fail'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise2 = promise1.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res, <span class=\"string\">'这里的onRejected本来是一个函数，但现在不是'</span>)</span><br><span class=\"line\">promise2.then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)  <span class=\"comment\">// 1秒后打印出：fail</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：不论 promise1 被 reject 还是被 resolve， promise2 都会被 resolve，只有出现异常时才会被 rejected。</p>\n<p><strong>根据上面的规则，我们来完善 MyPromise</strong></p>\n<p>修改 constructor : 增加执行队列<br>由于 then 方法支持多次调用，我们可以维护两个数组，将每次 then 方法注册时的回调函数添加到数组中，等待执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span> (executor) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isFunction(executor)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'MyPromise must accept a function as a parameter'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加状态</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._status = PENDING</span><br><span class=\"line\">  <span class=\"comment\">// 添加状态</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._value = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  <span class=\"comment\">// 添加成功回调函数队列</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._fulfilledQueues = []</span><br><span class=\"line\">  <span class=\"comment\">// 添加失败回调函数队列</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._rejectedQueues = []</span><br><span class=\"line\">  <span class=\"comment\">// 执行executor</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    executor(<span class=\"keyword\">this</span>._resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._reject.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._reject(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>添加then方法</strong></p>\n<p>首先，then 返回一个新的 Promise 对象，并且需要将回调函数加入到执行队列中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加then方法</span></span><br><span class=\"line\">then (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; _value, _status &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个新的Promise对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">switch</span> (_status) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> PENDING:</span><br><span class=\"line\">          <span class=\"keyword\">this</span>._fulfilledQueues.push(onFulfilled)</span><br><span class=\"line\">          <span class=\"keyword\">this</span>._rejectedQueues.push(onRejected)</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"comment\">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> FULFILLED:</span><br><span class=\"line\">          onFulfilled(_value)</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> REJECTED:</span><br><span class=\"line\">          onRejected(_value)</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那返回的新的<font color=\"#c7254e\">Promise</font>  对象什么时候改变状态？改变为哪种状态呢？<br>根据上文中<font color=\"#c7254e\">then</font>  方法的规则，我们知道返回的新的<font color=\"#c7254e\">Promise</font>  对象的状态依赖于当前 <font color=\"#c7254e\">then</font> 方法回调函数执行的情况以及返回值。<br>例如<font color=\"#c7254e\">then</font> 的参数是否为一个函数、回调函数执行是否出错、返回值是否为<font color=\"#c7254e\">Promise</font> 对象。<br><strong>我们来进一步完善 then 方法:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加then方法</span></span><br><span class=\"line\">then (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; _value, _status &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个新的Promise对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 封装一个成功时执行的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fulfilled = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class=\"line\">          onFulfilledNext(value)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> res =  onFulfilled(value);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (res <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class=\"line\">            res.then(onFulfilledNext, onRejectedNext)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class=\"line\">            onFulfilledNext(res)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class=\"line\">        onRejectedNext(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 封装一个失败时执行的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> rejected = <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isFunction(onRejected)) &#123;</span><br><span class=\"line\">          onRejectedNext(error)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> res = onRejected(error);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class=\"line\">              res.then(onFulfilledNext, onRejectedNext)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class=\"line\">              onFulfilledNext(res)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class=\"line\">        onRejectedNext(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (_status) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> PENDING:</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._fulfilledQueues.push(fulfilled)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._rejectedQueues.push(rejected)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"comment\">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> FULFILLED:</span><br><span class=\"line\">        fulfilled(_value)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> REJECTED:</span><br><span class=\"line\">        rejected(_value)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>接着修改 _resolve 和 _reject ：依次执行队列中的函数</strong></p>\n<p>当 resolve 或  reject 方法执行时，我们依次提取成功或失败任务队列当中的函数开始执行，并清空队列，从而实现 then 方法的多次调用，实现的代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加resovle时执行的函数</span></span><br><span class=\"line\">_resolve (val) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"comment\">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> run = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = FULFILLED</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = val</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cb;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._fulfilledQueues.shift()) &#123;</span><br><span class=\"line\">      cb(val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> run(), <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加reject时执行的函数</span></span><br><span class=\"line\">_reject (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"comment\">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> run = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = REJECTED</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._value = err</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cb;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._rejectedQueues.shift()) &#123;</span><br><span class=\"line\">      cb(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class=\"line\">  setTimeout(run, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个Promise的基本实现，当然还有一下细节需要处理。<br><strong><font color=\"#c7254e\">catch</font> 方法</strong><br>相当于调用 then 方法, 但只传入 Rejected 状态的回调函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加catch方法</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span> (onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">undefined</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>静态 <font color=\"#c7254e\">resolve</font> 方法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加静态reject方法</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> reject (value) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve ,reject</span>) =&gt;</span> reject(value))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>总结：</strong><br><strong>&emsp;&emsp;<font color=\"#c7254e\">Promise</font>表示了状态和值，异步操作完成之后，由用户通过resolve和reject方法来修改状态和值，且一旦发生改变，则永久保持。<br>&emsp;&emsp;<font color=\"#c7254e\">Promise</font>的值的获取是通过then方法的onFulfilled函数的参数返回的，多次调用同一个<font color=\"#c7254e\">Promise</font>的then方法，获取的值相同。<br>&emsp;&emsp;then方法返回了一个新的<font color=\"#c7254e\">Promise</font>，then方法主要处理了<font color=\"#c7254e\">新Promise</font>的状态变化问题。<font color=\"#c7254e\">新Promise</font>的值是onFulfilled或onRejected的返回值，如果返回值是<font color=\"#c7254e\">Promise</font>，则是<font color=\"#c7254e\">Promise</font>的值。</strong></p>\n</li>\n</ul>\n<h1 id=\"4-执行顺序\"><a href=\"#4-执行顺序\" class=\"headerlink\" title=\"4 执行顺序\"></a>4 执行顺序</h1><p>  猜一下下面这个例子的执行结果：<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'3'</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'4'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>执行结果</strong>：<font color=\"#fff\">2 4 3 1 </font>。</p>\n<p>  我们都知道事件任务分为同步和异步，实际上还可以更精细的定义：</p>\n<ul>\n<li><font color=\"#c7254e\">macro-task(宏任务)</font>：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.</li>\n<li><p><font color=\"#c7254e\">micro-task(微任务)</font>：process.nextTick （node.js中进程相关的对象）, Promise, Object.observer, MutationObserver</p>\n<p><strong>在浏览器的 Event Loop机制中，整个流程可以用张图来表示一下：</strong><br><img src=\"https://img.fengjr.com/image/2019/08/14/b81bcac936f778c63dbd58b2382ec368.jpg\" alt></p>\n<p>这张图中可以看到：</p>\n<ul>\n<li>微任务队列（micro tasks）只会有一个</li>\n<li>宏任务队列（macro tasks）可以有多个</li>\n<li>click ajax 等回调方法都会进入到宏任务队列（macro tasks）中</li>\n</ul>\n</li>\n</ul>\n<p>&emsp;&emsp;不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。<br>&emsp;&emsp;<strong>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。<br>&emsp;&emsp;即：执行完一个宏任务后，立即执行所有微任务，然后开始下一个循环。</strong></p>\n<p>参考资料：<br>1 <a href=\"https://www.jianshu.com/p/43de678e918a\" target=\"_blank\" rel=\"noopener\">Promise实现原理（附源码）</a><br>2 <a href=\"https://www.cnblogs.com/oicb/p/10615592.html\" target=\"_blank\" rel=\"noopener\">js 异步、栈、事件循环、任务队列</a></p>\n"},{"title":"JSDOC入门教程","comments":1,"date":"2019-08-30T03:32:58.000Z","author":"jun.zhou","_content":"\n# JSDOC入门教程\n\n![JSDOC](https://img.fengjr.com/image/2019/08/30/b6abbf9f9aa6709426d7de301a069eca.png)\n\n## jsDoc介绍\n\n> JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、模块的API文档 的工具。你可以使用他记录如：命名空间，类，方法，方法参数等。类似JavaDoc和PHPDoc。现在很多编辑器或IDE中还可以通过JSDoc直接或使用插件生成智能提示。从而使开发者很容易了解整个类和其中的属性和方法，并且快速知道如何使用，从而提高开发效率，降低维护成本。\n\n示例：\n\n```JS\n/**\n * Book类，代表一本书\n * @param title\n * @param anthor\n * @param pageNum\n * @constructor\n */\nfunction Book (title, anthor, pageNum ) {\n\t// 实例属JS性\n\tthis.title = title;\n\tthis.anthor = anthor;\n\tthis.pageNum = pageNum || 0;\n}\nBook.prototype = {\n\t/**\n\t * 获取书本的标题\n\t * @returns {*}\n\t */\n\tgetTitle : function () {\n\t\treturn this.title;\n\t},\n\t/**\n\t * 获取书本的作者\n\t * @returns {*}\n\t */\n\tgetAnthor: function  () {\n\t\treturn this.anthor;\n\t},\n\t/**\n\t * 设置书本的页码\n\t * @param pageNum\n\t */\n\tsetPageNum: function (pageNum) {\n\t\tthis.pageNum = pageNum;\n\t}\n};\n```\n\n## 入门\n\n### 下载jsdoc\n\n```shell\nnpm install jsdoc -g\n```\n\n### JSDoc 3中的名称路径\n\n如果涉及到一个JavaScript变量，这个变量在文档中的其他地方，你必须提供一个唯一标识符映射到该变量。\n名称路径提供了一种这样做的方法，并且消除实例成员，静态成员和内部变量之间的歧义。\n\njsDoc中名称路径的基本语法示例：\n\n\n```JS\n1、myFunction\n2、MyConstructor\n3、MyConstructor#instanceMember（实例成员）\n4、MyConstructor.staticMember（静态成员）\n5、MyConstructor~innerMember（内部成员）\n```\n\n示例：\n\n```JS\n/**\n * Person类，一个人\n * @param name\n * @constructor\n */\nconst  Person = function (name) {\n\tthis.name = name;\n\t/**\n\t * 这是一个实例成员\n\t * @returns {string}\n\t */\n\tthis.say = () => {\n\t\treturn 'I\\'am an instance.';\n\t};\n\t/**\n\t * 这是一个内部成员\n\t * @returns {string}\n\t */\n\tfunction say () {\n\t\treturn 'I\\' am an inner.';\n\t};\n};\n/**\n * 这是一个静态成员\n * @returns {string}\n */\nPerson.say = function () {\n\treturn 'I\\'am an static.';\n};\n/**\n * 实例化一个人\n * @type {Person}\n */\nconst person1 = new Person('fanerge');\n// Person#say 使用实例方法\nperson1.say();\n// Person.say 使用静态方法\nPerson.say();\n// Person~say 使用内部方法，但这里不能访问到\n```\n\n使用名称路径也有一些特殊的情况：\n\n- @module名称由”module:”前缀，\n- @external 名称由”external:”前缀\n- @event名称由”event:”前缀。\n\n### JSDoc中的命令行参数\n\n使用JSDoc最基本的，像这样使用：\n\n```\n/path/to/jsdoc yourSourceCodeFile.js anotherSourceCodeFile.js ...\n```\n\n其中…是生成文档文件的路径。\n\nJSDoc支持大量的命令行选项，其中许多选项有长和短两种形式\n\n选项 描述\n\n```\n-a , –access 只显示特定access方法属性的标识符： private, protected, public, or undefined, 或者 all（表示所有的访问级别）。默认情况下， 显示除private标识符以外的所有标识符。\n-c , –configure JSDoc配置文件的路径。默认为安装JSDoc目录下的conf.json或conf.json.EXAMPLE。\n-d , –destination 输出生成文档的文件夹路径。JSDoc内置的Haruki模板，使用console 将数据转储到控制台。默认为./out。\n–debug 打印日志信息，可以帮助调试JSDoc本身的问题。\n-e , –encoding 当JSDoc阅读源代码时假定使用这个编码，默认为 utf8。\n-h, –help 显示JSDoc的命令行选项的信息，然后退出。\n–match 只有运行测试，其名称中包含value。\n–nocolor 当运行测试时，在控制台输出信息不要使用的颜色。在Windows中，这个选项是默认启用的。\n-p, –private 将标记有[@private 标签][tags-private.md]的标识符也生成到文档中。默认情况下，不包括私有标识符。\n-P, –package 包含项目名称，版本，和其他细节的package.json文件。默认为在源路径中找到的第一个package.json文件。\n–pedantic 将错误视为致命错误，将警告视为错误。默认为false。\n-q , –query 一个查询字符串用来解析和存储到全局变量env.opts.query中。示例：foo=bar&baz=true。\n-r, –recurse 扫描源文件和导览时递归到子目录。\n-R, –readme 用来包含到生成文档的README.md文件。默认为在源路径中找到的第一README.md 文件。\n-t , –template 用于生成输出文档的模板的路径。默认为templates/default，JSDoc内置的默认模板。\n-T, –test 运行JSDoc的测试套件，并把结果打印到控制台。\n-u , –tutorials 导览路径，JSDoc要搜索的目录。如果省略，将不生成导览页。查看导览说明，以了解更多信息。\n-v, –version 显示JSDoc的版本号，然后退出。\n–verbose 日志的详细信息到控制台JSDoc运行。默认为false。\n-X, –explain 以JSON格式转储所有的doclet到控制台，然后退出。\n```\n\n示例：\n\n使用配置文件/path/to/my/conf.json，为./src目录的中文件生成文档，并保存输出到./docs目录中：\n\n```\n/path/to/jsdoc src -r -c /path/to/my/conf.json -d docs\n```\n\n运行所有JSDoc的测试，其名称包含 tag，并记录每个测试信息：\n\n```\n/path/to/jsdoc -T –match tag –verbose\n```\n\n### 用conf.json配置JSDoc\n\n#### Configuration File(配置文件)\n\n要自定义JSDoc的行为，可以使用JSON格式的配置文件格式化JSDoc，使用-c选项，例如： jsdoc -c /path/to/conf.json\n\n默认的jsDoc配置文件conf.json.EXAMPLE\n\n\n```\n{\n\t\"tags\": {\n\t\t\"allowUnknownTags\": true,\n\t\t\"dictionaries\": [\"jsdoc\",\"closure\"]\n\t},\n\t\"source\": {\n\t\t\"includePattern\": \".+\\\\.js(doc)?$\",\n\t\t\"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\"\n\t},\n\t\"plugins\": [],\n\t\"templates\": {\n\t\t\"cleverLinks\": false,\n\t\t\"monospaceLinks\": false\n\t}\n}\n```\n\n这意味着：\n- JSDoc允许您使用无法识别的标签（tags.allowUnknownTags）;\n- 这两个标准JSDoc标签和closure标签被启用（tags.dictionaries）;\n- 只有以.js和.jsdoc结尾的文件将会被处理（source.includePattern）;\n- 任何文件以下划线开始或开始下划线的目录都将被忽略（source.excludePattern）;\n- 无插件加载（plugins）;\n- @link标签呈现在纯文本（templates.cleverLinks，templates.monospaceLinks）\n\n#### Specifying input files(指定输入文件)\n\n**source**选项组，结合给JSDoc命令行的路径，确定哪些文件要用JSDoc生成文档\n\n\n```JS\n\"source\": {\n    \"include\": [ /* array of paths to files to generate documentation for */ ],\n    \"exclude\": [ /* array of paths to exclude */ ],\n    \"includePattern\": \".+\\\\.js(doc)?$\",\n    \"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\"\n} \n```\n\n- source.include：可选的路径数组，JSDoc应该为它们生成文档。JSDoc将会结合命令行上的路径和这些文件名，以形成文件组，并且扫描。如果路径是一个目录，可以使用-r选项来递归。\n- source.exclude：可选的路径数组，JSDoc应该忽略的路径。在JSDoc3.3.0或更高版本，该数组可包括source.include路径中的子目录。\n- source.includePattern：一个可选的字符串，解释为一个正则表达式。如果存在，所有文件必须匹配这个正则表达式，以通过JSDoc进行扫描。默认情况下此选项设置为.+.js(doc)?$，这意味着只有以.js或者.jsdoc结尾的文件将被扫描。\n- source.excludePattern：一个可选的字符串，解释为一个正则表达式。如果存在的话，任何匹配这个正则表达式的文件将被忽略。默认设置是以下划线开头的文件（或以下划线开头的目录下的所有文件）将被忽略。\n\n#### Incorporating command-line options into the configuration file(合并命令行选项到配置文件)\n\n它有可能把许多JSDoc的命令行选项放到配置文件，而不用在命令行中指定它们。要做到这一点，只要在conf.json的opts部分中使用的相关选项的longnames,值是该选项的值。\n\n\n```JS\n\"opts\": {\n    \"template\": \"templates/default\",  // same as -t templates/default\n    \"encoding\": \"utf8\",               // same as -e utf8\n    \"destination\": \"./out/\",          // same as -d ./out/\n    \"recurse\": true,                  // same as -r\n    \"tutorials\": \"path/to/tutorials\", // same as -u path/to/tutorials\n} \n```\n\n这样可以通过source.include和opts，把所有的JSDoc的参数放在配置文件中，以便命令行简化为：\n\n`jsdoc -c /path/to/conf.json`\n\n\n```\n注意：在命令行中所提供的选项 优先级高于在conf.json中提供的选项。\n```\n\n#### Plugins（插件）\n\n要启用插件，只要添加它们的路径（相对于JSDoc文件夹）到plugins数组中就可以了。\n\n示例：\n\n例如，以下将包括 markdown 插件，它转换 markdown格式的文本为HTML，和“summarize”插件，该自动生成的每个的doclet的摘要\n\n\n```JS\n\"plugins\": [\n    \"plugins/markdown\",\n    \"plugins/summarize\"\n] \n```\n\n#### Tags and tag dictionaries(标签和标签字典)\n\n`tags`选项控制哪些JSDoc标签允许被使用和解析。\n\n```JS\n\"tags\": {\n    \"allowUnknownTags\": true,\n    \"dictionaries\": [\"jsdoc\",\"closure\"]\n} \n```\n\n\n`tags.allowUnknownTags`属性影响JSDoc如何处理无法识别的标签。如果将此选项设置为false，JSDoc发现它不能识别（例如,@foo），JSDoc将记录一个警告。默认情况下，此选项设置为true。\n\n`tags.dictionaries`属性控制JSDoc识别哪些标签，以及JSDoc如何解析它识别标签。在JSDoc3.3.0或更高版本中，有两个内置的标签词典：\n\n- jsdoc: 核心JSDoc标签\n- closure: [Closure Compiler 标签](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler)\n\n默认情况下，两个词典都是启用的。此外，在默认情况下，`jsdoc`字典首先被解析;作为一个结果，如果`jsdoc`词典处理一个标签不同于closure词典，`jsdoc`版本的标签优先被采用(即，以jsdoc版本的标签为准)。\n\n如果您在Closure Compiler 项目中使用JSDoc，并且你想要避免使用 Closure Compiler无法识别的标签，更改tags.dictionaries设置为[“closure”]。如果你想允许核心JSDoc标签, 但又想要确保Closure Compiler特定的标记使用Closure Compiler对其进行解释，您也可以更改此设置为[“closure”,”jsdoc”]。\n\n#### 配置JSDoc的默认模板\n\n\n```\nJSDoc的默认模板中提供了几个选项，您可以使用自定义外观和内容来生成文档。\n要使用这些选项，您必须为JSDoc创建一个配置文件，并在配置文件中设置相应的选项。\n\nGenerating pretty-printed source files（生成适合打印的文档）\n    默认情况下，JSDoc的默认模板为你的源文件生成适合打印的文档。在文档中，它还链接到那些适合的打印文件。\n    要禁用适合打印的文件，设置选项templates.default.outputSourceFiles为false。\n    使用该选项也将删除文档中链接到源文件的连接。此选项在JSDoc3.3.0及更高版本上是可用的。\nCopying static files to the output directory(复制静态文件到输出目录)\n    SDoc的默认模板会自动复制一些静态文件，如CSS样式表，到输出目录。\n    在JSDoc3.3.0或更高版本，你可以告诉默认模板复制附加静态文件到输出目录。\n    例如，您可能希望复制一个图像的目录到输出目录，所以你可以在你的文档中显示这些图像。\n    如果您的静态文件目录中包含./myproject/static/img/screen.png文件，您可以通过HTML标签 <img src=\"img/screen.png\">在您的文档中显示该图片\nShowing the current date in the page footer（在页脚显示当前日期）\n    默认情况下，JSDoc的默认模板总是在生成文档的页脚显示当前日期。\n    在JSDoc3.3.0或更高版本，可以通过设置选项templates.default.includeDate为false来忽略当前日期。\nShowing longnames in the navigation column（在导航栏中显示长文件名）\n    默认情况下，JSDoc的默认模板在导航列中显示每个标识符缩写的名字。\n    例如，标识符my.namespace.MyClass将简单地称为显示MyClass。相反,要显示完整的长名称，设置选项templates.default.useLongnameInNav为true。\n    此选项在JSDoc3.4.0及更高版本中可用。\nOverriding the default template's layout file（重写默认模板的布局文件）\n    默认的模板使用名为 layout.tmpl 的文件 指定每个生成文档的页面中的页眉和页脚。\n    特别是，每个生产的文档页面会加载该文件定义了CSS和JavaScript文件。在JSDoc3.3.0或更高版本，可以指定使用自己的layout.tmpl文件，它允许你加载自己的自定义CSS和JavaScript文件，去除或替代，标准的文件。\n    要使用此功能，设置选项templates.default.layoutFile的路径到你的自定义布局文件。\n    路径是相对于config.json文件，当前的工作目录，和JSDoc目录的相对路径，按照这个顺序。\n```\n\n#### 块标签和内联标签\n\n##### 概述\n\nJSDoc支持两种不同类型的标签：\n- 块标签, 这是在一个JSDoc注释的最高级别。\n- 内联标签, 块标签文本中的标签或说明。\n\n块标签通常会提供有关您的代码的详细信息，如一个函数接受的参数。内联标签通常链接到文件的其他部分，类似于HTML中的锚标记（<a>）。\n\n块标签总是以 at 符号（@）开头。除了JSDoc注释中最后一个块标记，每个块标签后面必须跟一个换行符。\n\n内联标签也以 at 符号（@）开。然而，内联标签及其文本必须用花括号（{ and }）括起来。 { 表示行内联标签的开始，而}表示内联标签的结束。如果你的标签文本中包含右花括号（}），则必须用反斜线（ \\ ）进行转义。在内联标签后,你并不需要使用一个换行符。\n\n大多数JSDoc标签是块标签。一般来说，当这个网站上说\"JSDoc 标签\",我们真正的意思是\"块标签\"\n\n##### 示例\n\n在下面的例子中， @param 是一个块标签，而{@link}是一个内联标签。\n\n```JS\n/**\n * Shoe类，一双鞋子\n * @param color\n * @param size\n * @constructor\n */\nconst Shoe = function (color, size){\n\tthis.color = color;\n\tthis.size = size;\n};\n/**\n * Set shoe's color. Use {@link Shoe#setSize} to set the shoe size\n * @param color\n */\nShoe.prototype.setColor = function (color) {\n\tthis.color = color;\n};\n/**\n * 设置鞋子的尺寸\n * @param size\n */\nShoe.prototype.setSize = function (size) {\n\tthis.size = size;\n};\n/**\n * 设置花边的颜色和样式\n * @param color\n * @param type\n */\nShoe.prototype.setLaceType = function (color, type) {\n\t// ...\n};\nvar shoe1 = new Shoe('red', 12);\n```\n\n#### 关于JSDoc插件\n\n##### Creating and Enabling a Plugin（创建并启用插件）\n\n创建并启用新JSDoc插件,需要两个步骤：\n\n1. 创建一个包含你的插件代码的JavaScript模块.\n2. 将该模块添加到JSDoc配置文件的plugins数组中。你可以指定一个绝对或相对路径。如果使用相对路径，JSDoc按照相对于配置文件所在的目录，当前的工作目录和JSDoc安装目录的顺序搜索插件。\n\n例如，如果你的插件是在当前工作目录下，plugins/shout.js文件中定义的，你应该在JSDoc配置文件中的plugins数组中添加字符串plugins/shout。\n\n例如，在JSDoc配置文件中添加一个插件：\n\n```JSON\n{\n    \"plugins\": [\"plugins/shout\"]\n}\n```\n\n##### Authoring JSDoc 3 Plugins（创建JSDoc3插件）\n\nJSDoc 3的插件系统广泛的控制着解析过程。一个插件可以通过执行以下任何一项操作，影响解析结果：\n\n- 定义事件处理程序\n- 定义标签\n- 定义一个抽象语法树节点的访问者\n\n\n```\nEvent Handlers（事件处理程序）\n事件: parseBegin – JSDoc开始加载和解析源文件之前，parseBegin事件被触发。\n事件: fileBegin – 当解析器即将解析一个文件fileBegin事件触发。\n事件: beforeParse – beforeParse事件在解析开始之前被触发。\n事件: jsdocCommentFound – 每当JSDoc注释被发现,jsdocCommentFound事件就会被触发。\n事件: symbolFound – 当解析器在代码中遇到一个可能需要被文档化的标识符时，symbolFound 事件就会被触发。\n事件: newDoclet – newDoclet事件是最高级别的事件。新的doclet已被创建时，它就会被触发。\n事件: fileComplete – 当解析器解析完一个文件时，fileComplete 事件就会被触发。\n事件: parseComplete – JSDoc解析所有指定的源文件之后，parseComplete事件就会被触发。\n事件: processingComplete – JSDoc更新反映继承和借来的标识符的解析结果后，processingComplete事件被触发。\n\nTag Definitions （标签定义）\n添加标签到标签字典是影响文档生成的一个中级方式。在一个newDoclet事件被触发前，JSDoc注释块被解析以确定可能存在的说明和任何JSDoc标签。\n当一个标签被发现，如果它已在标签字典被定义，它就会被赋予一个修改doclet的机会。\n\n```\n\n#### 使用Markdown插件\n\n##### 概述\n\nJSDoc包括markdown插件，自动把Markdown-formatted文本转换成HTML。你可以在任何JSDoc模板中使用这个插件\n\n默认情况下，JSDoc会在以下JSDoc标签中查找markdown格式的文本：\n\n- @author\n- @classdesc\n- @description (包括在JSDoc注释开始地方的未标记的)\n- @param\n- @property\n- @returns\n- @see\n- @throws\n\n##### 启用markdown插件\n\n要启用markdown插件，只要将字符串plugins/markdown添加到JSDoc配置文件的plugins数组中即可。\n\n示例，配置文件启用markdown插件：\n\n```JSON\n{\n    \"plugins\": [\"plugins/markdown\"]\n} \n```\n\n##### 在额外的JSDoc标签中转换Markdown\n\n默认情况下，markdown插件只处理特定JSDoc标签的markdown文本。您可以通过添加一个 markdown.tags属性到你的JSDoc配置文件中，来处理的其他标签中的markdown文本。\n\n```JSON\n{\n    \"plugins\": [\"plugins/markdown\"],\n    \"markdown\": {\n        \"tags\": [\"foo\", \"bar\"]\n    }\n} \n```\n\n\n##### 剔除markdown默认处理的标签\n\n为了防止Markdown插件处理任何默认JSDoc标签，添加一个markdown.excludeTags属性到您的JSDoc配置文件。\n\n\n```JSON\n\n{\n    \"plugins\": [\"plugins/markdown\"],\n    \"markdown\": {\n        \"excludeTags\": [\"author\"]\n    }\n} \n```\n##### 用换行符换行文本\n\n默认情况下，Markdown插件不处理换行符换行的文本。这是因为，这是正常的JSDoc注释可以多行。如果您更喜欢处理换行符换行的文本，设置JSDoc配置文件中的markdown.hardwrap属性为true。此属性是在JSDoc3.4.0及更高版本中可用。\n\n##### 添加ID属性到标题标签\n\n默认情况下，Markdown插件不会给每个HTML标题标签添加id 属性。想要标题标签文本自动添加ID属性，设置JSDoc配置文件markdown.idInHeadings属性为true。此属性是在JSDoc3.4.0及更高版本中可用\n\n#### 包含Package（包）文件\n\n包文件包含的信息对你的项目文档是很有用的，比如该项目的名称和版本号。\n\n当JSDoc生成的文档的时候,可以自动使用项目中package.json文件中的信息。\n\n示例，默认的模板在文档中显示项目的名称和版本号。\n\n在源路径中包含一个包文件:\n\n\n```\njsdoc path/to/js path/to/package/package.json\n```\n\n使用 -P/–package 选项：\n\n\n```\njsdoc –package path/to/package/package-docs.json path/to/js\n```\n\n##### 包含 README 文件\n\n有两种方法可以将 README 文件中的信息合并到您的文档：\n\n1. 在你的JavaScript文件的源路径中，包含一个名为README.md的Markdown文件的路径。JSDoc将使用在源路径中发现的第一个 README.md 文件。\n2. 使用-R/--readme 包命令行选项运行JSDoc，指定 README 文件的路径。此选项在JSDoc3.3.0及更高版本中可用。README文件可以使用任何名称和扩展名，但它必须是Markdown格式。\n\n-R/--readme 命令行选项优先于你的源路径。如果使用-R/--readme命令行选项，JSDoc会忽略源路径中任何的README.md文件。\n\n如果您正在使用JSDoc的默认模板，README文件的内容将渲染成HTML，生成在文档 index.html 文件中。\n\n###### 例子\n\n在源路径中包含一个 README 文件:\n\n```\njsdoc path/to/js path/to/readme/README.md \n```\n使用 -R/--readme 选项：\n\n```\njsdoc --readme path/to/readme/README path/to/js \n```\n\n","source":"_posts/2019-08-30-jsdoc-course.md","raw":"---\ntitle: JSDOC入门教程\ncomments: true\ndate: 2019-08-30 11:32:58\ntags:\n- jsdoc\n- html\n- js\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n# JSDOC入门教程\n\n![JSDOC](https://img.fengjr.com/image/2019/08/30/b6abbf9f9aa6709426d7de301a069eca.png)\n\n## jsDoc介绍\n\n> JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、模块的API文档 的工具。你可以使用他记录如：命名空间，类，方法，方法参数等。类似JavaDoc和PHPDoc。现在很多编辑器或IDE中还可以通过JSDoc直接或使用插件生成智能提示。从而使开发者很容易了解整个类和其中的属性和方法，并且快速知道如何使用，从而提高开发效率，降低维护成本。\n\n示例：\n\n```JS\n/**\n * Book类，代表一本书\n * @param title\n * @param anthor\n * @param pageNum\n * @constructor\n */\nfunction Book (title, anthor, pageNum ) {\n\t// 实例属JS性\n\tthis.title = title;\n\tthis.anthor = anthor;\n\tthis.pageNum = pageNum || 0;\n}\nBook.prototype = {\n\t/**\n\t * 获取书本的标题\n\t * @returns {*}\n\t */\n\tgetTitle : function () {\n\t\treturn this.title;\n\t},\n\t/**\n\t * 获取书本的作者\n\t * @returns {*}\n\t */\n\tgetAnthor: function  () {\n\t\treturn this.anthor;\n\t},\n\t/**\n\t * 设置书本的页码\n\t * @param pageNum\n\t */\n\tsetPageNum: function (pageNum) {\n\t\tthis.pageNum = pageNum;\n\t}\n};\n```\n\n## 入门\n\n### 下载jsdoc\n\n```shell\nnpm install jsdoc -g\n```\n\n### JSDoc 3中的名称路径\n\n如果涉及到一个JavaScript变量，这个变量在文档中的其他地方，你必须提供一个唯一标识符映射到该变量。\n名称路径提供了一种这样做的方法，并且消除实例成员，静态成员和内部变量之间的歧义。\n\njsDoc中名称路径的基本语法示例：\n\n\n```JS\n1、myFunction\n2、MyConstructor\n3、MyConstructor#instanceMember（实例成员）\n4、MyConstructor.staticMember（静态成员）\n5、MyConstructor~innerMember（内部成员）\n```\n\n示例：\n\n```JS\n/**\n * Person类，一个人\n * @param name\n * @constructor\n */\nconst  Person = function (name) {\n\tthis.name = name;\n\t/**\n\t * 这是一个实例成员\n\t * @returns {string}\n\t */\n\tthis.say = () => {\n\t\treturn 'I\\'am an instance.';\n\t};\n\t/**\n\t * 这是一个内部成员\n\t * @returns {string}\n\t */\n\tfunction say () {\n\t\treturn 'I\\' am an inner.';\n\t};\n};\n/**\n * 这是一个静态成员\n * @returns {string}\n */\nPerson.say = function () {\n\treturn 'I\\'am an static.';\n};\n/**\n * 实例化一个人\n * @type {Person}\n */\nconst person1 = new Person('fanerge');\n// Person#say 使用实例方法\nperson1.say();\n// Person.say 使用静态方法\nPerson.say();\n// Person~say 使用内部方法，但这里不能访问到\n```\n\n使用名称路径也有一些特殊的情况：\n\n- @module名称由”module:”前缀，\n- @external 名称由”external:”前缀\n- @event名称由”event:”前缀。\n\n### JSDoc中的命令行参数\n\n使用JSDoc最基本的，像这样使用：\n\n```\n/path/to/jsdoc yourSourceCodeFile.js anotherSourceCodeFile.js ...\n```\n\n其中…是生成文档文件的路径。\n\nJSDoc支持大量的命令行选项，其中许多选项有长和短两种形式\n\n选项 描述\n\n```\n-a , –access 只显示特定access方法属性的标识符： private, protected, public, or undefined, 或者 all（表示所有的访问级别）。默认情况下， 显示除private标识符以外的所有标识符。\n-c , –configure JSDoc配置文件的路径。默认为安装JSDoc目录下的conf.json或conf.json.EXAMPLE。\n-d , –destination 输出生成文档的文件夹路径。JSDoc内置的Haruki模板，使用console 将数据转储到控制台。默认为./out。\n–debug 打印日志信息，可以帮助调试JSDoc本身的问题。\n-e , –encoding 当JSDoc阅读源代码时假定使用这个编码，默认为 utf8。\n-h, –help 显示JSDoc的命令行选项的信息，然后退出。\n–match 只有运行测试，其名称中包含value。\n–nocolor 当运行测试时，在控制台输出信息不要使用的颜色。在Windows中，这个选项是默认启用的。\n-p, –private 将标记有[@private 标签][tags-private.md]的标识符也生成到文档中。默认情况下，不包括私有标识符。\n-P, –package 包含项目名称，版本，和其他细节的package.json文件。默认为在源路径中找到的第一个package.json文件。\n–pedantic 将错误视为致命错误，将警告视为错误。默认为false。\n-q , –query 一个查询字符串用来解析和存储到全局变量env.opts.query中。示例：foo=bar&baz=true。\n-r, –recurse 扫描源文件和导览时递归到子目录。\n-R, –readme 用来包含到生成文档的README.md文件。默认为在源路径中找到的第一README.md 文件。\n-t , –template 用于生成输出文档的模板的路径。默认为templates/default，JSDoc内置的默认模板。\n-T, –test 运行JSDoc的测试套件，并把结果打印到控制台。\n-u , –tutorials 导览路径，JSDoc要搜索的目录。如果省略，将不生成导览页。查看导览说明，以了解更多信息。\n-v, –version 显示JSDoc的版本号，然后退出。\n–verbose 日志的详细信息到控制台JSDoc运行。默认为false。\n-X, –explain 以JSON格式转储所有的doclet到控制台，然后退出。\n```\n\n示例：\n\n使用配置文件/path/to/my/conf.json，为./src目录的中文件生成文档，并保存输出到./docs目录中：\n\n```\n/path/to/jsdoc src -r -c /path/to/my/conf.json -d docs\n```\n\n运行所有JSDoc的测试，其名称包含 tag，并记录每个测试信息：\n\n```\n/path/to/jsdoc -T –match tag –verbose\n```\n\n### 用conf.json配置JSDoc\n\n#### Configuration File(配置文件)\n\n要自定义JSDoc的行为，可以使用JSON格式的配置文件格式化JSDoc，使用-c选项，例如： jsdoc -c /path/to/conf.json\n\n默认的jsDoc配置文件conf.json.EXAMPLE\n\n\n```\n{\n\t\"tags\": {\n\t\t\"allowUnknownTags\": true,\n\t\t\"dictionaries\": [\"jsdoc\",\"closure\"]\n\t},\n\t\"source\": {\n\t\t\"includePattern\": \".+\\\\.js(doc)?$\",\n\t\t\"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\"\n\t},\n\t\"plugins\": [],\n\t\"templates\": {\n\t\t\"cleverLinks\": false,\n\t\t\"monospaceLinks\": false\n\t}\n}\n```\n\n这意味着：\n- JSDoc允许您使用无法识别的标签（tags.allowUnknownTags）;\n- 这两个标准JSDoc标签和closure标签被启用（tags.dictionaries）;\n- 只有以.js和.jsdoc结尾的文件将会被处理（source.includePattern）;\n- 任何文件以下划线开始或开始下划线的目录都将被忽略（source.excludePattern）;\n- 无插件加载（plugins）;\n- @link标签呈现在纯文本（templates.cleverLinks，templates.monospaceLinks）\n\n#### Specifying input files(指定输入文件)\n\n**source**选项组，结合给JSDoc命令行的路径，确定哪些文件要用JSDoc生成文档\n\n\n```JS\n\"source\": {\n    \"include\": [ /* array of paths to files to generate documentation for */ ],\n    \"exclude\": [ /* array of paths to exclude */ ],\n    \"includePattern\": \".+\\\\.js(doc)?$\",\n    \"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\"\n} \n```\n\n- source.include：可选的路径数组，JSDoc应该为它们生成文档。JSDoc将会结合命令行上的路径和这些文件名，以形成文件组，并且扫描。如果路径是一个目录，可以使用-r选项来递归。\n- source.exclude：可选的路径数组，JSDoc应该忽略的路径。在JSDoc3.3.0或更高版本，该数组可包括source.include路径中的子目录。\n- source.includePattern：一个可选的字符串，解释为一个正则表达式。如果存在，所有文件必须匹配这个正则表达式，以通过JSDoc进行扫描。默认情况下此选项设置为.+.js(doc)?$，这意味着只有以.js或者.jsdoc结尾的文件将被扫描。\n- source.excludePattern：一个可选的字符串，解释为一个正则表达式。如果存在的话，任何匹配这个正则表达式的文件将被忽略。默认设置是以下划线开头的文件（或以下划线开头的目录下的所有文件）将被忽略。\n\n#### Incorporating command-line options into the configuration file(合并命令行选项到配置文件)\n\n它有可能把许多JSDoc的命令行选项放到配置文件，而不用在命令行中指定它们。要做到这一点，只要在conf.json的opts部分中使用的相关选项的longnames,值是该选项的值。\n\n\n```JS\n\"opts\": {\n    \"template\": \"templates/default\",  // same as -t templates/default\n    \"encoding\": \"utf8\",               // same as -e utf8\n    \"destination\": \"./out/\",          // same as -d ./out/\n    \"recurse\": true,                  // same as -r\n    \"tutorials\": \"path/to/tutorials\", // same as -u path/to/tutorials\n} \n```\n\n这样可以通过source.include和opts，把所有的JSDoc的参数放在配置文件中，以便命令行简化为：\n\n`jsdoc -c /path/to/conf.json`\n\n\n```\n注意：在命令行中所提供的选项 优先级高于在conf.json中提供的选项。\n```\n\n#### Plugins（插件）\n\n要启用插件，只要添加它们的路径（相对于JSDoc文件夹）到plugins数组中就可以了。\n\n示例：\n\n例如，以下将包括 markdown 插件，它转换 markdown格式的文本为HTML，和“summarize”插件，该自动生成的每个的doclet的摘要\n\n\n```JS\n\"plugins\": [\n    \"plugins/markdown\",\n    \"plugins/summarize\"\n] \n```\n\n#### Tags and tag dictionaries(标签和标签字典)\n\n`tags`选项控制哪些JSDoc标签允许被使用和解析。\n\n```JS\n\"tags\": {\n    \"allowUnknownTags\": true,\n    \"dictionaries\": [\"jsdoc\",\"closure\"]\n} \n```\n\n\n`tags.allowUnknownTags`属性影响JSDoc如何处理无法识别的标签。如果将此选项设置为false，JSDoc发现它不能识别（例如,@foo），JSDoc将记录一个警告。默认情况下，此选项设置为true。\n\n`tags.dictionaries`属性控制JSDoc识别哪些标签，以及JSDoc如何解析它识别标签。在JSDoc3.3.0或更高版本中，有两个内置的标签词典：\n\n- jsdoc: 核心JSDoc标签\n- closure: [Closure Compiler 标签](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler)\n\n默认情况下，两个词典都是启用的。此外，在默认情况下，`jsdoc`字典首先被解析;作为一个结果，如果`jsdoc`词典处理一个标签不同于closure词典，`jsdoc`版本的标签优先被采用(即，以jsdoc版本的标签为准)。\n\n如果您在Closure Compiler 项目中使用JSDoc，并且你想要避免使用 Closure Compiler无法识别的标签，更改tags.dictionaries设置为[“closure”]。如果你想允许核心JSDoc标签, 但又想要确保Closure Compiler特定的标记使用Closure Compiler对其进行解释，您也可以更改此设置为[“closure”,”jsdoc”]。\n\n#### 配置JSDoc的默认模板\n\n\n```\nJSDoc的默认模板中提供了几个选项，您可以使用自定义外观和内容来生成文档。\n要使用这些选项，您必须为JSDoc创建一个配置文件，并在配置文件中设置相应的选项。\n\nGenerating pretty-printed source files（生成适合打印的文档）\n    默认情况下，JSDoc的默认模板为你的源文件生成适合打印的文档。在文档中，它还链接到那些适合的打印文件。\n    要禁用适合打印的文件，设置选项templates.default.outputSourceFiles为false。\n    使用该选项也将删除文档中链接到源文件的连接。此选项在JSDoc3.3.0及更高版本上是可用的。\nCopying static files to the output directory(复制静态文件到输出目录)\n    SDoc的默认模板会自动复制一些静态文件，如CSS样式表，到输出目录。\n    在JSDoc3.3.0或更高版本，你可以告诉默认模板复制附加静态文件到输出目录。\n    例如，您可能希望复制一个图像的目录到输出目录，所以你可以在你的文档中显示这些图像。\n    如果您的静态文件目录中包含./myproject/static/img/screen.png文件，您可以通过HTML标签 <img src=\"img/screen.png\">在您的文档中显示该图片\nShowing the current date in the page footer（在页脚显示当前日期）\n    默认情况下，JSDoc的默认模板总是在生成文档的页脚显示当前日期。\n    在JSDoc3.3.0或更高版本，可以通过设置选项templates.default.includeDate为false来忽略当前日期。\nShowing longnames in the navigation column（在导航栏中显示长文件名）\n    默认情况下，JSDoc的默认模板在导航列中显示每个标识符缩写的名字。\n    例如，标识符my.namespace.MyClass将简单地称为显示MyClass。相反,要显示完整的长名称，设置选项templates.default.useLongnameInNav为true。\n    此选项在JSDoc3.4.0及更高版本中可用。\nOverriding the default template's layout file（重写默认模板的布局文件）\n    默认的模板使用名为 layout.tmpl 的文件 指定每个生成文档的页面中的页眉和页脚。\n    特别是，每个生产的文档页面会加载该文件定义了CSS和JavaScript文件。在JSDoc3.3.0或更高版本，可以指定使用自己的layout.tmpl文件，它允许你加载自己的自定义CSS和JavaScript文件，去除或替代，标准的文件。\n    要使用此功能，设置选项templates.default.layoutFile的路径到你的自定义布局文件。\n    路径是相对于config.json文件，当前的工作目录，和JSDoc目录的相对路径，按照这个顺序。\n```\n\n#### 块标签和内联标签\n\n##### 概述\n\nJSDoc支持两种不同类型的标签：\n- 块标签, 这是在一个JSDoc注释的最高级别。\n- 内联标签, 块标签文本中的标签或说明。\n\n块标签通常会提供有关您的代码的详细信息，如一个函数接受的参数。内联标签通常链接到文件的其他部分，类似于HTML中的锚标记（<a>）。\n\n块标签总是以 at 符号（@）开头。除了JSDoc注释中最后一个块标记，每个块标签后面必须跟一个换行符。\n\n内联标签也以 at 符号（@）开。然而，内联标签及其文本必须用花括号（{ and }）括起来。 { 表示行内联标签的开始，而}表示内联标签的结束。如果你的标签文本中包含右花括号（}），则必须用反斜线（ \\ ）进行转义。在内联标签后,你并不需要使用一个换行符。\n\n大多数JSDoc标签是块标签。一般来说，当这个网站上说\"JSDoc 标签\",我们真正的意思是\"块标签\"\n\n##### 示例\n\n在下面的例子中， @param 是一个块标签，而{@link}是一个内联标签。\n\n```JS\n/**\n * Shoe类，一双鞋子\n * @param color\n * @param size\n * @constructor\n */\nconst Shoe = function (color, size){\n\tthis.color = color;\n\tthis.size = size;\n};\n/**\n * Set shoe's color. Use {@link Shoe#setSize} to set the shoe size\n * @param color\n */\nShoe.prototype.setColor = function (color) {\n\tthis.color = color;\n};\n/**\n * 设置鞋子的尺寸\n * @param size\n */\nShoe.prototype.setSize = function (size) {\n\tthis.size = size;\n};\n/**\n * 设置花边的颜色和样式\n * @param color\n * @param type\n */\nShoe.prototype.setLaceType = function (color, type) {\n\t// ...\n};\nvar shoe1 = new Shoe('red', 12);\n```\n\n#### 关于JSDoc插件\n\n##### Creating and Enabling a Plugin（创建并启用插件）\n\n创建并启用新JSDoc插件,需要两个步骤：\n\n1. 创建一个包含你的插件代码的JavaScript模块.\n2. 将该模块添加到JSDoc配置文件的plugins数组中。你可以指定一个绝对或相对路径。如果使用相对路径，JSDoc按照相对于配置文件所在的目录，当前的工作目录和JSDoc安装目录的顺序搜索插件。\n\n例如，如果你的插件是在当前工作目录下，plugins/shout.js文件中定义的，你应该在JSDoc配置文件中的plugins数组中添加字符串plugins/shout。\n\n例如，在JSDoc配置文件中添加一个插件：\n\n```JSON\n{\n    \"plugins\": [\"plugins/shout\"]\n}\n```\n\n##### Authoring JSDoc 3 Plugins（创建JSDoc3插件）\n\nJSDoc 3的插件系统广泛的控制着解析过程。一个插件可以通过执行以下任何一项操作，影响解析结果：\n\n- 定义事件处理程序\n- 定义标签\n- 定义一个抽象语法树节点的访问者\n\n\n```\nEvent Handlers（事件处理程序）\n事件: parseBegin – JSDoc开始加载和解析源文件之前，parseBegin事件被触发。\n事件: fileBegin – 当解析器即将解析一个文件fileBegin事件触发。\n事件: beforeParse – beforeParse事件在解析开始之前被触发。\n事件: jsdocCommentFound – 每当JSDoc注释被发现,jsdocCommentFound事件就会被触发。\n事件: symbolFound – 当解析器在代码中遇到一个可能需要被文档化的标识符时，symbolFound 事件就会被触发。\n事件: newDoclet – newDoclet事件是最高级别的事件。新的doclet已被创建时，它就会被触发。\n事件: fileComplete – 当解析器解析完一个文件时，fileComplete 事件就会被触发。\n事件: parseComplete – JSDoc解析所有指定的源文件之后，parseComplete事件就会被触发。\n事件: processingComplete – JSDoc更新反映继承和借来的标识符的解析结果后，processingComplete事件被触发。\n\nTag Definitions （标签定义）\n添加标签到标签字典是影响文档生成的一个中级方式。在一个newDoclet事件被触发前，JSDoc注释块被解析以确定可能存在的说明和任何JSDoc标签。\n当一个标签被发现，如果它已在标签字典被定义，它就会被赋予一个修改doclet的机会。\n\n```\n\n#### 使用Markdown插件\n\n##### 概述\n\nJSDoc包括markdown插件，自动把Markdown-formatted文本转换成HTML。你可以在任何JSDoc模板中使用这个插件\n\n默认情况下，JSDoc会在以下JSDoc标签中查找markdown格式的文本：\n\n- @author\n- @classdesc\n- @description (包括在JSDoc注释开始地方的未标记的)\n- @param\n- @property\n- @returns\n- @see\n- @throws\n\n##### 启用markdown插件\n\n要启用markdown插件，只要将字符串plugins/markdown添加到JSDoc配置文件的plugins数组中即可。\n\n示例，配置文件启用markdown插件：\n\n```JSON\n{\n    \"plugins\": [\"plugins/markdown\"]\n} \n```\n\n##### 在额外的JSDoc标签中转换Markdown\n\n默认情况下，markdown插件只处理特定JSDoc标签的markdown文本。您可以通过添加一个 markdown.tags属性到你的JSDoc配置文件中，来处理的其他标签中的markdown文本。\n\n```JSON\n{\n    \"plugins\": [\"plugins/markdown\"],\n    \"markdown\": {\n        \"tags\": [\"foo\", \"bar\"]\n    }\n} \n```\n\n\n##### 剔除markdown默认处理的标签\n\n为了防止Markdown插件处理任何默认JSDoc标签，添加一个markdown.excludeTags属性到您的JSDoc配置文件。\n\n\n```JSON\n\n{\n    \"plugins\": [\"plugins/markdown\"],\n    \"markdown\": {\n        \"excludeTags\": [\"author\"]\n    }\n} \n```\n##### 用换行符换行文本\n\n默认情况下，Markdown插件不处理换行符换行的文本。这是因为，这是正常的JSDoc注释可以多行。如果您更喜欢处理换行符换行的文本，设置JSDoc配置文件中的markdown.hardwrap属性为true。此属性是在JSDoc3.4.0及更高版本中可用。\n\n##### 添加ID属性到标题标签\n\n默认情况下，Markdown插件不会给每个HTML标题标签添加id 属性。想要标题标签文本自动添加ID属性，设置JSDoc配置文件markdown.idInHeadings属性为true。此属性是在JSDoc3.4.0及更高版本中可用\n\n#### 包含Package（包）文件\n\n包文件包含的信息对你的项目文档是很有用的，比如该项目的名称和版本号。\n\n当JSDoc生成的文档的时候,可以自动使用项目中package.json文件中的信息。\n\n示例，默认的模板在文档中显示项目的名称和版本号。\n\n在源路径中包含一个包文件:\n\n\n```\njsdoc path/to/js path/to/package/package.json\n```\n\n使用 -P/–package 选项：\n\n\n```\njsdoc –package path/to/package/package-docs.json path/to/js\n```\n\n##### 包含 README 文件\n\n有两种方法可以将 README 文件中的信息合并到您的文档：\n\n1. 在你的JavaScript文件的源路径中，包含一个名为README.md的Markdown文件的路径。JSDoc将使用在源路径中发现的第一个 README.md 文件。\n2. 使用-R/--readme 包命令行选项运行JSDoc，指定 README 文件的路径。此选项在JSDoc3.3.0及更高版本中可用。README文件可以使用任何名称和扩展名，但它必须是Markdown格式。\n\n-R/--readme 命令行选项优先于你的源路径。如果使用-R/--readme命令行选项，JSDoc会忽略源路径中任何的README.md文件。\n\n如果您正在使用JSDoc的默认模板，README文件的内容将渲染成HTML，生成在文档 index.html 文件中。\n\n###### 例子\n\n在源路径中包含一个 README 文件:\n\n```\njsdoc path/to/js path/to/readme/README.md \n```\n使用 -R/--readme 选项：\n\n```\njsdoc --readme path/to/readme/README path/to/js \n```\n\n","slug":"jsdoc-course","published":1,"updated":"2020-06-10T06:01:50.380Z","_id":"ck2yl0qc6000jh6q6ehkwz4vt","layout":"post","photos":[],"link":"","content":"<h1 id=\"JSDOC入门教程\"><a href=\"#JSDOC入门教程\" class=\"headerlink\" title=\"JSDOC入门教程\"></a>JSDOC入门教程</h1><p><img src=\"https://img.fengjr.com/image/2019/08/30/b6abbf9f9aa6709426d7de301a069eca.png\" alt=\"JSDOC\"></p>\n<h2 id=\"jsDoc介绍\"><a href=\"#jsDoc介绍\" class=\"headerlink\" title=\"jsDoc介绍\"></a>jsDoc介绍</h2><blockquote>\n<p>JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、模块的API文档 的工具。你可以使用他记录如：命名空间，类，方法，方法参数等。类似JavaDoc和PHPDoc。现在很多编辑器或IDE中还可以通过JSDoc直接或使用插件生成智能提示。从而使开发者很容易了解整个类和其中的属性和方法，并且快速知道如何使用，从而提高开发效率，降低维护成本。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Book类，代表一本书</span></span><br><span class=\"line\"><span class=\"comment\"> * @param title</span></span><br><span class=\"line\"><span class=\"comment\"> * @param anthor</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pageNum</span></span><br><span class=\"line\"><span class=\"comment\"> * @constructor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Book</span> (<span class=\"params\">title, anthor, pageNum </span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例属JS性</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.anthor = anthor;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.pageNum = pageNum || <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Book.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 获取书本的标题</span></span><br><span class=\"line\"><span class=\"comment\">\t * @returns &#123;*&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tgetTitle : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.title;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 获取书本的作者</span></span><br><span class=\"line\"><span class=\"comment\">\t * @returns &#123;*&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tgetAnthor: <span class=\"function\"><span class=\"keyword\">function</span>  (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.anthor;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 设置书本的页码</span></span><br><span class=\"line\"><span class=\"comment\">\t * @param pageNum</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tsetPageNum: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">pageNum</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.pageNum = pageNum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><h3 id=\"下载jsdoc\"><a href=\"#下载jsdoc\" class=\"headerlink\" title=\"下载jsdoc\"></a>下载jsdoc</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install jsdoc -g</span><br></pre></td></tr></table></figure>\n<h3 id=\"JSDoc-3中的名称路径\"><a href=\"#JSDoc-3中的名称路径\" class=\"headerlink\" title=\"JSDoc 3中的名称路径\"></a>JSDoc 3中的名称路径</h3><p>如果涉及到一个JavaScript变量，这个变量在文档中的其他地方，你必须提供一个唯一标识符映射到该变量。<br>名称路径提供了一种这样做的方法，并且消除实例成员，静态成员和内部变量之间的歧义。</p>\n<p>jsDoc中名称路径的基本语法示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、myFunction</span><br><span class=\"line\"><span class=\"number\">2</span>、MyConstructor</span><br><span class=\"line\">3、MyConstructor#instanceMember（实例成员）</span><br><span class=\"line\"><span class=\"number\">4</span>、MyConstructor.staticMember（静态成员）</span><br><span class=\"line\"><span class=\"number\">5</span>、MyConstructor~innerMember（内部成员）</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Person类，一个人</span></span><br><span class=\"line\"><span class=\"comment\"> * @param name</span></span><br><span class=\"line\"><span class=\"comment\"> * @constructor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span>  Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 这是一个实例成员</span></span><br><span class=\"line\"><span class=\"comment\">\t * @returns &#123;string&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">'I\\'am an instance.'</span>;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 这是一个内部成员</span></span><br><span class=\"line\"><span class=\"comment\">\t * @returns &#123;string&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">'I\\' am an inner.'</span>;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是一个静态成员</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;string&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Person.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">'I\\'am an static.'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实例化一个人</span></span><br><span class=\"line\"><span class=\"comment\"> * @type &#123;Person&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'fanerge'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Person#say 使用实例方法</span></span><br><span class=\"line\">person1.say();</span><br><span class=\"line\"><span class=\"comment\">// Person.say 使用静态方法</span></span><br><span class=\"line\">Person.say();</span><br><span class=\"line\"><span class=\"comment\">// Person~say 使用内部方法，但这里不能访问到</span></span><br></pre></td></tr></table></figure>\n<p>使用名称路径也有一些特殊的情况：</p>\n<ul>\n<li>@module名称由”module:”前缀，</li>\n<li>@external 名称由”external:”前缀</li>\n<li>@event名称由”event:”前缀。</li>\n</ul>\n<h3 id=\"JSDoc中的命令行参数\"><a href=\"#JSDoc中的命令行参数\" class=\"headerlink\" title=\"JSDoc中的命令行参数\"></a>JSDoc中的命令行参数</h3><p>使用JSDoc最基本的，像这样使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/path/to/jsdoc yourSourceCodeFile.js anotherSourceCodeFile.js ...</span><br></pre></td></tr></table></figure>\n<p>其中…是生成文档文件的路径。</p>\n<p>JSDoc支持大量的命令行选项，其中许多选项有长和短两种形式</p>\n<p>选项 描述</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a , –access 只显示特定access方法属性的标识符： private, protected, public, or undefined, 或者 all（表示所有的访问级别）。默认情况下， 显示除private标识符以外的所有标识符。</span><br><span class=\"line\">-c , –configure JSDoc配置文件的路径。默认为安装JSDoc目录下的conf.json或conf.json.EXAMPLE。</span><br><span class=\"line\">-d , –destination 输出生成文档的文件夹路径。JSDoc内置的Haruki模板，使用console 将数据转储到控制台。默认为./out。</span><br><span class=\"line\">–debug 打印日志信息，可以帮助调试JSDoc本身的问题。</span><br><span class=\"line\">-e , –encoding 当JSDoc阅读源代码时假定使用这个编码，默认为 utf8。</span><br><span class=\"line\">-h, –help 显示JSDoc的命令行选项的信息，然后退出。</span><br><span class=\"line\">–match 只有运行测试，其名称中包含value。</span><br><span class=\"line\">–nocolor 当运行测试时，在控制台输出信息不要使用的颜色。在Windows中，这个选项是默认启用的。</span><br><span class=\"line\">-p, –private 将标记有[@private 标签][tags-private.md]的标识符也生成到文档中。默认情况下，不包括私有标识符。</span><br><span class=\"line\">-P, –package 包含项目名称，版本，和其他细节的package.json文件。默认为在源路径中找到的第一个package.json文件。</span><br><span class=\"line\">–pedantic 将错误视为致命错误，将警告视为错误。默认为false。</span><br><span class=\"line\">-q , –query 一个查询字符串用来解析和存储到全局变量env.opts.query中。示例：foo=bar&amp;baz=true。</span><br><span class=\"line\">-r, –recurse 扫描源文件和导览时递归到子目录。</span><br><span class=\"line\">-R, –readme 用来包含到生成文档的README.md文件。默认为在源路径中找到的第一README.md 文件。</span><br><span class=\"line\">-t , –template 用于生成输出文档的模板的路径。默认为templates/default，JSDoc内置的默认模板。</span><br><span class=\"line\">-T, –test 运行JSDoc的测试套件，并把结果打印到控制台。</span><br><span class=\"line\">-u , –tutorials 导览路径，JSDoc要搜索的目录。如果省略，将不生成导览页。查看导览说明，以了解更多信息。</span><br><span class=\"line\">-v, –version 显示JSDoc的版本号，然后退出。</span><br><span class=\"line\">–verbose 日志的详细信息到控制台JSDoc运行。默认为false。</span><br><span class=\"line\">-X, –explain 以JSON格式转储所有的doclet到控制台，然后退出。</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<p>使用配置文件/path/to/my/conf.json，为./src目录的中文件生成文档，并保存输出到./docs目录中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/path/to/jsdoc src -r -c /path/to/my/conf.json -d docs</span><br></pre></td></tr></table></figure>\n<p>运行所有JSDoc的测试，其名称包含 tag，并记录每个测试信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/path/to/jsdoc -T –match tag –verbose</span><br></pre></td></tr></table></figure>\n<h3 id=\"用conf-json配置JSDoc\"><a href=\"#用conf-json配置JSDoc\" class=\"headerlink\" title=\"用conf.json配置JSDoc\"></a>用conf.json配置JSDoc</h3><h4 id=\"Configuration-File-配置文件\"><a href=\"#Configuration-File-配置文件\" class=\"headerlink\" title=\"Configuration File(配置文件)\"></a>Configuration File(配置文件)</h4><p>要自定义JSDoc的行为，可以使用JSON格式的配置文件格式化JSDoc，使用-c选项，例如： jsdoc -c /path/to/conf.json</p>\n<p>默认的jsDoc配置文件conf.json.EXAMPLE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;tags&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;allowUnknownTags&quot;: true,</span><br><span class=\"line\">\t\t&quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;]</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&quot;source&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;includePattern&quot;: &quot;.+\\\\.js(doc)?$&quot;,</span><br><span class=\"line\">\t\t&quot;excludePattern&quot;: &quot;(^|\\\\/|\\\\\\\\)_&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&quot;plugins&quot;: [],</span><br><span class=\"line\">\t&quot;templates&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;cleverLinks&quot;: false,</span><br><span class=\"line\">\t\t&quot;monospaceLinks&quot;: false</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这意味着：</p>\n<ul>\n<li>JSDoc允许您使用无法识别的标签（tags.allowUnknownTags）;</li>\n<li>这两个标准JSDoc标签和closure标签被启用（tags.dictionaries）;</li>\n<li>只有以.js和.jsdoc结尾的文件将会被处理（source.includePattern）;</li>\n<li>任何文件以下划线开始或开始下划线的目录都将被忽略（source.excludePattern）;</li>\n<li>无插件加载（plugins）;</li>\n<li>@link标签呈现在纯文本（templates.cleverLinks，templates.monospaceLinks）</li>\n</ul>\n<h4 id=\"Specifying-input-files-指定输入文件\"><a href=\"#Specifying-input-files-指定输入文件\" class=\"headerlink\" title=\"Specifying input files(指定输入文件)\"></a>Specifying input files(指定输入文件)</h4><p><strong>source</strong>选项组，结合给JSDoc命令行的路径，确定哪些文件要用JSDoc生成文档</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"source\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"include\"</span>: [ <span class=\"comment\">/* array of paths to files to generate documentation for */</span> ],</span><br><span class=\"line\">    <span class=\"string\">\"exclude\"</span>: [ <span class=\"comment\">/* array of paths to exclude */</span> ],</span><br><span class=\"line\">    <span class=\"string\">\"includePattern\"</span>: <span class=\"string\">\".+\\\\.js(doc)?$\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"excludePattern\"</span>: <span class=\"string\">\"(^|\\\\/|\\\\\\\\)_\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>source.include：可选的路径数组，JSDoc应该为它们生成文档。JSDoc将会结合命令行上的路径和这些文件名，以形成文件组，并且扫描。如果路径是一个目录，可以使用-r选项来递归。</li>\n<li>source.exclude：可选的路径数组，JSDoc应该忽略的路径。在JSDoc3.3.0或更高版本，该数组可包括source.include路径中的子目录。</li>\n<li>source.includePattern：一个可选的字符串，解释为一个正则表达式。如果存在，所有文件必须匹配这个正则表达式，以通过JSDoc进行扫描。默认情况下此选项设置为.+.js(doc)?$，这意味着只有以.js或者.jsdoc结尾的文件将被扫描。</li>\n<li>source.excludePattern：一个可选的字符串，解释为一个正则表达式。如果存在的话，任何匹配这个正则表达式的文件将被忽略。默认设置是以下划线开头的文件（或以下划线开头的目录下的所有文件）将被忽略。</li>\n</ul>\n<h4 id=\"Incorporating-command-line-options-into-the-configuration-file-合并命令行选项到配置文件\"><a href=\"#Incorporating-command-line-options-into-the-configuration-file-合并命令行选项到配置文件\" class=\"headerlink\" title=\"Incorporating command-line options into the configuration file(合并命令行选项到配置文件)\"></a>Incorporating command-line options into the configuration file(合并命令行选项到配置文件)</h4><p>它有可能把许多JSDoc的命令行选项放到配置文件，而不用在命令行中指定它们。要做到这一点，只要在conf.json的opts部分中使用的相关选项的longnames,值是该选项的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"opts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"template\"</span>: <span class=\"string\">\"templates/default\"</span>,  <span class=\"comment\">// same as -t templates/default</span></span><br><span class=\"line\">    <span class=\"string\">\"encoding\"</span>: <span class=\"string\">\"utf8\"</span>,               <span class=\"comment\">// same as -e utf8</span></span><br><span class=\"line\">    <span class=\"string\">\"destination\"</span>: <span class=\"string\">\"./out/\"</span>,          <span class=\"comment\">// same as -d ./out/</span></span><br><span class=\"line\">    <span class=\"string\">\"recurse\"</span>: <span class=\"literal\">true</span>,                  <span class=\"comment\">// same as -r</span></span><br><span class=\"line\">    <span class=\"string\">\"tutorials\"</span>: <span class=\"string\">\"path/to/tutorials\"</span>, <span class=\"comment\">// same as -u path/to/tutorials</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样可以通过source.include和opts，把所有的JSDoc的参数放在配置文件中，以便命令行简化为：</p>\n<p><code>jsdoc -c /path/to/conf.json</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意：在命令行中所提供的选项 优先级高于在conf.json中提供的选项。</span><br></pre></td></tr></table></figure>\n<h4 id=\"Plugins（插件）\"><a href=\"#Plugins（插件）\" class=\"headerlink\" title=\"Plugins（插件）\"></a>Plugins（插件）</h4><p>要启用插件，只要添加它们的路径（相对于JSDoc文件夹）到plugins数组中就可以了。</p>\n<p>示例：</p>\n<p>例如，以下将包括 markdown 插件，它转换 markdown格式的文本为HTML，和“summarize”插件，该自动生成的每个的doclet的摘要</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"plugins/markdown\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"plugins/summarize\"</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h4 id=\"Tags-and-tag-dictionaries-标签和标签字典\"><a href=\"#Tags-and-tag-dictionaries-标签和标签字典\" class=\"headerlink\" title=\"Tags and tag dictionaries(标签和标签字典)\"></a>Tags and tag dictionaries(标签和标签字典)</h4><p><code>tags</code>选项控制哪些JSDoc标签允许被使用和解析。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"tags\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"allowUnknownTags\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dictionaries\"</span>: [<span class=\"string\">\"jsdoc\"</span>,<span class=\"string\">\"closure\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>tags.allowUnknownTags</code>属性影响JSDoc如何处理无法识别的标签。如果将此选项设置为false，JSDoc发现它不能识别（例如,@foo），JSDoc将记录一个警告。默认情况下，此选项设置为true。</p>\n<p><code>tags.dictionaries</code>属性控制JSDoc识别哪些标签，以及JSDoc如何解析它识别标签。在JSDoc3.3.0或更高版本中，有两个内置的标签词典：</p>\n<ul>\n<li>jsdoc: 核心JSDoc标签</li>\n<li>closure: <a href=\"https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler\" target=\"_blank\" rel=\"noopener\">Closure Compiler 标签</a></li>\n</ul>\n<p>默认情况下，两个词典都是启用的。此外，在默认情况下，<code>jsdoc</code>字典首先被解析;作为一个结果，如果<code>jsdoc</code>词典处理一个标签不同于closure词典，<code>jsdoc</code>版本的标签优先被采用(即，以jsdoc版本的标签为准)。</p>\n<p>如果您在Closure Compiler 项目中使用JSDoc，并且你想要避免使用 Closure Compiler无法识别的标签，更改tags.dictionaries设置为[“closure”]。如果你想允许核心JSDoc标签, 但又想要确保Closure Compiler特定的标记使用Closure Compiler对其进行解释，您也可以更改此设置为[“closure”,”jsdoc”]。</p>\n<h4 id=\"配置JSDoc的默认模板\"><a href=\"#配置JSDoc的默认模板\" class=\"headerlink\" title=\"配置JSDoc的默认模板\"></a>配置JSDoc的默认模板</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSDoc的默认模板中提供了几个选项，您可以使用自定义外观和内容来生成文档。</span><br><span class=\"line\">要使用这些选项，您必须为JSDoc创建一个配置文件，并在配置文件中设置相应的选项。</span><br><span class=\"line\"></span><br><span class=\"line\">Generating pretty-printed source files（生成适合打印的文档）</span><br><span class=\"line\">    默认情况下，JSDoc的默认模板为你的源文件生成适合打印的文档。在文档中，它还链接到那些适合的打印文件。</span><br><span class=\"line\">    要禁用适合打印的文件，设置选项templates.default.outputSourceFiles为false。</span><br><span class=\"line\">    使用该选项也将删除文档中链接到源文件的连接。此选项在JSDoc3.3.0及更高版本上是可用的。</span><br><span class=\"line\">Copying static files to the output directory(复制静态文件到输出目录)</span><br><span class=\"line\">    SDoc的默认模板会自动复制一些静态文件，如CSS样式表，到输出目录。</span><br><span class=\"line\">    在JSDoc3.3.0或更高版本，你可以告诉默认模板复制附加静态文件到输出目录。</span><br><span class=\"line\">    例如，您可能希望复制一个图像的目录到输出目录，所以你可以在你的文档中显示这些图像。</span><br><span class=\"line\">    如果您的静态文件目录中包含./myproject/static/img/screen.png文件，您可以通过HTML标签 &lt;img src=&quot;img/screen.png&quot;&gt;在您的文档中显示该图片</span><br><span class=\"line\">Showing the current date in the page footer（在页脚显示当前日期）</span><br><span class=\"line\">    默认情况下，JSDoc的默认模板总是在生成文档的页脚显示当前日期。</span><br><span class=\"line\">    在JSDoc3.3.0或更高版本，可以通过设置选项templates.default.includeDate为false来忽略当前日期。</span><br><span class=\"line\">Showing longnames in the navigation column（在导航栏中显示长文件名）</span><br><span class=\"line\">    默认情况下，JSDoc的默认模板在导航列中显示每个标识符缩写的名字。</span><br><span class=\"line\">    例如，标识符my.namespace.MyClass将简单地称为显示MyClass。相反,要显示完整的长名称，设置选项templates.default.useLongnameInNav为true。</span><br><span class=\"line\">    此选项在JSDoc3.4.0及更高版本中可用。</span><br><span class=\"line\">Overriding the default template&apos;s layout file（重写默认模板的布局文件）</span><br><span class=\"line\">    默认的模板使用名为 layout.tmpl 的文件 指定每个生成文档的页面中的页眉和页脚。</span><br><span class=\"line\">    特别是，每个生产的文档页面会加载该文件定义了CSS和JavaScript文件。在JSDoc3.3.0或更高版本，可以指定使用自己的layout.tmpl文件，它允许你加载自己的自定义CSS和JavaScript文件，去除或替代，标准的文件。</span><br><span class=\"line\">    要使用此功能，设置选项templates.default.layoutFile的路径到你的自定义布局文件。</span><br><span class=\"line\">    路径是相对于config.json文件，当前的工作目录，和JSDoc目录的相对路径，按照这个顺序。</span><br></pre></td></tr></table></figure>\n<h4 id=\"块标签和内联标签\"><a href=\"#块标签和内联标签\" class=\"headerlink\" title=\"块标签和内联标签\"></a>块标签和内联标签</h4><h5 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h5><p>JSDoc支持两种不同类型的标签：</p>\n<ul>\n<li>块标签, 这是在一个JSDoc注释的最高级别。</li>\n<li>内联标签, 块标签文本中的标签或说明。</li>\n</ul>\n<p>块标签通常会提供有关您的代码的详细信息，如一个函数接受的参数。内联标签通常链接到文件的其他部分，类似于HTML中的锚标记（<a>）。</a></p>\n<p>块标签总是以 at 符号（@）开头。除了JSDoc注释中最后一个块标记，每个块标签后面必须跟一个换行符。</p>\n<p>内联标签也以 at 符号（@）开。然而，内联标签及其文本必须用花括号（{ and }）括起来。 { 表示行内联标签的开始，而}表示内联标签的结束。如果你的标签文本中包含右花括号（}），则必须用反斜线（ \\ ）进行转义。在内联标签后,你并不需要使用一个换行符。</p>\n<p>大多数JSDoc标签是块标签。一般来说，当这个网站上说”JSDoc 标签”,我们真正的意思是”块标签”</p>\n<h5 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h5><p>在下面的例子中， @param 是一个块标签，而{@link}是一个内联标签。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Shoe类，一双鞋子</span></span><br><span class=\"line\"><span class=\"comment\"> * @param color</span></span><br><span class=\"line\"><span class=\"comment\"> * @param size</span></span><br><span class=\"line\"><span class=\"comment\"> * @constructor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Shoe = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">color, size</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Set shoe's color. Use &#123;@link Shoe#setSize&#125; to set the shoe size</span></span><br><span class=\"line\"><span class=\"comment\"> * @param color</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Shoe.prototype.setColor = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置鞋子的尺寸</span></span><br><span class=\"line\"><span class=\"comment\"> * @param size</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Shoe.prototype.setSize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">size</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置花边的颜色和样式</span></span><br><span class=\"line\"><span class=\"comment\"> * @param color</span></span><br><span class=\"line\"><span class=\"comment\"> * @param type</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Shoe.prototype.setLaceType = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">color, type</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> shoe1 = <span class=\"keyword\">new</span> Shoe(<span class=\"string\">'red'</span>, <span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"关于JSDoc插件\"><a href=\"#关于JSDoc插件\" class=\"headerlink\" title=\"关于JSDoc插件\"></a>关于JSDoc插件</h4><h5 id=\"Creating-and-Enabling-a-Plugin（创建并启用插件）\"><a href=\"#Creating-and-Enabling-a-Plugin（创建并启用插件）\" class=\"headerlink\" title=\"Creating and Enabling a Plugin（创建并启用插件）\"></a>Creating and Enabling a Plugin（创建并启用插件）</h5><p>创建并启用新JSDoc插件,需要两个步骤：</p>\n<ol>\n<li>创建一个包含你的插件代码的JavaScript模块.</li>\n<li>将该模块添加到JSDoc配置文件的plugins数组中。你可以指定一个绝对或相对路径。如果使用相对路径，JSDoc按照相对于配置文件所在的目录，当前的工作目录和JSDoc安装目录的顺序搜索插件。</li>\n</ol>\n<p>例如，如果你的插件是在当前工作目录下，plugins/shout.js文件中定义的，你应该在JSDoc配置文件中的plugins数组中添加字符串plugins/shout。</p>\n<p>例如，在JSDoc配置文件中添加一个插件：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"plugins/shout\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Authoring-JSDoc-3-Plugins（创建JSDoc3插件）\"><a href=\"#Authoring-JSDoc-3-Plugins（创建JSDoc3插件）\" class=\"headerlink\" title=\"Authoring JSDoc 3 Plugins（创建JSDoc3插件）\"></a>Authoring JSDoc 3 Plugins（创建JSDoc3插件）</h5><p>JSDoc 3的插件系统广泛的控制着解析过程。一个插件可以通过执行以下任何一项操作，影响解析结果：</p>\n<ul>\n<li>定义事件处理程序</li>\n<li>定义标签</li>\n<li>定义一个抽象语法树节点的访问者</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Event Handlers（事件处理程序）</span><br><span class=\"line\">事件: parseBegin – JSDoc开始加载和解析源文件之前，parseBegin事件被触发。</span><br><span class=\"line\">事件: fileBegin – 当解析器即将解析一个文件fileBegin事件触发。</span><br><span class=\"line\">事件: beforeParse – beforeParse事件在解析开始之前被触发。</span><br><span class=\"line\">事件: jsdocCommentFound – 每当JSDoc注释被发现,jsdocCommentFound事件就会被触发。</span><br><span class=\"line\">事件: symbolFound – 当解析器在代码中遇到一个可能需要被文档化的标识符时，symbolFound 事件就会被触发。</span><br><span class=\"line\">事件: newDoclet – newDoclet事件是最高级别的事件。新的doclet已被创建时，它就会被触发。</span><br><span class=\"line\">事件: fileComplete – 当解析器解析完一个文件时，fileComplete 事件就会被触发。</span><br><span class=\"line\">事件: parseComplete – JSDoc解析所有指定的源文件之后，parseComplete事件就会被触发。</span><br><span class=\"line\">事件: processingComplete – JSDoc更新反映继承和借来的标识符的解析结果后，processingComplete事件被触发。</span><br><span class=\"line\"></span><br><span class=\"line\">Tag Definitions （标签定义）</span><br><span class=\"line\">添加标签到标签字典是影响文档生成的一个中级方式。在一个newDoclet事件被触发前，JSDoc注释块被解析以确定可能存在的说明和任何JSDoc标签。</span><br><span class=\"line\">当一个标签被发现，如果它已在标签字典被定义，它就会被赋予一个修改doclet的机会。</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用Markdown插件\"><a href=\"#使用Markdown插件\" class=\"headerlink\" title=\"使用Markdown插件\"></a>使用Markdown插件</h4><h5 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h5><p>JSDoc包括markdown插件，自动把Markdown-formatted文本转换成HTML。你可以在任何JSDoc模板中使用这个插件</p>\n<p>默认情况下，JSDoc会在以下JSDoc标签中查找markdown格式的文本：</p>\n<ul>\n<li>@author</li>\n<li>@classdesc</li>\n<li>@description (包括在JSDoc注释开始地方的未标记的)</li>\n<li>@param</li>\n<li>@property</li>\n<li>@returns</li>\n<li>@see</li>\n<li>@throws</li>\n</ul>\n<h5 id=\"启用markdown插件\"><a href=\"#启用markdown插件\" class=\"headerlink\" title=\"启用markdown插件\"></a>启用markdown插件</h5><p>要启用markdown插件，只要将字符串plugins/markdown添加到JSDoc配置文件的plugins数组中即可。</p>\n<p>示例，配置文件启用markdown插件：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"plugins/markdown\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"在额外的JSDoc标签中转换Markdown\"><a href=\"#在额外的JSDoc标签中转换Markdown\" class=\"headerlink\" title=\"在额外的JSDoc标签中转换Markdown\"></a>在额外的JSDoc标签中转换Markdown</h5><p>默认情况下，markdown插件只处理特定JSDoc标签的markdown文本。您可以通过添加一个 markdown.tags属性到你的JSDoc配置文件中，来处理的其他标签中的markdown文本。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"plugins/markdown\"</span>],</span><br><span class=\"line\">    <span class=\"attr\">\"markdown\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"tags\"</span>: [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"剔除markdown默认处理的标签\"><a href=\"#剔除markdown默认处理的标签\" class=\"headerlink\" title=\"剔除markdown默认处理的标签\"></a>剔除markdown默认处理的标签</h5><p>为了防止Markdown插件处理任何默认JSDoc标签，添加一个markdown.excludeTags属性到您的JSDoc配置文件。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"plugins/markdown\"</span>],</span><br><span class=\"line\">    <span class=\"attr\">\"markdown\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"excludeTags\"</span>: [<span class=\"string\">\"author\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"用换行符换行文本\"><a href=\"#用换行符换行文本\" class=\"headerlink\" title=\"用换行符换行文本\"></a>用换行符换行文本</h5><p>默认情况下，Markdown插件不处理换行符换行的文本。这是因为，这是正常的JSDoc注释可以多行。如果您更喜欢处理换行符换行的文本，设置JSDoc配置文件中的markdown.hardwrap属性为true。此属性是在JSDoc3.4.0及更高版本中可用。</p>\n<h5 id=\"添加ID属性到标题标签\"><a href=\"#添加ID属性到标题标签\" class=\"headerlink\" title=\"添加ID属性到标题标签\"></a>添加ID属性到标题标签</h5><p>默认情况下，Markdown插件不会给每个HTML标题标签添加id 属性。想要标题标签文本自动添加ID属性，设置JSDoc配置文件markdown.idInHeadings属性为true。此属性是在JSDoc3.4.0及更高版本中可用</p>\n<h4 id=\"包含Package（包）文件\"><a href=\"#包含Package（包）文件\" class=\"headerlink\" title=\"包含Package（包）文件\"></a>包含Package（包）文件</h4><p>包文件包含的信息对你的项目文档是很有用的，比如该项目的名称和版本号。</p>\n<p>当JSDoc生成的文档的时候,可以自动使用项目中package.json文件中的信息。</p>\n<p>示例，默认的模板在文档中显示项目的名称和版本号。</p>\n<p>在源路径中包含一个包文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc path/to/js path/to/package/package.json</span><br></pre></td></tr></table></figure>\n<p>使用 -P/–package 选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc –package path/to/package/package-docs.json path/to/js</span><br></pre></td></tr></table></figure>\n<h5 id=\"包含-README-文件\"><a href=\"#包含-README-文件\" class=\"headerlink\" title=\"包含 README 文件\"></a>包含 README 文件</h5><p>有两种方法可以将 README 文件中的信息合并到您的文档：</p>\n<ol>\n<li>在你的JavaScript文件的源路径中，包含一个名为README.md的Markdown文件的路径。JSDoc将使用在源路径中发现的第一个 README.md 文件。</li>\n<li>使用-R/–readme 包命令行选项运行JSDoc，指定 README 文件的路径。此选项在JSDoc3.3.0及更高版本中可用。README文件可以使用任何名称和扩展名，但它必须是Markdown格式。</li>\n</ol>\n<p>-R/–readme 命令行选项优先于你的源路径。如果使用-R/–readme命令行选项，JSDoc会忽略源路径中任何的README.md文件。</p>\n<p>如果您正在使用JSDoc的默认模板，README文件的内容将渲染成HTML，生成在文档 index.html 文件中。</p>\n<h6 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h6><p>在源路径中包含一个 README 文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc path/to/js path/to/readme/README.md</span><br></pre></td></tr></table></figure>\n<p>使用 -R/–readme 选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc --readme path/to/readme/README path/to/js</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JSDOC入门教程\"><a href=\"#JSDOC入门教程\" class=\"headerlink\" title=\"JSDOC入门教程\"></a>JSDOC入门教程</h1><p><img src=\"https://img.fengjr.com/image/2019/08/30/b6abbf9f9aa6709426d7de301a069eca.png\" alt=\"JSDOC\"></p>\n<h2 id=\"jsDoc介绍\"><a href=\"#jsDoc介绍\" class=\"headerlink\" title=\"jsDoc介绍\"></a>jsDoc介绍</h2><blockquote>\n<p>JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、模块的API文档 的工具。你可以使用他记录如：命名空间，类，方法，方法参数等。类似JavaDoc和PHPDoc。现在很多编辑器或IDE中还可以通过JSDoc直接或使用插件生成智能提示。从而使开发者很容易了解整个类和其中的属性和方法，并且快速知道如何使用，从而提高开发效率，降低维护成本。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Book类，代表一本书</span></span><br><span class=\"line\"><span class=\"comment\"> * @param title</span></span><br><span class=\"line\"><span class=\"comment\"> * @param anthor</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pageNum</span></span><br><span class=\"line\"><span class=\"comment\"> * @constructor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Book</span> (<span class=\"params\">title, anthor, pageNum </span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例属JS性</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.anthor = anthor;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.pageNum = pageNum || <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Book.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 获取书本的标题</span></span><br><span class=\"line\"><span class=\"comment\">\t * @returns &#123;*&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tgetTitle : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.title;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 获取书本的作者</span></span><br><span class=\"line\"><span class=\"comment\">\t * @returns &#123;*&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tgetAnthor: <span class=\"function\"><span class=\"keyword\">function</span>  (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.anthor;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 设置书本的页码</span></span><br><span class=\"line\"><span class=\"comment\">\t * @param pageNum</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tsetPageNum: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">pageNum</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.pageNum = pageNum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><h3 id=\"下载jsdoc\"><a href=\"#下载jsdoc\" class=\"headerlink\" title=\"下载jsdoc\"></a>下载jsdoc</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install jsdoc -g</span><br></pre></td></tr></table></figure>\n<h3 id=\"JSDoc-3中的名称路径\"><a href=\"#JSDoc-3中的名称路径\" class=\"headerlink\" title=\"JSDoc 3中的名称路径\"></a>JSDoc 3中的名称路径</h3><p>如果涉及到一个JavaScript变量，这个变量在文档中的其他地方，你必须提供一个唯一标识符映射到该变量。<br>名称路径提供了一种这样做的方法，并且消除实例成员，静态成员和内部变量之间的歧义。</p>\n<p>jsDoc中名称路径的基本语法示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、myFunction</span><br><span class=\"line\"><span class=\"number\">2</span>、MyConstructor</span><br><span class=\"line\">3、MyConstructor#instanceMember（实例成员）</span><br><span class=\"line\"><span class=\"number\">4</span>、MyConstructor.staticMember（静态成员）</span><br><span class=\"line\"><span class=\"number\">5</span>、MyConstructor~innerMember（内部成员）</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Person类，一个人</span></span><br><span class=\"line\"><span class=\"comment\"> * @param name</span></span><br><span class=\"line\"><span class=\"comment\"> * @constructor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span>  Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 这是一个实例成员</span></span><br><span class=\"line\"><span class=\"comment\">\t * @returns &#123;string&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">'I\\'am an instance.'</span>;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 这是一个内部成员</span></span><br><span class=\"line\"><span class=\"comment\">\t * @returns &#123;string&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">'I\\' am an inner.'</span>;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是一个静态成员</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;string&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Person.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">'I\\'am an static.'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实例化一个人</span></span><br><span class=\"line\"><span class=\"comment\"> * @type &#123;Person&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'fanerge'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Person#say 使用实例方法</span></span><br><span class=\"line\">person1.say();</span><br><span class=\"line\"><span class=\"comment\">// Person.say 使用静态方法</span></span><br><span class=\"line\">Person.say();</span><br><span class=\"line\"><span class=\"comment\">// Person~say 使用内部方法，但这里不能访问到</span></span><br></pre></td></tr></table></figure>\n<p>使用名称路径也有一些特殊的情况：</p>\n<ul>\n<li>@module名称由”module:”前缀，</li>\n<li>@external 名称由”external:”前缀</li>\n<li>@event名称由”event:”前缀。</li>\n</ul>\n<h3 id=\"JSDoc中的命令行参数\"><a href=\"#JSDoc中的命令行参数\" class=\"headerlink\" title=\"JSDoc中的命令行参数\"></a>JSDoc中的命令行参数</h3><p>使用JSDoc最基本的，像这样使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/path/to/jsdoc yourSourceCodeFile.js anotherSourceCodeFile.js ...</span><br></pre></td></tr></table></figure>\n<p>其中…是生成文档文件的路径。</p>\n<p>JSDoc支持大量的命令行选项，其中许多选项有长和短两种形式</p>\n<p>选项 描述</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a , –access 只显示特定access方法属性的标识符： private, protected, public, or undefined, 或者 all（表示所有的访问级别）。默认情况下， 显示除private标识符以外的所有标识符。</span><br><span class=\"line\">-c , –configure JSDoc配置文件的路径。默认为安装JSDoc目录下的conf.json或conf.json.EXAMPLE。</span><br><span class=\"line\">-d , –destination 输出生成文档的文件夹路径。JSDoc内置的Haruki模板，使用console 将数据转储到控制台。默认为./out。</span><br><span class=\"line\">–debug 打印日志信息，可以帮助调试JSDoc本身的问题。</span><br><span class=\"line\">-e , –encoding 当JSDoc阅读源代码时假定使用这个编码，默认为 utf8。</span><br><span class=\"line\">-h, –help 显示JSDoc的命令行选项的信息，然后退出。</span><br><span class=\"line\">–match 只有运行测试，其名称中包含value。</span><br><span class=\"line\">–nocolor 当运行测试时，在控制台输出信息不要使用的颜色。在Windows中，这个选项是默认启用的。</span><br><span class=\"line\">-p, –private 将标记有[@private 标签][tags-private.md]的标识符也生成到文档中。默认情况下，不包括私有标识符。</span><br><span class=\"line\">-P, –package 包含项目名称，版本，和其他细节的package.json文件。默认为在源路径中找到的第一个package.json文件。</span><br><span class=\"line\">–pedantic 将错误视为致命错误，将警告视为错误。默认为false。</span><br><span class=\"line\">-q , –query 一个查询字符串用来解析和存储到全局变量env.opts.query中。示例：foo=bar&amp;baz=true。</span><br><span class=\"line\">-r, –recurse 扫描源文件和导览时递归到子目录。</span><br><span class=\"line\">-R, –readme 用来包含到生成文档的README.md文件。默认为在源路径中找到的第一README.md 文件。</span><br><span class=\"line\">-t , –template 用于生成输出文档的模板的路径。默认为templates/default，JSDoc内置的默认模板。</span><br><span class=\"line\">-T, –test 运行JSDoc的测试套件，并把结果打印到控制台。</span><br><span class=\"line\">-u , –tutorials 导览路径，JSDoc要搜索的目录。如果省略，将不生成导览页。查看导览说明，以了解更多信息。</span><br><span class=\"line\">-v, –version 显示JSDoc的版本号，然后退出。</span><br><span class=\"line\">–verbose 日志的详细信息到控制台JSDoc运行。默认为false。</span><br><span class=\"line\">-X, –explain 以JSON格式转储所有的doclet到控制台，然后退出。</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<p>使用配置文件/path/to/my/conf.json，为./src目录的中文件生成文档，并保存输出到./docs目录中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/path/to/jsdoc src -r -c /path/to/my/conf.json -d docs</span><br></pre></td></tr></table></figure>\n<p>运行所有JSDoc的测试，其名称包含 tag，并记录每个测试信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/path/to/jsdoc -T –match tag –verbose</span><br></pre></td></tr></table></figure>\n<h3 id=\"用conf-json配置JSDoc\"><a href=\"#用conf-json配置JSDoc\" class=\"headerlink\" title=\"用conf.json配置JSDoc\"></a>用conf.json配置JSDoc</h3><h4 id=\"Configuration-File-配置文件\"><a href=\"#Configuration-File-配置文件\" class=\"headerlink\" title=\"Configuration File(配置文件)\"></a>Configuration File(配置文件)</h4><p>要自定义JSDoc的行为，可以使用JSON格式的配置文件格式化JSDoc，使用-c选项，例如： jsdoc -c /path/to/conf.json</p>\n<p>默认的jsDoc配置文件conf.json.EXAMPLE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;tags&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;allowUnknownTags&quot;: true,</span><br><span class=\"line\">\t\t&quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;]</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&quot;source&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;includePattern&quot;: &quot;.+\\\\.js(doc)?$&quot;,</span><br><span class=\"line\">\t\t&quot;excludePattern&quot;: &quot;(^|\\\\/|\\\\\\\\)_&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&quot;plugins&quot;: [],</span><br><span class=\"line\">\t&quot;templates&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;cleverLinks&quot;: false,</span><br><span class=\"line\">\t\t&quot;monospaceLinks&quot;: false</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这意味着：</p>\n<ul>\n<li>JSDoc允许您使用无法识别的标签（tags.allowUnknownTags）;</li>\n<li>这两个标准JSDoc标签和closure标签被启用（tags.dictionaries）;</li>\n<li>只有以.js和.jsdoc结尾的文件将会被处理（source.includePattern）;</li>\n<li>任何文件以下划线开始或开始下划线的目录都将被忽略（source.excludePattern）;</li>\n<li>无插件加载（plugins）;</li>\n<li>@link标签呈现在纯文本（templates.cleverLinks，templates.monospaceLinks）</li>\n</ul>\n<h4 id=\"Specifying-input-files-指定输入文件\"><a href=\"#Specifying-input-files-指定输入文件\" class=\"headerlink\" title=\"Specifying input files(指定输入文件)\"></a>Specifying input files(指定输入文件)</h4><p><strong>source</strong>选项组，结合给JSDoc命令行的路径，确定哪些文件要用JSDoc生成文档</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"source\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"include\"</span>: [ <span class=\"comment\">/* array of paths to files to generate documentation for */</span> ],</span><br><span class=\"line\">    <span class=\"string\">\"exclude\"</span>: [ <span class=\"comment\">/* array of paths to exclude */</span> ],</span><br><span class=\"line\">    <span class=\"string\">\"includePattern\"</span>: <span class=\"string\">\".+\\\\.js(doc)?$\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"excludePattern\"</span>: <span class=\"string\">\"(^|\\\\/|\\\\\\\\)_\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>source.include：可选的路径数组，JSDoc应该为它们生成文档。JSDoc将会结合命令行上的路径和这些文件名，以形成文件组，并且扫描。如果路径是一个目录，可以使用-r选项来递归。</li>\n<li>source.exclude：可选的路径数组，JSDoc应该忽略的路径。在JSDoc3.3.0或更高版本，该数组可包括source.include路径中的子目录。</li>\n<li>source.includePattern：一个可选的字符串，解释为一个正则表达式。如果存在，所有文件必须匹配这个正则表达式，以通过JSDoc进行扫描。默认情况下此选项设置为.+.js(doc)?$，这意味着只有以.js或者.jsdoc结尾的文件将被扫描。</li>\n<li>source.excludePattern：一个可选的字符串，解释为一个正则表达式。如果存在的话，任何匹配这个正则表达式的文件将被忽略。默认设置是以下划线开头的文件（或以下划线开头的目录下的所有文件）将被忽略。</li>\n</ul>\n<h4 id=\"Incorporating-command-line-options-into-the-configuration-file-合并命令行选项到配置文件\"><a href=\"#Incorporating-command-line-options-into-the-configuration-file-合并命令行选项到配置文件\" class=\"headerlink\" title=\"Incorporating command-line options into the configuration file(合并命令行选项到配置文件)\"></a>Incorporating command-line options into the configuration file(合并命令行选项到配置文件)</h4><p>它有可能把许多JSDoc的命令行选项放到配置文件，而不用在命令行中指定它们。要做到这一点，只要在conf.json的opts部分中使用的相关选项的longnames,值是该选项的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"opts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"template\"</span>: <span class=\"string\">\"templates/default\"</span>,  <span class=\"comment\">// same as -t templates/default</span></span><br><span class=\"line\">    <span class=\"string\">\"encoding\"</span>: <span class=\"string\">\"utf8\"</span>,               <span class=\"comment\">// same as -e utf8</span></span><br><span class=\"line\">    <span class=\"string\">\"destination\"</span>: <span class=\"string\">\"./out/\"</span>,          <span class=\"comment\">// same as -d ./out/</span></span><br><span class=\"line\">    <span class=\"string\">\"recurse\"</span>: <span class=\"literal\">true</span>,                  <span class=\"comment\">// same as -r</span></span><br><span class=\"line\">    <span class=\"string\">\"tutorials\"</span>: <span class=\"string\">\"path/to/tutorials\"</span>, <span class=\"comment\">// same as -u path/to/tutorials</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样可以通过source.include和opts，把所有的JSDoc的参数放在配置文件中，以便命令行简化为：</p>\n<p><code>jsdoc -c /path/to/conf.json</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意：在命令行中所提供的选项 优先级高于在conf.json中提供的选项。</span><br></pre></td></tr></table></figure>\n<h4 id=\"Plugins（插件）\"><a href=\"#Plugins（插件）\" class=\"headerlink\" title=\"Plugins（插件）\"></a>Plugins（插件）</h4><p>要启用插件，只要添加它们的路径（相对于JSDoc文件夹）到plugins数组中就可以了。</p>\n<p>示例：</p>\n<p>例如，以下将包括 markdown 插件，它转换 markdown格式的文本为HTML，和“summarize”插件，该自动生成的每个的doclet的摘要</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"plugins/markdown\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"plugins/summarize\"</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h4 id=\"Tags-and-tag-dictionaries-标签和标签字典\"><a href=\"#Tags-and-tag-dictionaries-标签和标签字典\" class=\"headerlink\" title=\"Tags and tag dictionaries(标签和标签字典)\"></a>Tags and tag dictionaries(标签和标签字典)</h4><p><code>tags</code>选项控制哪些JSDoc标签允许被使用和解析。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"tags\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"allowUnknownTags\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dictionaries\"</span>: [<span class=\"string\">\"jsdoc\"</span>,<span class=\"string\">\"closure\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>tags.allowUnknownTags</code>属性影响JSDoc如何处理无法识别的标签。如果将此选项设置为false，JSDoc发现它不能识别（例如,@foo），JSDoc将记录一个警告。默认情况下，此选项设置为true。</p>\n<p><code>tags.dictionaries</code>属性控制JSDoc识别哪些标签，以及JSDoc如何解析它识别标签。在JSDoc3.3.0或更高版本中，有两个内置的标签词典：</p>\n<ul>\n<li>jsdoc: 核心JSDoc标签</li>\n<li>closure: <a href=\"https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler\" target=\"_blank\" rel=\"noopener\">Closure Compiler 标签</a></li>\n</ul>\n<p>默认情况下，两个词典都是启用的。此外，在默认情况下，<code>jsdoc</code>字典首先被解析;作为一个结果，如果<code>jsdoc</code>词典处理一个标签不同于closure词典，<code>jsdoc</code>版本的标签优先被采用(即，以jsdoc版本的标签为准)。</p>\n<p>如果您在Closure Compiler 项目中使用JSDoc，并且你想要避免使用 Closure Compiler无法识别的标签，更改tags.dictionaries设置为[“closure”]。如果你想允许核心JSDoc标签, 但又想要确保Closure Compiler特定的标记使用Closure Compiler对其进行解释，您也可以更改此设置为[“closure”,”jsdoc”]。</p>\n<h4 id=\"配置JSDoc的默认模板\"><a href=\"#配置JSDoc的默认模板\" class=\"headerlink\" title=\"配置JSDoc的默认模板\"></a>配置JSDoc的默认模板</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSDoc的默认模板中提供了几个选项，您可以使用自定义外观和内容来生成文档。</span><br><span class=\"line\">要使用这些选项，您必须为JSDoc创建一个配置文件，并在配置文件中设置相应的选项。</span><br><span class=\"line\"></span><br><span class=\"line\">Generating pretty-printed source files（生成适合打印的文档）</span><br><span class=\"line\">    默认情况下，JSDoc的默认模板为你的源文件生成适合打印的文档。在文档中，它还链接到那些适合的打印文件。</span><br><span class=\"line\">    要禁用适合打印的文件，设置选项templates.default.outputSourceFiles为false。</span><br><span class=\"line\">    使用该选项也将删除文档中链接到源文件的连接。此选项在JSDoc3.3.0及更高版本上是可用的。</span><br><span class=\"line\">Copying static files to the output directory(复制静态文件到输出目录)</span><br><span class=\"line\">    SDoc的默认模板会自动复制一些静态文件，如CSS样式表，到输出目录。</span><br><span class=\"line\">    在JSDoc3.3.0或更高版本，你可以告诉默认模板复制附加静态文件到输出目录。</span><br><span class=\"line\">    例如，您可能希望复制一个图像的目录到输出目录，所以你可以在你的文档中显示这些图像。</span><br><span class=\"line\">    如果您的静态文件目录中包含./myproject/static/img/screen.png文件，您可以通过HTML标签 &lt;img src=&quot;img/screen.png&quot;&gt;在您的文档中显示该图片</span><br><span class=\"line\">Showing the current date in the page footer（在页脚显示当前日期）</span><br><span class=\"line\">    默认情况下，JSDoc的默认模板总是在生成文档的页脚显示当前日期。</span><br><span class=\"line\">    在JSDoc3.3.0或更高版本，可以通过设置选项templates.default.includeDate为false来忽略当前日期。</span><br><span class=\"line\">Showing longnames in the navigation column（在导航栏中显示长文件名）</span><br><span class=\"line\">    默认情况下，JSDoc的默认模板在导航列中显示每个标识符缩写的名字。</span><br><span class=\"line\">    例如，标识符my.namespace.MyClass将简单地称为显示MyClass。相反,要显示完整的长名称，设置选项templates.default.useLongnameInNav为true。</span><br><span class=\"line\">    此选项在JSDoc3.4.0及更高版本中可用。</span><br><span class=\"line\">Overriding the default template&apos;s layout file（重写默认模板的布局文件）</span><br><span class=\"line\">    默认的模板使用名为 layout.tmpl 的文件 指定每个生成文档的页面中的页眉和页脚。</span><br><span class=\"line\">    特别是，每个生产的文档页面会加载该文件定义了CSS和JavaScript文件。在JSDoc3.3.0或更高版本，可以指定使用自己的layout.tmpl文件，它允许你加载自己的自定义CSS和JavaScript文件，去除或替代，标准的文件。</span><br><span class=\"line\">    要使用此功能，设置选项templates.default.layoutFile的路径到你的自定义布局文件。</span><br><span class=\"line\">    路径是相对于config.json文件，当前的工作目录，和JSDoc目录的相对路径，按照这个顺序。</span><br></pre></td></tr></table></figure>\n<h4 id=\"块标签和内联标签\"><a href=\"#块标签和内联标签\" class=\"headerlink\" title=\"块标签和内联标签\"></a>块标签和内联标签</h4><h5 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h5><p>JSDoc支持两种不同类型的标签：</p>\n<ul>\n<li>块标签, 这是在一个JSDoc注释的最高级别。</li>\n<li>内联标签, 块标签文本中的标签或说明。</li>\n</ul>\n<p>块标签通常会提供有关您的代码的详细信息，如一个函数接受的参数。内联标签通常链接到文件的其他部分，类似于HTML中的锚标记（<a>）。</a></p>\n<p>块标签总是以 at 符号（@）开头。除了JSDoc注释中最后一个块标记，每个块标签后面必须跟一个换行符。</p>\n<p>内联标签也以 at 符号（@）开。然而，内联标签及其文本必须用花括号（{ and }）括起来。 { 表示行内联标签的开始，而}表示内联标签的结束。如果你的标签文本中包含右花括号（}），则必须用反斜线（ \\ ）进行转义。在内联标签后,你并不需要使用一个换行符。</p>\n<p>大多数JSDoc标签是块标签。一般来说，当这个网站上说”JSDoc 标签”,我们真正的意思是”块标签”</p>\n<h5 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h5><p>在下面的例子中， @param 是一个块标签，而{@link}是一个内联标签。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Shoe类，一双鞋子</span></span><br><span class=\"line\"><span class=\"comment\"> * @param color</span></span><br><span class=\"line\"><span class=\"comment\"> * @param size</span></span><br><span class=\"line\"><span class=\"comment\"> * @constructor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Shoe = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">color, size</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Set shoe's color. Use &#123;@link Shoe#setSize&#125; to set the shoe size</span></span><br><span class=\"line\"><span class=\"comment\"> * @param color</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Shoe.prototype.setColor = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置鞋子的尺寸</span></span><br><span class=\"line\"><span class=\"comment\"> * @param size</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Shoe.prototype.setSize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">size</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置花边的颜色和样式</span></span><br><span class=\"line\"><span class=\"comment\"> * @param color</span></span><br><span class=\"line\"><span class=\"comment\"> * @param type</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Shoe.prototype.setLaceType = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">color, type</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> shoe1 = <span class=\"keyword\">new</span> Shoe(<span class=\"string\">'red'</span>, <span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"关于JSDoc插件\"><a href=\"#关于JSDoc插件\" class=\"headerlink\" title=\"关于JSDoc插件\"></a>关于JSDoc插件</h4><h5 id=\"Creating-and-Enabling-a-Plugin（创建并启用插件）\"><a href=\"#Creating-and-Enabling-a-Plugin（创建并启用插件）\" class=\"headerlink\" title=\"Creating and Enabling a Plugin（创建并启用插件）\"></a>Creating and Enabling a Plugin（创建并启用插件）</h5><p>创建并启用新JSDoc插件,需要两个步骤：</p>\n<ol>\n<li>创建一个包含你的插件代码的JavaScript模块.</li>\n<li>将该模块添加到JSDoc配置文件的plugins数组中。你可以指定一个绝对或相对路径。如果使用相对路径，JSDoc按照相对于配置文件所在的目录，当前的工作目录和JSDoc安装目录的顺序搜索插件。</li>\n</ol>\n<p>例如，如果你的插件是在当前工作目录下，plugins/shout.js文件中定义的，你应该在JSDoc配置文件中的plugins数组中添加字符串plugins/shout。</p>\n<p>例如，在JSDoc配置文件中添加一个插件：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"plugins/shout\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Authoring-JSDoc-3-Plugins（创建JSDoc3插件）\"><a href=\"#Authoring-JSDoc-3-Plugins（创建JSDoc3插件）\" class=\"headerlink\" title=\"Authoring JSDoc 3 Plugins（创建JSDoc3插件）\"></a>Authoring JSDoc 3 Plugins（创建JSDoc3插件）</h5><p>JSDoc 3的插件系统广泛的控制着解析过程。一个插件可以通过执行以下任何一项操作，影响解析结果：</p>\n<ul>\n<li>定义事件处理程序</li>\n<li>定义标签</li>\n<li>定义一个抽象语法树节点的访问者</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Event Handlers（事件处理程序）</span><br><span class=\"line\">事件: parseBegin – JSDoc开始加载和解析源文件之前，parseBegin事件被触发。</span><br><span class=\"line\">事件: fileBegin – 当解析器即将解析一个文件fileBegin事件触发。</span><br><span class=\"line\">事件: beforeParse – beforeParse事件在解析开始之前被触发。</span><br><span class=\"line\">事件: jsdocCommentFound – 每当JSDoc注释被发现,jsdocCommentFound事件就会被触发。</span><br><span class=\"line\">事件: symbolFound – 当解析器在代码中遇到一个可能需要被文档化的标识符时，symbolFound 事件就会被触发。</span><br><span class=\"line\">事件: newDoclet – newDoclet事件是最高级别的事件。新的doclet已被创建时，它就会被触发。</span><br><span class=\"line\">事件: fileComplete – 当解析器解析完一个文件时，fileComplete 事件就会被触发。</span><br><span class=\"line\">事件: parseComplete – JSDoc解析所有指定的源文件之后，parseComplete事件就会被触发。</span><br><span class=\"line\">事件: processingComplete – JSDoc更新反映继承和借来的标识符的解析结果后，processingComplete事件被触发。</span><br><span class=\"line\"></span><br><span class=\"line\">Tag Definitions （标签定义）</span><br><span class=\"line\">添加标签到标签字典是影响文档生成的一个中级方式。在一个newDoclet事件被触发前，JSDoc注释块被解析以确定可能存在的说明和任何JSDoc标签。</span><br><span class=\"line\">当一个标签被发现，如果它已在标签字典被定义，它就会被赋予一个修改doclet的机会。</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用Markdown插件\"><a href=\"#使用Markdown插件\" class=\"headerlink\" title=\"使用Markdown插件\"></a>使用Markdown插件</h4><h5 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h5><p>JSDoc包括markdown插件，自动把Markdown-formatted文本转换成HTML。你可以在任何JSDoc模板中使用这个插件</p>\n<p>默认情况下，JSDoc会在以下JSDoc标签中查找markdown格式的文本：</p>\n<ul>\n<li>@author</li>\n<li>@classdesc</li>\n<li>@description (包括在JSDoc注释开始地方的未标记的)</li>\n<li>@param</li>\n<li>@property</li>\n<li>@returns</li>\n<li>@see</li>\n<li>@throws</li>\n</ul>\n<h5 id=\"启用markdown插件\"><a href=\"#启用markdown插件\" class=\"headerlink\" title=\"启用markdown插件\"></a>启用markdown插件</h5><p>要启用markdown插件，只要将字符串plugins/markdown添加到JSDoc配置文件的plugins数组中即可。</p>\n<p>示例，配置文件启用markdown插件：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"plugins/markdown\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"在额外的JSDoc标签中转换Markdown\"><a href=\"#在额外的JSDoc标签中转换Markdown\" class=\"headerlink\" title=\"在额外的JSDoc标签中转换Markdown\"></a>在额外的JSDoc标签中转换Markdown</h5><p>默认情况下，markdown插件只处理特定JSDoc标签的markdown文本。您可以通过添加一个 markdown.tags属性到你的JSDoc配置文件中，来处理的其他标签中的markdown文本。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"plugins/markdown\"</span>],</span><br><span class=\"line\">    <span class=\"attr\">\"markdown\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"tags\"</span>: [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"剔除markdown默认处理的标签\"><a href=\"#剔除markdown默认处理的标签\" class=\"headerlink\" title=\"剔除markdown默认处理的标签\"></a>剔除markdown默认处理的标签</h5><p>为了防止Markdown插件处理任何默认JSDoc标签，添加一个markdown.excludeTags属性到您的JSDoc配置文件。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"plugins/markdown\"</span>],</span><br><span class=\"line\">    <span class=\"attr\">\"markdown\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"excludeTags\"</span>: [<span class=\"string\">\"author\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"用换行符换行文本\"><a href=\"#用换行符换行文本\" class=\"headerlink\" title=\"用换行符换行文本\"></a>用换行符换行文本</h5><p>默认情况下，Markdown插件不处理换行符换行的文本。这是因为，这是正常的JSDoc注释可以多行。如果您更喜欢处理换行符换行的文本，设置JSDoc配置文件中的markdown.hardwrap属性为true。此属性是在JSDoc3.4.0及更高版本中可用。</p>\n<h5 id=\"添加ID属性到标题标签\"><a href=\"#添加ID属性到标题标签\" class=\"headerlink\" title=\"添加ID属性到标题标签\"></a>添加ID属性到标题标签</h5><p>默认情况下，Markdown插件不会给每个HTML标题标签添加id 属性。想要标题标签文本自动添加ID属性，设置JSDoc配置文件markdown.idInHeadings属性为true。此属性是在JSDoc3.4.0及更高版本中可用</p>\n<h4 id=\"包含Package（包）文件\"><a href=\"#包含Package（包）文件\" class=\"headerlink\" title=\"包含Package（包）文件\"></a>包含Package（包）文件</h4><p>包文件包含的信息对你的项目文档是很有用的，比如该项目的名称和版本号。</p>\n<p>当JSDoc生成的文档的时候,可以自动使用项目中package.json文件中的信息。</p>\n<p>示例，默认的模板在文档中显示项目的名称和版本号。</p>\n<p>在源路径中包含一个包文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc path/to/js path/to/package/package.json</span><br></pre></td></tr></table></figure>\n<p>使用 -P/–package 选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc –package path/to/package/package-docs.json path/to/js</span><br></pre></td></tr></table></figure>\n<h5 id=\"包含-README-文件\"><a href=\"#包含-README-文件\" class=\"headerlink\" title=\"包含 README 文件\"></a>包含 README 文件</h5><p>有两种方法可以将 README 文件中的信息合并到您的文档：</p>\n<ol>\n<li>在你的JavaScript文件的源路径中，包含一个名为README.md的Markdown文件的路径。JSDoc将使用在源路径中发现的第一个 README.md 文件。</li>\n<li>使用-R/–readme 包命令行选项运行JSDoc，指定 README 文件的路径。此选项在JSDoc3.3.0及更高版本中可用。README文件可以使用任何名称和扩展名，但它必须是Markdown格式。</li>\n</ol>\n<p>-R/–readme 命令行选项优先于你的源路径。如果使用-R/–readme命令行选项，JSDoc会忽略源路径中任何的README.md文件。</p>\n<p>如果您正在使用JSDoc的默认模板，README文件的内容将渲染成HTML，生成在文档 index.html 文件中。</p>\n<h6 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h6><p>在源路径中包含一个 README 文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc path/to/js path/to/readme/README.md</span><br></pre></td></tr></table></figure>\n<p>使用 -R/–readme 选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc --readme path/to/readme/README path/to/js</span><br></pre></td></tr></table></figure>\n"},{"title":"async/await原理","comments":0,"date":"2019-09-09T02:58:28.000Z","updated":"2020-06-10T06:01:48.445Z","author":"jun.zhou","_content":"\n### 主要内容：\n  ##### 1 Iterator\n  ##### 2 Generator\n  ##### 3 Async/await\n\n# 1 迭代器 iterator\nIterator 函数返回一个对象，它实现了迭代协议，并且迭代了一个对象的可枚举属性。\n### (1) 可迭代协议（对象）\n一个对象要变成可迭代的，需要实现 @@iterator 方法\n即必须有一个名字是 Symbol.iterator 的无参函数，返回一个符合迭代器协议的迭代器对象\n### (2) 迭代器协议（对象）\n迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值，并且当所有的值都已经被迭代后，就会有一个默认的返回值\n必须实现next()方法，该方法必须要返回一个对象，该对象有两个必要的属性： done和value\n\n下面我们实现一个可迭代的对象\n```javascript\n    let iterableObj = {\n        obj:{\n            a: 'v_a',\n            b: 'v_b',\n            c: 'v_c',\n        },\n        [Symbol.iterator]: function () {\n            let fields =this.getFields();\n            let index = 0;\n            return {\n                next: ()=> {\n                    if (index < fields.length) {\n                        return {value: fields[index++]}\n                    } else {\n                        return {done: true}\n                    }\n                }\n            }\n        },\n        getFields(){\n            let fields = [];\n            for (let f in this.obj) {\n                fields.push({key: f, value: this.obj[f]});\n            }\n            return fields;\n        }\n    }\n\n    for (let {key,value} of iterableObj) {\n        console.log(key, ':', value);\n    }\n```\n\n# 2 Generator\nGenerator 是ES6 提供的一种异步编程解决方案， 函数是一个状态机，封装了多个内部状态\nyield 表达式本身没有返回值\nyield 表达式左边的值等于next方法所带的参数。\n执行 Generator 函数会返回一个实现了可迭代协议的迭代器对象\n下面通过例子熟悉一下generator的用法\n```javascript\n    function* gen(x) {\n        var y = yield x + 2;\n        return y + 2;\n    }\n\n    let g = gen(1);\n    let iter = g[Symbol.iterator]();//包含Symbol.iterator属性\n    console.log(g === iter);//true\n    let re = g.next()\n    console.log('re:', re);// { value: 3, done: false }\n    re = g.next(2)\n    console.log('re:', re);// { value: 4, done: true }\n```\n\n利用Iterator我们模拟一个自己的Generator\n```javascript\n    function myGenerator(yields) {//返回一个迭代器\n        let l = yields.length;\n        let index = 0;\n        return {\n            next(value){\n                let newValue = yields[index++](value)//表达式左边的值是next函数传入的\n                return {\n                    value: newValue,\n                    done: index >= l,\n                }\n            }\n        }\n    }\n\n    let x = 1;\n    let g = myGenerator([\n          value=> {//模拟yield表达式\n            return x + 2;\n          },\n          value=> {//模拟yield表达式\n            return value + 2;\n          }\n      ]);\n    let re = g.next()\n    console.log('re:', re);// { value: 3, done: false }\n    re = g.next(2)\n    console.log('re:', re);// { value: 4, done: true }\n```\n\n# 3 async/await\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖\n\n下面从读取文件的异步操作开始，我们先来看一下读取文件的函数\n```javascript\nfunction readFilePromise(path) {\n    return new Promise(resolve=> {\n        setTimeout(()=> {\n            resolve(`path:${path}`)\n        }, 1000)\n    })\n}\n```\n\n如果我们要读取两个文件，要怎么写的呢？\n### 一 通常写法\n```javascript\nlet f1 = readFilePromise('file1');\nf1.then(function (file) {\n    console.log('f1:', file);\n    let f2 = readFilePromise('file2')\n    f2.then(function (file) {\n        console.log('f2:', file);\n    })\n})\n/*\n   f1: path:file1\n   f2: path:file2\n*/\n```\n\n### 二 用Generator的写法\n\n```javascript\nlet genFun = function*() {\n    let f1 = yield readFilePromise('/file1');\n    console.log('f1:', f1);\n    let f2 = yield readFilePromise('/file2');\n    console.log('f2:', f2);\n    return f2;\n}\n```\n\n但是Generator不会自动执行，我们知道Generator函数返回的就是一个迭代器，因此我们可以手动执行\n那么直接执行可不可以呢？\n```javascript\nlet g = genFun();\nlet t1 = g.next();\n//t1: {value: Promise {<resolved>: \"path:/file1\"}, done: false}\nlet t2 = g.next();\n//t2: {value: Promise {<resolved>: \"path:/file2\"}, done: false}\nlet t3 = g.next();\n//t3: {value: undefined, done: true}\n```\n直接执行显然不行，f1和f2没有输出\n\n正确执行\n```javascript\nlet g2=genFun();\nlet t1=g2.next();\nt1.value.then(value=>{\n    let t2=g2.next(value);\n    t2.value.then(value=>{\n        let t3=g2.next(value);\n    })\n})\n/*\n  f1: path:/file1\n  f2: path:/file2\n*/\n```\n\n很明显，上面的运行是一个递归调用，因此我们可以写成下面这种形式\n```javascript\nfunction step(value) {\n    let t = g2.next(value);\n    if (t.done)return t.value;\n    t.value.then(value=> {\n        step(value);\n    })\n}\nstep();\n```\n这就是一个执行器，有了这个，我们可以方便的执行Generator\n\n### 三 async/await的写法\n```javascript\nasync function gen2(){\n    let f1=await readFilePromise('/file1', 'open');\n    console.log('f1:', f1);\n    let f2 = await readFilePromise('/file2', 'read');\n    console.log('f2:', f2);\n}\n```\n这种写法跟Generator的写法非常类似，只是把*换成了async，把yield换成了await，这样语义更明确。\n\n而且async/await就是自带执行器的，可以自动执行。\n\n## 下面我们利用Generator来实现一下async/await\n\n```javascript\nfunction myAsync(genF) {\n    return new Promise(function (resolve, reject) {\n        const gen = genF();\n        function step(data) {\n            let next = gen.next(data);\n            if (next.done) {\n                return resolve(next.value);\n            }\n            Promise.resolve(next.value)//这样写可以把不是promise的对象转为proimsie,若是Promise则等待其执行结束\n                .then(v=> {//用新的promise保留的中间结果\n                    step(v);\n                }, e=> {\n                    step(e)\n                })\n        }\n        step();\n    });\n}\n\nlet genF = function*() {\n    let f1 = yield readFilePromise('/file1');\n    console.log('f1:', f1);\n    let f2 = yield readFilePromise('/file2');\n    console.log('f2:', f2);\n    return f2;\n}\nlet f1 = myAsync(genF);\n\nf1.then(data=> {\n    console.log('data:', data);\n})\n\n/*\n f1: path:/file1\n f2: path:/file2\n data: path:/file2\n */\n```\n其实就是封装了一个执行器。\n\n## 结合之前模拟的Generator，我们用Iterator来模拟一下async/await\n```javascript\n\nfunction myAsync(genF) {\n    return new Promise(function (resolve, reject) {\n        const gen = genF();\n        //执行器\n        function step(data) {\n            let next = gen.next(data);\n            if (next.done) {\n                return resolve(next.value);\n            }\n            Promise.resolve(next.value)//这样写可以把不是promse的对象转为promsie\n                .then(v=> {//用新的promise保留的中间结果\n                    step(v);\n                }, e=> {\n                    step(e)\n                })\n        }\n        step();\n    });\n}\n\nfunction myGenerator(yields) {//返回一个迭代器\n    let l = yields.length;\n    let index = 0;\n    return {\n        next(value){\n            let newValue = yields[index++](value)//表达式左边的值是next函数传入的\n            return {\n                value: newValue,\n                done: index >= l,\n            }\n        }\n    }\n}\n\nfunction getGen() {//generator函数\n    return myGenerator(\n        [\n            (value)=> {\n                return readFilePromise('/file1');\n            },\n            (value)=> {\n                console.log('f1:', value);\n                return readFilePromise('/file2')\n            },\n            (value)=> {\n                console.log('f2:', value);\n                return value;\n            }\n        ]\n    );\n}\n\nlet f2 = myAsync(getGen);\nf2.then(data=> {\n    console.log('data:', data);\n})\n```\n**总结**\n<font color=#c7254e >async/await本质是就是一个迭代器和一个自动执行器，结合promise组成的一个异步编程中的同步解决方案，如果我们不需要等待执行结果，那就没必要用async/await</font>\n\n\n\n\n\n","source":"_posts/2019-09-09-Async-await原理.md","raw":"---\ntitle: async/await原理\ncomments: false\ndate: 2019-09-09 10:58:28\ntags:\n- js\nupdated:\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n### 主要内容：\n  ##### 1 Iterator\n  ##### 2 Generator\n  ##### 3 Async/await\n\n# 1 迭代器 iterator\nIterator 函数返回一个对象，它实现了迭代协议，并且迭代了一个对象的可枚举属性。\n### (1) 可迭代协议（对象）\n一个对象要变成可迭代的，需要实现 @@iterator 方法\n即必须有一个名字是 Symbol.iterator 的无参函数，返回一个符合迭代器协议的迭代器对象\n### (2) 迭代器协议（对象）\n迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值，并且当所有的值都已经被迭代后，就会有一个默认的返回值\n必须实现next()方法，该方法必须要返回一个对象，该对象有两个必要的属性： done和value\n\n下面我们实现一个可迭代的对象\n```javascript\n    let iterableObj = {\n        obj:{\n            a: 'v_a',\n            b: 'v_b',\n            c: 'v_c',\n        },\n        [Symbol.iterator]: function () {\n            let fields =this.getFields();\n            let index = 0;\n            return {\n                next: ()=> {\n                    if (index < fields.length) {\n                        return {value: fields[index++]}\n                    } else {\n                        return {done: true}\n                    }\n                }\n            }\n        },\n        getFields(){\n            let fields = [];\n            for (let f in this.obj) {\n                fields.push({key: f, value: this.obj[f]});\n            }\n            return fields;\n        }\n    }\n\n    for (let {key,value} of iterableObj) {\n        console.log(key, ':', value);\n    }\n```\n\n# 2 Generator\nGenerator 是ES6 提供的一种异步编程解决方案， 函数是一个状态机，封装了多个内部状态\nyield 表达式本身没有返回值\nyield 表达式左边的值等于next方法所带的参数。\n执行 Generator 函数会返回一个实现了可迭代协议的迭代器对象\n下面通过例子熟悉一下generator的用法\n```javascript\n    function* gen(x) {\n        var y = yield x + 2;\n        return y + 2;\n    }\n\n    let g = gen(1);\n    let iter = g[Symbol.iterator]();//包含Symbol.iterator属性\n    console.log(g === iter);//true\n    let re = g.next()\n    console.log('re:', re);// { value: 3, done: false }\n    re = g.next(2)\n    console.log('re:', re);// { value: 4, done: true }\n```\n\n利用Iterator我们模拟一个自己的Generator\n```javascript\n    function myGenerator(yields) {//返回一个迭代器\n        let l = yields.length;\n        let index = 0;\n        return {\n            next(value){\n                let newValue = yields[index++](value)//表达式左边的值是next函数传入的\n                return {\n                    value: newValue,\n                    done: index >= l,\n                }\n            }\n        }\n    }\n\n    let x = 1;\n    let g = myGenerator([\n          value=> {//模拟yield表达式\n            return x + 2;\n          },\n          value=> {//模拟yield表达式\n            return value + 2;\n          }\n      ]);\n    let re = g.next()\n    console.log('re:', re);// { value: 3, done: false }\n    re = g.next(2)\n    console.log('re:', re);// { value: 4, done: true }\n```\n\n# 3 async/await\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖\n\n下面从读取文件的异步操作开始，我们先来看一下读取文件的函数\n```javascript\nfunction readFilePromise(path) {\n    return new Promise(resolve=> {\n        setTimeout(()=> {\n            resolve(`path:${path}`)\n        }, 1000)\n    })\n}\n```\n\n如果我们要读取两个文件，要怎么写的呢？\n### 一 通常写法\n```javascript\nlet f1 = readFilePromise('file1');\nf1.then(function (file) {\n    console.log('f1:', file);\n    let f2 = readFilePromise('file2')\n    f2.then(function (file) {\n        console.log('f2:', file);\n    })\n})\n/*\n   f1: path:file1\n   f2: path:file2\n*/\n```\n\n### 二 用Generator的写法\n\n```javascript\nlet genFun = function*() {\n    let f1 = yield readFilePromise('/file1');\n    console.log('f1:', f1);\n    let f2 = yield readFilePromise('/file2');\n    console.log('f2:', f2);\n    return f2;\n}\n```\n\n但是Generator不会自动执行，我们知道Generator函数返回的就是一个迭代器，因此我们可以手动执行\n那么直接执行可不可以呢？\n```javascript\nlet g = genFun();\nlet t1 = g.next();\n//t1: {value: Promise {<resolved>: \"path:/file1\"}, done: false}\nlet t2 = g.next();\n//t2: {value: Promise {<resolved>: \"path:/file2\"}, done: false}\nlet t3 = g.next();\n//t3: {value: undefined, done: true}\n```\n直接执行显然不行，f1和f2没有输出\n\n正确执行\n```javascript\nlet g2=genFun();\nlet t1=g2.next();\nt1.value.then(value=>{\n    let t2=g2.next(value);\n    t2.value.then(value=>{\n        let t3=g2.next(value);\n    })\n})\n/*\n  f1: path:/file1\n  f2: path:/file2\n*/\n```\n\n很明显，上面的运行是一个递归调用，因此我们可以写成下面这种形式\n```javascript\nfunction step(value) {\n    let t = g2.next(value);\n    if (t.done)return t.value;\n    t.value.then(value=> {\n        step(value);\n    })\n}\nstep();\n```\n这就是一个执行器，有了这个，我们可以方便的执行Generator\n\n### 三 async/await的写法\n```javascript\nasync function gen2(){\n    let f1=await readFilePromise('/file1', 'open');\n    console.log('f1:', f1);\n    let f2 = await readFilePromise('/file2', 'read');\n    console.log('f2:', f2);\n}\n```\n这种写法跟Generator的写法非常类似，只是把*换成了async，把yield换成了await，这样语义更明确。\n\n而且async/await就是自带执行器的，可以自动执行。\n\n## 下面我们利用Generator来实现一下async/await\n\n```javascript\nfunction myAsync(genF) {\n    return new Promise(function (resolve, reject) {\n        const gen = genF();\n        function step(data) {\n            let next = gen.next(data);\n            if (next.done) {\n                return resolve(next.value);\n            }\n            Promise.resolve(next.value)//这样写可以把不是promise的对象转为proimsie,若是Promise则等待其执行结束\n                .then(v=> {//用新的promise保留的中间结果\n                    step(v);\n                }, e=> {\n                    step(e)\n                })\n        }\n        step();\n    });\n}\n\nlet genF = function*() {\n    let f1 = yield readFilePromise('/file1');\n    console.log('f1:', f1);\n    let f2 = yield readFilePromise('/file2');\n    console.log('f2:', f2);\n    return f2;\n}\nlet f1 = myAsync(genF);\n\nf1.then(data=> {\n    console.log('data:', data);\n})\n\n/*\n f1: path:/file1\n f2: path:/file2\n data: path:/file2\n */\n```\n其实就是封装了一个执行器。\n\n## 结合之前模拟的Generator，我们用Iterator来模拟一下async/await\n```javascript\n\nfunction myAsync(genF) {\n    return new Promise(function (resolve, reject) {\n        const gen = genF();\n        //执行器\n        function step(data) {\n            let next = gen.next(data);\n            if (next.done) {\n                return resolve(next.value);\n            }\n            Promise.resolve(next.value)//这样写可以把不是promse的对象转为promsie\n                .then(v=> {//用新的promise保留的中间结果\n                    step(v);\n                }, e=> {\n                    step(e)\n                })\n        }\n        step();\n    });\n}\n\nfunction myGenerator(yields) {//返回一个迭代器\n    let l = yields.length;\n    let index = 0;\n    return {\n        next(value){\n            let newValue = yields[index++](value)//表达式左边的值是next函数传入的\n            return {\n                value: newValue,\n                done: index >= l,\n            }\n        }\n    }\n}\n\nfunction getGen() {//generator函数\n    return myGenerator(\n        [\n            (value)=> {\n                return readFilePromise('/file1');\n            },\n            (value)=> {\n                console.log('f1:', value);\n                return readFilePromise('/file2')\n            },\n            (value)=> {\n                console.log('f2:', value);\n                return value;\n            }\n        ]\n    );\n}\n\nlet f2 = myAsync(getGen);\nf2.then(data=> {\n    console.log('data:', data);\n})\n```\n**总结**\n<font color=#c7254e >async/await本质是就是一个迭代器和一个自动执行器，结合promise组成的一个异步编程中的同步解决方案，如果我们不需要等待执行结果，那就没必要用async/await</font>\n\n\n\n\n\n","slug":"Async-await原理","published":1,"_id":"ck2yl0qc7000mh6q683g7gwqa","layout":"post","photos":[],"link":"","content":"<h3 id=\"主要内容：\"><a href=\"#主要内容：\" class=\"headerlink\" title=\"主要内容：\"></a>主要内容：</h3><h5 id=\"1-Iterator\"><a href=\"#1-Iterator\" class=\"headerlink\" title=\"1 Iterator\"></a>1 Iterator</h5><h5 id=\"2-Generator\"><a href=\"#2-Generator\" class=\"headerlink\" title=\"2 Generator\"></a>2 Generator</h5><h5 id=\"3-Async-await\"><a href=\"#3-Async-await\" class=\"headerlink\" title=\"3 Async/await\"></a>3 Async/await</h5><h1 id=\"1-迭代器-iterator\"><a href=\"#1-迭代器-iterator\" class=\"headerlink\" title=\"1 迭代器 iterator\"></a>1 迭代器 iterator</h1><p>Iterator 函数返回一个对象，它实现了迭代协议，并且迭代了一个对象的可枚举属性。</p>\n<h3 id=\"1-可迭代协议（对象）\"><a href=\"#1-可迭代协议（对象）\" class=\"headerlink\" title=\"(1) 可迭代协议（对象）\"></a>(1) 可迭代协议（对象）</h3><p>一个对象要变成可迭代的，需要实现 @@iterator 方法<br>即必须有一个名字是 Symbol.iterator 的无参函数，返回一个符合迭代器协议的迭代器对象</p>\n<h3 id=\"2-迭代器协议（对象）\"><a href=\"#2-迭代器协议（对象）\" class=\"headerlink\" title=\"(2) 迭代器协议（对象）\"></a>(2) 迭代器协议（对象）</h3><p>迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值，并且当所有的值都已经被迭代后，就会有一个默认的返回值<br>必须实现next()方法，该方法必须要返回一个对象，该对象有两个必要的属性： done和value</p>\n<p>下面我们实现一个可迭代的对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterableObj = &#123;</span><br><span class=\"line\">    obj:&#123;</span><br><span class=\"line\">        a: <span class=\"string\">'v_a'</span>,</span><br><span class=\"line\">        b: <span class=\"string\">'v_b'</span>,</span><br><span class=\"line\">        c: <span class=\"string\">'v_c'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [<span class=\"built_in\">Symbol</span>.iterator]: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fields =<span class=\"keyword\">this</span>.getFields();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            next: <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index &lt; fields.length) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: fields[index++]&#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">done</span>: <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getFields()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fields = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> f <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.obj) &#123;</span><br><span class=\"line\">            fields.push(&#123;<span class=\"attr\">key</span>: f, <span class=\"attr\">value</span>: <span class=\"keyword\">this</span>.obj[f]&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fields;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> &#123;key,value&#125; <span class=\"keyword\">of</span> iterableObj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key, <span class=\"string\">':'</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-Generator-1\"><a href=\"#2-Generator-1\" class=\"headerlink\" title=\"2 Generator\"></a>2 Generator</h1><p>Generator 是ES6 提供的一种异步编程解决方案， 函数是一个状态机，封装了多个内部状态<br>yield 表达式本身没有返回值<br>yield 表达式左边的值等于next方法所带的参数。<br>执行 Generator 函数会返回一个实现了可迭代协议的迭代器对象<br>下面通过例子熟悉一下generator的用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">yield</span> x + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y + <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> g = gen(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> iter = g[<span class=\"built_in\">Symbol</span>.iterator]();<span class=\"comment\">//包含Symbol.iterator属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g === iter);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> re = g.next()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'re:'</span>, re);<span class=\"comment\">// &#123; value: 3, done: false &#125;</span></span><br><span class=\"line\">re = g.next(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'re:'</span>, re);<span class=\"comment\">// &#123; value: 4, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>利用Iterator我们模拟一个自己的Generator<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myGenerator</span>(<span class=\"params\">yields</span>) </span>&#123;<span class=\"comment\">//返回一个迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = yields.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        next(value)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> newValue = yields[index++](value)<span class=\"comment\">//表达式左边的值是next函数传入的</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                value: newValue,</span><br><span class=\"line\">                done: index &gt;= l,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> g = myGenerator([</span><br><span class=\"line\">      value=&gt; &#123;<span class=\"comment\">//模拟yield表达式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + <span class=\"number\">2</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      value=&gt; &#123;<span class=\"comment\">//模拟yield表达式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"number\">2</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  ]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> re = g.next()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'re:'</span>, re);<span class=\"comment\">// &#123; value: 3, done: false &#125;</span></span><br><span class=\"line\">re = g.next(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'re:'</span>, re);<span class=\"comment\">// &#123; value: 4, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-async-await\"><a href=\"#3-async-await\" class=\"headerlink\" title=\"3 async/await\"></a>3 async/await</h1><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async 函数是什么？一句话，它就是 Generator 函数的语法糖</p>\n<p>下面从读取文件的异步操作开始，我们先来看一下读取文件的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFilePromise</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span>=&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">`path:<span class=\"subst\">$&#123;path&#125;</span>`</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果我们要读取两个文件，要怎么写的呢？</p>\n<h3 id=\"一-通常写法\"><a href=\"#一-通常写法\" class=\"headerlink\" title=\"一 通常写法\"></a>一 通常写法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f1 = readFilePromise(<span class=\"string\">'file1'</span>);</span><br><span class=\"line\">f1.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, file);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f2 = readFilePromise(<span class=\"string\">'file2'</span>)</span><br><span class=\"line\">    f2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, file);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   f1: path:file1</span></span><br><span class=\"line\"><span class=\"comment\">   f2: path:file2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-用Generator的写法\"><a href=\"#二-用Generator的写法\" class=\"headerlink\" title=\"二 用Generator的写法\"></a>二 用Generator的写法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> genFun = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f1 = <span class=\"keyword\">yield</span> readFilePromise(<span class=\"string\">'/file1'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, f1);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f2 = <span class=\"keyword\">yield</span> readFilePromise(<span class=\"string\">'/file2'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, f2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是Generator不会自动执行，我们知道Generator函数返回的就是一个迭代器，因此我们可以手动执行<br>那么直接执行可不可以呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> g = genFun();</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1 = g.next();</span><br><span class=\"line\"><span class=\"comment\">//t1: &#123;value: Promise &#123;&lt;resolved&gt;: \"path:/file1\"&#125;, done: false&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t2 = g.next();</span><br><span class=\"line\"><span class=\"comment\">//t2: &#123;value: Promise &#123;&lt;resolved&gt;: \"path:/file2\"&#125;, done: false&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t3 = g.next();</span><br><span class=\"line\"><span class=\"comment\">//t3: &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>直接执行显然不行，f1和f2没有输出</p>\n<p>正确执行<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> g2=genFun();</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1=g2.next();</span><br><span class=\"line\">t1.value.then(<span class=\"function\"><span class=\"params\">value</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> t2=g2.next(value);</span><br><span class=\"line\">    t2.value.then(<span class=\"function\"><span class=\"params\">value</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> t3=g2.next(value);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  f1: path:/file1</span></span><br><span class=\"line\"><span class=\"comment\">  f2: path:/file2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>很明显，上面的运行是一个递归调用，因此我们可以写成下面这种形式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> t = g2.next(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.done)<span class=\"keyword\">return</span> t.value;</span><br><span class=\"line\">    t.value.then(<span class=\"function\"><span class=\"params\">value</span>=&gt;</span> &#123;</span><br><span class=\"line\">        step(value);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">step();</span><br></pre></td></tr></table></figure></p>\n<p>这就是一个执行器，有了这个，我们可以方便的执行Generator</p>\n<h3 id=\"三-async-await的写法\"><a href=\"#三-async-await的写法\" class=\"headerlink\" title=\"三 async/await的写法\"></a>三 async/await的写法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gen2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f1=<span class=\"keyword\">await</span> readFilePromise(<span class=\"string\">'/file1'</span>, <span class=\"string\">'open'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, f1);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f2 = <span class=\"keyword\">await</span> readFilePromise(<span class=\"string\">'/file2'</span>, <span class=\"string\">'read'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, f2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种写法跟Generator的写法非常类似，只是把*换成了async，把yield换成了await，这样语义更明确。</p>\n<p>而且async/await就是自带执行器的，可以自动执行。</p>\n<h2 id=\"下面我们利用Generator来实现一下async-await\"><a href=\"#下面我们利用Generator来实现一下async-await\" class=\"headerlink\" title=\"下面我们利用Generator来实现一下async/await\"></a>下面我们利用Generator来实现一下async/await</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">genF</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> gen = genF();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> next = gen.next(data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next.done) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> resolve(next.value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">Promise</span>.resolve(next.value)<span class=\"comment\">//这样写可以把不是promise的对象转为proimsie,若是Promise则等待其执行结束</span></span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span> &#123;<span class=\"comment\">//用新的promise保留的中间结果</span></span><br><span class=\"line\">                    step(v);</span><br><span class=\"line\">                &#125;, e=&gt; &#123;</span><br><span class=\"line\">                    step(e)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        step();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> genF = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f1 = <span class=\"keyword\">yield</span> readFilePromise(<span class=\"string\">'/file1'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, f1);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f2 = <span class=\"keyword\">yield</span> readFilePromise(<span class=\"string\">'/file2'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, f2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f1 = myAsync(genF);</span><br><span class=\"line\"></span><br><span class=\"line\">f1.then(<span class=\"function\"><span class=\"params\">data</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'data:'</span>, data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> f1: path:/file1</span></span><br><span class=\"line\"><span class=\"comment\"> f2: path:/file2</span></span><br><span class=\"line\"><span class=\"comment\"> data: path:/file2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>其实就是封装了一个执行器。</p>\n<h2 id=\"结合之前模拟的Generator，我们用Iterator来模拟一下async-await\"><a href=\"#结合之前模拟的Generator，我们用Iterator来模拟一下async-await\" class=\"headerlink\" title=\"结合之前模拟的Generator，我们用Iterator来模拟一下async/await\"></a>结合之前模拟的Generator，我们用Iterator来模拟一下async/await</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">genF</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> gen = genF();</span><br><span class=\"line\">        <span class=\"comment\">//执行器</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> next = gen.next(data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next.done) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> resolve(next.value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">Promise</span>.resolve(next.value)<span class=\"comment\">//这样写可以把不是promse的对象转为promsie</span></span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span> &#123;<span class=\"comment\">//用新的promise保留的中间结果</span></span><br><span class=\"line\">                    step(v);</span><br><span class=\"line\">                &#125;, e=&gt; &#123;</span><br><span class=\"line\">                    step(e)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        step();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myGenerator</span>(<span class=\"params\">yields</span>) </span>&#123;<span class=\"comment\">//返回一个迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = yields.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        next(value)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> newValue = yields[index++](value)<span class=\"comment\">//表达式左边的值是next函数传入的</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                value: newValue,</span><br><span class=\"line\">                done: index &gt;= l,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getGen</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">//generator函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> myGenerator(</span><br><span class=\"line\">        [</span><br><span class=\"line\">            (value)=&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> readFilePromise(<span class=\"string\">'/file1'</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            (value)=&gt; &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, value);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> readFilePromise(<span class=\"string\">'/file2'</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            (value)=&gt; &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, value);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> f2 = myAsync(getGen);</span><br><span class=\"line\">f2.then(<span class=\"function\"><span class=\"params\">data</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'data:'</span>, data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>总结</strong></p>\n<font color=\"#c7254e\">async/await本质是就是一个迭代器和一个自动执行器，结合promise组成的一个异步编程中的同步解决方案，如果我们不需要等待执行结果，那就没必要用async/await</font>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"主要内容：\"><a href=\"#主要内容：\" class=\"headerlink\" title=\"主要内容：\"></a>主要内容：</h3><h5 id=\"1-Iterator\"><a href=\"#1-Iterator\" class=\"headerlink\" title=\"1 Iterator\"></a>1 Iterator</h5><h5 id=\"2-Generator\"><a href=\"#2-Generator\" class=\"headerlink\" title=\"2 Generator\"></a>2 Generator</h5><h5 id=\"3-Async-await\"><a href=\"#3-Async-await\" class=\"headerlink\" title=\"3 Async/await\"></a>3 Async/await</h5><h1 id=\"1-迭代器-iterator\"><a href=\"#1-迭代器-iterator\" class=\"headerlink\" title=\"1 迭代器 iterator\"></a>1 迭代器 iterator</h1><p>Iterator 函数返回一个对象，它实现了迭代协议，并且迭代了一个对象的可枚举属性。</p>\n<h3 id=\"1-可迭代协议（对象）\"><a href=\"#1-可迭代协议（对象）\" class=\"headerlink\" title=\"(1) 可迭代协议（对象）\"></a>(1) 可迭代协议（对象）</h3><p>一个对象要变成可迭代的，需要实现 @@iterator 方法<br>即必须有一个名字是 Symbol.iterator 的无参函数，返回一个符合迭代器协议的迭代器对象</p>\n<h3 id=\"2-迭代器协议（对象）\"><a href=\"#2-迭代器协议（对象）\" class=\"headerlink\" title=\"(2) 迭代器协议（对象）\"></a>(2) 迭代器协议（对象）</h3><p>迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值，并且当所有的值都已经被迭代后，就会有一个默认的返回值<br>必须实现next()方法，该方法必须要返回一个对象，该对象有两个必要的属性： done和value</p>\n<p>下面我们实现一个可迭代的对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterableObj = &#123;</span><br><span class=\"line\">    obj:&#123;</span><br><span class=\"line\">        a: <span class=\"string\">'v_a'</span>,</span><br><span class=\"line\">        b: <span class=\"string\">'v_b'</span>,</span><br><span class=\"line\">        c: <span class=\"string\">'v_c'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [<span class=\"built_in\">Symbol</span>.iterator]: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fields =<span class=\"keyword\">this</span>.getFields();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            next: <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index &lt; fields.length) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: fields[index++]&#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">done</span>: <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getFields()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fields = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> f <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.obj) &#123;</span><br><span class=\"line\">            fields.push(&#123;<span class=\"attr\">key</span>: f, <span class=\"attr\">value</span>: <span class=\"keyword\">this</span>.obj[f]&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fields;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> &#123;key,value&#125; <span class=\"keyword\">of</span> iterableObj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key, <span class=\"string\">':'</span>, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-Generator-1\"><a href=\"#2-Generator-1\" class=\"headerlink\" title=\"2 Generator\"></a>2 Generator</h1><p>Generator 是ES6 提供的一种异步编程解决方案， 函数是一个状态机，封装了多个内部状态<br>yield 表达式本身没有返回值<br>yield 表达式左边的值等于next方法所带的参数。<br>执行 Generator 函数会返回一个实现了可迭代协议的迭代器对象<br>下面通过例子熟悉一下generator的用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">yield</span> x + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y + <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> g = gen(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> iter = g[<span class=\"built_in\">Symbol</span>.iterator]();<span class=\"comment\">//包含Symbol.iterator属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g === iter);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> re = g.next()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'re:'</span>, re);<span class=\"comment\">// &#123; value: 3, done: false &#125;</span></span><br><span class=\"line\">re = g.next(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'re:'</span>, re);<span class=\"comment\">// &#123; value: 4, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>利用Iterator我们模拟一个自己的Generator<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myGenerator</span>(<span class=\"params\">yields</span>) </span>&#123;<span class=\"comment\">//返回一个迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = yields.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        next(value)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> newValue = yields[index++](value)<span class=\"comment\">//表达式左边的值是next函数传入的</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                value: newValue,</span><br><span class=\"line\">                done: index &gt;= l,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> g = myGenerator([</span><br><span class=\"line\">      value=&gt; &#123;<span class=\"comment\">//模拟yield表达式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + <span class=\"number\">2</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      value=&gt; &#123;<span class=\"comment\">//模拟yield表达式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"number\">2</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  ]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> re = g.next()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'re:'</span>, re);<span class=\"comment\">// &#123; value: 3, done: false &#125;</span></span><br><span class=\"line\">re = g.next(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'re:'</span>, re);<span class=\"comment\">// &#123; value: 4, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-async-await\"><a href=\"#3-async-await\" class=\"headerlink\" title=\"3 async/await\"></a>3 async/await</h1><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async 函数是什么？一句话，它就是 Generator 函数的语法糖</p>\n<p>下面从读取文件的异步操作开始，我们先来看一下读取文件的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFilePromise</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span>=&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">`path:<span class=\"subst\">$&#123;path&#125;</span>`</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果我们要读取两个文件，要怎么写的呢？</p>\n<h3 id=\"一-通常写法\"><a href=\"#一-通常写法\" class=\"headerlink\" title=\"一 通常写法\"></a>一 通常写法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f1 = readFilePromise(<span class=\"string\">'file1'</span>);</span><br><span class=\"line\">f1.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, file);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f2 = readFilePromise(<span class=\"string\">'file2'</span>)</span><br><span class=\"line\">    f2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, file);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   f1: path:file1</span></span><br><span class=\"line\"><span class=\"comment\">   f2: path:file2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-用Generator的写法\"><a href=\"#二-用Generator的写法\" class=\"headerlink\" title=\"二 用Generator的写法\"></a>二 用Generator的写法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> genFun = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f1 = <span class=\"keyword\">yield</span> readFilePromise(<span class=\"string\">'/file1'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, f1);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f2 = <span class=\"keyword\">yield</span> readFilePromise(<span class=\"string\">'/file2'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, f2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是Generator不会自动执行，我们知道Generator函数返回的就是一个迭代器，因此我们可以手动执行<br>那么直接执行可不可以呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> g = genFun();</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1 = g.next();</span><br><span class=\"line\"><span class=\"comment\">//t1: &#123;value: Promise &#123;&lt;resolved&gt;: \"path:/file1\"&#125;, done: false&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t2 = g.next();</span><br><span class=\"line\"><span class=\"comment\">//t2: &#123;value: Promise &#123;&lt;resolved&gt;: \"path:/file2\"&#125;, done: false&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t3 = g.next();</span><br><span class=\"line\"><span class=\"comment\">//t3: &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>直接执行显然不行，f1和f2没有输出</p>\n<p>正确执行<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> g2=genFun();</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1=g2.next();</span><br><span class=\"line\">t1.value.then(<span class=\"function\"><span class=\"params\">value</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> t2=g2.next(value);</span><br><span class=\"line\">    t2.value.then(<span class=\"function\"><span class=\"params\">value</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> t3=g2.next(value);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  f1: path:/file1</span></span><br><span class=\"line\"><span class=\"comment\">  f2: path:/file2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>很明显，上面的运行是一个递归调用，因此我们可以写成下面这种形式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> t = g2.next(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.done)<span class=\"keyword\">return</span> t.value;</span><br><span class=\"line\">    t.value.then(<span class=\"function\"><span class=\"params\">value</span>=&gt;</span> &#123;</span><br><span class=\"line\">        step(value);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">step();</span><br></pre></td></tr></table></figure></p>\n<p>这就是一个执行器，有了这个，我们可以方便的执行Generator</p>\n<h3 id=\"三-async-await的写法\"><a href=\"#三-async-await的写法\" class=\"headerlink\" title=\"三 async/await的写法\"></a>三 async/await的写法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gen2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f1=<span class=\"keyword\">await</span> readFilePromise(<span class=\"string\">'/file1'</span>, <span class=\"string\">'open'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, f1);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f2 = <span class=\"keyword\">await</span> readFilePromise(<span class=\"string\">'/file2'</span>, <span class=\"string\">'read'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, f2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种写法跟Generator的写法非常类似，只是把*换成了async，把yield换成了await，这样语义更明确。</p>\n<p>而且async/await就是自带执行器的，可以自动执行。</p>\n<h2 id=\"下面我们利用Generator来实现一下async-await\"><a href=\"#下面我们利用Generator来实现一下async-await\" class=\"headerlink\" title=\"下面我们利用Generator来实现一下async/await\"></a>下面我们利用Generator来实现一下async/await</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">genF</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> gen = genF();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> next = gen.next(data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next.done) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> resolve(next.value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">Promise</span>.resolve(next.value)<span class=\"comment\">//这样写可以把不是promise的对象转为proimsie,若是Promise则等待其执行结束</span></span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span> &#123;<span class=\"comment\">//用新的promise保留的中间结果</span></span><br><span class=\"line\">                    step(v);</span><br><span class=\"line\">                &#125;, e=&gt; &#123;</span><br><span class=\"line\">                    step(e)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        step();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> genF = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f1 = <span class=\"keyword\">yield</span> readFilePromise(<span class=\"string\">'/file1'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, f1);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f2 = <span class=\"keyword\">yield</span> readFilePromise(<span class=\"string\">'/file2'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, f2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f1 = myAsync(genF);</span><br><span class=\"line\"></span><br><span class=\"line\">f1.then(<span class=\"function\"><span class=\"params\">data</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'data:'</span>, data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> f1: path:/file1</span></span><br><span class=\"line\"><span class=\"comment\"> f2: path:/file2</span></span><br><span class=\"line\"><span class=\"comment\"> data: path:/file2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>其实就是封装了一个执行器。</p>\n<h2 id=\"结合之前模拟的Generator，我们用Iterator来模拟一下async-await\"><a href=\"#结合之前模拟的Generator，我们用Iterator来模拟一下async-await\" class=\"headerlink\" title=\"结合之前模拟的Generator，我们用Iterator来模拟一下async/await\"></a>结合之前模拟的Generator，我们用Iterator来模拟一下async/await</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">genF</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> gen = genF();</span><br><span class=\"line\">        <span class=\"comment\">//执行器</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> next = gen.next(data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next.done) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> resolve(next.value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">Promise</span>.resolve(next.value)<span class=\"comment\">//这样写可以把不是promse的对象转为promsie</span></span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span> &#123;<span class=\"comment\">//用新的promise保留的中间结果</span></span><br><span class=\"line\">                    step(v);</span><br><span class=\"line\">                &#125;, e=&gt; &#123;</span><br><span class=\"line\">                    step(e)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        step();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myGenerator</span>(<span class=\"params\">yields</span>) </span>&#123;<span class=\"comment\">//返回一个迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = yields.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        next(value)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> newValue = yields[index++](value)<span class=\"comment\">//表达式左边的值是next函数传入的</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                value: newValue,</span><br><span class=\"line\">                done: index &gt;= l,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getGen</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">//generator函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> myGenerator(</span><br><span class=\"line\">        [</span><br><span class=\"line\">            (value)=&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> readFilePromise(<span class=\"string\">'/file1'</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            (value)=&gt; &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1:'</span>, value);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> readFilePromise(<span class=\"string\">'/file2'</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            (value)=&gt; &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2:'</span>, value);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> f2 = myAsync(getGen);</span><br><span class=\"line\">f2.then(<span class=\"function\"><span class=\"params\">data</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'data:'</span>, data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>总结</strong></p>\n<font color=\"#c7254e\">async/await本质是就是一个迭代器和一个自动执行器，结合promise组成的一个异步编程中的同步解决方案，如果我们不需要等待执行结果，那就没必要用async/await</font>\n\n\n\n\n\n"},{"title":"Web Components 介绍","comments":0,"date":"2019-08-09T02:58:28.000Z","updated":"2020-06-10T06:01:45.618Z","author":"jun.zhou","_content":"\n### 主要内容：\n  ##### 1 Web组件简介\n  ##### 2 Web组件的组成\n  ##### 3 Web组件总结\n\n# 1 Web组件简介\n&emsp;&emsp;**Web组件**（英语：Web Components）是W3C正在向HTML和DOM规范添加的一套标准，它允许在Web文档和Web应用程序中创建可重用的小部件或组件。这样做的目的是将基于组件的软件工程引入万维网。组件模型将允许单个HTML元素的**封装和互操作性**。\n&emsp;&emsp;作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的HTML（以及相关的样式和脚本），有时您不得不写代码来呈现自定义UI控件，并且如果您不小心的话，多次使用它们会使您的页面变得一团糟。\n&emsp;&emsp;Web Components旨在解决这些问题——它由三项主要技术组成，它们可以单独或一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。\n+ **Custom elements（自定义元素）**：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。\n+ **Shadow DOM（影子DOM）**：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\n+ **HTML templates（HTML模板）**：&lt;template&gt; 和 &lt;slot&gt;元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。\n+ **HTML Imports**:该标准已被弃用，将用ES6的module代替。\n\n**实现web components的基本方法通常如下所示：**\n 1. 创建一个类或函数来指定web组件的功能。\n 2. 使用 CustomElementRegistry.define() 方法注册您的自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类、以及可选的其所继承自的元素。\n 3. 如果需要的话，使用Element.attachShadow() 方法将一个shadow DOM附加到自定义元素上。使用通常的DOM方法向shadow DOM中添加子元素、事件监听器等等。\n 4. 如果需要的话，使用&lt;template&gt; 和&lt;slot&gt; 定义一个HTML模板。再次使用常规DOM方法克隆模板并将其附加到您的shadow DOM中。\n 5. 在页面任何您喜欢的位置使用自定义元素，就像使用常规HTML元素那样。\n\n# 2 Web组件的组成\n## 2.1 custom elements（自定义标签）\nWeb Components 标准非常重要的一个特性是，它使开发者能够将HTML页面的功能封装为 custom elements（自定义标签），而往常，开发者不得不写一大堆冗长、深层嵌套的标签来实现同样的页面功能。\n**下面我们实现一个简单的组件：**\n``` javascript\n//定义组件\nclass HelloWorld extends HTMLElement {\n    constructor() {\n        super();\n        let span=document.createElement('span');\n        span.innerText='hello world';\n        this.append(span);\n    }\n}\n//注册组件\nwindow.customElements.define('hello-world', HelloWorld);\n```\n\n``` html\n<!--使用组件-->\n<hello-world></hello-world>\n或\nlet hello = document.createElement(\"hello-world\");\n```\n**结果：**\n![](https://img.fengjr.com/image/2019/10/25/2d8140250c99c357a3d0e7629e063cdc.png)\n\n**CustomElementRegistry.define()方法用来注册一个custom element，该方法接受以下参数：**\n\n+ 表示所创建的元素名称的符合 DOMString 标准的字符串。注意，custom element 的名称不能是单个单词，且其中必须要有短横线，用与区别原生的 HTML 元素。\n+ 用于定义元素行为的 类 。\n+ 可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。\n\n```javascript\nclass HelloP extends HTMLParagraphElement {\n    constructor() {\n        super();\n        this.innerText='hello paragraph'\n    }\n}\nwindow.customElements.define('hello-p', HelloP,{ extends: 'p' });\n```\n```html\n<p is=\"hello-p\"></p>\n或\nlet hello = document.createElement(\"p\", { is: \"hello-p\" });\n```\n**共有两种 custom elements:**\n+ Autonomous custom elements 是**独立元素**，它不继承其他内建的HTML元素。你可以直接把它们写成HTML标签的形式，来在页面上使用。\n+ Customized built-in elements **继承自基本的HTML元素**。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称。\n\n### 使用生命周期回调函数\n\n在custom element的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用：\n\n+ connectedCallback：当 custom element首次被插入文档DOM时，被调用。\n+ disconnectedCallback：当 custom element从文档DOM中删除时，被调用。\n+ adoptedCallback：当 custom element被移动到新的文档时，被调用。\n+ attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。\n\n```javascript\n\n<hello-world attr=\"hello\"></hello-world>\n\nclass HelloWorld extends HTMLElement {\n    static get observedAttributes() {\n        return ['attr'];\n    }\n\n    constructor() {\n        super();\n        let attr = this.getAttribute('attr');\n        this.innerText = attr + ' world'\n    }\n\n    connectedCallback() {//加载\n        console.log('第一次被连接到文档dom')\n    }\n\n    disconnectedCallback() {//卸载\n        console.log('自定义元素与文档DOM断开连接')\n    }\n\n    adoptedCallback() {\n        console.log('当自定义元素被移动到新文档时被调用')\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {//修改\n        console.log('被修改。', name, oldValue, newValue)\n        let attr = this.getAttribute('attr');\n        this.innerText = attr + ' world'\n    }\n}\nwindow.customElements.define('hello-world', HelloWorld);\n```\n需要注意的是，如果需要在元素属性变化后，触发attributeChangedCallback()回调函数，你必须监听这个属性。这可以通过定义observedAttributes()get函数来实现，observedAttributes()函数体内包含一个return语句，返回一个数组，包含了需要监听的属性名称。\n\n# 2.2 shadow DOM（影子DOM）\n\nShadow DOM允许将隐藏的DOM树添加到常规的DOM树中——它以shadow root为起始根节点，在这个根节点的下方，可以是任意元素，和普通的DOM元素一样。\n![](https://img.fengjr.com/image/2019/10/23/cdf0ebf83bc2fc85c748178b7024ebc7.png)\n+ Shadow host： 一个常规 DOM节点，Shadow DOM会被添加到这个节点上。\n+ Shadow tree：Shadow DOM内部的DOM树。\n+ Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。\n+ Shadow root: Shadow tree的根节点。\n\n&emsp;&emsp;你可以使用同样的方式来操作Shadow DOM，就和操作常规DOM一样，不同的是，Shadow DOM内部的元素始终不会影响到它外部的元素，这为封装提供了便利。\n&emsp;&emsp;Shadow DOM 都不是一个新事物——在过去的很长一段时间里，浏览器用它来封装一个元素的内部结构，我们可以看一下video标签的Shadow DOM。\n&emsp;&emsp;浏览器默认隐藏Shadow DOM实现，若要查看，首先打开chrome的开发者工具，然后打开setting，将Show user agent shadow Dom打钩，如下图。\n![](https://img.fengjr.com/image/2019/10/23/20bd6d5c36f60dbffdc623f4972da530.png)\n&emsp;&emsp;然后，我们就可以看到 video 标签的真面目了：\n![](https://img.fengjr.com/image/2019/10/23/d9e68eb2060e6ca3e60cbcb0b6979ea2.png)\n&emsp;&emsp;我们可以看到上面这些 shadow DOM 中的节点大多都有 pseudo 属性，根据这个属性，你就可以在外面编写 CSS 样式来控制对应的节点样式了。比如，将上面这个 pseudo=\"-webkit-media-controls-play-button\" 的 input 按钮的背景色改为橙色：\n```css\nvideo::-webkit-media-controls-play-button {\n            background-color: orange;\n}\n```\n&emsp;&emsp;浏览器中还有很多 Element 都使用了 Shadow DOM 的形式进行封装，比如 &lt;input&gt;、&lt;select&gt;、&lt;audio&gt; 等。\n\n### 基本用法\n可以使用**Element.attachShadow()**方法来将一个 shadow root 附加到任何一个元素上。它接受一个配置对象作为参数，该对象有一个mode属性，值可以是open或者closed。\nopen 表示你可以通过**Element.shadowRoot**属性获取 Shadow DOM，closed的话返回是null\n```javascript\n//<div id=\"container\" ></div>\n\nlet container=document.getElementById('container');\nlet shadow=container.attachShadow({mode:'open'});\nconsole.log('shadow:',container.shadowRoot)//shadow: #shadow-root (open)\n```\n如果你想将一个Shadow DOM添加到 custom element上，可以在 custom element的构造函数添加如下实现\n```javascript\nlet shadow = this.attachShadow({mode: 'open'});\n```\n下面我们看一个实例\n```javascript\nclass HelloWorld extends HTMLElement {\n        constructor() {\n            super();\n            let shadow = this.attachShadow({mode: 'open'});\n            //创建任意标签\n            let span=document.createElement('span');\n            span.innerText='hello world';\n            //创建样式\n            let style=document.createElement('style');\n            style.textContent='span{color:red}';\n            //\n            shadow.append(style);\n            shadow.append(span);\n        }\n    }\n    window.customElements.define('hello-world', HelloWorld);\n```\n运行结果：\n![](https://img.fengjr.com/image/2019/10/25/103b301fcc820410e3a46b0fc242ab30.png)\n\n# 2.3 HTML templates（HTML模板）\n\n### 关于模板 (Templates)\n当在网页上重复使用相同的标记结构时，肯定是某种模板而不是一遍又一遍地重复复制。但使用HTML &lt;template&gt; 元素更容易实现(这在现代浏览器中得到了很好的支持)。 此元素及其内容不会在DOM中呈现，但仍可使用JavaScript去引用它。\n下面是一个使用template模板的例子：\n```html\n<!--定义模板-->\n<template id=\"my-paragraph\">\n  <p>My paragraph</p>\n</template>\n```\n```javascript\n//使用模板\nlet template = document.getElementById('my-paragraph');\nlet templateContent = template.content;\ndocument.body.appendChild(templateContent);\n```\n\n### 在Web Components中使用模板\n使用模板，我们创建web组件就更加简单了，实例：\n```html\n<template id=\"template\">\n    <style>\n        span{\n            color: red;\n        }\n    </style>\n    <span></span>\n</template>\n\n<hello-world></hello-world>\n```\n```javascript\nclass HelloWorld extends HTMLElement {\n        constructor() {\n            super();\n            let shadow = this.attachShadow({mode: 'open'});\n            let template = document.getElementById('template'); //获取模板\n            let content = template.content.cloneNode(true);//复制模板\n            let span=content.querySelector('span');//获取span\n            span.innerText='hello world';\n            shadow.append(content);\n        }\n    }\n    window.customElements.define('hello-world', HelloWorld);\n```\n运行结果：\n![](https://img.fengjr.com/image/2019/10/25/fa7a633ca1acc134bb685030175d4432.png)\n\n# 3 Web组件总结\n### 好处\n1. 原生，无需框架；\n2. 易于集成，无需转换；\n3. 真正的作用域 CSS；\n4. 标准化，只有 HTML、CSS 和 JavaScript。\n5. 互操作性\nreact和vue仅限于他们的生态内，不能在vue中调用react组件，也不能在react中用vue组件。但是webComponents可以超越框架而存在，可以在不同的技术栈中使用。可以在react，vue中使用，也可以在原生js使用。且不用考虑react或者vue升级，改变公共组件。\n6. 寿命\n因为组件的互操作性，它们将有更长的寿命，基本不需要为了适应新的技术而重写。\n7. 移植性\n组件可以在任何地方使用，因为很少甚至没有依赖，组件的使用障碍要明显低于依赖库或者框架的组件\n原生代码可以为你带来与框架相同的功能，但性能更强、需要的代码更少，更加简洁。\n\n### 坏处\n1. 数据绑定\n2. 状态管理\n3. 兼容性，需要引入polyfill，Shady CSS polyfill，webcomponents-loader\n5. 全局注入\n\n### 发展\n&emsp;&emsp; 对于大型项目而言，直接用web Components开发是不显示的，必然需要一定的库来简化开发和管理状态，例如Polymer。Web Component编码工具会更像编译器而非框架。目前前端框架仍然由三巨头（React、Vue、Angular）占领，Web Components能否有所突破还要靠时间来检验。\n\n","source":"_posts/2019-09-29-webcomponent.md","raw":"---\ntitle: Web Components 介绍\ncomments: false\ndate: 2019-08-09 10:58:28\ntags:\n- js\nupdated:\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n### 主要内容：\n  ##### 1 Web组件简介\n  ##### 2 Web组件的组成\n  ##### 3 Web组件总结\n\n# 1 Web组件简介\n&emsp;&emsp;**Web组件**（英语：Web Components）是W3C正在向HTML和DOM规范添加的一套标准，它允许在Web文档和Web应用程序中创建可重用的小部件或组件。这样做的目的是将基于组件的软件工程引入万维网。组件模型将允许单个HTML元素的**封装和互操作性**。\n&emsp;&emsp;作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的HTML（以及相关的样式和脚本），有时您不得不写代码来呈现自定义UI控件，并且如果您不小心的话，多次使用它们会使您的页面变得一团糟。\n&emsp;&emsp;Web Components旨在解决这些问题——它由三项主要技术组成，它们可以单独或一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。\n+ **Custom elements（自定义元素）**：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。\n+ **Shadow DOM（影子DOM）**：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\n+ **HTML templates（HTML模板）**：&lt;template&gt; 和 &lt;slot&gt;元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。\n+ **HTML Imports**:该标准已被弃用，将用ES6的module代替。\n\n**实现web components的基本方法通常如下所示：**\n 1. 创建一个类或函数来指定web组件的功能。\n 2. 使用 CustomElementRegistry.define() 方法注册您的自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类、以及可选的其所继承自的元素。\n 3. 如果需要的话，使用Element.attachShadow() 方法将一个shadow DOM附加到自定义元素上。使用通常的DOM方法向shadow DOM中添加子元素、事件监听器等等。\n 4. 如果需要的话，使用&lt;template&gt; 和&lt;slot&gt; 定义一个HTML模板。再次使用常规DOM方法克隆模板并将其附加到您的shadow DOM中。\n 5. 在页面任何您喜欢的位置使用自定义元素，就像使用常规HTML元素那样。\n\n# 2 Web组件的组成\n## 2.1 custom elements（自定义标签）\nWeb Components 标准非常重要的一个特性是，它使开发者能够将HTML页面的功能封装为 custom elements（自定义标签），而往常，开发者不得不写一大堆冗长、深层嵌套的标签来实现同样的页面功能。\n**下面我们实现一个简单的组件：**\n``` javascript\n//定义组件\nclass HelloWorld extends HTMLElement {\n    constructor() {\n        super();\n        let span=document.createElement('span');\n        span.innerText='hello world';\n        this.append(span);\n    }\n}\n//注册组件\nwindow.customElements.define('hello-world', HelloWorld);\n```\n\n``` html\n<!--使用组件-->\n<hello-world></hello-world>\n或\nlet hello = document.createElement(\"hello-world\");\n```\n**结果：**\n![](https://img.fengjr.com/image/2019/10/25/2d8140250c99c357a3d0e7629e063cdc.png)\n\n**CustomElementRegistry.define()方法用来注册一个custom element，该方法接受以下参数：**\n\n+ 表示所创建的元素名称的符合 DOMString 标准的字符串。注意，custom element 的名称不能是单个单词，且其中必须要有短横线，用与区别原生的 HTML 元素。\n+ 用于定义元素行为的 类 。\n+ 可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。\n\n```javascript\nclass HelloP extends HTMLParagraphElement {\n    constructor() {\n        super();\n        this.innerText='hello paragraph'\n    }\n}\nwindow.customElements.define('hello-p', HelloP,{ extends: 'p' });\n```\n```html\n<p is=\"hello-p\"></p>\n或\nlet hello = document.createElement(\"p\", { is: \"hello-p\" });\n```\n**共有两种 custom elements:**\n+ Autonomous custom elements 是**独立元素**，它不继承其他内建的HTML元素。你可以直接把它们写成HTML标签的形式，来在页面上使用。\n+ Customized built-in elements **继承自基本的HTML元素**。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称。\n\n### 使用生命周期回调函数\n\n在custom element的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用：\n\n+ connectedCallback：当 custom element首次被插入文档DOM时，被调用。\n+ disconnectedCallback：当 custom element从文档DOM中删除时，被调用。\n+ adoptedCallback：当 custom element被移动到新的文档时，被调用。\n+ attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。\n\n```javascript\n\n<hello-world attr=\"hello\"></hello-world>\n\nclass HelloWorld extends HTMLElement {\n    static get observedAttributes() {\n        return ['attr'];\n    }\n\n    constructor() {\n        super();\n        let attr = this.getAttribute('attr');\n        this.innerText = attr + ' world'\n    }\n\n    connectedCallback() {//加载\n        console.log('第一次被连接到文档dom')\n    }\n\n    disconnectedCallback() {//卸载\n        console.log('自定义元素与文档DOM断开连接')\n    }\n\n    adoptedCallback() {\n        console.log('当自定义元素被移动到新文档时被调用')\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {//修改\n        console.log('被修改。', name, oldValue, newValue)\n        let attr = this.getAttribute('attr');\n        this.innerText = attr + ' world'\n    }\n}\nwindow.customElements.define('hello-world', HelloWorld);\n```\n需要注意的是，如果需要在元素属性变化后，触发attributeChangedCallback()回调函数，你必须监听这个属性。这可以通过定义observedAttributes()get函数来实现，observedAttributes()函数体内包含一个return语句，返回一个数组，包含了需要监听的属性名称。\n\n# 2.2 shadow DOM（影子DOM）\n\nShadow DOM允许将隐藏的DOM树添加到常规的DOM树中——它以shadow root为起始根节点，在这个根节点的下方，可以是任意元素，和普通的DOM元素一样。\n![](https://img.fengjr.com/image/2019/10/23/cdf0ebf83bc2fc85c748178b7024ebc7.png)\n+ Shadow host： 一个常规 DOM节点，Shadow DOM会被添加到这个节点上。\n+ Shadow tree：Shadow DOM内部的DOM树。\n+ Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。\n+ Shadow root: Shadow tree的根节点。\n\n&emsp;&emsp;你可以使用同样的方式来操作Shadow DOM，就和操作常规DOM一样，不同的是，Shadow DOM内部的元素始终不会影响到它外部的元素，这为封装提供了便利。\n&emsp;&emsp;Shadow DOM 都不是一个新事物——在过去的很长一段时间里，浏览器用它来封装一个元素的内部结构，我们可以看一下video标签的Shadow DOM。\n&emsp;&emsp;浏览器默认隐藏Shadow DOM实现，若要查看，首先打开chrome的开发者工具，然后打开setting，将Show user agent shadow Dom打钩，如下图。\n![](https://img.fengjr.com/image/2019/10/23/20bd6d5c36f60dbffdc623f4972da530.png)\n&emsp;&emsp;然后，我们就可以看到 video 标签的真面目了：\n![](https://img.fengjr.com/image/2019/10/23/d9e68eb2060e6ca3e60cbcb0b6979ea2.png)\n&emsp;&emsp;我们可以看到上面这些 shadow DOM 中的节点大多都有 pseudo 属性，根据这个属性，你就可以在外面编写 CSS 样式来控制对应的节点样式了。比如，将上面这个 pseudo=\"-webkit-media-controls-play-button\" 的 input 按钮的背景色改为橙色：\n```css\nvideo::-webkit-media-controls-play-button {\n            background-color: orange;\n}\n```\n&emsp;&emsp;浏览器中还有很多 Element 都使用了 Shadow DOM 的形式进行封装，比如 &lt;input&gt;、&lt;select&gt;、&lt;audio&gt; 等。\n\n### 基本用法\n可以使用**Element.attachShadow()**方法来将一个 shadow root 附加到任何一个元素上。它接受一个配置对象作为参数，该对象有一个mode属性，值可以是open或者closed。\nopen 表示你可以通过**Element.shadowRoot**属性获取 Shadow DOM，closed的话返回是null\n```javascript\n//<div id=\"container\" ></div>\n\nlet container=document.getElementById('container');\nlet shadow=container.attachShadow({mode:'open'});\nconsole.log('shadow:',container.shadowRoot)//shadow: #shadow-root (open)\n```\n如果你想将一个Shadow DOM添加到 custom element上，可以在 custom element的构造函数添加如下实现\n```javascript\nlet shadow = this.attachShadow({mode: 'open'});\n```\n下面我们看一个实例\n```javascript\nclass HelloWorld extends HTMLElement {\n        constructor() {\n            super();\n            let shadow = this.attachShadow({mode: 'open'});\n            //创建任意标签\n            let span=document.createElement('span');\n            span.innerText='hello world';\n            //创建样式\n            let style=document.createElement('style');\n            style.textContent='span{color:red}';\n            //\n            shadow.append(style);\n            shadow.append(span);\n        }\n    }\n    window.customElements.define('hello-world', HelloWorld);\n```\n运行结果：\n![](https://img.fengjr.com/image/2019/10/25/103b301fcc820410e3a46b0fc242ab30.png)\n\n# 2.3 HTML templates（HTML模板）\n\n### 关于模板 (Templates)\n当在网页上重复使用相同的标记结构时，肯定是某种模板而不是一遍又一遍地重复复制。但使用HTML &lt;template&gt; 元素更容易实现(这在现代浏览器中得到了很好的支持)。 此元素及其内容不会在DOM中呈现，但仍可使用JavaScript去引用它。\n下面是一个使用template模板的例子：\n```html\n<!--定义模板-->\n<template id=\"my-paragraph\">\n  <p>My paragraph</p>\n</template>\n```\n```javascript\n//使用模板\nlet template = document.getElementById('my-paragraph');\nlet templateContent = template.content;\ndocument.body.appendChild(templateContent);\n```\n\n### 在Web Components中使用模板\n使用模板，我们创建web组件就更加简单了，实例：\n```html\n<template id=\"template\">\n    <style>\n        span{\n            color: red;\n        }\n    </style>\n    <span></span>\n</template>\n\n<hello-world></hello-world>\n```\n```javascript\nclass HelloWorld extends HTMLElement {\n        constructor() {\n            super();\n            let shadow = this.attachShadow({mode: 'open'});\n            let template = document.getElementById('template'); //获取模板\n            let content = template.content.cloneNode(true);//复制模板\n            let span=content.querySelector('span');//获取span\n            span.innerText='hello world';\n            shadow.append(content);\n        }\n    }\n    window.customElements.define('hello-world', HelloWorld);\n```\n运行结果：\n![](https://img.fengjr.com/image/2019/10/25/fa7a633ca1acc134bb685030175d4432.png)\n\n# 3 Web组件总结\n### 好处\n1. 原生，无需框架；\n2. 易于集成，无需转换；\n3. 真正的作用域 CSS；\n4. 标准化，只有 HTML、CSS 和 JavaScript。\n5. 互操作性\nreact和vue仅限于他们的生态内，不能在vue中调用react组件，也不能在react中用vue组件。但是webComponents可以超越框架而存在，可以在不同的技术栈中使用。可以在react，vue中使用，也可以在原生js使用。且不用考虑react或者vue升级，改变公共组件。\n6. 寿命\n因为组件的互操作性，它们将有更长的寿命，基本不需要为了适应新的技术而重写。\n7. 移植性\n组件可以在任何地方使用，因为很少甚至没有依赖，组件的使用障碍要明显低于依赖库或者框架的组件\n原生代码可以为你带来与框架相同的功能，但性能更强、需要的代码更少，更加简洁。\n\n### 坏处\n1. 数据绑定\n2. 状态管理\n3. 兼容性，需要引入polyfill，Shady CSS polyfill，webcomponents-loader\n5. 全局注入\n\n### 发展\n&emsp;&emsp; 对于大型项目而言，直接用web Components开发是不显示的，必然需要一定的库来简化开发和管理状态，例如Polymer。Web Component编码工具会更像编译器而非框架。目前前端框架仍然由三巨头（React、Vue、Angular）占领，Web Components能否有所突破还要靠时间来检验。\n\n","slug":"webcomponent","published":1,"_id":"ck2yl0qc8000qh6q65uno84ka","layout":"post","photos":[],"link":"","content":"<h3 id=\"主要内容：\"><a href=\"#主要内容：\" class=\"headerlink\" title=\"主要内容：\"></a>主要内容：</h3><h5 id=\"1-Web组件简介\"><a href=\"#1-Web组件简介\" class=\"headerlink\" title=\"1 Web组件简介\"></a>1 Web组件简介</h5><h5 id=\"2-Web组件的组成\"><a href=\"#2-Web组件的组成\" class=\"headerlink\" title=\"2 Web组件的组成\"></a>2 Web组件的组成</h5><h5 id=\"3-Web组件总结\"><a href=\"#3-Web组件总结\" class=\"headerlink\" title=\"3 Web组件总结\"></a>3 Web组件总结</h5><h1 id=\"1-Web组件简介-1\"><a href=\"#1-Web组件简介-1\" class=\"headerlink\" title=\"1 Web组件简介\"></a>1 Web组件简介</h1><p>&emsp;&emsp;<strong>Web组件</strong>（英语：Web Components）是W3C正在向HTML和DOM规范添加的一套标准，它允许在Web文档和Web应用程序中创建可重用的小部件或组件。这样做的目的是将基于组件的软件工程引入万维网。组件模型将允许单个HTML元素的<strong>封装和互操作性</strong>。<br>&emsp;&emsp;作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的HTML（以及相关的样式和脚本），有时您不得不写代码来呈现自定义UI控件，并且如果您不小心的话，多次使用它们会使您的页面变得一团糟。<br>&emsp;&emsp;Web Components旨在解决这些问题——它由三项主要技术组成，它们可以单独或一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。</p>\n<ul>\n<li><strong>Custom elements（自定义元素）</strong>：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。</li>\n<li><strong>Shadow DOM（影子DOM）</strong>：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。</li>\n<li><strong>HTML templates（HTML模板）</strong>：&lt;template&gt; 和 &lt;slot&gt;元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</li>\n<li><strong>HTML Imports</strong>:该标准已被弃用，将用ES6的module代替。</li>\n</ul>\n<p><strong>实现web components的基本方法通常如下所示：</strong></p>\n<ol>\n<li>创建一个类或函数来指定web组件的功能。</li>\n<li>使用 CustomElementRegistry.define() 方法注册您的自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类、以及可选的其所继承自的元素。</li>\n<li>如果需要的话，使用Element.attachShadow() 方法将一个shadow DOM附加到自定义元素上。使用通常的DOM方法向shadow DOM中添加子元素、事件监听器等等。</li>\n<li>如果需要的话，使用&lt;template&gt; 和&lt;slot&gt; 定义一个HTML模板。再次使用常规DOM方法克隆模板并将其附加到您的shadow DOM中。</li>\n<li>在页面任何您喜欢的位置使用自定义元素，就像使用常规HTML元素那样。</li>\n</ol>\n<h1 id=\"2-Web组件的组成-1\"><a href=\"#2-Web组件的组成-1\" class=\"headerlink\" title=\"2 Web组件的组成\"></a>2 Web组件的组成</h1><h2 id=\"2-1-custom-elements（自定义标签）\"><a href=\"#2-1-custom-elements（自定义标签）\" class=\"headerlink\" title=\"2.1 custom elements（自定义标签）\"></a>2.1 custom elements（自定义标签）</h2><p>Web Components 标准非常重要的一个特性是，它使开发者能够将HTML页面的功能封装为 custom elements（自定义标签），而往常，开发者不得不写一大堆冗长、深层嵌套的标签来实现同样的页面功能。<br><strong>下面我们实现一个简单的组件：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义组件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> span=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'span'</span>);</span><br><span class=\"line\">        span.innerText=<span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.append(span);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//注册组件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-world'</span>, HelloWorld);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--使用组件--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">hello-world</span>&gt;</span></span><br><span class=\"line\">或</span><br><span class=\"line\">let hello = document.createElement(\"hello-world\");</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong><br><img src=\"https://img.fengjr.com/image/2019/10/25/2d8140250c99c357a3d0e7629e063cdc.png\" alt></p>\n<p><strong>CustomElementRegistry.define()方法用来注册一个custom element，该方法接受以下参数：</strong></p>\n<ul>\n<li>表示所创建的元素名称的符合 DOMString 标准的字符串。注意，custom element 的名称不能是单个单词，且其中必须要有短横线，用与区别原生的 HTML 元素。</li>\n<li>用于定义元素行为的 类 。</li>\n<li>可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloP</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLParagraphElement</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.innerText=<span class=\"string\">'hello paragraph'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-p'</span>, HelloP,&#123; <span class=\"attr\">extends</span>: <span class=\"string\">'p'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">is</span>=<span class=\"string\">\"hello-p\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">或</span><br><span class=\"line\">let hello = document.createElement(\"p\", &#123; is: \"hello-p\" &#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>共有两种 custom elements:</strong></p>\n<ul>\n<li>Autonomous custom elements 是<strong>独立元素</strong>，它不继承其他内建的HTML元素。你可以直接把它们写成HTML标签的形式，来在页面上使用。</li>\n<li>Customized built-in elements <strong>继承自基本的HTML元素</strong>。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称。</li>\n</ul>\n<h3 id=\"使用生命周期回调函数\"><a href=\"#使用生命周期回调函数\" class=\"headerlink\" title=\"使用生命周期回调函数\"></a>使用生命周期回调函数</h3><p>在custom element的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用：</p>\n<ul>\n<li>connectedCallback：当 custom element首次被插入文档DOM时，被调用。</li>\n<li>disconnectedCallback：当 custom element从文档DOM中删除时，被调用。</li>\n<li>adoptedCallback：当 custom element被移动到新的文档时，被调用。</li>\n<li>attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;hello-world attr=<span class=\"string\">\"hello\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">hello-world</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> observedAttributes() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"string\">'attr'</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> attr = <span class=\"keyword\">this</span>.getAttribute(<span class=\"string\">'attr'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.innerText = attr + <span class=\"string\">' world'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    connectedCallback() &#123;<span class=\"comment\">//加载</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'第一次被连接到文档dom'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    disconnectedCallback() &#123;<span class=\"comment\">//卸载</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'自定义元素与文档DOM断开连接'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    adoptedCallback() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'当自定义元素被移动到新文档时被调用'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    attributeChangedCallback(name, oldValue, newValue) &#123;<span class=\"comment\">//修改</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'被修改。'</span>, name, oldValue, newValue)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> attr = <span class=\"keyword\">this</span>.getAttribute(<span class=\"string\">'attr'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.innerText = attr + <span class=\"string\">' world'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-world'</span>, HelloWorld);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，如果需要在元素属性变化后，触发attributeChangedCallback()回调函数，你必须监听这个属性。这可以通过定义observedAttributes()get函数来实现，observedAttributes()函数体内包含一个return语句，返回一个数组，包含了需要监听的属性名称。</p>\n<h1 id=\"2-2-shadow-DOM（影子DOM）\"><a href=\"#2-2-shadow-DOM（影子DOM）\" class=\"headerlink\" title=\"2.2 shadow DOM（影子DOM）\"></a>2.2 shadow DOM（影子DOM）</h1><p>Shadow DOM允许将隐藏的DOM树添加到常规的DOM树中——它以shadow root为起始根节点，在这个根节点的下方，可以是任意元素，和普通的DOM元素一样。<br><img src=\"https://img.fengjr.com/image/2019/10/23/cdf0ebf83bc2fc85c748178b7024ebc7.png\" alt></p>\n<ul>\n<li>Shadow host： 一个常规 DOM节点，Shadow DOM会被添加到这个节点上。</li>\n<li>Shadow tree：Shadow DOM内部的DOM树。</li>\n<li>Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。</li>\n<li>Shadow root: Shadow tree的根节点。</li>\n</ul>\n<p>&emsp;&emsp;你可以使用同样的方式来操作Shadow DOM，就和操作常规DOM一样，不同的是，Shadow DOM内部的元素始终不会影响到它外部的元素，这为封装提供了便利。<br>&emsp;&emsp;Shadow DOM 都不是一个新事物——在过去的很长一段时间里，浏览器用它来封装一个元素的内部结构，我们可以看一下video标签的Shadow DOM。<br>&emsp;&emsp;浏览器默认隐藏Shadow DOM实现，若要查看，首先打开chrome的开发者工具，然后打开setting，将Show user agent shadow Dom打钩，如下图。<br><img src=\"https://img.fengjr.com/image/2019/10/23/20bd6d5c36f60dbffdc623f4972da530.png\" alt><br>&emsp;&emsp;然后，我们就可以看到 video 标签的真面目了：<br><img src=\"https://img.fengjr.com/image/2019/10/23/d9e68eb2060e6ca3e60cbcb0b6979ea2.png\" alt><br>&emsp;&emsp;我们可以看到上面这些 shadow DOM 中的节点大多都有 pseudo 属性，根据这个属性，你就可以在外面编写 CSS 样式来控制对应的节点样式了。比如，将上面这个 pseudo=”-webkit-media-controls-play-button” 的 input 按钮的背景色改为橙色：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">video</span><span class=\"selector-pseudo\">::-webkit-media-controls-play-button</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">background-color</span>: orange;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;浏览器中还有很多 Element 都使用了 Shadow DOM 的形式进行封装，比如 &lt;input&gt;、&lt;select&gt;、&lt;audio&gt; 等。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>可以使用<strong>Element.attachShadow()</strong>方法来将一个 shadow root 附加到任何一个元素上。它接受一个配置对象作为参数，该对象有一个mode属性，值可以是open或者closed。<br>open 表示你可以通过<strong>Element.shadowRoot</strong>属性获取 Shadow DOM，closed的话返回是null<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//&lt;div id=\"container\" &gt;&lt;/div&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> container=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> shadow=container.attachShadow(&#123;<span class=\"attr\">mode</span>:<span class=\"string\">'open'</span>&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'shadow:'</span>,container.shadowRoot)<span class=\"comment\">//shadow: #shadow-root (open)</span></span><br></pre></td></tr></table></figure></p>\n<p>如果你想将一个Shadow DOM添加到 custom element上，可以在 custom element的构造函数添加如下实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> shadow = <span class=\"keyword\">this</span>.attachShadow(&#123;<span class=\"attr\">mode</span>: <span class=\"string\">'open'</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>下面我们看一个实例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> shadow = <span class=\"keyword\">this</span>.attachShadow(&#123;<span class=\"attr\">mode</span>: <span class=\"string\">'open'</span>&#125;);</span><br><span class=\"line\">            <span class=\"comment\">//创建任意标签</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> span=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'span'</span>);</span><br><span class=\"line\">            span.innerText=<span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">            <span class=\"comment\">//创建样式</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> style=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'style'</span>);</span><br><span class=\"line\">            style.textContent=<span class=\"string\">'span&#123;color:red&#125;'</span>;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            shadow.append(style);</span><br><span class=\"line\">            shadow.append(span);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-world'</span>, HelloWorld);</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://img.fengjr.com/image/2019/10/25/103b301fcc820410e3a46b0fc242ab30.png\" alt></p>\n<h1 id=\"2-3-HTML-templates（HTML模板）\"><a href=\"#2-3-HTML-templates（HTML模板）\" class=\"headerlink\" title=\"2.3 HTML templates（HTML模板）\"></a>2.3 HTML templates（HTML模板）</h1><h3 id=\"关于模板-Templates\"><a href=\"#关于模板-Templates\" class=\"headerlink\" title=\"关于模板 (Templates)\"></a>关于模板 (Templates)</h3><p>当在网页上重复使用相同的标记结构时，肯定是某种模板而不是一遍又一遍地重复复制。但使用HTML &lt;template&gt; 元素更容易实现(这在现代浏览器中得到了很好的支持)。 此元素及其内容不会在DOM中呈现，但仍可使用JavaScript去引用它。<br>下面是一个使用template模板的例子：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--定义模板--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">\"my-paragraph\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>My paragraph<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用模板</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> template = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'my-paragraph'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> templateContent = template.content;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(templateContent);</span><br></pre></td></tr></table></figure>\n<h3 id=\"在Web-Components中使用模板\"><a href=\"#在Web-Components中使用模板\" class=\"headerlink\" title=\"在Web Components中使用模板\"></a>在Web Components中使用模板</h3><p>使用模板，我们创建web组件就更加简单了，实例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">\"template\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">        span&#123;</span><br><span class=\"line\">            color: red;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">hello-world</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> shadow = <span class=\"keyword\">this</span>.attachShadow(&#123;<span class=\"attr\">mode</span>: <span class=\"string\">'open'</span>&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> template = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'template'</span>); <span class=\"comment\">//获取模板</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = template.content.cloneNode(<span class=\"literal\">true</span>);<span class=\"comment\">//复制模板</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> span=content.querySelector(<span class=\"string\">'span'</span>);<span class=\"comment\">//获取span</span></span><br><span class=\"line\">            span.innerText=<span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">            shadow.append(content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-world'</span>, HelloWorld);</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://img.fengjr.com/image/2019/10/25/fa7a633ca1acc134bb685030175d4432.png\" alt></p>\n<h1 id=\"3-Web组件总结-1\"><a href=\"#3-Web组件总结-1\" class=\"headerlink\" title=\"3 Web组件总结\"></a>3 Web组件总结</h1><h3 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h3><ol>\n<li>原生，无需框架；</li>\n<li>易于集成，无需转换；</li>\n<li>真正的作用域 CSS；</li>\n<li>标准化，只有 HTML、CSS 和 JavaScript。</li>\n<li>互操作性<br>react和vue仅限于他们的生态内，不能在vue中调用react组件，也不能在react中用vue组件。但是webComponents可以超越框架而存在，可以在不同的技术栈中使用。可以在react，vue中使用，也可以在原生js使用。且不用考虑react或者vue升级，改变公共组件。</li>\n<li>寿命<br>因为组件的互操作性，它们将有更长的寿命，基本不需要为了适应新的技术而重写。</li>\n<li>移植性<br>组件可以在任何地方使用，因为很少甚至没有依赖，组件的使用障碍要明显低于依赖库或者框架的组件<br>原生代码可以为你带来与框架相同的功能，但性能更强、需要的代码更少，更加简洁。</li>\n</ol>\n<h3 id=\"坏处\"><a href=\"#坏处\" class=\"headerlink\" title=\"坏处\"></a>坏处</h3><ol>\n<li>数据绑定</li>\n<li>状态管理</li>\n<li>兼容性，需要引入polyfill，Shady CSS polyfill，webcomponents-loader</li>\n<li>全局注入</li>\n</ol>\n<h3 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h3><p>&emsp;&emsp; 对于大型项目而言，直接用web Components开发是不显示的，必然需要一定的库来简化开发和管理状态，例如Polymer。Web Component编码工具会更像编译器而非框架。目前前端框架仍然由三巨头（React、Vue、Angular）占领，Web Components能否有所突破还要靠时间来检验。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"主要内容：\"><a href=\"#主要内容：\" class=\"headerlink\" title=\"主要内容：\"></a>主要内容：</h3><h5 id=\"1-Web组件简介\"><a href=\"#1-Web组件简介\" class=\"headerlink\" title=\"1 Web组件简介\"></a>1 Web组件简介</h5><h5 id=\"2-Web组件的组成\"><a href=\"#2-Web组件的组成\" class=\"headerlink\" title=\"2 Web组件的组成\"></a>2 Web组件的组成</h5><h5 id=\"3-Web组件总结\"><a href=\"#3-Web组件总结\" class=\"headerlink\" title=\"3 Web组件总结\"></a>3 Web组件总结</h5><h1 id=\"1-Web组件简介-1\"><a href=\"#1-Web组件简介-1\" class=\"headerlink\" title=\"1 Web组件简介\"></a>1 Web组件简介</h1><p>&emsp;&emsp;<strong>Web组件</strong>（英语：Web Components）是W3C正在向HTML和DOM规范添加的一套标准，它允许在Web文档和Web应用程序中创建可重用的小部件或组件。这样做的目的是将基于组件的软件工程引入万维网。组件模型将允许单个HTML元素的<strong>封装和互操作性</strong>。<br>&emsp;&emsp;作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的HTML（以及相关的样式和脚本），有时您不得不写代码来呈现自定义UI控件，并且如果您不小心的话，多次使用它们会使您的页面变得一团糟。<br>&emsp;&emsp;Web Components旨在解决这些问题——它由三项主要技术组成，它们可以单独或一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。</p>\n<ul>\n<li><strong>Custom elements（自定义元素）</strong>：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。</li>\n<li><strong>Shadow DOM（影子DOM）</strong>：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。</li>\n<li><strong>HTML templates（HTML模板）</strong>：&lt;template&gt; 和 &lt;slot&gt;元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</li>\n<li><strong>HTML Imports</strong>:该标准已被弃用，将用ES6的module代替。</li>\n</ul>\n<p><strong>实现web components的基本方法通常如下所示：</strong></p>\n<ol>\n<li>创建一个类或函数来指定web组件的功能。</li>\n<li>使用 CustomElementRegistry.define() 方法注册您的自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类、以及可选的其所继承自的元素。</li>\n<li>如果需要的话，使用Element.attachShadow() 方法将一个shadow DOM附加到自定义元素上。使用通常的DOM方法向shadow DOM中添加子元素、事件监听器等等。</li>\n<li>如果需要的话，使用&lt;template&gt; 和&lt;slot&gt; 定义一个HTML模板。再次使用常规DOM方法克隆模板并将其附加到您的shadow DOM中。</li>\n<li>在页面任何您喜欢的位置使用自定义元素，就像使用常规HTML元素那样。</li>\n</ol>\n<h1 id=\"2-Web组件的组成-1\"><a href=\"#2-Web组件的组成-1\" class=\"headerlink\" title=\"2 Web组件的组成\"></a>2 Web组件的组成</h1><h2 id=\"2-1-custom-elements（自定义标签）\"><a href=\"#2-1-custom-elements（自定义标签）\" class=\"headerlink\" title=\"2.1 custom elements（自定义标签）\"></a>2.1 custom elements（自定义标签）</h2><p>Web Components 标准非常重要的一个特性是，它使开发者能够将HTML页面的功能封装为 custom elements（自定义标签），而往常，开发者不得不写一大堆冗长、深层嵌套的标签来实现同样的页面功能。<br><strong>下面我们实现一个简单的组件：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义组件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> span=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'span'</span>);</span><br><span class=\"line\">        span.innerText=<span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.append(span);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//注册组件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-world'</span>, HelloWorld);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--使用组件--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">hello-world</span>&gt;</span></span><br><span class=\"line\">或</span><br><span class=\"line\">let hello = document.createElement(\"hello-world\");</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong><br><img src=\"https://img.fengjr.com/image/2019/10/25/2d8140250c99c357a3d0e7629e063cdc.png\" alt></p>\n<p><strong>CustomElementRegistry.define()方法用来注册一个custom element，该方法接受以下参数：</strong></p>\n<ul>\n<li>表示所创建的元素名称的符合 DOMString 标准的字符串。注意，custom element 的名称不能是单个单词，且其中必须要有短横线，用与区别原生的 HTML 元素。</li>\n<li>用于定义元素行为的 类 。</li>\n<li>可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloP</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLParagraphElement</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.innerText=<span class=\"string\">'hello paragraph'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-p'</span>, HelloP,&#123; <span class=\"attr\">extends</span>: <span class=\"string\">'p'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">is</span>=<span class=\"string\">\"hello-p\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">或</span><br><span class=\"line\">let hello = document.createElement(\"p\", &#123; is: \"hello-p\" &#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>共有两种 custom elements:</strong></p>\n<ul>\n<li>Autonomous custom elements 是<strong>独立元素</strong>，它不继承其他内建的HTML元素。你可以直接把它们写成HTML标签的形式，来在页面上使用。</li>\n<li>Customized built-in elements <strong>继承自基本的HTML元素</strong>。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称。</li>\n</ul>\n<h3 id=\"使用生命周期回调函数\"><a href=\"#使用生命周期回调函数\" class=\"headerlink\" title=\"使用生命周期回调函数\"></a>使用生命周期回调函数</h3><p>在custom element的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用：</p>\n<ul>\n<li>connectedCallback：当 custom element首次被插入文档DOM时，被调用。</li>\n<li>disconnectedCallback：当 custom element从文档DOM中删除时，被调用。</li>\n<li>adoptedCallback：当 custom element被移动到新的文档时，被调用。</li>\n<li>attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;hello-world attr=<span class=\"string\">\"hello\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">hello-world</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> observedAttributes() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"string\">'attr'</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> attr = <span class=\"keyword\">this</span>.getAttribute(<span class=\"string\">'attr'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.innerText = attr + <span class=\"string\">' world'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    connectedCallback() &#123;<span class=\"comment\">//加载</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'第一次被连接到文档dom'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    disconnectedCallback() &#123;<span class=\"comment\">//卸载</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'自定义元素与文档DOM断开连接'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    adoptedCallback() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'当自定义元素被移动到新文档时被调用'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    attributeChangedCallback(name, oldValue, newValue) &#123;<span class=\"comment\">//修改</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'被修改。'</span>, name, oldValue, newValue)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> attr = <span class=\"keyword\">this</span>.getAttribute(<span class=\"string\">'attr'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.innerText = attr + <span class=\"string\">' world'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-world'</span>, HelloWorld);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，如果需要在元素属性变化后，触发attributeChangedCallback()回调函数，你必须监听这个属性。这可以通过定义observedAttributes()get函数来实现，observedAttributes()函数体内包含一个return语句，返回一个数组，包含了需要监听的属性名称。</p>\n<h1 id=\"2-2-shadow-DOM（影子DOM）\"><a href=\"#2-2-shadow-DOM（影子DOM）\" class=\"headerlink\" title=\"2.2 shadow DOM（影子DOM）\"></a>2.2 shadow DOM（影子DOM）</h1><p>Shadow DOM允许将隐藏的DOM树添加到常规的DOM树中——它以shadow root为起始根节点，在这个根节点的下方，可以是任意元素，和普通的DOM元素一样。<br><img src=\"https://img.fengjr.com/image/2019/10/23/cdf0ebf83bc2fc85c748178b7024ebc7.png\" alt></p>\n<ul>\n<li>Shadow host： 一个常规 DOM节点，Shadow DOM会被添加到这个节点上。</li>\n<li>Shadow tree：Shadow DOM内部的DOM树。</li>\n<li>Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。</li>\n<li>Shadow root: Shadow tree的根节点。</li>\n</ul>\n<p>&emsp;&emsp;你可以使用同样的方式来操作Shadow DOM，就和操作常规DOM一样，不同的是，Shadow DOM内部的元素始终不会影响到它外部的元素，这为封装提供了便利。<br>&emsp;&emsp;Shadow DOM 都不是一个新事物——在过去的很长一段时间里，浏览器用它来封装一个元素的内部结构，我们可以看一下video标签的Shadow DOM。<br>&emsp;&emsp;浏览器默认隐藏Shadow DOM实现，若要查看，首先打开chrome的开发者工具，然后打开setting，将Show user agent shadow Dom打钩，如下图。<br><img src=\"https://img.fengjr.com/image/2019/10/23/20bd6d5c36f60dbffdc623f4972da530.png\" alt><br>&emsp;&emsp;然后，我们就可以看到 video 标签的真面目了：<br><img src=\"https://img.fengjr.com/image/2019/10/23/d9e68eb2060e6ca3e60cbcb0b6979ea2.png\" alt><br>&emsp;&emsp;我们可以看到上面这些 shadow DOM 中的节点大多都有 pseudo 属性，根据这个属性，你就可以在外面编写 CSS 样式来控制对应的节点样式了。比如，将上面这个 pseudo=”-webkit-media-controls-play-button” 的 input 按钮的背景色改为橙色：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">video</span><span class=\"selector-pseudo\">::-webkit-media-controls-play-button</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">background-color</span>: orange;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;浏览器中还有很多 Element 都使用了 Shadow DOM 的形式进行封装，比如 &lt;input&gt;、&lt;select&gt;、&lt;audio&gt; 等。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>可以使用<strong>Element.attachShadow()</strong>方法来将一个 shadow root 附加到任何一个元素上。它接受一个配置对象作为参数，该对象有一个mode属性，值可以是open或者closed。<br>open 表示你可以通过<strong>Element.shadowRoot</strong>属性获取 Shadow DOM，closed的话返回是null<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//&lt;div id=\"container\" &gt;&lt;/div&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> container=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> shadow=container.attachShadow(&#123;<span class=\"attr\">mode</span>:<span class=\"string\">'open'</span>&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'shadow:'</span>,container.shadowRoot)<span class=\"comment\">//shadow: #shadow-root (open)</span></span><br></pre></td></tr></table></figure></p>\n<p>如果你想将一个Shadow DOM添加到 custom element上，可以在 custom element的构造函数添加如下实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> shadow = <span class=\"keyword\">this</span>.attachShadow(&#123;<span class=\"attr\">mode</span>: <span class=\"string\">'open'</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>下面我们看一个实例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> shadow = <span class=\"keyword\">this</span>.attachShadow(&#123;<span class=\"attr\">mode</span>: <span class=\"string\">'open'</span>&#125;);</span><br><span class=\"line\">            <span class=\"comment\">//创建任意标签</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> span=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'span'</span>);</span><br><span class=\"line\">            span.innerText=<span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">            <span class=\"comment\">//创建样式</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> style=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'style'</span>);</span><br><span class=\"line\">            style.textContent=<span class=\"string\">'span&#123;color:red&#125;'</span>;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            shadow.append(style);</span><br><span class=\"line\">            shadow.append(span);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-world'</span>, HelloWorld);</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://img.fengjr.com/image/2019/10/25/103b301fcc820410e3a46b0fc242ab30.png\" alt></p>\n<h1 id=\"2-3-HTML-templates（HTML模板）\"><a href=\"#2-3-HTML-templates（HTML模板）\" class=\"headerlink\" title=\"2.3 HTML templates（HTML模板）\"></a>2.3 HTML templates（HTML模板）</h1><h3 id=\"关于模板-Templates\"><a href=\"#关于模板-Templates\" class=\"headerlink\" title=\"关于模板 (Templates)\"></a>关于模板 (Templates)</h3><p>当在网页上重复使用相同的标记结构时，肯定是某种模板而不是一遍又一遍地重复复制。但使用HTML &lt;template&gt; 元素更容易实现(这在现代浏览器中得到了很好的支持)。 此元素及其内容不会在DOM中呈现，但仍可使用JavaScript去引用它。<br>下面是一个使用template模板的例子：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--定义模板--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">\"my-paragraph\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>My paragraph<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用模板</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> template = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'my-paragraph'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> templateContent = template.content;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(templateContent);</span><br></pre></td></tr></table></figure>\n<h3 id=\"在Web-Components中使用模板\"><a href=\"#在Web-Components中使用模板\" class=\"headerlink\" title=\"在Web Components中使用模板\"></a>在Web Components中使用模板</h3><p>使用模板，我们创建web组件就更加简单了，实例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">\"template\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">        span&#123;</span><br><span class=\"line\">            color: red;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">hello-world</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">HTMLElement</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> shadow = <span class=\"keyword\">this</span>.attachShadow(&#123;<span class=\"attr\">mode</span>: <span class=\"string\">'open'</span>&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> template = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'template'</span>); <span class=\"comment\">//获取模板</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = template.content.cloneNode(<span class=\"literal\">true</span>);<span class=\"comment\">//复制模板</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> span=content.querySelector(<span class=\"string\">'span'</span>);<span class=\"comment\">//获取span</span></span><br><span class=\"line\">            span.innerText=<span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">            shadow.append(content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.customElements.define(<span class=\"string\">'hello-world'</span>, HelloWorld);</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://img.fengjr.com/image/2019/10/25/fa7a633ca1acc134bb685030175d4432.png\" alt></p>\n<h1 id=\"3-Web组件总结-1\"><a href=\"#3-Web组件总结-1\" class=\"headerlink\" title=\"3 Web组件总结\"></a>3 Web组件总结</h1><h3 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h3><ol>\n<li>原生，无需框架；</li>\n<li>易于集成，无需转换；</li>\n<li>真正的作用域 CSS；</li>\n<li>标准化，只有 HTML、CSS 和 JavaScript。</li>\n<li>互操作性<br>react和vue仅限于他们的生态内，不能在vue中调用react组件，也不能在react中用vue组件。但是webComponents可以超越框架而存在，可以在不同的技术栈中使用。可以在react，vue中使用，也可以在原生js使用。且不用考虑react或者vue升级，改变公共组件。</li>\n<li>寿命<br>因为组件的互操作性，它们将有更长的寿命，基本不需要为了适应新的技术而重写。</li>\n<li>移植性<br>组件可以在任何地方使用，因为很少甚至没有依赖，组件的使用障碍要明显低于依赖库或者框架的组件<br>原生代码可以为你带来与框架相同的功能，但性能更强、需要的代码更少，更加简洁。</li>\n</ol>\n<h3 id=\"坏处\"><a href=\"#坏处\" class=\"headerlink\" title=\"坏处\"></a>坏处</h3><ol>\n<li>数据绑定</li>\n<li>状态管理</li>\n<li>兼容性，需要引入polyfill，Shady CSS polyfill，webcomponents-loader</li>\n<li>全局注入</li>\n</ol>\n<h3 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h3><p>&emsp;&emsp; 对于大型项目而言，直接用web Components开发是不显示的，必然需要一定的库来简化开发和管理状态，例如Polymer。Web Component编码工具会更像编译器而非框架。目前前端框架仍然由三巨头（React、Vue、Angular）占领，Web Components能否有所突破还要靠时间来检验。</p>\n"},{"title":"koa2框架介绍及搭建","comments":1,"date":"2019-09-18T08:06:59.000Z","author":"jun.zhou","_content":"\n# 一、koa简介\nKoa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。\n\n# 二、koa2的优势\n\n#### 1. express\n虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：\n\n```\napp.get('/test', function (req, res) {\n    fs.readFile('/file1', function (err, data) {\n        if (err) {\n            res.status(500).send('read file1 error');\n        }\n        fs.readFile('/file2', function (err, data) {\n            if (err) {\n                res.status(500).send('read file2 error');\n            }\n            res.type('text/plain');\n            res.send(data);\n        });\n    });\n});\n```\n\n#### 2. koa 1.0\n随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.0使用generator实现异步，代码看起来像同步的：\n\n```\nvar koa = require('koa');\nvar app = koa();\n\napp.use('/test', function *() {\n    yield doReadFile1();\n    var data = yield doReadFile2();\n    this.body = data;\n});\n\napp.listen(3000);\n```\n\n#### 3. koa 2.0\n随着ES7引入了新的语法糖async和await，JavaScript未来标准的异步代码是这样的\n\n```\nasync function () {\n    var data = await fs.read('/file1');\n}\n```\n\nkoa团队并没有止步于koa 1.0，他们非常超前地基于ES7开发了koa2。koa2的代码看上去像这样：\n\n```\napp.use(async (ctx, next) => {\n    await next();\n    var data = await doReadFile();\n    ctx.response.type = 'text/plain';\n    ctx.response.body = data;\n});\n```\n#### 4. 中间件的执行顺序\nkoa的中间件是由generator组成的，这决定了中间件的执行顺序。\nExpress的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。\n\nkoa是从第一个中间件开始执行，遇到<code>next</code>进入下一个中间件，一直执行到最后一个中间件，在逆序，执行上一个中间件<code>next</code>之后的代码，一直到第一个中间件执行结束才发出响应。\n```\nconst one = (ctx, next) => {\n  console.log('>> one');\n  next();\n  console.log('<< one');\n}\n \nconst two = (ctx, next) => {\n  console.log('>> two');\n  next();\n  console.log('<< two');\n}\n \nconst three = (ctx, next) => {\n  console.log('>> three');\n  next();\n  console.log('<< three');\n}\n \napp.use(one);\napp.use(two);\napp.use(three);\n \n输出结果：\n>> one\n>> two\n>> three\n<< three\n<< two\n<< one\n```\n\n# 三、koa2入门及搭建\n\n#### 1. Context\nContext封装了node中的request和response。\n\nkoa@1.x使用this引用Context对象：\n\n```\napp.use(function *(){\n  this.body = 'Hello World';\n});\n```\n\nkoa@2.x中使用ctx来访问Context对象：\n\n```\napp.use(async (ctx, next) => {\n  await next();\n  ctx.body = 'Hello World';\n});\n```\n\n#### 2. 创建koa2工程\n首先，我们创建一个目录hello-koa并作为工程目录用VS Code打开。然后，我们创建app.js，输入以下代码：\n\n```\n// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:\nconst Koa = require('koa');\n\n// 创建一个Koa对象表示web app本身:\nconst app = new Koa();\n\n// 对于任何请求，app将调用该异步函数处理请求：\napp.use(async (ctx, next) => {\n  await next();\n  ctx.response.type = 'text/html';\n  ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n\n// 在端口3000监听:\napp.listen(3000);\nconsole.log('app started at port 3000...');\n\n```\n\n对于每一个http请求，koa将调用我们传入的异步函数来处理：\n\n```\nasync (ctx, next) => {\n  await next();\n  // 设置response的Content-Type:\n  ctx.response.type = 'text/html';\n  // 设置response的内容:\n  ctx.response.body = '<h1>Hello, koa2!</h1>';\n}\n```\n\n其中，参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，next是koa传入的将要处理的下一个异步函数。\n\n上面的异步函数中，我们首先用await next();处理下一个异步函数，然后，设置response的Content-Type和内容。\n\n由async标记的函数称为异步函数，在异步函数中，可以用await调用另一个异步函数，这两个关键字将在ES7中引入。\n\n现在我们遇到第一个问题：koa这个包怎么装，app.js才能正常导入它？\n\n在hello-koa这个目录下创建一个package.json，这个文件描述了我们的hello-koa工程会用到哪些包。完整的文件内容如下：\n\n```\n{\n  \"name\": \"hello-koa2\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Hello Koa 2 example with async\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n      \"start\": \"node app.js\"\n  },\n  \"keywords\": [\n      \"koa\",\n      \"async\"\n  ],\n  \"author\": \"\",\n  \"license\": \"Apache-2.0\",\n  \"repository\": {\n      \"type\": \"git\",\n      \"url\": \"\"\n  },\n  \"dependencies\": {\n      \"koa\": \"2.0.0\"\n  }\n}\n```\n\n然后，我们在hello-koa目录下执行npm install就可以把所需包以及依赖包一次性全部装好。\n现在，我们的工程结构如下：\n```\nhello-koa/\n|\n+- app.js <-- 使用koa的js\n|\n+- package.json <-- 项目描述文件\n|\n+- node_modules/ <-- npm安装的所有依赖包\n```\n\n在控制台执行 npm run start,我们打开浏览器，输入http://localhost:3000，即可看到效果：\n\n#### 3. koa middleware\n让我们再仔细看看koa的执行逻辑。核心代码是：\n```\napp.use(async (ctx, next) => {\n  await next();\n  ctx.response.type = 'text/html';\n  ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n```\n每收到一个http请求，koa就会调用通过app.use()注册的async函数，并传入ctx和next参数。\n\n我们可以对ctx操作，并设置返回内容。但是为什么要调用await next()？\n\n原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。\n\n例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：\n\n```\napp.use(async (ctx, next) => {\n  console.log(`${ctx.request.method} ${ctx.request.url}`); // 打印URL\n  await next(); // 调用下一个middleware\n});\n\napp.use(async (ctx, next) => {\n  const start = new Date().getTime(); // 当前时间\n  await next(); // 调用下一个middleware\n  const ms = new Date().getTime() - start; // 耗费时间\n  console.log(`Time: ${ms}ms`); // 打印耗费时间\n});\n\napp.use(async (ctx, next) => {\n  await next();\n  ctx.response.type = 'text/html';\n  ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n```\nmiddleware的顺序很重要，也就是调用app.use()的顺序决定了middleware的顺序。\n\n此外，如果一个middleware没有调用await next()，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：\n\n```\napp.use(async (ctx, next) => {\n  if (await checkUserPermission(ctx)) {\n    await next();\n  } else {\n    ctx.response.status = 403;\n  }\n});\n```\n理解了middleware，我们就已经会用koa了！\n\n最后注意ctx对象有一些简写的方法，例如ctx.url相当于ctx.request.url，ctx.type相当于ctx.response.type。\n\n# 四、处理URL\n\n在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。\n正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：\n\n```\napp.use(async (ctx, next) => {\n  if (ctx.request.path === '/') {\n    ctx.response.body = 'index page';\n  } else {\n    await next();\n  }\n});\n\napp.use(async (ctx, next) => {\n  if (ctx.request.path === '/test') {\n    ctx.response.body = 'TEST page';\n  } else {\n    await next();\n  }\n});\n\napp.use(async (ctx, next) => {\n  if (ctx.request.path === '/error') {\n    ctx.response.body = 'ERROR page';\n  } else {\n    await next();\n  }\n});\n```\n这么写是可以运行的，但是好像有点蠢。\n\n应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。\n\n#### 1. koa-router\n\n为了处理URL，我们需要引入koa-router这个middleware，让它负责处理URL映射。\n\n我们把上一节的hello-koa工程复制一份，重命名为url-koa。\n\n先在package.json中添加依赖项：\n```\n\"koa-router\": \"7.0.0\"\n```\n然后用npm install安装。\n\n接下来，我们修改app.js，使用koa-router来处理URL：\n\n```\nconst Koa = require('koa');\n\n// 注意require('koa-router')返回的是函数:\nconst router = require('koa-router')();\n\nconst app = new Koa();\n\n// log request URL:\napp.use(async (ctx, next) => {\n  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);\n  await next();\n});\n\n// add url-route:\nrouter.get('/hello/:name', async (ctx, next) => {\n  var name = ctx.params.name;\n  ctx.response.body = `<h1>Hello, ${name}!</h1>`;\n});\n\nrouter.get('/', async (ctx, next) => {\n    ctx.response.body = '<h1>Index</h1>';\n});\n\n// add router middleware:\napp.use(router.routes());\n\napp.listen(3000);\nconsole.log('app started at port 3000...');\n```\n\n然后，我们使用router.get('/path', async fn)来注册一个GET请求。可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问。\n\n再运行app.js，我们就可以测试不同的URL。\n\n#### 2. 处理post请求\n\n用router.get('/path', async fn)处理的是get请求。如果要处理post请求，可以用router.post('/path', async fn)。\n\n用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！\n\n所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。\n\nkoa-bodyparser就是用来干这个活的。\n\n我们在package.json中添加依赖项：\n```\n\"koa-bodyparser\": \"3.2.0\"\n```\n然后使用npm install安装。\n\n下面，修改app.js，引入koa-bodyparser：\n```\nconst bodyParser = require('koa-bodyparser');\n```\n在合适的位置加上：\n```\napp.use(bodyParser());\n```\n\n由于middleware的顺序很重要，这个koa-bodyparser必须在router之前被注册到app对象上。\n\n现在我们就可以处理post请求了。写一个简单的登录表单：\n```\nrouter.get('/', async (ctx, next) => {\n  ctx.response.body = `<h1>Index</h1>\n      <form action=\"/signin\" method=\"post\">\n          <p>Name: <input name=\"name\" value=\"koa\"></p>\n          <p>Password: <input name=\"password\" type=\"password\"></p>\n          <p><input type=\"submit\" value=\"Submit\"></p>\n      </form>`;\n});\n\nrouter.post('/signin', async (ctx, next) => {\n  var\n    name = ctx.request.body.name || '',\n    password = ctx.request.body.password || '';\n  console.log(`signin with name: ${name}, password: ${password}`);\n  if (name === 'koa' && password === '12345') {\n    ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\n  } else {\n    ctx.response.body = `<h1>Login failed!</h1>\n    <p><a href=\"/\">Try again</a></p>`;\n  }\n});\n```\n注意到我们用var name = ctx.request.body.name || ''拿到表单的name字段，如果该字段不存在，默认值设置为''。\n\n类似的，put、delete、head请求也可以由router处理。\n\n#### 3. 重构\n现在，我们已经可以处理不同的URL了，但是看看app.js，总觉得还是有点不对劲。\n\n所有的URL处理函数都放到app.js里显得很乱，而且，每加一个URL，就需要修改app.js。随着URL越来越多，app.js就会越来越长。\n\n如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让app.js自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：\n```\n+- controllers/\n|  |\n|  +- login.js <-- 处理login相关URL\n|  |\n|  +- users.js <-- 处理用户管理相关URL\n|\n+- app.js <-- 使用koa的js\n|\n+- package.json <-- 项目描述文件\n|\n+- node_modules/ <-- npm安装的所有依赖包\n```\n\n我们先在controllers目录下编写index.js：\n```\nvar fn_index = async (ctx, next) => {\n  ctx.response.body = `<h1>Index</h1>\n      <form action=\"/signin\" method=\"post\">\n          <p>Name: <input name=\"name\" value=\"koa\"></p>\n          <p>Password: <input name=\"password\" type=\"password\"></p>\n          <p><input type=\"submit\" value=\"Submit\"></p>\n      </form>`;\n};\n\nvar fn_signin = async (ctx, next) => {\n  var\n    name = ctx.request.body.name || '',\n    password = ctx.request.body.password || '';\n  console.log(`signin with name: ${name}, password: ${password}`);\n  if (name === 'koa' && password === '12345') {\n    ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\n  } else {\n    ctx.response.body = `<h1>Login failed!</h1>\n    <p><a href=\"/\">Try again</a></p>`;\n  }\n};\n\nmodule.exports = {\n  'GET /': fn_index,\n  'POST /signin': fn_signin\n};\n```\n\n这个index.js通过module.exports把两个URL处理函数暴露出来。\n\n类似的，hello.js把一个URL处理函数暴露出来：\n```\nvar fn_hello = async (ctx, next) => {\n  var name = ctx.params.name;\n  ctx.response.body = `<h1>Hello, ${name}!</h1>`;\n};\n\nmodule.exports = {\n  'GET /hello/:name': fn_hello\n};\n```\n\n现在，我们修改app.js，让它自动扫描controllers目录，找到所有js文件，导入，然后注册每个URL：\n\n```\n// 先导入fs模块，然后用readdirSync列出文件\n// 这里可以用sync是因为启动时只运行一次，不存在性能问题:\nvar files = fs.readdirSync(__dirname + '/controllers');\n\n// 过滤出.js文件:\nvar js_files = files.filter((f)=>{\n  return f.endsWith('.js');\n});\n\n// 处理每个js文件:\nfor (var f of js_files) {\n  console.log(`process controller: ${f}...`);\n  // 导入js文件:\n  let mapping = require(__dirname + '/controllers/' + f);\n  for (var url in mapping) {\n    if (url.startsWith('GET ')) {\n      // 如果url类似\"GET xxx\":\n      var path = url.substring(4);\n      router.get(path, mapping[url]);\n      console.log(`register URL mapping: GET ${path}`);\n    } else if (url.startsWith('POST ')) {\n      // 如果url类似\"POST xxx\":\n      var path = url.substring(5);\n      router.post(path, mapping[url]);\n      console.log(`register URL mapping: POST ${path}`);\n    } else {\n      // 无效的URL:\n      console.log(`invalid URL: ${url}`);\n    }\n  }\n}\n```\n\n如果上面的大段代码看起来还是有点费劲，那就把它拆成更小单元的函数：\n\n```\nfunction addMapping(router, mapping) {\n  for (var url in mapping) {\n    if (url.startsWith('GET ')) {\n      var path = url.substring(4);\n      router.get(path, mapping[url]);\n      console.log(`register URL mapping: GET ${path}`);\n    } else if (url.startsWith('POST ')) {\n      var path = url.substring(5);\n      router.post(path, mapping[url]);\n      console.log(`register URL mapping: POST ${path}`);\n    } else {\n      console.log(`invalid URL: ${url}`);\n    }\n  }\n}\n\nfunction addControllers(router) {\n  var files = fs.readdirSync(__dirname + '/controllers');\n  var js_files = files.filter((f) => {\n      return f.endsWith('.js');\n  });\n\n  for (var f of js_files) {\n      console.log(`process controller: ${f}...`);\n      let mapping = require(__dirname + '/controllers/' + f);\n      addMapping(router, mapping);\n  }\n}\n\naddControllers(router);\n```\n\n确保每个函数功能非常简单，一眼能看明白，是代码可维护的关键。\n\n#### Controller Middleware\n最后，我们把扫描controllers目录和创建router的代码从app.js中提取出来，作为一个简单的middleware使用，命名为controller.js：\n\n```\nconst fs = require('fs');\n\nfunction addMapping(router, mapping) {\n    ...\n}\n\nfunction addControllers(router, dir) {\n    ...\n}\n\nmodule.exports = function (dir) {\n  let\n      controllers_dir = dir || 'controllers', // 如果不传参数，扫描目录默认为'controllers'\n      router = require('koa-router')();\n  addControllers(router, controllers_dir);\n  return router.routes();\n};\n```\n\n这样一来，我们在app.js的代码又简化了：\n\n```\n...\n\n// 导入controller middleware:\nconst controller = require('./controller');\n\n...\n\n// 使用middleware:\napp.use(controller());\n\n...\n```\n\n经过重新整理后的工程url2-koa目前具备非常好的模块化，所有处理URL的函数按功能组存放在controllers目录，今后我们也只需要不断往这个目录下加东西就可以了，app.js保持不变。\n\n# 五、使用Nunjucks模板引擎\n\n模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。\n有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？\n因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。\n输出HTML有几个特别重要的问题需要考虑：\n\n#### 转义\n对特殊字符要转义，避免受到XSS攻击。比如，如果变量name的值不是小明，而是小明<script>...</script>，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。\n\n#### 格式化\n对不同类型的变量要格式化，比如，货币需要变成12,345.00这样的格式，日期需要变成2016-01-01这样的格式。\n\n#### 简单逻辑\n模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：\n\n```\n{{ name }}同学，\n{% if score >= 90 %}\n    成绩优秀，应该奖励\n{% elif score >=60 %}\n    成绩良好，继续努力\n{% else %}\n    不及格，建议回家打屁股\n{% endif %}\n```\n所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。\n\n#### Nunjucks\n我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。\n\n虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：\n\n```\nfunction render(view, model) {\n    // TODO:...\n}\n```\n\n其中，view是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。model就是数据，在JavaScript中，它就是一个简单的Object。render函数返回一个字符串，就是模板的输出。\n\n下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。\n\n我们创建一个use-nunjucks的VS Code工程结构如下：\n\n```\nuse-nunjucks/\n|\n+- views/\n|  |\n|  +- hello.html <-- HTML模板文件\n|\n+- app.js <-- 入口js\n|\n+- package.json <-- 项目描述文件\n|\n+- node_modules/ <-- npm安装的所有依赖包\n```\n\n其中，模板文件存放在views目录中。\n\n我们先在package.json中添加nunjucks的依赖：\n```\n\"nunjucks\": \"2.4.2\"\n```\n注意，模板引擎是可以独立使用的，并不需要依赖koa。用npm install安装所有依赖包。\n\n紧接着，我们要编写使用Nunjucks的函数render。怎么写？方法是查看[Nunjucks](http://mozilla.github.io/nunjucks/)的官方文档，仔细阅读后，在app.js中编写代码如下：\n\n```\nconst nunjucks = require('nunjucks');\n\nfunction createEnv(path, opts) {\n    var\n        autoescape = opts.autoescape === undefined ? true : opts.autoescape,\n        noCache = opts.noCache || false,\n        watch = opts.watch || false,\n        throwOnUndefined = opts.throwOnUndefined || false,\n        env = new nunjucks.Environment(\n            new nunjucks.FileSystemLoader('views', {\n                noCache: noCache,\n                watch: watch,\n            }), {\n                autoescape: autoescape,\n                throwOnUndefined: throwOnUndefined\n            });\n    if (opts.filters) {\n        for (var f in opts.filters) {\n            env.addFilter(f, opts.filters[f]);\n        }\n    }\n    return env;\n}\n\nvar env = createEnv('views', {\n    watch: true,\n    filters: {\n        hex: function (n) {\n            return '0x' + n.toString(16);\n        }\n    }\n});\n```\n\n变量env就表示Nunjucks模板引擎对象，它有一个render(view, model)方法，正好传入view和model两个参数，并返回字符串。\n\n创建env需要的参数可以查看文档获知。我们用autoescape = opts.autoescape && true这样的代码给每个参数加上默认值，最后使用new nunjucks.FileSystemLoader('views')创建一个文件系统加载器，从views目录读取模板。\n\n我们编写一个hello.html模板文件，放到views目录下，内容如下：\n```\n<h1>Hello {{ name }}</h1>\n```\n然后，我们就可以用下面的代码来渲染这个模板：\n```\nvar s = env.render('hello.html', { name: '小明' });\nconsole.log(s);\n```\n获得输出如下：\n```\n<h1>Hello 小明</h1>\n```\n\n咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：\n```\nvar s = env.render('hello.html', { name: '<script>alert(\"小明\")</script>' });\nconsole.log(s);\n```\n获得输出如下：\n```\n<h1>Hello &lt;script&gt;alert(\"小明\")&lt;/script&gt;</h1>\n```\n这样就避免了输出恶意脚本。\n\n此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：\n```\n<!-- 循环输出名字 -->\n<body>\n    <h3>Fruits List</h3>\n    {% for f in fruits %}\n    <p>{{ f }}</p>\n    {% endfor %}\n</body>\n```\n\nNunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。\n\n更好的方式是使用继承。先定义一个基本的网页框架base.html：\n\n```\n<html><body>\n{% block header %} <h3>Unnamed</h3> {% endblock %}\n{% block body %} <div>No body</div> {% endblock %}\n{% block footer %} <div>copyright</div> {% endblock %}\n</body>\n```\nbase.html定义了三个可编辑的块，分别命名为header、body和footer。子模板可以有选择地对块进行重新定义：\n```\n{% extends 'base.html' %}\n\n{% block header %}<h1>{{ header }}</h1>{% endblock %}\n\n{% block body %}<p>{{ body }}</p>{% endblock %}\n```\n\n然后，我们对子模板进行渲染：\n```\nconsole.log(env.render('extend.html', {\n    header: 'Hello',\n    body: 'bla bla bla...'\n}));\n```\n\n输出HTML如下：\n```\n<html><body>\n<h1>Hello</h1>\n<p>bla bla bla...</p>\n<div>copyright</div> <-- footer没有重定义，所以仍使用父模板的内容\n</body>\n```\n#### 性能\n最后我们要考虑一下Nunjucks的性能。\n\n对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。\n\n性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。\n\n好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了noCache: false这个参数。\n\n在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。\n\nNunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。\n\n# 六、使用MVC\n\n我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！\n\n当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：\n```\nctx.render('home.html', { name: 'Michael' });\n```\n通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了。\n\n![](https://img.fengjr.com/image/2019/09/18/3b40147c96c8b17cb2564c782f90bd40.png)\n\n这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。\n\n异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；\n\n包含变量{{ name }}的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。\n\nMVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。\n\n上面的例子中，Model就是一个JavaScript对象：\n```\n{ name: 'Michael' }\n```\n下面，我们根据原来的项目创建工程，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为ctx.render(view, model)的方式。\n\n工程结构如下：\n```\nview-koa/\n|\n+- controllers/ <-- Controller\n|\n+- views/ <-- html模板文件\n|\n+- static/ <-- 静态资源文件\n|\n+- controller.js <-- 扫描注册Controller\n|\n+- app.js <-- 使用koa的js\n|\n+- package.json <-- 项目描述文件\n|\n+- node_modules/ <-- npm安装的所有依赖包\n```\n\n先用npm install安装依赖包。\n\n然后，我们准备编写以下两个Controller：\n\n#### 处理首页 GET /\n我们定义一个async函数处理首页URL/：\n```\nasync (ctx, next) => {\n    ctx.render('index.html', {\n        title: 'Welcome'\n    });\n}\n```\n注意到koa并没有在ctx对象上提供render方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用ctx.render(view, model)就完成了页面输出。\n\n#### 处理登录请求 POST /signin\n我们再定义一个async函数处理登录请求/signin：\n```\nasync (ctx, next) => {\n    var\n        email = ctx.request.body.email || '',\n        password = ctx.request.body.password || '';\n    if (email === 'admin@example.com' && password === '123456') {\n        // 登录成功:\n        ctx.render('signin-ok.html', {\n            title: 'Sign In OK',\n            name: 'Mr Node'\n        });\n    } else {\n        // 登录失败:\n        ctx.render('signin-failed.html', {\n            title: 'Sign In Failed'\n        });\n    }\n}\n```\n\n由于登录请求是一个POST，我们就用ctx.request.body.<name>拿到POST请求的数据，并给一个默认值。\n\n登录成功时我们用signin-ok.html渲染，登录失败时我们用signin-failed.html渲染，所以，我们一共需要以下3个View：\n\n- base.html\n- signin-ok.html\n- signin-failed.html\n\n\n\n#### 集成Nunjucks\n集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给ctx对象绑定一个render(view, model)的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。\n\n我们创建一个templating.js来实现这个middleware：\n```\nconst nunjucks = require('nunjucks');\n\nfunction createEnv(path, opts) {\n    var\n        autoescape = opts.autoescape === undefined ? true : opts.autoescape,\n        noCache = opts.noCache || false,\n        watch = opts.watch || false,\n        throwOnUndefined = opts.throwOnUndefined || false,\n        env = new nunjucks.Environment(\n            new nunjucks.FileSystemLoader(path || 'views', {\n                noCache: noCache,\n                watch: watch,\n            }), {\n                autoescape: autoescape,\n                throwOnUndefined: throwOnUndefined\n            });\n    if (opts.filters) {\n        for (var f in opts.filters) {\n            env.addFilter(f, opts.filters[f]);\n        }\n    }\n    return env;\n}\n\nfunction templating(path, opts) {\n    // 创建Nunjucks的env对象:\n    var env = createEnv(path, opts);\n    return async (ctx, next) => {\n        // 给ctx绑定render函数:\n        ctx.render = function (view, model) {\n            // 把render后的内容赋值给response.body:\n            ctx.response.body = env.render(view, Object.assign({}, ctx.state || {}, model || {}));\n            // 设置Content-Type:\n            ctx.response.type = 'text/html';\n        };\n        // 继续处理请求:\n        await next();\n    };\n}\n\nmodule.exports = templating;\n```\n\n注意到createEnv()函数和前面使用Nunjucks时编写的函数是一模一样的。我们主要关心tempating()函数，它会返回一个middleware，在这个middleware中，我们只给ctx“安装”了一个render()函数，其他什么事情也没干，就继续调用下一个middleware。\n\n使用的时候，我们在app.js添加如下代码：\n\n```\nconst isProduction = process.env.NODE_ENV === 'production';\n\napp.use(templating('views', {\n    noCache: !isProduction,\n    watch: !isProduction\n}));\n```\n\n这里我们定义了一个常量isProduction，它判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。\n\nNode.js在全局变量process中定义了一个环境变量env.NODE_ENV，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为'development'，而部署到服务器时，环境变量应该设置为'production'。在编写代码的时候，要根据当前环境作不同的判断。\n\n注意：生产环境上必须配置环境变量NODE_ENV = 'production'，而开发环境不需要配置，实际上NODE_ENV可能是undefined，所以判断的时候，不要用NODE_ENV === 'development'。\n\n这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。\n\n#### 编写View\n在编写View的时候，非常有必要先编写一个base.html作为骨架，其他模板都继承自base.html，这样，才能大大减少重复工作。\n\n编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了base.html。\n\nbase.html\n```\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <meta name=\"description\" content=\"learn javascript\">\n    <title>{{ title }}</title>\n</head>\n\n<body>\n  <header style=\"background-color:#6f5499;height: 100px;color: #fff;\">\n      header top main\n  </header>\n  {% block main %} {% endblock %}\n  <footer style=\"background-color:#ddd; padding: 20px 0;text-align: center;color: #666;\">\n      copy right @2019\n  </footer>\n</body>\n\n</html>\n```\n\nsignin-ok.html\n```\n{% extends \"base.html\" %} \n{% block main %}\n\n<div>\n  <h1>Sign in success!</h1>\n  <div class=\"alert alert-danger\"> \n    <strong>This is post login name: {{ title }}</strong>\n  </div>\n  <ul>\n    {% for f in data %}\n      {% if f.age < 10 %}\n        <li>postValue: 00000</li>\n      {% elif f.age == 10 %}\n        <li>postValue: 10</li>\n      {% else %}\n        <li>postValue: {{ f.name }}</li>\n      {% endif %}\n    {% endfor %}\n  </ul>\n</div>\n\n{% endblock %}\n```\n\n#### 运行\n一切顺利的话，这个view-koa工程应该可以顺利运行。运行前，我们再检查一下app.js里的middleware的顺序：\n\n第一个middleware是记录URL以及页面执行时间：\n```\napp.use(async (ctx, next) => {\n    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);\n    var\n        start = new Date().getTime(),\n        execTime;\n    await next();\n    execTime = new Date().getTime() - start;\n    ctx.response.set('X-Response-Time', `${execTime}ms`);\n});\n```\n\n第二个middleware解析POST请求：\n```\napp.use(bodyParser());\n```\n第三个middleware负责给ctx加上render()来使用Nunjucks：\n```\napp.use(templating('view', {\n    noCache: !isProduction,\n    watch: !isProduction\n}));\n```\n最后一个middleware处理URL路由：\n```\napp.use(controller());\n```\n\n现在，在VS Code中运行代码，不出意外的话，在浏览器输入localhost:3000/，可以看到效果。","source":"_posts/2019-09-18-koa2.md","raw":"---\ntitle: koa2框架介绍及搭建\ncomments: true\ndate: 2019-09-18 16:06:59\ntags:\n- es6\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n# 一、koa简介\nKoa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。\n\n# 二、koa2的优势\n\n#### 1. express\n虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：\n\n```\napp.get('/test', function (req, res) {\n    fs.readFile('/file1', function (err, data) {\n        if (err) {\n            res.status(500).send('read file1 error');\n        }\n        fs.readFile('/file2', function (err, data) {\n            if (err) {\n                res.status(500).send('read file2 error');\n            }\n            res.type('text/plain');\n            res.send(data);\n        });\n    });\n});\n```\n\n#### 2. koa 1.0\n随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.0使用generator实现异步，代码看起来像同步的：\n\n```\nvar koa = require('koa');\nvar app = koa();\n\napp.use('/test', function *() {\n    yield doReadFile1();\n    var data = yield doReadFile2();\n    this.body = data;\n});\n\napp.listen(3000);\n```\n\n#### 3. koa 2.0\n随着ES7引入了新的语法糖async和await，JavaScript未来标准的异步代码是这样的\n\n```\nasync function () {\n    var data = await fs.read('/file1');\n}\n```\n\nkoa团队并没有止步于koa 1.0，他们非常超前地基于ES7开发了koa2。koa2的代码看上去像这样：\n\n```\napp.use(async (ctx, next) => {\n    await next();\n    var data = await doReadFile();\n    ctx.response.type = 'text/plain';\n    ctx.response.body = data;\n});\n```\n#### 4. 中间件的执行顺序\nkoa的中间件是由generator组成的，这决定了中间件的执行顺序。\nExpress的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。\n\nkoa是从第一个中间件开始执行，遇到<code>next</code>进入下一个中间件，一直执行到最后一个中间件，在逆序，执行上一个中间件<code>next</code>之后的代码，一直到第一个中间件执行结束才发出响应。\n```\nconst one = (ctx, next) => {\n  console.log('>> one');\n  next();\n  console.log('<< one');\n}\n \nconst two = (ctx, next) => {\n  console.log('>> two');\n  next();\n  console.log('<< two');\n}\n \nconst three = (ctx, next) => {\n  console.log('>> three');\n  next();\n  console.log('<< three');\n}\n \napp.use(one);\napp.use(two);\napp.use(three);\n \n输出结果：\n>> one\n>> two\n>> three\n<< three\n<< two\n<< one\n```\n\n# 三、koa2入门及搭建\n\n#### 1. Context\nContext封装了node中的request和response。\n\nkoa@1.x使用this引用Context对象：\n\n```\napp.use(function *(){\n  this.body = 'Hello World';\n});\n```\n\nkoa@2.x中使用ctx来访问Context对象：\n\n```\napp.use(async (ctx, next) => {\n  await next();\n  ctx.body = 'Hello World';\n});\n```\n\n#### 2. 创建koa2工程\n首先，我们创建一个目录hello-koa并作为工程目录用VS Code打开。然后，我们创建app.js，输入以下代码：\n\n```\n// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:\nconst Koa = require('koa');\n\n// 创建一个Koa对象表示web app本身:\nconst app = new Koa();\n\n// 对于任何请求，app将调用该异步函数处理请求：\napp.use(async (ctx, next) => {\n  await next();\n  ctx.response.type = 'text/html';\n  ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n\n// 在端口3000监听:\napp.listen(3000);\nconsole.log('app started at port 3000...');\n\n```\n\n对于每一个http请求，koa将调用我们传入的异步函数来处理：\n\n```\nasync (ctx, next) => {\n  await next();\n  // 设置response的Content-Type:\n  ctx.response.type = 'text/html';\n  // 设置response的内容:\n  ctx.response.body = '<h1>Hello, koa2!</h1>';\n}\n```\n\n其中，参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，next是koa传入的将要处理的下一个异步函数。\n\n上面的异步函数中，我们首先用await next();处理下一个异步函数，然后，设置response的Content-Type和内容。\n\n由async标记的函数称为异步函数，在异步函数中，可以用await调用另一个异步函数，这两个关键字将在ES7中引入。\n\n现在我们遇到第一个问题：koa这个包怎么装，app.js才能正常导入它？\n\n在hello-koa这个目录下创建一个package.json，这个文件描述了我们的hello-koa工程会用到哪些包。完整的文件内容如下：\n\n```\n{\n  \"name\": \"hello-koa2\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Hello Koa 2 example with async\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n      \"start\": \"node app.js\"\n  },\n  \"keywords\": [\n      \"koa\",\n      \"async\"\n  ],\n  \"author\": \"\",\n  \"license\": \"Apache-2.0\",\n  \"repository\": {\n      \"type\": \"git\",\n      \"url\": \"\"\n  },\n  \"dependencies\": {\n      \"koa\": \"2.0.0\"\n  }\n}\n```\n\n然后，我们在hello-koa目录下执行npm install就可以把所需包以及依赖包一次性全部装好。\n现在，我们的工程结构如下：\n```\nhello-koa/\n|\n+- app.js <-- 使用koa的js\n|\n+- package.json <-- 项目描述文件\n|\n+- node_modules/ <-- npm安装的所有依赖包\n```\n\n在控制台执行 npm run start,我们打开浏览器，输入http://localhost:3000，即可看到效果：\n\n#### 3. koa middleware\n让我们再仔细看看koa的执行逻辑。核心代码是：\n```\napp.use(async (ctx, next) => {\n  await next();\n  ctx.response.type = 'text/html';\n  ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n```\n每收到一个http请求，koa就会调用通过app.use()注册的async函数，并传入ctx和next参数。\n\n我们可以对ctx操作，并设置返回内容。但是为什么要调用await next()？\n\n原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。\n\n例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：\n\n```\napp.use(async (ctx, next) => {\n  console.log(`${ctx.request.method} ${ctx.request.url}`); // 打印URL\n  await next(); // 调用下一个middleware\n});\n\napp.use(async (ctx, next) => {\n  const start = new Date().getTime(); // 当前时间\n  await next(); // 调用下一个middleware\n  const ms = new Date().getTime() - start; // 耗费时间\n  console.log(`Time: ${ms}ms`); // 打印耗费时间\n});\n\napp.use(async (ctx, next) => {\n  await next();\n  ctx.response.type = 'text/html';\n  ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n```\nmiddleware的顺序很重要，也就是调用app.use()的顺序决定了middleware的顺序。\n\n此外，如果一个middleware没有调用await next()，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：\n\n```\napp.use(async (ctx, next) => {\n  if (await checkUserPermission(ctx)) {\n    await next();\n  } else {\n    ctx.response.status = 403;\n  }\n});\n```\n理解了middleware，我们就已经会用koa了！\n\n最后注意ctx对象有一些简写的方法，例如ctx.url相当于ctx.request.url，ctx.type相当于ctx.response.type。\n\n# 四、处理URL\n\n在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。\n正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：\n\n```\napp.use(async (ctx, next) => {\n  if (ctx.request.path === '/') {\n    ctx.response.body = 'index page';\n  } else {\n    await next();\n  }\n});\n\napp.use(async (ctx, next) => {\n  if (ctx.request.path === '/test') {\n    ctx.response.body = 'TEST page';\n  } else {\n    await next();\n  }\n});\n\napp.use(async (ctx, next) => {\n  if (ctx.request.path === '/error') {\n    ctx.response.body = 'ERROR page';\n  } else {\n    await next();\n  }\n});\n```\n这么写是可以运行的，但是好像有点蠢。\n\n应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。\n\n#### 1. koa-router\n\n为了处理URL，我们需要引入koa-router这个middleware，让它负责处理URL映射。\n\n我们把上一节的hello-koa工程复制一份，重命名为url-koa。\n\n先在package.json中添加依赖项：\n```\n\"koa-router\": \"7.0.0\"\n```\n然后用npm install安装。\n\n接下来，我们修改app.js，使用koa-router来处理URL：\n\n```\nconst Koa = require('koa');\n\n// 注意require('koa-router')返回的是函数:\nconst router = require('koa-router')();\n\nconst app = new Koa();\n\n// log request URL:\napp.use(async (ctx, next) => {\n  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);\n  await next();\n});\n\n// add url-route:\nrouter.get('/hello/:name', async (ctx, next) => {\n  var name = ctx.params.name;\n  ctx.response.body = `<h1>Hello, ${name}!</h1>`;\n});\n\nrouter.get('/', async (ctx, next) => {\n    ctx.response.body = '<h1>Index</h1>';\n});\n\n// add router middleware:\napp.use(router.routes());\n\napp.listen(3000);\nconsole.log('app started at port 3000...');\n```\n\n然后，我们使用router.get('/path', async fn)来注册一个GET请求。可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问。\n\n再运行app.js，我们就可以测试不同的URL。\n\n#### 2. 处理post请求\n\n用router.get('/path', async fn)处理的是get请求。如果要处理post请求，可以用router.post('/path', async fn)。\n\n用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！\n\n所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。\n\nkoa-bodyparser就是用来干这个活的。\n\n我们在package.json中添加依赖项：\n```\n\"koa-bodyparser\": \"3.2.0\"\n```\n然后使用npm install安装。\n\n下面，修改app.js，引入koa-bodyparser：\n```\nconst bodyParser = require('koa-bodyparser');\n```\n在合适的位置加上：\n```\napp.use(bodyParser());\n```\n\n由于middleware的顺序很重要，这个koa-bodyparser必须在router之前被注册到app对象上。\n\n现在我们就可以处理post请求了。写一个简单的登录表单：\n```\nrouter.get('/', async (ctx, next) => {\n  ctx.response.body = `<h1>Index</h1>\n      <form action=\"/signin\" method=\"post\">\n          <p>Name: <input name=\"name\" value=\"koa\"></p>\n          <p>Password: <input name=\"password\" type=\"password\"></p>\n          <p><input type=\"submit\" value=\"Submit\"></p>\n      </form>`;\n});\n\nrouter.post('/signin', async (ctx, next) => {\n  var\n    name = ctx.request.body.name || '',\n    password = ctx.request.body.password || '';\n  console.log(`signin with name: ${name}, password: ${password}`);\n  if (name === 'koa' && password === '12345') {\n    ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\n  } else {\n    ctx.response.body = `<h1>Login failed!</h1>\n    <p><a href=\"/\">Try again</a></p>`;\n  }\n});\n```\n注意到我们用var name = ctx.request.body.name || ''拿到表单的name字段，如果该字段不存在，默认值设置为''。\n\n类似的，put、delete、head请求也可以由router处理。\n\n#### 3. 重构\n现在，我们已经可以处理不同的URL了，但是看看app.js，总觉得还是有点不对劲。\n\n所有的URL处理函数都放到app.js里显得很乱，而且，每加一个URL，就需要修改app.js。随着URL越来越多，app.js就会越来越长。\n\n如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让app.js自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：\n```\n+- controllers/\n|  |\n|  +- login.js <-- 处理login相关URL\n|  |\n|  +- users.js <-- 处理用户管理相关URL\n|\n+- app.js <-- 使用koa的js\n|\n+- package.json <-- 项目描述文件\n|\n+- node_modules/ <-- npm安装的所有依赖包\n```\n\n我们先在controllers目录下编写index.js：\n```\nvar fn_index = async (ctx, next) => {\n  ctx.response.body = `<h1>Index</h1>\n      <form action=\"/signin\" method=\"post\">\n          <p>Name: <input name=\"name\" value=\"koa\"></p>\n          <p>Password: <input name=\"password\" type=\"password\"></p>\n          <p><input type=\"submit\" value=\"Submit\"></p>\n      </form>`;\n};\n\nvar fn_signin = async (ctx, next) => {\n  var\n    name = ctx.request.body.name || '',\n    password = ctx.request.body.password || '';\n  console.log(`signin with name: ${name}, password: ${password}`);\n  if (name === 'koa' && password === '12345') {\n    ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\n  } else {\n    ctx.response.body = `<h1>Login failed!</h1>\n    <p><a href=\"/\">Try again</a></p>`;\n  }\n};\n\nmodule.exports = {\n  'GET /': fn_index,\n  'POST /signin': fn_signin\n};\n```\n\n这个index.js通过module.exports把两个URL处理函数暴露出来。\n\n类似的，hello.js把一个URL处理函数暴露出来：\n```\nvar fn_hello = async (ctx, next) => {\n  var name = ctx.params.name;\n  ctx.response.body = `<h1>Hello, ${name}!</h1>`;\n};\n\nmodule.exports = {\n  'GET /hello/:name': fn_hello\n};\n```\n\n现在，我们修改app.js，让它自动扫描controllers目录，找到所有js文件，导入，然后注册每个URL：\n\n```\n// 先导入fs模块，然后用readdirSync列出文件\n// 这里可以用sync是因为启动时只运行一次，不存在性能问题:\nvar files = fs.readdirSync(__dirname + '/controllers');\n\n// 过滤出.js文件:\nvar js_files = files.filter((f)=>{\n  return f.endsWith('.js');\n});\n\n// 处理每个js文件:\nfor (var f of js_files) {\n  console.log(`process controller: ${f}...`);\n  // 导入js文件:\n  let mapping = require(__dirname + '/controllers/' + f);\n  for (var url in mapping) {\n    if (url.startsWith('GET ')) {\n      // 如果url类似\"GET xxx\":\n      var path = url.substring(4);\n      router.get(path, mapping[url]);\n      console.log(`register URL mapping: GET ${path}`);\n    } else if (url.startsWith('POST ')) {\n      // 如果url类似\"POST xxx\":\n      var path = url.substring(5);\n      router.post(path, mapping[url]);\n      console.log(`register URL mapping: POST ${path}`);\n    } else {\n      // 无效的URL:\n      console.log(`invalid URL: ${url}`);\n    }\n  }\n}\n```\n\n如果上面的大段代码看起来还是有点费劲，那就把它拆成更小单元的函数：\n\n```\nfunction addMapping(router, mapping) {\n  for (var url in mapping) {\n    if (url.startsWith('GET ')) {\n      var path = url.substring(4);\n      router.get(path, mapping[url]);\n      console.log(`register URL mapping: GET ${path}`);\n    } else if (url.startsWith('POST ')) {\n      var path = url.substring(5);\n      router.post(path, mapping[url]);\n      console.log(`register URL mapping: POST ${path}`);\n    } else {\n      console.log(`invalid URL: ${url}`);\n    }\n  }\n}\n\nfunction addControllers(router) {\n  var files = fs.readdirSync(__dirname + '/controllers');\n  var js_files = files.filter((f) => {\n      return f.endsWith('.js');\n  });\n\n  for (var f of js_files) {\n      console.log(`process controller: ${f}...`);\n      let mapping = require(__dirname + '/controllers/' + f);\n      addMapping(router, mapping);\n  }\n}\n\naddControllers(router);\n```\n\n确保每个函数功能非常简单，一眼能看明白，是代码可维护的关键。\n\n#### Controller Middleware\n最后，我们把扫描controllers目录和创建router的代码从app.js中提取出来，作为一个简单的middleware使用，命名为controller.js：\n\n```\nconst fs = require('fs');\n\nfunction addMapping(router, mapping) {\n    ...\n}\n\nfunction addControllers(router, dir) {\n    ...\n}\n\nmodule.exports = function (dir) {\n  let\n      controllers_dir = dir || 'controllers', // 如果不传参数，扫描目录默认为'controllers'\n      router = require('koa-router')();\n  addControllers(router, controllers_dir);\n  return router.routes();\n};\n```\n\n这样一来，我们在app.js的代码又简化了：\n\n```\n...\n\n// 导入controller middleware:\nconst controller = require('./controller');\n\n...\n\n// 使用middleware:\napp.use(controller());\n\n...\n```\n\n经过重新整理后的工程url2-koa目前具备非常好的模块化，所有处理URL的函数按功能组存放在controllers目录，今后我们也只需要不断往这个目录下加东西就可以了，app.js保持不变。\n\n# 五、使用Nunjucks模板引擎\n\n模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。\n有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？\n因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。\n输出HTML有几个特别重要的问题需要考虑：\n\n#### 转义\n对特殊字符要转义，避免受到XSS攻击。比如，如果变量name的值不是小明，而是小明<script>...</script>，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。\n\n#### 格式化\n对不同类型的变量要格式化，比如，货币需要变成12,345.00这样的格式，日期需要变成2016-01-01这样的格式。\n\n#### 简单逻辑\n模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：\n\n```\n{{ name }}同学，\n{% if score >= 90 %}\n    成绩优秀，应该奖励\n{% elif score >=60 %}\n    成绩良好，继续努力\n{% else %}\n    不及格，建议回家打屁股\n{% endif %}\n```\n所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。\n\n#### Nunjucks\n我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。\n\n虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：\n\n```\nfunction render(view, model) {\n    // TODO:...\n}\n```\n\n其中，view是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。model就是数据，在JavaScript中，它就是一个简单的Object。render函数返回一个字符串，就是模板的输出。\n\n下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。\n\n我们创建一个use-nunjucks的VS Code工程结构如下：\n\n```\nuse-nunjucks/\n|\n+- views/\n|  |\n|  +- hello.html <-- HTML模板文件\n|\n+- app.js <-- 入口js\n|\n+- package.json <-- 项目描述文件\n|\n+- node_modules/ <-- npm安装的所有依赖包\n```\n\n其中，模板文件存放在views目录中。\n\n我们先在package.json中添加nunjucks的依赖：\n```\n\"nunjucks\": \"2.4.2\"\n```\n注意，模板引擎是可以独立使用的，并不需要依赖koa。用npm install安装所有依赖包。\n\n紧接着，我们要编写使用Nunjucks的函数render。怎么写？方法是查看[Nunjucks](http://mozilla.github.io/nunjucks/)的官方文档，仔细阅读后，在app.js中编写代码如下：\n\n```\nconst nunjucks = require('nunjucks');\n\nfunction createEnv(path, opts) {\n    var\n        autoescape = opts.autoescape === undefined ? true : opts.autoescape,\n        noCache = opts.noCache || false,\n        watch = opts.watch || false,\n        throwOnUndefined = opts.throwOnUndefined || false,\n        env = new nunjucks.Environment(\n            new nunjucks.FileSystemLoader('views', {\n                noCache: noCache,\n                watch: watch,\n            }), {\n                autoescape: autoescape,\n                throwOnUndefined: throwOnUndefined\n            });\n    if (opts.filters) {\n        for (var f in opts.filters) {\n            env.addFilter(f, opts.filters[f]);\n        }\n    }\n    return env;\n}\n\nvar env = createEnv('views', {\n    watch: true,\n    filters: {\n        hex: function (n) {\n            return '0x' + n.toString(16);\n        }\n    }\n});\n```\n\n变量env就表示Nunjucks模板引擎对象，它有一个render(view, model)方法，正好传入view和model两个参数，并返回字符串。\n\n创建env需要的参数可以查看文档获知。我们用autoescape = opts.autoescape && true这样的代码给每个参数加上默认值，最后使用new nunjucks.FileSystemLoader('views')创建一个文件系统加载器，从views目录读取模板。\n\n我们编写一个hello.html模板文件，放到views目录下，内容如下：\n```\n<h1>Hello {{ name }}</h1>\n```\n然后，我们就可以用下面的代码来渲染这个模板：\n```\nvar s = env.render('hello.html', { name: '小明' });\nconsole.log(s);\n```\n获得输出如下：\n```\n<h1>Hello 小明</h1>\n```\n\n咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：\n```\nvar s = env.render('hello.html', { name: '<script>alert(\"小明\")</script>' });\nconsole.log(s);\n```\n获得输出如下：\n```\n<h1>Hello &lt;script&gt;alert(\"小明\")&lt;/script&gt;</h1>\n```\n这样就避免了输出恶意脚本。\n\n此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：\n```\n<!-- 循环输出名字 -->\n<body>\n    <h3>Fruits List</h3>\n    {% for f in fruits %}\n    <p>{{ f }}</p>\n    {% endfor %}\n</body>\n```\n\nNunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。\n\n更好的方式是使用继承。先定义一个基本的网页框架base.html：\n\n```\n<html><body>\n{% block header %} <h3>Unnamed</h3> {% endblock %}\n{% block body %} <div>No body</div> {% endblock %}\n{% block footer %} <div>copyright</div> {% endblock %}\n</body>\n```\nbase.html定义了三个可编辑的块，分别命名为header、body和footer。子模板可以有选择地对块进行重新定义：\n```\n{% extends 'base.html' %}\n\n{% block header %}<h1>{{ header }}</h1>{% endblock %}\n\n{% block body %}<p>{{ body }}</p>{% endblock %}\n```\n\n然后，我们对子模板进行渲染：\n```\nconsole.log(env.render('extend.html', {\n    header: 'Hello',\n    body: 'bla bla bla...'\n}));\n```\n\n输出HTML如下：\n```\n<html><body>\n<h1>Hello</h1>\n<p>bla bla bla...</p>\n<div>copyright</div> <-- footer没有重定义，所以仍使用父模板的内容\n</body>\n```\n#### 性能\n最后我们要考虑一下Nunjucks的性能。\n\n对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。\n\n性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。\n\n好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了noCache: false这个参数。\n\n在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。\n\nNunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。\n\n# 六、使用MVC\n\n我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！\n\n当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：\n```\nctx.render('home.html', { name: 'Michael' });\n```\n通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了。\n\n![](https://img.fengjr.com/image/2019/09/18/3b40147c96c8b17cb2564c782f90bd40.png)\n\n这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。\n\n异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；\n\n包含变量{{ name }}的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。\n\nMVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。\n\n上面的例子中，Model就是一个JavaScript对象：\n```\n{ name: 'Michael' }\n```\n下面，我们根据原来的项目创建工程，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为ctx.render(view, model)的方式。\n\n工程结构如下：\n```\nview-koa/\n|\n+- controllers/ <-- Controller\n|\n+- views/ <-- html模板文件\n|\n+- static/ <-- 静态资源文件\n|\n+- controller.js <-- 扫描注册Controller\n|\n+- app.js <-- 使用koa的js\n|\n+- package.json <-- 项目描述文件\n|\n+- node_modules/ <-- npm安装的所有依赖包\n```\n\n先用npm install安装依赖包。\n\n然后，我们准备编写以下两个Controller：\n\n#### 处理首页 GET /\n我们定义一个async函数处理首页URL/：\n```\nasync (ctx, next) => {\n    ctx.render('index.html', {\n        title: 'Welcome'\n    });\n}\n```\n注意到koa并没有在ctx对象上提供render方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用ctx.render(view, model)就完成了页面输出。\n\n#### 处理登录请求 POST /signin\n我们再定义一个async函数处理登录请求/signin：\n```\nasync (ctx, next) => {\n    var\n        email = ctx.request.body.email || '',\n        password = ctx.request.body.password || '';\n    if (email === 'admin@example.com' && password === '123456') {\n        // 登录成功:\n        ctx.render('signin-ok.html', {\n            title: 'Sign In OK',\n            name: 'Mr Node'\n        });\n    } else {\n        // 登录失败:\n        ctx.render('signin-failed.html', {\n            title: 'Sign In Failed'\n        });\n    }\n}\n```\n\n由于登录请求是一个POST，我们就用ctx.request.body.<name>拿到POST请求的数据，并给一个默认值。\n\n登录成功时我们用signin-ok.html渲染，登录失败时我们用signin-failed.html渲染，所以，我们一共需要以下3个View：\n\n- base.html\n- signin-ok.html\n- signin-failed.html\n\n\n\n#### 集成Nunjucks\n集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给ctx对象绑定一个render(view, model)的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。\n\n我们创建一个templating.js来实现这个middleware：\n```\nconst nunjucks = require('nunjucks');\n\nfunction createEnv(path, opts) {\n    var\n        autoescape = opts.autoescape === undefined ? true : opts.autoescape,\n        noCache = opts.noCache || false,\n        watch = opts.watch || false,\n        throwOnUndefined = opts.throwOnUndefined || false,\n        env = new nunjucks.Environment(\n            new nunjucks.FileSystemLoader(path || 'views', {\n                noCache: noCache,\n                watch: watch,\n            }), {\n                autoescape: autoescape,\n                throwOnUndefined: throwOnUndefined\n            });\n    if (opts.filters) {\n        for (var f in opts.filters) {\n            env.addFilter(f, opts.filters[f]);\n        }\n    }\n    return env;\n}\n\nfunction templating(path, opts) {\n    // 创建Nunjucks的env对象:\n    var env = createEnv(path, opts);\n    return async (ctx, next) => {\n        // 给ctx绑定render函数:\n        ctx.render = function (view, model) {\n            // 把render后的内容赋值给response.body:\n            ctx.response.body = env.render(view, Object.assign({}, ctx.state || {}, model || {}));\n            // 设置Content-Type:\n            ctx.response.type = 'text/html';\n        };\n        // 继续处理请求:\n        await next();\n    };\n}\n\nmodule.exports = templating;\n```\n\n注意到createEnv()函数和前面使用Nunjucks时编写的函数是一模一样的。我们主要关心tempating()函数，它会返回一个middleware，在这个middleware中，我们只给ctx“安装”了一个render()函数，其他什么事情也没干，就继续调用下一个middleware。\n\n使用的时候，我们在app.js添加如下代码：\n\n```\nconst isProduction = process.env.NODE_ENV === 'production';\n\napp.use(templating('views', {\n    noCache: !isProduction,\n    watch: !isProduction\n}));\n```\n\n这里我们定义了一个常量isProduction，它判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。\n\nNode.js在全局变量process中定义了一个环境变量env.NODE_ENV，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为'development'，而部署到服务器时，环境变量应该设置为'production'。在编写代码的时候，要根据当前环境作不同的判断。\n\n注意：生产环境上必须配置环境变量NODE_ENV = 'production'，而开发环境不需要配置，实际上NODE_ENV可能是undefined，所以判断的时候，不要用NODE_ENV === 'development'。\n\n这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。\n\n#### 编写View\n在编写View的时候，非常有必要先编写一个base.html作为骨架，其他模板都继承自base.html，这样，才能大大减少重复工作。\n\n编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了base.html。\n\nbase.html\n```\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <meta name=\"description\" content=\"learn javascript\">\n    <title>{{ title }}</title>\n</head>\n\n<body>\n  <header style=\"background-color:#6f5499;height: 100px;color: #fff;\">\n      header top main\n  </header>\n  {% block main %} {% endblock %}\n  <footer style=\"background-color:#ddd; padding: 20px 0;text-align: center;color: #666;\">\n      copy right @2019\n  </footer>\n</body>\n\n</html>\n```\n\nsignin-ok.html\n```\n{% extends \"base.html\" %} \n{% block main %}\n\n<div>\n  <h1>Sign in success!</h1>\n  <div class=\"alert alert-danger\"> \n    <strong>This is post login name: {{ title }}</strong>\n  </div>\n  <ul>\n    {% for f in data %}\n      {% if f.age < 10 %}\n        <li>postValue: 00000</li>\n      {% elif f.age == 10 %}\n        <li>postValue: 10</li>\n      {% else %}\n        <li>postValue: {{ f.name }}</li>\n      {% endif %}\n    {% endfor %}\n  </ul>\n</div>\n\n{% endblock %}\n```\n\n#### 运行\n一切顺利的话，这个view-koa工程应该可以顺利运行。运行前，我们再检查一下app.js里的middleware的顺序：\n\n第一个middleware是记录URL以及页面执行时间：\n```\napp.use(async (ctx, next) => {\n    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);\n    var\n        start = new Date().getTime(),\n        execTime;\n    await next();\n    execTime = new Date().getTime() - start;\n    ctx.response.set('X-Response-Time', `${execTime}ms`);\n});\n```\n\n第二个middleware解析POST请求：\n```\napp.use(bodyParser());\n```\n第三个middleware负责给ctx加上render()来使用Nunjucks：\n```\napp.use(templating('view', {\n    noCache: !isProduction,\n    watch: !isProduction\n}));\n```\n最后一个middleware处理URL路由：\n```\napp.use(controller());\n```\n\n现在，在VS Code中运行代码，不出意外的话，在浏览器输入localhost:3000/，可以看到效果。","slug":"koa2","published":1,"updated":"2020-06-10T06:01:47.365Z","_id":"ck2yl0qc9000th6q6m434kggm","layout":"post","photos":[],"link":"","content":"<h1 id=\"一、koa简介\"><a href=\"#一、koa简介\" class=\"headerlink\" title=\"一、koa简介\"></a>一、koa简介</h1><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p>\n<h1 id=\"二、koa2的优势\"><a href=\"#二、koa2的优势\" class=\"headerlink\" title=\"二、koa2的优势\"></a>二、koa2的优势</h1><h4 id=\"1-express\"><a href=\"#1-express\" class=\"headerlink\" title=\"1. express\"></a>1. express</h4><p>虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/test&apos;, function (req, res) &#123;</span><br><span class=\"line\">    fs.readFile(&apos;/file1&apos;, function (err, data) &#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            res.status(500).send(&apos;read file1 error&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fs.readFile(&apos;/file2&apos;, function (err, data) &#123;</span><br><span class=\"line\">            if (err) &#123;</span><br><span class=\"line\">                res.status(500).send(&apos;read file2 error&apos;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.type(&apos;text/plain&apos;);</span><br><span class=\"line\">            res.send(data);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-koa-1-0\"><a href=\"#2-koa-1-0\" class=\"headerlink\" title=\"2. koa 1.0\"></a>2. koa 1.0</h4><p>随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.0使用generator实现异步，代码看起来像同步的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var koa = require(&apos;koa&apos;);</span><br><span class=\"line\">var app = koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(&apos;/test&apos;, function *() &#123;</span><br><span class=\"line\">    yield doReadFile1();</span><br><span class=\"line\">    var data = yield doReadFile2();</span><br><span class=\"line\">    this.body = data;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-koa-2-0\"><a href=\"#3-koa-2-0\" class=\"headerlink\" title=\"3. koa 2.0\"></a>3. koa 2.0</h4><p>随着ES7引入了新的语法糖async和await，JavaScript未来标准的异步代码是这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function () &#123;</span><br><span class=\"line\">    var data = await fs.read(&apos;/file1&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>koa团队并没有止步于koa 1.0，他们非常超前地基于ES7开发了koa2。koa2的代码看上去像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">    var data = await doReadFile();</span><br><span class=\"line\">    ctx.response.type = &apos;text/plain&apos;;</span><br><span class=\"line\">    ctx.response.body = data;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-中间件的执行顺序\"><a href=\"#4-中间件的执行顺序\" class=\"headerlink\" title=\"4. 中间件的执行顺序\"></a>4. 中间件的执行顺序</h4><p>koa的中间件是由generator组成的，这决定了中间件的执行顺序。<br>Express的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。</p>\n<p>koa是从第一个中间件开始执行，遇到<code>next</code>进入下一个中间件，一直执行到最后一个中间件，在逆序，执行上一个中间件<code>next</code>之后的代码，一直到第一个中间件执行结束才发出响应。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const one = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;&gt;&gt; one&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">  console.log(&apos;&lt;&lt; one&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">const two = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;&gt;&gt; two&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">  console.log(&apos;&lt;&lt; two&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">const three = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;&gt;&gt; three&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">  console.log(&apos;&lt;&lt; three&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">app.use(one);</span><br><span class=\"line\">app.use(two);</span><br><span class=\"line\">app.use(three);</span><br><span class=\"line\"> </span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">&gt;&gt; one</span><br><span class=\"line\">&gt;&gt; two</span><br><span class=\"line\">&gt;&gt; three</span><br><span class=\"line\">&lt;&lt; three</span><br><span class=\"line\">&lt;&lt; two</span><br><span class=\"line\">&lt;&lt; one</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"三、koa2入门及搭建\"><a href=\"#三、koa2入门及搭建\" class=\"headerlink\" title=\"三、koa2入门及搭建\"></a>三、koa2入门及搭建</h1><h4 id=\"1-Context\"><a href=\"#1-Context\" class=\"headerlink\" title=\"1. Context\"></a>1. Context</h4><p>Context封装了node中的request和response。</p>\n<p><a href=\"mailto:koa@1.x\" target=\"_blank\" rel=\"noopener\">koa@1.x</a>使用this引用Context对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(function *()&#123;</span><br><span class=\"line\">  this.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"mailto:koa@2.x\" target=\"_blank\" rel=\"noopener\">koa@2.x</a>中使用ctx来访问Context对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  ctx.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-创建koa2工程\"><a href=\"#2-创建koa2工程\" class=\"headerlink\" title=\"2. 创建koa2工程\"></a>2. 创建koa2工程</h4><p>首先，我们创建一个目录hello-koa并作为工程目录用VS Code打开。然后，我们创建app.js，输入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:</span><br><span class=\"line\">const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建一个Koa对象表示web app本身:</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\"></span><br><span class=\"line\">// 对于任何请求，app将调用该异步函数处理请求：</span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 在端口3000监听:</span><br><span class=\"line\">app.listen(3000);</span><br><span class=\"line\">console.log(&apos;app started at port 3000...&apos;);</span><br></pre></td></tr></table></figure>\n<p>对于每一个http请求，koa将调用我们传入的异步函数来处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  // 设置response的Content-Type:</span><br><span class=\"line\">  ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">  // 设置response的内容:</span><br><span class=\"line\">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，next是koa传入的将要处理的下一个异步函数。</p>\n<p>上面的异步函数中，我们首先用await next();处理下一个异步函数，然后，设置response的Content-Type和内容。</p>\n<p>由async标记的函数称为异步函数，在异步函数中，可以用await调用另一个异步函数，这两个关键字将在ES7中引入。</p>\n<p>现在我们遇到第一个问题：koa这个包怎么装，app.js才能正常导入它？</p>\n<p>在hello-koa这个目录下创建一个package.json，这个文件描述了我们的hello-koa工程会用到哪些包。完整的文件内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hello-koa2&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;description&quot;: &quot;Hello Koa 2 example with async&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">      &quot;start&quot;: &quot;node app.js&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;keywords&quot;: [</span><br><span class=\"line\">      &quot;koa&quot;,</span><br><span class=\"line\">      &quot;async&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;author&quot;: &quot;&quot;,</span><br><span class=\"line\">  &quot;license&quot;: &quot;Apache-2.0&quot;,</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">      &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">      &quot;url&quot;: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">      &quot;koa&quot;: &quot;2.0.0&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们在hello-koa目录下执行npm install就可以把所需包以及依赖包一次性全部装好。<br>现在，我们的工程结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello-koa/</span><br><span class=\"line\">|</span><br><span class=\"line\">+- app.js &lt;-- 使用koa的js</span><br><span class=\"line\">|</span><br><span class=\"line\">+- package.json &lt;-- 项目描述文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure></p>\n<p>在控制台执行 npm run start,我们打开浏览器，输入<a href=\"http://localhost:3000，即可看到效果：\" target=\"_blank\" rel=\"noopener\">http://localhost:3000，即可看到效果：</a></p>\n<h4 id=\"3-koa-middleware\"><a href=\"#3-koa-middleware\" class=\"headerlink\" title=\"3. koa middleware\"></a>3. koa middleware</h4><p>让我们再仔细看看koa的执行逻辑。核心代码是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>每收到一个http请求，koa就会调用通过app.use()注册的async函数，并传入ctx和next参数。</p>\n<p>我们可以对ctx操作，并设置返回内容。但是为什么要调用await next()？</p>\n<p>原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>\n<p>例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(`$&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); // 打印URL</span><br><span class=\"line\">  await next(); // 调用下一个middleware</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  const start = new Date().getTime(); // 当前时间</span><br><span class=\"line\">  await next(); // 调用下一个middleware</span><br><span class=\"line\">  const ms = new Date().getTime() - start; // 耗费时间</span><br><span class=\"line\">  console.log(`Time: $&#123;ms&#125;ms`); // 打印耗费时间</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>middleware的顺序很重要，也就是调用app.use()的顺序决定了middleware的顺序。</p>\n<p>此外，如果一个middleware没有调用await next()，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  if (await checkUserPermission(ctx)) &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    ctx.response.status = 403;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>理解了middleware，我们就已经会用koa了！</p>\n<p>最后注意ctx对象有一些简写的方法，例如ctx.url相当于ctx.request.url，ctx.type相当于ctx.response.type。</p>\n<h1 id=\"四、处理URL\"><a href=\"#四、处理URL\" class=\"headerlink\" title=\"四、处理URL\"></a>四、处理URL</h1><p>在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。<br>正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  if (ctx.request.path === &apos;/&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = &apos;index page&apos;;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  if (ctx.request.path === &apos;/test&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = &apos;TEST page&apos;;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  if (ctx.request.path === &apos;/error&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = &apos;ERROR page&apos;;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这么写是可以运行的，但是好像有点蠢。</p>\n<p>应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。</p>\n<h4 id=\"1-koa-router\"><a href=\"#1-koa-router\" class=\"headerlink\" title=\"1. koa-router\"></a>1. koa-router</h4><p>为了处理URL，我们需要引入koa-router这个middleware，让它负责处理URL映射。</p>\n<p>我们把上一节的hello-koa工程复制一份，重命名为url-koa。</p>\n<p>先在package.json中添加依赖项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;koa-router&quot;: &quot;7.0.0&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后用npm install安装。</p>\n<p>接下来，我们修改app.js，使用koa-router来处理URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 注意require(&apos;koa-router&apos;)返回的是函数:</span><br><span class=\"line\">const router = require(&apos;koa-router&apos;)();</span><br><span class=\"line\"></span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\"></span><br><span class=\"line\">// log request URL:</span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`);</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// add url-route:</span><br><span class=\"line\">router.get(&apos;/hello/:name&apos;, async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  var name = ctx.params.name;</span><br><span class=\"line\">  ctx.response.body = `&lt;h1&gt;Hello, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    ctx.response.body = &apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// add router middleware:</span><br><span class=\"line\">app.use(router.routes());</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br><span class=\"line\">console.log(&apos;app started at port 3000...&apos;);</span><br></pre></td></tr></table></figure>\n<p>然后，我们使用router.get(‘/path’, async fn)来注册一个GET请求。可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问。</p>\n<p>再运行app.js，我们就可以测试不同的URL。</p>\n<h4 id=\"2-处理post请求\"><a href=\"#2-处理post请求\" class=\"headerlink\" title=\"2. 处理post请求\"></a>2. 处理post请求</h4><p>用router.get(‘/path’, async fn)处理的是get请求。如果要处理post请求，可以用router.post(‘/path’, async fn)。</p>\n<p>用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！</p>\n<p>所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。</p>\n<p>koa-bodyparser就是用来干这个活的。</p>\n<p>我们在package.json中添加依赖项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;koa-bodyparser&quot;: &quot;3.2.0&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后使用npm install安装。</p>\n<p>下面，修改app.js，引入koa-bodyparser：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const bodyParser = require(&apos;koa-bodyparser&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>在合适的位置加上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(bodyParser());</span><br></pre></td></tr></table></figure></p>\n<p>由于middleware的顺序很重要，这个koa-bodyparser必须在router之前被注册到app对象上。</p>\n<p>现在我们就可以处理post请求了。写一个简单的登录表单：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt;</span><br><span class=\"line\">      &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">          &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">          &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">          &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/form&gt;`;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(&apos;/signin&apos;, async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  var</span><br><span class=\"line\">    name = ctx.request.body.name || &apos;&apos;,</span><br><span class=\"line\">    password = ctx.request.body.password || &apos;&apos;;</span><br><span class=\"line\">  console.log(`signin with name: $&#123;name&#125;, password: $&#123;password&#125;`);</span><br><span class=\"line\">  if (name === &apos;koa&apos; &amp;&amp; password === &apos;12345&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>注意到我们用var name = ctx.request.body.name || ‘’拿到表单的name字段，如果该字段不存在，默认值设置为’’。</p>\n<p>类似的，put、delete、head请求也可以由router处理。</p>\n<h4 id=\"3-重构\"><a href=\"#3-重构\" class=\"headerlink\" title=\"3. 重构\"></a>3. 重构</h4><p>现在，我们已经可以处理不同的URL了，但是看看app.js，总觉得还是有点不对劲。</p>\n<p>所有的URL处理函数都放到app.js里显得很乱，而且，每加一个URL，就需要修改app.js。随着URL越来越多，app.js就会越来越长。</p>\n<p>如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让app.js自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+- controllers/</span><br><span class=\"line\">|  |</span><br><span class=\"line\">|  +- login.js &lt;-- 处理login相关URL</span><br><span class=\"line\">|  |</span><br><span class=\"line\">|  +- users.js &lt;-- 处理用户管理相关URL</span><br><span class=\"line\">|</span><br><span class=\"line\">+- app.js &lt;-- 使用koa的js</span><br><span class=\"line\">|</span><br><span class=\"line\">+- package.json &lt;-- 项目描述文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure></p>\n<p>我们先在controllers目录下编写index.js：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fn_index = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt;</span><br><span class=\"line\">      &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">          &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">          &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">          &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/form&gt;`;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var fn_signin = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  var</span><br><span class=\"line\">    name = ctx.request.body.name || &apos;&apos;,</span><br><span class=\"line\">    password = ctx.request.body.password || &apos;&apos;;</span><br><span class=\"line\">  console.log(`signin with name: $&#123;name&#125;, password: $&#123;password&#125;`);</span><br><span class=\"line\">  if (name === &apos;koa&apos; &amp;&amp; password === &apos;12345&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  &apos;GET /&apos;: fn_index,</span><br><span class=\"line\">  &apos;POST /signin&apos;: fn_signin</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这个index.js通过module.exports把两个URL处理函数暴露出来。</p>\n<p>类似的，hello.js把一个URL处理函数暴露出来：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fn_hello = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  var name = ctx.params.name;</span><br><span class=\"line\">  ctx.response.body = `&lt;h1&gt;Hello, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  &apos;GET /hello/:name&apos;: fn_hello</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>现在，我们修改app.js，让它自动扫描controllers目录，找到所有js文件，导入，然后注册每个URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先导入fs模块，然后用readdirSync列出文件</span><br><span class=\"line\">// 这里可以用sync是因为启动时只运行一次，不存在性能问题:</span><br><span class=\"line\">var files = fs.readdirSync(__dirname + &apos;/controllers&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 过滤出.js文件:</span><br><span class=\"line\">var js_files = files.filter((f)=&gt;&#123;</span><br><span class=\"line\">  return f.endsWith(&apos;.js&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 处理每个js文件:</span><br><span class=\"line\">for (var f of js_files) &#123;</span><br><span class=\"line\">  console.log(`process controller: $&#123;f&#125;...`);</span><br><span class=\"line\">  // 导入js文件:</span><br><span class=\"line\">  let mapping = require(__dirname + &apos;/controllers/&apos; + f);</span><br><span class=\"line\">  for (var url in mapping) &#123;</span><br><span class=\"line\">    if (url.startsWith(&apos;GET &apos;)) &#123;</span><br><span class=\"line\">      // 如果url类似&quot;GET xxx&quot;:</span><br><span class=\"line\">      var path = url.substring(4);</span><br><span class=\"line\">      router.get(path, mapping[url]);</span><br><span class=\"line\">      console.log(`register URL mapping: GET $&#123;path&#125;`);</span><br><span class=\"line\">    &#125; else if (url.startsWith(&apos;POST &apos;)) &#123;</span><br><span class=\"line\">      // 如果url类似&quot;POST xxx&quot;:</span><br><span class=\"line\">      var path = url.substring(5);</span><br><span class=\"line\">      router.post(path, mapping[url]);</span><br><span class=\"line\">      console.log(`register URL mapping: POST $&#123;path&#125;`);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 无效的URL:</span><br><span class=\"line\">      console.log(`invalid URL: $&#123;url&#125;`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果上面的大段代码看起来还是有点费劲，那就把它拆成更小单元的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addMapping(router, mapping) &#123;</span><br><span class=\"line\">  for (var url in mapping) &#123;</span><br><span class=\"line\">    if (url.startsWith(&apos;GET &apos;)) &#123;</span><br><span class=\"line\">      var path = url.substring(4);</span><br><span class=\"line\">      router.get(path, mapping[url]);</span><br><span class=\"line\">      console.log(`register URL mapping: GET $&#123;path&#125;`);</span><br><span class=\"line\">    &#125; else if (url.startsWith(&apos;POST &apos;)) &#123;</span><br><span class=\"line\">      var path = url.substring(5);</span><br><span class=\"line\">      router.post(path, mapping[url]);</span><br><span class=\"line\">      console.log(`register URL mapping: POST $&#123;path&#125;`);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      console.log(`invalid URL: $&#123;url&#125;`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function addControllers(router) &#123;</span><br><span class=\"line\">  var files = fs.readdirSync(__dirname + &apos;/controllers&apos;);</span><br><span class=\"line\">  var js_files = files.filter((f) =&gt; &#123;</span><br><span class=\"line\">      return f.endsWith(&apos;.js&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  for (var f of js_files) &#123;</span><br><span class=\"line\">      console.log(`process controller: $&#123;f&#125;...`);</span><br><span class=\"line\">      let mapping = require(__dirname + &apos;/controllers/&apos; + f);</span><br><span class=\"line\">      addMapping(router, mapping);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addControllers(router);</span><br></pre></td></tr></table></figure>\n<p>确保每个函数功能非常简单，一眼能看明白，是代码可维护的关键。</p>\n<h4 id=\"Controller-Middleware\"><a href=\"#Controller-Middleware\" class=\"headerlink\" title=\"Controller Middleware\"></a>Controller Middleware</h4><p>最后，我们把扫描controllers目录和创建router的代码从app.js中提取出来，作为一个简单的middleware使用，命名为controller.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function addMapping(router, mapping) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function addControllers(router, dir) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function (dir) &#123;</span><br><span class=\"line\">  let</span><br><span class=\"line\">      controllers_dir = dir || &apos;controllers&apos;, // 如果不传参数，扫描目录默认为&apos;controllers&apos;</span><br><span class=\"line\">      router = require(&apos;koa-router&apos;)();</span><br><span class=\"line\">  addControllers(router, controllers_dir);</span><br><span class=\"line\">  return router.routes();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样一来，我们在app.js的代码又简化了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">// 导入controller middleware:</span><br><span class=\"line\">const controller = require(&apos;./controller&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用middleware:</span><br><span class=\"line\">app.use(controller());</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>经过重新整理后的工程url2-koa目前具备非常好的模块化，所有处理URL的函数按功能组存放在controllers目录，今后我们也只需要不断往这个目录下加东西就可以了，app.js保持不变。</p>\n<h1 id=\"五、使用Nunjucks模板引擎\"><a href=\"#五、使用Nunjucks模板引擎\" class=\"headerlink\" title=\"五、使用Nunjucks模板引擎\"></a>五、使用Nunjucks模板引擎</h1><p>模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。<br>有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？<br>因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。<br>输出HTML有几个特别重要的问题需要考虑：</p>\n<h4 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h4><p>对特殊字符要转义，避免受到XSS攻击。比如，如果变量name的值不是小明，而是小明<script>…</script>，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。</p>\n<h4 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h4><p>对不同类型的变量要格式化，比如，货币需要变成12,345.00这样的格式，日期需要变成2016-01-01这样的格式。</p>\n<h4 id=\"简单逻辑\"><a href=\"#简单逻辑\" class=\"headerlink\" title=\"简单逻辑\"></a>简单逻辑</h4><p>模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; name &#125;&#125;同学，</span><br><span class=\"line\">&#123;% if score &gt;= 90 %&#125;</span><br><span class=\"line\">    成绩优秀，应该奖励</span><br><span class=\"line\">&#123;% elif score &gt;=60 %&#125;</span><br><span class=\"line\">    成绩良好，继续努力</span><br><span class=\"line\">&#123;% else %&#125;</span><br><span class=\"line\">    不及格，建议回家打屁股</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。</p>\n<h4 id=\"Nunjucks\"><a href=\"#Nunjucks\" class=\"headerlink\" title=\"Nunjucks\"></a>Nunjucks</h4><p>我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。</p>\n<p>虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function render(view, model) &#123;</span><br><span class=\"line\">    // TODO:...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，view是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。model就是数据，在JavaScript中，它就是一个简单的Object。render函数返回一个字符串，就是模板的输出。</p>\n<p>下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。</p>\n<p>我们创建一个use-nunjucks的VS Code工程结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use-nunjucks/</span><br><span class=\"line\">|</span><br><span class=\"line\">+- views/</span><br><span class=\"line\">|  |</span><br><span class=\"line\">|  +- hello.html &lt;-- HTML模板文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- app.js &lt;-- 入口js</span><br><span class=\"line\">|</span><br><span class=\"line\">+- package.json &lt;-- 项目描述文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure>\n<p>其中，模板文件存放在views目录中。</p>\n<p>我们先在package.json中添加nunjucks的依赖：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;nunjucks&quot;: &quot;2.4.2&quot;</span><br></pre></td></tr></table></figure></p>\n<p>注意，模板引擎是可以独立使用的，并不需要依赖koa。用npm install安装所有依赖包。</p>\n<p>紧接着，我们要编写使用Nunjucks的函数render。怎么写？方法是查看<a href=\"http://mozilla.github.io/nunjucks/\" target=\"_blank\" rel=\"noopener\">Nunjucks</a>的官方文档，仔细阅读后，在app.js中编写代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const nunjucks = require(&apos;nunjucks&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function createEnv(path, opts) &#123;</span><br><span class=\"line\">    var</span><br><span class=\"line\">        autoescape = opts.autoescape === undefined ? true : opts.autoescape,</span><br><span class=\"line\">        noCache = opts.noCache || false,</span><br><span class=\"line\">        watch = opts.watch || false,</span><br><span class=\"line\">        throwOnUndefined = opts.throwOnUndefined || false,</span><br><span class=\"line\">        env = new nunjucks.Environment(</span><br><span class=\"line\">            new nunjucks.FileSystemLoader(&apos;views&apos;, &#123;</span><br><span class=\"line\">                noCache: noCache,</span><br><span class=\"line\">                watch: watch,</span><br><span class=\"line\">            &#125;), &#123;</span><br><span class=\"line\">                autoescape: autoescape,</span><br><span class=\"line\">                throwOnUndefined: throwOnUndefined</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    if (opts.filters) &#123;</span><br><span class=\"line\">        for (var f in opts.filters) &#123;</span><br><span class=\"line\">            env.addFilter(f, opts.filters[f]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return env;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var env = createEnv(&apos;views&apos;, &#123;</span><br><span class=\"line\">    watch: true,</span><br><span class=\"line\">    filters: &#123;</span><br><span class=\"line\">        hex: function (n) &#123;</span><br><span class=\"line\">            return &apos;0x&apos; + n.toString(16);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>变量env就表示Nunjucks模板引擎对象，它有一个render(view, model)方法，正好传入view和model两个参数，并返回字符串。</p>\n<p>创建env需要的参数可以查看文档获知。我们用autoescape = opts.autoescape &amp;&amp; true这样的代码给每个参数加上默认值，最后使用new nunjucks.FileSystemLoader(‘views’)创建一个文件系统加载器，从views目录读取模板。</p>\n<p>我们编写一个hello.html模板文件，放到views目录下，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后，我们就可以用下面的代码来渲染这个模板：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = env.render(&apos;hello.html&apos;, &#123; name: &apos;小明&apos; &#125;);</span><br><span class=\"line\">console.log(s);</span><br></pre></td></tr></table></figure></p>\n<p>获得输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;Hello 小明&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>\n<p>咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = env.render(&apos;hello.html&apos;, &#123; name: &apos;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&apos; &#125;);</span><br><span class=\"line\">console.log(s);</span><br></pre></td></tr></table></figure></p>\n<p>获得输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;Hello &amp;lt;script&amp;gt;alert(&quot;小明&quot;)&amp;lt;/script&amp;gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这样就避免了输出恶意脚本。</p>\n<p>此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 循环输出名字 --&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;h3&gt;Fruits List&lt;/h3&gt;</span><br><span class=\"line\">    &#123;% for f in fruits %&#125;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123; f &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &#123;% endfor %&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>\n<p>Nunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。</p>\n<p>更好的方式是使用继承。先定义一个基本的网页框架base.html：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;&lt;body&gt;</span><br><span class=\"line\">&#123;% block header %&#125; &lt;h3&gt;Unnamed&lt;/h3&gt; &#123;% endblock %&#125;</span><br><span class=\"line\">&#123;% block body %&#125; &lt;div&gt;No body&lt;/div&gt; &#123;% endblock %&#125;</span><br><span class=\"line\">&#123;% block footer %&#125; &lt;div&gt;copyright&lt;/div&gt; &#123;% endblock %&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>base.html定义了三个可编辑的块，分别命名为header、body和footer。子模板可以有选择地对块进行重新定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends &apos;base.html&apos; %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block header %&#125;&lt;h1&gt;&#123;&#123; header &#125;&#125;&lt;/h1&gt;&#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block body %&#125;&lt;p&gt;&#123;&#123; body &#125;&#125;&lt;/p&gt;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后，我们对子模板进行渲染：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(env.render(&apos;extend.html&apos;, &#123;</span><br><span class=\"line\">    header: &apos;Hello&apos;,</span><br><span class=\"line\">    body: &apos;bla bla bla...&apos;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>输出HTML如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\">&lt;p&gt;bla bla bla...&lt;/p&gt;</span><br><span class=\"line\">&lt;div&gt;copyright&lt;/div&gt; &lt;-- footer没有重定义，所以仍使用父模板的内容</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><p>最后我们要考虑一下Nunjucks的性能。</p>\n<p>对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。</p>\n<p>性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。</p>\n<p>好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了noCache: false这个参数。</p>\n<p>在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。</p>\n<p>Nunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。</p>\n<h1 id=\"六、使用MVC\"><a href=\"#六、使用MVC\" class=\"headerlink\" title=\"六、使用MVC\"></a>六、使用MVC</h1><p>我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！</p>\n<p>当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.render(&apos;home.html&apos;, &#123; name: &apos;Michael&apos; &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/09/18/3b40147c96c8b17cb2564c782f90bd40.png\" alt></p>\n<p>这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。</p>\n<p>异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；</p>\n<p>包含变量的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>\n<p>MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</p>\n<p>上面的例子中，Model就是一个JavaScript对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; name: &apos;Michael&apos; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面，我们根据原来的项目创建工程，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为ctx.render(view, model)的方式。</p>\n<p>工程结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view-koa/</span><br><span class=\"line\">|</span><br><span class=\"line\">+- controllers/ &lt;-- Controller</span><br><span class=\"line\">|</span><br><span class=\"line\">+- views/ &lt;-- html模板文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- static/ &lt;-- 静态资源文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- controller.js &lt;-- 扫描注册Controller</span><br><span class=\"line\">|</span><br><span class=\"line\">+- app.js &lt;-- 使用koa的js</span><br><span class=\"line\">|</span><br><span class=\"line\">+- package.json &lt;-- 项目描述文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure></p>\n<p>先用npm install安装依赖包。</p>\n<p>然后，我们准备编写以下两个Controller：</p>\n<h4 id=\"处理首页-GET\"><a href=\"#处理首页-GET\" class=\"headerlink\" title=\"处理首页 GET /\"></a>处理首页 GET /</h4><p>我们定义一个async函数处理首页URL/：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    ctx.render(&apos;index.html&apos;, &#123;</span><br><span class=\"line\">        title: &apos;Welcome&apos;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意到koa并没有在ctx对象上提供render方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用ctx.render(view, model)就完成了页面输出。</p>\n<h4 id=\"处理登录请求-POST-signin\"><a href=\"#处理登录请求-POST-signin\" class=\"headerlink\" title=\"处理登录请求 POST /signin\"></a>处理登录请求 POST /signin</h4><p>我们再定义一个async函数处理登录请求/signin：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    var</span><br><span class=\"line\">        email = ctx.request.body.email || &apos;&apos;,</span><br><span class=\"line\">        password = ctx.request.body.password || &apos;&apos;;</span><br><span class=\"line\">    if (email === &apos;admin@example.com&apos; &amp;&amp; password === &apos;123456&apos;) &#123;</span><br><span class=\"line\">        // 登录成功:</span><br><span class=\"line\">        ctx.render(&apos;signin-ok.html&apos;, &#123;</span><br><span class=\"line\">            title: &apos;Sign In OK&apos;,</span><br><span class=\"line\">            name: &apos;Mr Node&apos;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // 登录失败:</span><br><span class=\"line\">        ctx.render(&apos;signin-failed.html&apos;, &#123;</span><br><span class=\"line\">            title: &apos;Sign In Failed&apos;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于登录请求是一个POST，我们就用ctx.request.body.<name>拿到POST请求的数据，并给一个默认值。</name></p>\n<p>登录成功时我们用signin-ok.html渲染，登录失败时我们用signin-failed.html渲染，所以，我们一共需要以下3个View：</p>\n<ul>\n<li>base.html</li>\n<li>signin-ok.html</li>\n<li>signin-failed.html</li>\n</ul>\n<h4 id=\"集成Nunjucks\"><a href=\"#集成Nunjucks\" class=\"headerlink\" title=\"集成Nunjucks\"></a>集成Nunjucks</h4><p>集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给ctx对象绑定一个render(view, model)的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。</p>\n<p>我们创建一个templating.js来实现这个middleware：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const nunjucks = require(&apos;nunjucks&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function createEnv(path, opts) &#123;</span><br><span class=\"line\">    var</span><br><span class=\"line\">        autoescape = opts.autoescape === undefined ? true : opts.autoescape,</span><br><span class=\"line\">        noCache = opts.noCache || false,</span><br><span class=\"line\">        watch = opts.watch || false,</span><br><span class=\"line\">        throwOnUndefined = opts.throwOnUndefined || false,</span><br><span class=\"line\">        env = new nunjucks.Environment(</span><br><span class=\"line\">            new nunjucks.FileSystemLoader(path || &apos;views&apos;, &#123;</span><br><span class=\"line\">                noCache: noCache,</span><br><span class=\"line\">                watch: watch,</span><br><span class=\"line\">            &#125;), &#123;</span><br><span class=\"line\">                autoescape: autoescape,</span><br><span class=\"line\">                throwOnUndefined: throwOnUndefined</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    if (opts.filters) &#123;</span><br><span class=\"line\">        for (var f in opts.filters) &#123;</span><br><span class=\"line\">            env.addFilter(f, opts.filters[f]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return env;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function templating(path, opts) &#123;</span><br><span class=\"line\">    // 创建Nunjucks的env对象:</span><br><span class=\"line\">    var env = createEnv(path, opts);</span><br><span class=\"line\">    return async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">        // 给ctx绑定render函数:</span><br><span class=\"line\">        ctx.render = function (view, model) &#123;</span><br><span class=\"line\">            // 把render后的内容赋值给response.body:</span><br><span class=\"line\">            ctx.response.body = env.render(view, Object.assign(&#123;&#125;, ctx.state || &#123;&#125;, model || &#123;&#125;));</span><br><span class=\"line\">            // 设置Content-Type:</span><br><span class=\"line\">            ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        // 继续处理请求:</span><br><span class=\"line\">        await next();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = templating;</span><br></pre></td></tr></table></figure></p>\n<p>注意到createEnv()函数和前面使用Nunjucks时编写的函数是一模一样的。我们主要关心tempating()函数，它会返回一个middleware，在这个middleware中，我们只给ctx“安装”了一个render()函数，其他什么事情也没干，就继续调用下一个middleware。</p>\n<p>使用的时候，我们在app.js添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const isProduction = process.env.NODE_ENV === &apos;production&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(templating(&apos;views&apos;, &#123;</span><br><span class=\"line\">    noCache: !isProduction,</span><br><span class=\"line\">    watch: !isProduction</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了一个常量isProduction，它判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。</p>\n<p>Node.js在全局变量process中定义了一个环境变量env.NODE_ENV，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为’development’，而部署到服务器时，环境变量应该设置为’production’。在编写代码的时候，要根据当前环境作不同的判断。</p>\n<p>注意：生产环境上必须配置环境变量NODE_ENV = ‘production’，而开发环境不需要配置，实际上NODE_ENV可能是undefined，所以判断的时候，不要用NODE_ENV === ‘development’。</p>\n<p>这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。</p>\n<h4 id=\"编写View\"><a href=\"#编写View\" class=\"headerlink\" title=\"编写View\"></a>编写View</h4><p>在编写View的时候，非常有必要先编写一个base.html作为骨架，其他模板都继承自base.html，这样，才能大大减少重复工作。</p>\n<p>编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了base.html。</p>\n<p>base.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;description&quot; content=&quot;learn javascript&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;header style=&quot;background-color:#6f5499;height: 100px;color: #fff;&quot;&gt;</span><br><span class=\"line\">      header top main</span><br><span class=\"line\">  &lt;/header&gt;</span><br><span class=\"line\">  &#123;% block main %&#125; &#123;% endblock %&#125;</span><br><span class=\"line\">  &lt;footer style=&quot;background-color:#ddd; padding: 20px 0;text-align: center;color: #666;&quot;&gt;</span><br><span class=\"line\">      copy right @2019</span><br><span class=\"line\">  &lt;/footer&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>signin-ok.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends &quot;base.html&quot; %&#125; </span><br><span class=\"line\">&#123;% block main %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;h1&gt;Sign in success!&lt;/h1&gt;</span><br><span class=\"line\">  &lt;div class=&quot;alert alert-danger&quot;&gt; </span><br><span class=\"line\">    &lt;strong&gt;This is post login name: &#123;&#123; title &#125;&#125;&lt;/strong&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">    &#123;% for f in data %&#125;</span><br><span class=\"line\">      &#123;% if f.age &lt; 10 %&#125;</span><br><span class=\"line\">        &lt;li&gt;postValue: 00000&lt;/li&gt;</span><br><span class=\"line\">      &#123;% elif f.age == 10 %&#125;</span><br><span class=\"line\">        &lt;li&gt;postValue: 10&lt;/li&gt;</span><br><span class=\"line\">      &#123;% else %&#125;</span><br><span class=\"line\">        &lt;li&gt;postValue: &#123;&#123; f.name &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">    &#123;% endfor %&#125;</span><br><span class=\"line\">  &lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><p>一切顺利的话，这个view-koa工程应该可以顺利运行。运行前，我们再检查一下app.js里的middleware的顺序：</p>\n<p>第一个middleware是记录URL以及页面执行时间：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`);</span><br><span class=\"line\">    var</span><br><span class=\"line\">        start = new Date().getTime(),</span><br><span class=\"line\">        execTime;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">    execTime = new Date().getTime() - start;</span><br><span class=\"line\">    ctx.response.set(&apos;X-Response-Time&apos;, `$&#123;execTime&#125;ms`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>第二个middleware解析POST请求：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(bodyParser());</span><br></pre></td></tr></table></figure></p>\n<p>第三个middleware负责给ctx加上render()来使用Nunjucks：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(templating(&apos;view&apos;, &#123;</span><br><span class=\"line\">    noCache: !isProduction,</span><br><span class=\"line\">    watch: !isProduction</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>最后一个middleware处理URL路由：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(controller());</span><br></pre></td></tr></table></figure></p>\n<p>现在，在VS Code中运行代码，不出意外的话，在浏览器输入localhost:3000/，可以看到效果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、koa简介\"><a href=\"#一、koa简介\" class=\"headerlink\" title=\"一、koa简介\"></a>一、koa简介</h1><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p>\n<h1 id=\"二、koa2的优势\"><a href=\"#二、koa2的优势\" class=\"headerlink\" title=\"二、koa2的优势\"></a>二、koa2的优势</h1><h4 id=\"1-express\"><a href=\"#1-express\" class=\"headerlink\" title=\"1. express\"></a>1. express</h4><p>虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/test&apos;, function (req, res) &#123;</span><br><span class=\"line\">    fs.readFile(&apos;/file1&apos;, function (err, data) &#123;</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">            res.status(500).send(&apos;read file1 error&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fs.readFile(&apos;/file2&apos;, function (err, data) &#123;</span><br><span class=\"line\">            if (err) &#123;</span><br><span class=\"line\">                res.status(500).send(&apos;read file2 error&apos;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.type(&apos;text/plain&apos;);</span><br><span class=\"line\">            res.send(data);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-koa-1-0\"><a href=\"#2-koa-1-0\" class=\"headerlink\" title=\"2. koa 1.0\"></a>2. koa 1.0</h4><p>随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.0使用generator实现异步，代码看起来像同步的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var koa = require(&apos;koa&apos;);</span><br><span class=\"line\">var app = koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(&apos;/test&apos;, function *() &#123;</span><br><span class=\"line\">    yield doReadFile1();</span><br><span class=\"line\">    var data = yield doReadFile2();</span><br><span class=\"line\">    this.body = data;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-koa-2-0\"><a href=\"#3-koa-2-0\" class=\"headerlink\" title=\"3. koa 2.0\"></a>3. koa 2.0</h4><p>随着ES7引入了新的语法糖async和await，JavaScript未来标准的异步代码是这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function () &#123;</span><br><span class=\"line\">    var data = await fs.read(&apos;/file1&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>koa团队并没有止步于koa 1.0，他们非常超前地基于ES7开发了koa2。koa2的代码看上去像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">    var data = await doReadFile();</span><br><span class=\"line\">    ctx.response.type = &apos;text/plain&apos;;</span><br><span class=\"line\">    ctx.response.body = data;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-中间件的执行顺序\"><a href=\"#4-中间件的执行顺序\" class=\"headerlink\" title=\"4. 中间件的执行顺序\"></a>4. 中间件的执行顺序</h4><p>koa的中间件是由generator组成的，这决定了中间件的执行顺序。<br>Express的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。</p>\n<p>koa是从第一个中间件开始执行，遇到<code>next</code>进入下一个中间件，一直执行到最后一个中间件，在逆序，执行上一个中间件<code>next</code>之后的代码，一直到第一个中间件执行结束才发出响应。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const one = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;&gt;&gt; one&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">  console.log(&apos;&lt;&lt; one&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">const two = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;&gt;&gt; two&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">  console.log(&apos;&lt;&lt; two&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">const three = (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;&gt;&gt; three&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">  console.log(&apos;&lt;&lt; three&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">app.use(one);</span><br><span class=\"line\">app.use(two);</span><br><span class=\"line\">app.use(three);</span><br><span class=\"line\"> </span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">&gt;&gt; one</span><br><span class=\"line\">&gt;&gt; two</span><br><span class=\"line\">&gt;&gt; three</span><br><span class=\"line\">&lt;&lt; three</span><br><span class=\"line\">&lt;&lt; two</span><br><span class=\"line\">&lt;&lt; one</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"三、koa2入门及搭建\"><a href=\"#三、koa2入门及搭建\" class=\"headerlink\" title=\"三、koa2入门及搭建\"></a>三、koa2入门及搭建</h1><h4 id=\"1-Context\"><a href=\"#1-Context\" class=\"headerlink\" title=\"1. Context\"></a>1. Context</h4><p>Context封装了node中的request和response。</p>\n<p><a href=\"mailto:koa@1.x\" target=\"_blank\" rel=\"noopener\">koa@1.x</a>使用this引用Context对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(function *()&#123;</span><br><span class=\"line\">  this.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><a href=\"mailto:koa@2.x\" target=\"_blank\" rel=\"noopener\">koa@2.x</a>中使用ctx来访问Context对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  ctx.body = &apos;Hello World&apos;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-创建koa2工程\"><a href=\"#2-创建koa2工程\" class=\"headerlink\" title=\"2. 创建koa2工程\"></a>2. 创建koa2工程</h4><p>首先，我们创建一个目录hello-koa并作为工程目录用VS Code打开。然后，我们创建app.js，输入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:</span><br><span class=\"line\">const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建一个Koa对象表示web app本身:</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\"></span><br><span class=\"line\">// 对于任何请求，app将调用该异步函数处理请求：</span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 在端口3000监听:</span><br><span class=\"line\">app.listen(3000);</span><br><span class=\"line\">console.log(&apos;app started at port 3000...&apos;);</span><br></pre></td></tr></table></figure>\n<p>对于每一个http请求，koa将调用我们传入的异步函数来处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  // 设置response的Content-Type:</span><br><span class=\"line\">  ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">  // 设置response的内容:</span><br><span class=\"line\">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，next是koa传入的将要处理的下一个异步函数。</p>\n<p>上面的异步函数中，我们首先用await next();处理下一个异步函数，然后，设置response的Content-Type和内容。</p>\n<p>由async标记的函数称为异步函数，在异步函数中，可以用await调用另一个异步函数，这两个关键字将在ES7中引入。</p>\n<p>现在我们遇到第一个问题：koa这个包怎么装，app.js才能正常导入它？</p>\n<p>在hello-koa这个目录下创建一个package.json，这个文件描述了我们的hello-koa工程会用到哪些包。完整的文件内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hello-koa2&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;description&quot;: &quot;Hello Koa 2 example with async&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">      &quot;start&quot;: &quot;node app.js&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;keywords&quot;: [</span><br><span class=\"line\">      &quot;koa&quot;,</span><br><span class=\"line\">      &quot;async&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;author&quot;: &quot;&quot;,</span><br><span class=\"line\">  &quot;license&quot;: &quot;Apache-2.0&quot;,</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">      &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">      &quot;url&quot;: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">      &quot;koa&quot;: &quot;2.0.0&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们在hello-koa目录下执行npm install就可以把所需包以及依赖包一次性全部装好。<br>现在，我们的工程结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello-koa/</span><br><span class=\"line\">|</span><br><span class=\"line\">+- app.js &lt;-- 使用koa的js</span><br><span class=\"line\">|</span><br><span class=\"line\">+- package.json &lt;-- 项目描述文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure></p>\n<p>在控制台执行 npm run start,我们打开浏览器，输入<a href=\"http://localhost:3000，即可看到效果：\" target=\"_blank\" rel=\"noopener\">http://localhost:3000，即可看到效果：</a></p>\n<h4 id=\"3-koa-middleware\"><a href=\"#3-koa-middleware\" class=\"headerlink\" title=\"3. koa middleware\"></a>3. koa middleware</h4><p>让我们再仔细看看koa的执行逻辑。核心代码是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>每收到一个http请求，koa就会调用通过app.use()注册的async函数，并传入ctx和next参数。</p>\n<p>我们可以对ctx操作，并设置返回内容。但是为什么要调用await next()？</p>\n<p>原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>\n<p>例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(`$&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); // 打印URL</span><br><span class=\"line\">  await next(); // 调用下一个middleware</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  const start = new Date().getTime(); // 当前时间</span><br><span class=\"line\">  await next(); // 调用下一个middleware</span><br><span class=\"line\">  const ms = new Date().getTime() - start; // 耗费时间</span><br><span class=\"line\">  console.log(`Time: $&#123;ms&#125;ms`); // 打印耗费时间</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">  ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>middleware的顺序很重要，也就是调用app.use()的顺序决定了middleware的顺序。</p>\n<p>此外，如果一个middleware没有调用await next()，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  if (await checkUserPermission(ctx)) &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    ctx.response.status = 403;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>理解了middleware，我们就已经会用koa了！</p>\n<p>最后注意ctx对象有一些简写的方法，例如ctx.url相当于ctx.request.url，ctx.type相当于ctx.response.type。</p>\n<h1 id=\"四、处理URL\"><a href=\"#四、处理URL\" class=\"headerlink\" title=\"四、处理URL\"></a>四、处理URL</h1><p>在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。<br>正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  if (ctx.request.path === &apos;/&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = &apos;index page&apos;;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  if (ctx.request.path === &apos;/test&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = &apos;TEST page&apos;;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  if (ctx.request.path === &apos;/error&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = &apos;ERROR page&apos;;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这么写是可以运行的，但是好像有点蠢。</p>\n<p>应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。</p>\n<h4 id=\"1-koa-router\"><a href=\"#1-koa-router\" class=\"headerlink\" title=\"1. koa-router\"></a>1. koa-router</h4><p>为了处理URL，我们需要引入koa-router这个middleware，让它负责处理URL映射。</p>\n<p>我们把上一节的hello-koa工程复制一份，重命名为url-koa。</p>\n<p>先在package.json中添加依赖项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;koa-router&quot;: &quot;7.0.0&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后用npm install安装。</p>\n<p>接下来，我们修改app.js，使用koa-router来处理URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 注意require(&apos;koa-router&apos;)返回的是函数:</span><br><span class=\"line\">const router = require(&apos;koa-router&apos;)();</span><br><span class=\"line\"></span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\"></span><br><span class=\"line\">// log request URL:</span><br><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`);</span><br><span class=\"line\">  await next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// add url-route:</span><br><span class=\"line\">router.get(&apos;/hello/:name&apos;, async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  var name = ctx.params.name;</span><br><span class=\"line\">  ctx.response.body = `&lt;h1&gt;Hello, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    ctx.response.body = &apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// add router middleware:</span><br><span class=\"line\">app.use(router.routes());</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000);</span><br><span class=\"line\">console.log(&apos;app started at port 3000...&apos;);</span><br></pre></td></tr></table></figure>\n<p>然后，我们使用router.get(‘/path’, async fn)来注册一个GET请求。可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问。</p>\n<p>再运行app.js，我们就可以测试不同的URL。</p>\n<h4 id=\"2-处理post请求\"><a href=\"#2-处理post请求\" class=\"headerlink\" title=\"2. 处理post请求\"></a>2. 处理post请求</h4><p>用router.get(‘/path’, async fn)处理的是get请求。如果要处理post请求，可以用router.post(‘/path’, async fn)。</p>\n<p>用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！</p>\n<p>所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。</p>\n<p>koa-bodyparser就是用来干这个活的。</p>\n<p>我们在package.json中添加依赖项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;koa-bodyparser&quot;: &quot;3.2.0&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后使用npm install安装。</p>\n<p>下面，修改app.js，引入koa-bodyparser：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const bodyParser = require(&apos;koa-bodyparser&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>在合适的位置加上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(bodyParser());</span><br></pre></td></tr></table></figure></p>\n<p>由于middleware的顺序很重要，这个koa-bodyparser必须在router之前被注册到app对象上。</p>\n<p>现在我们就可以处理post请求了。写一个简单的登录表单：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt;</span><br><span class=\"line\">      &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">          &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">          &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">          &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/form&gt;`;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(&apos;/signin&apos;, async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  var</span><br><span class=\"line\">    name = ctx.request.body.name || &apos;&apos;,</span><br><span class=\"line\">    password = ctx.request.body.password || &apos;&apos;;</span><br><span class=\"line\">  console.log(`signin with name: $&#123;name&#125;, password: $&#123;password&#125;`);</span><br><span class=\"line\">  if (name === &apos;koa&apos; &amp;&amp; password === &apos;12345&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>注意到我们用var name = ctx.request.body.name || ‘’拿到表单的name字段，如果该字段不存在，默认值设置为’’。</p>\n<p>类似的，put、delete、head请求也可以由router处理。</p>\n<h4 id=\"3-重构\"><a href=\"#3-重构\" class=\"headerlink\" title=\"3. 重构\"></a>3. 重构</h4><p>现在，我们已经可以处理不同的URL了，但是看看app.js，总觉得还是有点不对劲。</p>\n<p>所有的URL处理函数都放到app.js里显得很乱，而且，每加一个URL，就需要修改app.js。随着URL越来越多，app.js就会越来越长。</p>\n<p>如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让app.js自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+- controllers/</span><br><span class=\"line\">|  |</span><br><span class=\"line\">|  +- login.js &lt;-- 处理login相关URL</span><br><span class=\"line\">|  |</span><br><span class=\"line\">|  +- users.js &lt;-- 处理用户管理相关URL</span><br><span class=\"line\">|</span><br><span class=\"line\">+- app.js &lt;-- 使用koa的js</span><br><span class=\"line\">|</span><br><span class=\"line\">+- package.json &lt;-- 项目描述文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure></p>\n<p>我们先在controllers目录下编写index.js：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fn_index = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt;</span><br><span class=\"line\">      &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">          &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">          &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">          &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">      &lt;/form&gt;`;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var fn_signin = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  var</span><br><span class=\"line\">    name = ctx.request.body.name || &apos;&apos;,</span><br><span class=\"line\">    password = ctx.request.body.password || &apos;&apos;;</span><br><span class=\"line\">  console.log(`signin with name: $&#123;name&#125;, password: $&#123;password&#125;`);</span><br><span class=\"line\">  if (name === &apos;koa&apos; &amp;&amp; password === &apos;12345&apos;) &#123;</span><br><span class=\"line\">    ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  &apos;GET /&apos;: fn_index,</span><br><span class=\"line\">  &apos;POST /signin&apos;: fn_signin</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这个index.js通过module.exports把两个URL处理函数暴露出来。</p>\n<p>类似的，hello.js把一个URL处理函数暴露出来：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fn_hello = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  var name = ctx.params.name;</span><br><span class=\"line\">  ctx.response.body = `&lt;h1&gt;Hello, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  &apos;GET /hello/:name&apos;: fn_hello</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>现在，我们修改app.js，让它自动扫描controllers目录，找到所有js文件，导入，然后注册每个URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先导入fs模块，然后用readdirSync列出文件</span><br><span class=\"line\">// 这里可以用sync是因为启动时只运行一次，不存在性能问题:</span><br><span class=\"line\">var files = fs.readdirSync(__dirname + &apos;/controllers&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 过滤出.js文件:</span><br><span class=\"line\">var js_files = files.filter((f)=&gt;&#123;</span><br><span class=\"line\">  return f.endsWith(&apos;.js&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 处理每个js文件:</span><br><span class=\"line\">for (var f of js_files) &#123;</span><br><span class=\"line\">  console.log(`process controller: $&#123;f&#125;...`);</span><br><span class=\"line\">  // 导入js文件:</span><br><span class=\"line\">  let mapping = require(__dirname + &apos;/controllers/&apos; + f);</span><br><span class=\"line\">  for (var url in mapping) &#123;</span><br><span class=\"line\">    if (url.startsWith(&apos;GET &apos;)) &#123;</span><br><span class=\"line\">      // 如果url类似&quot;GET xxx&quot;:</span><br><span class=\"line\">      var path = url.substring(4);</span><br><span class=\"line\">      router.get(path, mapping[url]);</span><br><span class=\"line\">      console.log(`register URL mapping: GET $&#123;path&#125;`);</span><br><span class=\"line\">    &#125; else if (url.startsWith(&apos;POST &apos;)) &#123;</span><br><span class=\"line\">      // 如果url类似&quot;POST xxx&quot;:</span><br><span class=\"line\">      var path = url.substring(5);</span><br><span class=\"line\">      router.post(path, mapping[url]);</span><br><span class=\"line\">      console.log(`register URL mapping: POST $&#123;path&#125;`);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 无效的URL:</span><br><span class=\"line\">      console.log(`invalid URL: $&#123;url&#125;`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果上面的大段代码看起来还是有点费劲，那就把它拆成更小单元的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addMapping(router, mapping) &#123;</span><br><span class=\"line\">  for (var url in mapping) &#123;</span><br><span class=\"line\">    if (url.startsWith(&apos;GET &apos;)) &#123;</span><br><span class=\"line\">      var path = url.substring(4);</span><br><span class=\"line\">      router.get(path, mapping[url]);</span><br><span class=\"line\">      console.log(`register URL mapping: GET $&#123;path&#125;`);</span><br><span class=\"line\">    &#125; else if (url.startsWith(&apos;POST &apos;)) &#123;</span><br><span class=\"line\">      var path = url.substring(5);</span><br><span class=\"line\">      router.post(path, mapping[url]);</span><br><span class=\"line\">      console.log(`register URL mapping: POST $&#123;path&#125;`);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      console.log(`invalid URL: $&#123;url&#125;`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function addControllers(router) &#123;</span><br><span class=\"line\">  var files = fs.readdirSync(__dirname + &apos;/controllers&apos;);</span><br><span class=\"line\">  var js_files = files.filter((f) =&gt; &#123;</span><br><span class=\"line\">      return f.endsWith(&apos;.js&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  for (var f of js_files) &#123;</span><br><span class=\"line\">      console.log(`process controller: $&#123;f&#125;...`);</span><br><span class=\"line\">      let mapping = require(__dirname + &apos;/controllers/&apos; + f);</span><br><span class=\"line\">      addMapping(router, mapping);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addControllers(router);</span><br></pre></td></tr></table></figure>\n<p>确保每个函数功能非常简单，一眼能看明白，是代码可维护的关键。</p>\n<h4 id=\"Controller-Middleware\"><a href=\"#Controller-Middleware\" class=\"headerlink\" title=\"Controller Middleware\"></a>Controller Middleware</h4><p>最后，我们把扫描controllers目录和创建router的代码从app.js中提取出来，作为一个简单的middleware使用，命名为controller.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function addMapping(router, mapping) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function addControllers(router, dir) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function (dir) &#123;</span><br><span class=\"line\">  let</span><br><span class=\"line\">      controllers_dir = dir || &apos;controllers&apos;, // 如果不传参数，扫描目录默认为&apos;controllers&apos;</span><br><span class=\"line\">      router = require(&apos;koa-router&apos;)();</span><br><span class=\"line\">  addControllers(router, controllers_dir);</span><br><span class=\"line\">  return router.routes();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样一来，我们在app.js的代码又简化了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">// 导入controller middleware:</span><br><span class=\"line\">const controller = require(&apos;./controller&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用middleware:</span><br><span class=\"line\">app.use(controller());</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>经过重新整理后的工程url2-koa目前具备非常好的模块化，所有处理URL的函数按功能组存放在controllers目录，今后我们也只需要不断往这个目录下加东西就可以了，app.js保持不变。</p>\n<h1 id=\"五、使用Nunjucks模板引擎\"><a href=\"#五、使用Nunjucks模板引擎\" class=\"headerlink\" title=\"五、使用Nunjucks模板引擎\"></a>五、使用Nunjucks模板引擎</h1><p>模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。<br>有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？<br>因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。<br>输出HTML有几个特别重要的问题需要考虑：</p>\n<h4 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h4><p>对特殊字符要转义，避免受到XSS攻击。比如，如果变量name的值不是小明，而是小明<script>…</script>，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。</p>\n<h4 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h4><p>对不同类型的变量要格式化，比如，货币需要变成12,345.00这样的格式，日期需要变成2016-01-01这样的格式。</p>\n<h4 id=\"简单逻辑\"><a href=\"#简单逻辑\" class=\"headerlink\" title=\"简单逻辑\"></a>简单逻辑</h4><p>模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; name &#125;&#125;同学，</span><br><span class=\"line\">&#123;% if score &gt;= 90 %&#125;</span><br><span class=\"line\">    成绩优秀，应该奖励</span><br><span class=\"line\">&#123;% elif score &gt;=60 %&#125;</span><br><span class=\"line\">    成绩良好，继续努力</span><br><span class=\"line\">&#123;% else %&#125;</span><br><span class=\"line\">    不及格，建议回家打屁股</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。</p>\n<h4 id=\"Nunjucks\"><a href=\"#Nunjucks\" class=\"headerlink\" title=\"Nunjucks\"></a>Nunjucks</h4><p>我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。</p>\n<p>虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function render(view, model) &#123;</span><br><span class=\"line\">    // TODO:...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，view是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。model就是数据，在JavaScript中，它就是一个简单的Object。render函数返回一个字符串，就是模板的输出。</p>\n<p>下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。</p>\n<p>我们创建一个use-nunjucks的VS Code工程结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use-nunjucks/</span><br><span class=\"line\">|</span><br><span class=\"line\">+- views/</span><br><span class=\"line\">|  |</span><br><span class=\"line\">|  +- hello.html &lt;-- HTML模板文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- app.js &lt;-- 入口js</span><br><span class=\"line\">|</span><br><span class=\"line\">+- package.json &lt;-- 项目描述文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure>\n<p>其中，模板文件存放在views目录中。</p>\n<p>我们先在package.json中添加nunjucks的依赖：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;nunjucks&quot;: &quot;2.4.2&quot;</span><br></pre></td></tr></table></figure></p>\n<p>注意，模板引擎是可以独立使用的，并不需要依赖koa。用npm install安装所有依赖包。</p>\n<p>紧接着，我们要编写使用Nunjucks的函数render。怎么写？方法是查看<a href=\"http://mozilla.github.io/nunjucks/\" target=\"_blank\" rel=\"noopener\">Nunjucks</a>的官方文档，仔细阅读后，在app.js中编写代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const nunjucks = require(&apos;nunjucks&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function createEnv(path, opts) &#123;</span><br><span class=\"line\">    var</span><br><span class=\"line\">        autoescape = opts.autoescape === undefined ? true : opts.autoescape,</span><br><span class=\"line\">        noCache = opts.noCache || false,</span><br><span class=\"line\">        watch = opts.watch || false,</span><br><span class=\"line\">        throwOnUndefined = opts.throwOnUndefined || false,</span><br><span class=\"line\">        env = new nunjucks.Environment(</span><br><span class=\"line\">            new nunjucks.FileSystemLoader(&apos;views&apos;, &#123;</span><br><span class=\"line\">                noCache: noCache,</span><br><span class=\"line\">                watch: watch,</span><br><span class=\"line\">            &#125;), &#123;</span><br><span class=\"line\">                autoescape: autoescape,</span><br><span class=\"line\">                throwOnUndefined: throwOnUndefined</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    if (opts.filters) &#123;</span><br><span class=\"line\">        for (var f in opts.filters) &#123;</span><br><span class=\"line\">            env.addFilter(f, opts.filters[f]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return env;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var env = createEnv(&apos;views&apos;, &#123;</span><br><span class=\"line\">    watch: true,</span><br><span class=\"line\">    filters: &#123;</span><br><span class=\"line\">        hex: function (n) &#123;</span><br><span class=\"line\">            return &apos;0x&apos; + n.toString(16);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>变量env就表示Nunjucks模板引擎对象，它有一个render(view, model)方法，正好传入view和model两个参数，并返回字符串。</p>\n<p>创建env需要的参数可以查看文档获知。我们用autoescape = opts.autoescape &amp;&amp; true这样的代码给每个参数加上默认值，最后使用new nunjucks.FileSystemLoader(‘views’)创建一个文件系统加载器，从views目录读取模板。</p>\n<p>我们编写一个hello.html模板文件，放到views目录下，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后，我们就可以用下面的代码来渲染这个模板：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = env.render(&apos;hello.html&apos;, &#123; name: &apos;小明&apos; &#125;);</span><br><span class=\"line\">console.log(s);</span><br></pre></td></tr></table></figure></p>\n<p>获得输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;Hello 小明&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>\n<p>咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = env.render(&apos;hello.html&apos;, &#123; name: &apos;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&apos; &#125;);</span><br><span class=\"line\">console.log(s);</span><br></pre></td></tr></table></figure></p>\n<p>获得输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;Hello &amp;lt;script&amp;gt;alert(&quot;小明&quot;)&amp;lt;/script&amp;gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这样就避免了输出恶意脚本。</p>\n<p>此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 循环输出名字 --&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;h3&gt;Fruits List&lt;/h3&gt;</span><br><span class=\"line\">    &#123;% for f in fruits %&#125;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123; f &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &#123;% endfor %&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>\n<p>Nunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。</p>\n<p>更好的方式是使用继承。先定义一个基本的网页框架base.html：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;&lt;body&gt;</span><br><span class=\"line\">&#123;% block header %&#125; &lt;h3&gt;Unnamed&lt;/h3&gt; &#123;% endblock %&#125;</span><br><span class=\"line\">&#123;% block body %&#125; &lt;div&gt;No body&lt;/div&gt; &#123;% endblock %&#125;</span><br><span class=\"line\">&#123;% block footer %&#125; &lt;div&gt;copyright&lt;/div&gt; &#123;% endblock %&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>base.html定义了三个可编辑的块，分别命名为header、body和footer。子模板可以有选择地对块进行重新定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends &apos;base.html&apos; %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block header %&#125;&lt;h1&gt;&#123;&#123; header &#125;&#125;&lt;/h1&gt;&#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block body %&#125;&lt;p&gt;&#123;&#123; body &#125;&#125;&lt;/p&gt;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后，我们对子模板进行渲染：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(env.render(&apos;extend.html&apos;, &#123;</span><br><span class=\"line\">    header: &apos;Hello&apos;,</span><br><span class=\"line\">    body: &apos;bla bla bla...&apos;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>输出HTML如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\">&lt;p&gt;bla bla bla...&lt;/p&gt;</span><br><span class=\"line\">&lt;div&gt;copyright&lt;/div&gt; &lt;-- footer没有重定义，所以仍使用父模板的内容</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><p>最后我们要考虑一下Nunjucks的性能。</p>\n<p>对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。</p>\n<p>性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。</p>\n<p>好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了noCache: false这个参数。</p>\n<p>在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。</p>\n<p>Nunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。</p>\n<h1 id=\"六、使用MVC\"><a href=\"#六、使用MVC\" class=\"headerlink\" title=\"六、使用MVC\"></a>六、使用MVC</h1><p>我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！</p>\n<p>当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.render(&apos;home.html&apos;, &#123; name: &apos;Michael&apos; &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/09/18/3b40147c96c8b17cb2564c782f90bd40.png\" alt></p>\n<p>这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。</p>\n<p>异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；</p>\n<p>包含变量的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>\n<p>MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</p>\n<p>上面的例子中，Model就是一个JavaScript对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; name: &apos;Michael&apos; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面，我们根据原来的项目创建工程，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为ctx.render(view, model)的方式。</p>\n<p>工程结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view-koa/</span><br><span class=\"line\">|</span><br><span class=\"line\">+- controllers/ &lt;-- Controller</span><br><span class=\"line\">|</span><br><span class=\"line\">+- views/ &lt;-- html模板文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- static/ &lt;-- 静态资源文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- controller.js &lt;-- 扫描注册Controller</span><br><span class=\"line\">|</span><br><span class=\"line\">+- app.js &lt;-- 使用koa的js</span><br><span class=\"line\">|</span><br><span class=\"line\">+- package.json &lt;-- 项目描述文件</span><br><span class=\"line\">|</span><br><span class=\"line\">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure></p>\n<p>先用npm install安装依赖包。</p>\n<p>然后，我们准备编写以下两个Controller：</p>\n<h4 id=\"处理首页-GET\"><a href=\"#处理首页-GET\" class=\"headerlink\" title=\"处理首页 GET /\"></a>处理首页 GET /</h4><p>我们定义一个async函数处理首页URL/：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    ctx.render(&apos;index.html&apos;, &#123;</span><br><span class=\"line\">        title: &apos;Welcome&apos;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意到koa并没有在ctx对象上提供render方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用ctx.render(view, model)就完成了页面输出。</p>\n<h4 id=\"处理登录请求-POST-signin\"><a href=\"#处理登录请求-POST-signin\" class=\"headerlink\" title=\"处理登录请求 POST /signin\"></a>处理登录请求 POST /signin</h4><p>我们再定义一个async函数处理登录请求/signin：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    var</span><br><span class=\"line\">        email = ctx.request.body.email || &apos;&apos;,</span><br><span class=\"line\">        password = ctx.request.body.password || &apos;&apos;;</span><br><span class=\"line\">    if (email === &apos;admin@example.com&apos; &amp;&amp; password === &apos;123456&apos;) &#123;</span><br><span class=\"line\">        // 登录成功:</span><br><span class=\"line\">        ctx.render(&apos;signin-ok.html&apos;, &#123;</span><br><span class=\"line\">            title: &apos;Sign In OK&apos;,</span><br><span class=\"line\">            name: &apos;Mr Node&apos;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // 登录失败:</span><br><span class=\"line\">        ctx.render(&apos;signin-failed.html&apos;, &#123;</span><br><span class=\"line\">            title: &apos;Sign In Failed&apos;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于登录请求是一个POST，我们就用ctx.request.body.<name>拿到POST请求的数据，并给一个默认值。</name></p>\n<p>登录成功时我们用signin-ok.html渲染，登录失败时我们用signin-failed.html渲染，所以，我们一共需要以下3个View：</p>\n<ul>\n<li>base.html</li>\n<li>signin-ok.html</li>\n<li>signin-failed.html</li>\n</ul>\n<h4 id=\"集成Nunjucks\"><a href=\"#集成Nunjucks\" class=\"headerlink\" title=\"集成Nunjucks\"></a>集成Nunjucks</h4><p>集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给ctx对象绑定一个render(view, model)的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。</p>\n<p>我们创建一个templating.js来实现这个middleware：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const nunjucks = require(&apos;nunjucks&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function createEnv(path, opts) &#123;</span><br><span class=\"line\">    var</span><br><span class=\"line\">        autoescape = opts.autoescape === undefined ? true : opts.autoescape,</span><br><span class=\"line\">        noCache = opts.noCache || false,</span><br><span class=\"line\">        watch = opts.watch || false,</span><br><span class=\"line\">        throwOnUndefined = opts.throwOnUndefined || false,</span><br><span class=\"line\">        env = new nunjucks.Environment(</span><br><span class=\"line\">            new nunjucks.FileSystemLoader(path || &apos;views&apos;, &#123;</span><br><span class=\"line\">                noCache: noCache,</span><br><span class=\"line\">                watch: watch,</span><br><span class=\"line\">            &#125;), &#123;</span><br><span class=\"line\">                autoescape: autoescape,</span><br><span class=\"line\">                throwOnUndefined: throwOnUndefined</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    if (opts.filters) &#123;</span><br><span class=\"line\">        for (var f in opts.filters) &#123;</span><br><span class=\"line\">            env.addFilter(f, opts.filters[f]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return env;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function templating(path, opts) &#123;</span><br><span class=\"line\">    // 创建Nunjucks的env对象:</span><br><span class=\"line\">    var env = createEnv(path, opts);</span><br><span class=\"line\">    return async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">        // 给ctx绑定render函数:</span><br><span class=\"line\">        ctx.render = function (view, model) &#123;</span><br><span class=\"line\">            // 把render后的内容赋值给response.body:</span><br><span class=\"line\">            ctx.response.body = env.render(view, Object.assign(&#123;&#125;, ctx.state || &#123;&#125;, model || &#123;&#125;));</span><br><span class=\"line\">            // 设置Content-Type:</span><br><span class=\"line\">            ctx.response.type = &apos;text/html&apos;;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        // 继续处理请求:</span><br><span class=\"line\">        await next();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = templating;</span><br></pre></td></tr></table></figure></p>\n<p>注意到createEnv()函数和前面使用Nunjucks时编写的函数是一模一样的。我们主要关心tempating()函数，它会返回一个middleware，在这个middleware中，我们只给ctx“安装”了一个render()函数，其他什么事情也没干，就继续调用下一个middleware。</p>\n<p>使用的时候，我们在app.js添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const isProduction = process.env.NODE_ENV === &apos;production&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(templating(&apos;views&apos;, &#123;</span><br><span class=\"line\">    noCache: !isProduction,</span><br><span class=\"line\">    watch: !isProduction</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了一个常量isProduction，它判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。</p>\n<p>Node.js在全局变量process中定义了一个环境变量env.NODE_ENV，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为’development’，而部署到服务器时，环境变量应该设置为’production’。在编写代码的时候，要根据当前环境作不同的判断。</p>\n<p>注意：生产环境上必须配置环境变量NODE_ENV = ‘production’，而开发环境不需要配置，实际上NODE_ENV可能是undefined，所以判断的时候，不要用NODE_ENV === ‘development’。</p>\n<p>这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。</p>\n<h4 id=\"编写View\"><a href=\"#编写View\" class=\"headerlink\" title=\"编写View\"></a>编写View</h4><p>在编写View的时候，非常有必要先编写一个base.html作为骨架，其他模板都继承自base.html，这样，才能大大减少重复工作。</p>\n<p>编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了base.html。</p>\n<p>base.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;description&quot; content=&quot;learn javascript&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;header style=&quot;background-color:#6f5499;height: 100px;color: #fff;&quot;&gt;</span><br><span class=\"line\">      header top main</span><br><span class=\"line\">  &lt;/header&gt;</span><br><span class=\"line\">  &#123;% block main %&#125; &#123;% endblock %&#125;</span><br><span class=\"line\">  &lt;footer style=&quot;background-color:#ddd; padding: 20px 0;text-align: center;color: #666;&quot;&gt;</span><br><span class=\"line\">      copy right @2019</span><br><span class=\"line\">  &lt;/footer&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>signin-ok.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% extends &quot;base.html&quot; %&#125; </span><br><span class=\"line\">&#123;% block main %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;h1&gt;Sign in success!&lt;/h1&gt;</span><br><span class=\"line\">  &lt;div class=&quot;alert alert-danger&quot;&gt; </span><br><span class=\"line\">    &lt;strong&gt;This is post login name: &#123;&#123; title &#125;&#125;&lt;/strong&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">    &#123;% for f in data %&#125;</span><br><span class=\"line\">      &#123;% if f.age &lt; 10 %&#125;</span><br><span class=\"line\">        &lt;li&gt;postValue: 00000&lt;/li&gt;</span><br><span class=\"line\">      &#123;% elif f.age == 10 %&#125;</span><br><span class=\"line\">        &lt;li&gt;postValue: 10&lt;/li&gt;</span><br><span class=\"line\">      &#123;% else %&#125;</span><br><span class=\"line\">        &lt;li&gt;postValue: &#123;&#123; f.name &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">      &#123;% endif %&#125;</span><br><span class=\"line\">    &#123;% endfor %&#125;</span><br><span class=\"line\">  &lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><p>一切顺利的话，这个view-koa工程应该可以顺利运行。运行前，我们再检查一下app.js里的middleware的顺序：</p>\n<p>第一个middleware是记录URL以及页面执行时间：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`);</span><br><span class=\"line\">    var</span><br><span class=\"line\">        start = new Date().getTime(),</span><br><span class=\"line\">        execTime;</span><br><span class=\"line\">    await next();</span><br><span class=\"line\">    execTime = new Date().getTime() - start;</span><br><span class=\"line\">    ctx.response.set(&apos;X-Response-Time&apos;, `$&#123;execTime&#125;ms`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>第二个middleware解析POST请求：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(bodyParser());</span><br></pre></td></tr></table></figure></p>\n<p>第三个middleware负责给ctx加上render()来使用Nunjucks：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(templating(&apos;view&apos;, &#123;</span><br><span class=\"line\">    noCache: !isProduction,</span><br><span class=\"line\">    watch: !isProduction</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>最后一个middleware处理URL路由：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(controller());</span><br></pre></td></tr></table></figure></p>\n<p>现在，在VS Code中运行代码，不出意外的话，在浏览器输入localhost:3000/，可以看到效果。</p>\n"},{"title":"MongoDB 基础教程","comments":1,"date":"2019-10-17T02:18:35.000Z","author":"jun.zhou","_content":"\n# MongoDB基础教程\n\n![MongoDB](https://img.fengjr.com/image/2019/10/17/76a8980ba092a2e602c20dc4498b0fdb.png)\n\n## 简介\n\n[MongoDB](https://baike.baidu.com/item/MongoDB)是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的，它支持的数据结构非常松散，是类似json的bson（二进制JSON）格式。\n\n特点是高性能、易部署、易使用，存储数据非常方便，适用于敏捷开发。\n\n## 安装和连接\n\n### Mac OSX 平台安装 MongoDB\n\n#### 官网\n\n官网下载地址 https://www.mongodb.com/download-center#community\n\n按照教程直接下载即可，命令行下载的方式如下。\n\n#### 使用 curl 命令安装\n\n\n```bash\n# 进入 /usr/local\ncd /usr/local\n\n# 下载\nsudo curl -O https://fastdl.mongodb.org/osx/mongodb-osx-ssl-x86_64-4.0.11.tgz\n\n# 解压\nsudo tar -zxvf mongodb-osx-ssl-x86_64-4.0.9.tgz\n\n# 重命名为 mongodb 目录\n\nsudo mv mongodb-osx-x86_64-4.0.9/ mongodb\n```\n\n安装完成后，我们可以把 MongoDB 的二进制命令文件目录（安装目录/bin）添加到 PATH 路径中：\n\n```bash\nexport PATH=/usr/local/mongodb/bin:$PATH\n```\n\n#### 使用 brew 安装\n\n此外，还可以使用macos的homebrew安装mongodb\n\n\n```bash\nsudo brew install mongodb\n# 如果要安装支持 TLS/SSL 命令如下：\nsudo brew install mongodb --with-openssl\n# 安装最新开发版本\nsudo brew install mongodb --devel\n```\n\n### 运行MongoDB\n\n1、首先我们创建一个数据库存储目录\n\n```bash\nsudo mkdir -p /data/db\n```\n\n2、启动 mongodb，默认数据库目录即为 /data/db\n\n```bash\nsudo mongod\n\n# 如果没有创建全局路径 PATH，需要进入以下目录\ncd /usr/local/mongodb/bin\nsudo ./mongod\n```\n\n3、再打开一个终端进入执行以下命令：\n\n\n```bash\n$ cd /usr/local/mongodb/bin \n$ ./mongo\nMongoDB shell version v4.0.11\nconnecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb\nImplicit session: session { \"id\" : UUID(\"27e2b200-fa7c-4463-8c5d-506b97004e97\") }\nMongoDB server version: 4.0.11\n……\n> 1 + 1\n2\n> \n```\n\n如果你的数据库目录不是 /data/db，可以通过 --dbpath指定\n\n```bash\nsudo mongod --dbpath=/data/db \n```\n\n4、还可以通过工具 [Robo 3T](https://robomongo.org/) 来创建连接\n\n如下图所示，自定义应用名称，mongodb默认端口为27017\n\n![](https://img.fengjr.com/image/2019/10/16/58af404fd31241f2a6fb8d8195590f24.png)\n\n5、node mongoose 连接\n\n\n```bash\nconst mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost:27017/test');\n\nconst Cat = mongoose.model('Cat', { name: String });\n\nconst kitty = new Cat({ name: 'Zildjian' });\nkitty.save().then(() => console.log('meow'));\n```\n\n\n\n## 基础概念解析\n\n\nSQL术语/概念 | MongoDB术语/概 | 解释/说明\n---|---|---\ndatabase | database | 数据库\nrow | document | 数据记录行/文档\ncolumn | field | 数据字段/域\nindex | index | 索引\ntable joins |  | 表连接,MongoDB不支持\nprimary key | primary key | 主键,MongoDB自动将_id字段设置为主键\n\n### 数据库\n\n一个mongodb可以建立多个数据库\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。\n\nMongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中\n\n\"show dbs\" 命令可以显示所有数据的列表。\n\n```shell\n> show dbs\n<database>  0.000GB\nadmin       0.000GB\nconfig      0.000GB\nfund-cms    0.000GB\nlocal       0.000GB\n>\n```\n\n执行 \"db\" 命令可以显示当前数据库对象或集合。\n\n```bash\n$ ./mongo\nMongoDB shell version: 3.0.6\nconnecting to: test\n> db\ntest\n> \n```\n\n运行\"use\"命令，可以连接到一个指定的数据库。\n\n```\n> use local\nswitched to db local\n> db\nlocal\n> \n```\n\n### 文档(Document)\n\n文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n\n一个简单的文档例子如下：\n\n```JSON\n{\n    \"site\":\"www.fengjr.com\", \n    \"name\":\"凤凰金融\"\n}\n```\n需要注意的是：\n1. 文档中的键/值对是有序的。\n1. 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。\n1. MongoDB区分类型和大小写。\n1. MongoDB的文档不能有重复的键。\n1. 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符\n\n文档键命名规范：\n\n- 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。\n- .和$有特别的意义，只有在特定环境下才能使用。\n- 以下划线\"_\"开头的键是保留的(不是严格要求的)。\n\n### 集合\n\n集合就是 MongoDB 文档组，集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。\n\n```\n{\"site\":\"www.baidu.com\"}\n{\"site\":\"www.google.com\",\"name\":\"Google\"}\n{\"site\":\"www.runoob.com\",\"name\":\"菜鸟教程\",\"num\":5}\n```\n\n当第一个文档插入时，集合就会被创建\n\n#### 合法的集合名\n\n- 集合名不能是空字符串\"\"。\n- 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。\n- 集合名不能以\"system.\"开头，这是为系统集合保留的前缀。\n- 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　\n\n\n#### MongoDB 数据类型\n\n数据类型 | 描述\n---|---\nString | 字符串\nInteger | 整数数值\nDouble | 双精度浮点值\nArray | 数组\nTimestamp | 时间戳\nObject | 用户内嵌文档\nNull | 空\nSymbol | 符号\nDate | 日期时间\nObject ID | 对象ID\nBinary Data | 二进制数据\nCode | 代码类型\nRegular expression | 正则表达式\n\n\n\n## 基本命令\n\n### 创建数据库\n#### 语法\n\n```\nuse DATABASE_NAME\n```\n\n如果数据库不存在，则创建数据库，否则切换到指定数据库\n\n### 删除数据库\n\n#### 语法\n```\ndb.dropDatabase()\n```\n### 创建集合\n\n##### 语法\n\n```\ndb.createCollection(name, options)\n```\n\n- name:要创建的集合名称\n- options：可选参数，指定内存大小和索引\n\n\n|字段 | 类型 | 描述|\n|---|---|---|\n|capped | boolean | （可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。|\n|autoIndexId | boolean |（可选）如为 true，自动在 _id 字段创建索引。默认为 false。|\n|size | number | 为固定集合指定一个最大值 |\n|max | number | 指定固定集合中包含文档的最大数量 |\n\n##### 实例\n\n创建test1实例，可以使用 show collections 或 show tables 命令\n\n```bash\n> use test1\nswitched to db test1\n> db.createCollection(\"abc\")\n{ \"ok\" : 1 }\n> show collections\nabc\n> show tables\nabc\n>\n```\n\n在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合\n\n\n```bash\n> db.abc3.insert({name:\"yupan\"})\nWriteResult({ \"nInserted\" : 1 })\n> show collections\nabc\nabc1\nabc2\nabc3\n>\n```\n\n### 删除集合\n\n#### 语法\n\n```\ndb.collection.drop()\n```\n\n#### 返回值\n\n如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。\n\n#### 实例\n\n```bash\n> db.abc1.drop()\ntrue\n> db.abc2.drop()\ntrue\n> db.abc4.drop()\nfalse\n> show collections\nabc\nabc3\n```\n\n### 插入文档\n\n#### 语法\n\nMongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下\n\n```\ndb.COLLECTION_NAME.insert(document)\n```\n##### 实例\n\n```\ndb.col1.insert({\"_id\":1, \"name\":\"111\"})\ndb.save.insert({\"_id\":1, \"name\":\"222\"})\n```\n\n查看已插入的文档用find()\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"222\" }\n{ \"_id\" : ObjectId(\"5da7313b00818179fd1c9b98\"), \"name\" : \"jin\" }\n>\n```\n#### save和update的区别\n\n当主健\"_id\"不存在时，都是添加一个新的文档，但是当主键\"_id\"存在时，\n\ninsert:当主键\"_id\"在集合中存在时，不做任何处理。\n\nsave:当主键\"_id\"在集合中存在时，进行更新。\n\n```bash\n> db.col1.insert({\"_id\":1, \"name\":\"yupan\"})\nWriteResult({ \"nInserted\" : 1 })\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n> db.col1.insert({\"_id\":1, \"name\":\"111\"})\nWriteResult({\n\t\"nInserted\" : 0,\n\t\"writeError\" : {\n\t\t\"code\" : 11000,\n\t\t\"errmsg\" : \"E11000 duplicate key error collection: test1.col1 index: _id_ dup key: { : 1.0 }\"\n\t}\n})\n> db.col1.save({\"_id\":1, \"name\":\"111\"})\nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })\n```\n\n### 更新文档\n\nMongoDB 使用 **update()** 和 **save()** 方法来更新集合中的文档\n\n#### update() 方法\n\nupdate() 方法用于更新已存在的文档\n\n##### 语法\n\n```bash\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明\n\n- query : update的查询条件，类似sql update查询内where后面的。\n- update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\n- upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n- multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n- writeConcern :可选，抛出异常的级别\n\n#### save() 方法\n\nsave() 方法通过传入的文档来替换已有文档。\n\n##### 语法\n\n```\ndb.collection.save(\n   <document>,\n   {\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明：\n\n- document : 文档数据。\n- writeConcern :可选，抛出异常的级别\n\n##### 实例\n\n```\n>db.col.save({\n    \"_id\" : 1,\n    \"name\":\"111\"\n})\n```\n\n> save 其实就是update的变种，通过设置upsert等即可使update实现save的功能\n\n\n### 删除文档\n\nMongoDB remove()函数是用来移除集合中的数据\n\n#### 语法\n\n```bash\n# 2.6之前\ndb.collection.remove(\n   <query>,\n   <justOne>\n)\n# 2.6之后\ndb.collection.remove(\n   <query>,\n   {\n     justOne: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n##### 参数说明\n\n- query :（可选）删除的文档的条件。\n- justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。\n- writeConcern :（可选）抛出异常的级别。\n\n#### 实例\n\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"nnn\" }\n{ \"_id\" : ObjectId(\"5da7313b00818179fd1c9b98\"), \"name\" : \"jin\" }\n{ \"_id\" : 2, \"name\" : \"nnn\" }\n> db.col1.remove({\"_id\":1})\nWriteResult({ \"nRemoved\" : 1 }) # 删除了一条数据\n> db.col1.find()\n{ \"_id\" : ObjectId(\"5da7313b00818179fd1c9b98\"), \"name\" : \"jin\" }\n{ \"_id\" : 2, \"name\" : \"nnn\" }\n```\n\n如果你想删除所有数据\n\n```\n> db.col1.remove({})\nWriteResult({ \"nRemoved\" : 2 })\n> db.col1.find()\n>\n```\n\n### 查询文档\n\nMongoDB 查询文档使用 find() 方法。\n\nfind() 方法以非结构化的方式来显示所有文档\n\npretty() 方法以格式化的方式来显示所有文档。\n\n#### 语法\n\n```bash\ndb.collection.find(query, projection)\n```\n\n- query ：可选，使用查询操作符指定查询条件\n- projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）\n\n易读pretty() 方法\n\n```\n> db.col1.find()\n{ \"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 100 }\n> db.col1.find().pretty()\n{\n\t\"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"),\n\t\"title\" : \"MongoDB 教程\",\n\t\"description\" : \"MongoDB 是一个 Nosql 数据库\",\n\t\"by\" : \"菜鸟教程\",\n\t\"url\" : \"http://www.runoob.com\",\n\t\"tags\" : [\n\t\t\"mongodb\",\n\t\t\"database\",\n\t\t\"NoSQL\"\n\t],\n\t\"likes\" : 100\n}\n\n```\n\n另外还有findOne()方法，只返回一个文档\n\n### 条件操作符\n\n#### AND 条件\n\nMongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件\n\n##### 语法\n\n```bash\n>db.col.find({key1:value1, key2:value2}).pretty()\n```\n\n#### OR 条件\n\nMongoDB OR 条件语句使用了关键字 $or\n\n##### 语法\n\n```bash\n>db.col.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n```\n\n##### 实例\n\n以下实例中，我们演示了查询键 name 值为yupan 或键 age 值为 20 的文档。\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n> db.col1.find({$or:[{\"name\":\"yupan\"}, {\"age\":20}]})\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n>\n```\n\n### AND 和 OR 联合使用\n\n#### 实例\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n{ \"_id\" : 3, \"name\" : \"messi\", \"age\" : 30 }\n> db.col1.find({\"age\":{$gt:10}, $or:[{\"name\":\"yupan\"}, {\"age\":20}]})\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n```\n\n### (>) 大于操作符 - $gt\n\n#### 语法\n\n```bash\ndb.col1.find({age : {$gt : 10}})\n```\n\n### （>=）大于等于操作符 - $gte\n\n#### 语法\n\n```bash\ndb.col1.find({age : {$gt : 10}})\n```\n\n### （<）小于操作符 - $lt\n\n#### 语法\n\n```bash\ndb.col1.find({age : {$gt : 10}})\n```\n\n### （<=）小于等于操作符 - $lte\n\n#### 语法\n\n```bash\ndb.col1.find({age : {$gt : 10}})\n```\n\n### limit（）和skip方法\n\n#### limit（）\n\n读取指定数量的数据记录。\n\n##### 语法\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER)\n```\n\n#### skip（）\n\n跳过指定数量的数据记录。默认为0\n\n##### 语法\n\n```bash\n>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n```\n\n### sort() \n\n在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。\n\n#### 语法\n\n```bash\n>db.COLLECTION_NAME.find().sort({KEY:1})\n```\n\n#### 实例\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n{ \"_id\" : 3, \"name\" : \"messi\", \"age\" : 30 }\n> db.col1.find().sort({age: -1})\n{ \"_id\" : 3, \"name\" : \"messi\", \"age\" : 30 }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n>\n```\n\n\n\n","source":"_posts/2019-10-17-mongodb-basic-one.md","raw":"---\ntitle: MongoDB 基础教程\ncomments: true\ndate: 2019-10-17 10:18:35\ntags:\n- js\n- node\n- mongodb\ncategories: WEB前端\nauthor: jun.zhou\n---\n\n# MongoDB基础教程\n\n![MongoDB](https://img.fengjr.com/image/2019/10/17/76a8980ba092a2e602c20dc4498b0fdb.png)\n\n## 简介\n\n[MongoDB](https://baike.baidu.com/item/MongoDB)是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的，它支持的数据结构非常松散，是类似json的bson（二进制JSON）格式。\n\n特点是高性能、易部署、易使用，存储数据非常方便，适用于敏捷开发。\n\n## 安装和连接\n\n### Mac OSX 平台安装 MongoDB\n\n#### 官网\n\n官网下载地址 https://www.mongodb.com/download-center#community\n\n按照教程直接下载即可，命令行下载的方式如下。\n\n#### 使用 curl 命令安装\n\n\n```bash\n# 进入 /usr/local\ncd /usr/local\n\n# 下载\nsudo curl -O https://fastdl.mongodb.org/osx/mongodb-osx-ssl-x86_64-4.0.11.tgz\n\n# 解压\nsudo tar -zxvf mongodb-osx-ssl-x86_64-4.0.9.tgz\n\n# 重命名为 mongodb 目录\n\nsudo mv mongodb-osx-x86_64-4.0.9/ mongodb\n```\n\n安装完成后，我们可以把 MongoDB 的二进制命令文件目录（安装目录/bin）添加到 PATH 路径中：\n\n```bash\nexport PATH=/usr/local/mongodb/bin:$PATH\n```\n\n#### 使用 brew 安装\n\n此外，还可以使用macos的homebrew安装mongodb\n\n\n```bash\nsudo brew install mongodb\n# 如果要安装支持 TLS/SSL 命令如下：\nsudo brew install mongodb --with-openssl\n# 安装最新开发版本\nsudo brew install mongodb --devel\n```\n\n### 运行MongoDB\n\n1、首先我们创建一个数据库存储目录\n\n```bash\nsudo mkdir -p /data/db\n```\n\n2、启动 mongodb，默认数据库目录即为 /data/db\n\n```bash\nsudo mongod\n\n# 如果没有创建全局路径 PATH，需要进入以下目录\ncd /usr/local/mongodb/bin\nsudo ./mongod\n```\n\n3、再打开一个终端进入执行以下命令：\n\n\n```bash\n$ cd /usr/local/mongodb/bin \n$ ./mongo\nMongoDB shell version v4.0.11\nconnecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb\nImplicit session: session { \"id\" : UUID(\"27e2b200-fa7c-4463-8c5d-506b97004e97\") }\nMongoDB server version: 4.0.11\n……\n> 1 + 1\n2\n> \n```\n\n如果你的数据库目录不是 /data/db，可以通过 --dbpath指定\n\n```bash\nsudo mongod --dbpath=/data/db \n```\n\n4、还可以通过工具 [Robo 3T](https://robomongo.org/) 来创建连接\n\n如下图所示，自定义应用名称，mongodb默认端口为27017\n\n![](https://img.fengjr.com/image/2019/10/16/58af404fd31241f2a6fb8d8195590f24.png)\n\n5、node mongoose 连接\n\n\n```bash\nconst mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost:27017/test');\n\nconst Cat = mongoose.model('Cat', { name: String });\n\nconst kitty = new Cat({ name: 'Zildjian' });\nkitty.save().then(() => console.log('meow'));\n```\n\n\n\n## 基础概念解析\n\n\nSQL术语/概念 | MongoDB术语/概 | 解释/说明\n---|---|---\ndatabase | database | 数据库\nrow | document | 数据记录行/文档\ncolumn | field | 数据字段/域\nindex | index | 索引\ntable joins |  | 表连接,MongoDB不支持\nprimary key | primary key | 主键,MongoDB自动将_id字段设置为主键\n\n### 数据库\n\n一个mongodb可以建立多个数据库\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。\n\nMongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中\n\n\"show dbs\" 命令可以显示所有数据的列表。\n\n```shell\n> show dbs\n<database>  0.000GB\nadmin       0.000GB\nconfig      0.000GB\nfund-cms    0.000GB\nlocal       0.000GB\n>\n```\n\n执行 \"db\" 命令可以显示当前数据库对象或集合。\n\n```bash\n$ ./mongo\nMongoDB shell version: 3.0.6\nconnecting to: test\n> db\ntest\n> \n```\n\n运行\"use\"命令，可以连接到一个指定的数据库。\n\n```\n> use local\nswitched to db local\n> db\nlocal\n> \n```\n\n### 文档(Document)\n\n文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n\n一个简单的文档例子如下：\n\n```JSON\n{\n    \"site\":\"www.fengjr.com\", \n    \"name\":\"凤凰金融\"\n}\n```\n需要注意的是：\n1. 文档中的键/值对是有序的。\n1. 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。\n1. MongoDB区分类型和大小写。\n1. MongoDB的文档不能有重复的键。\n1. 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符\n\n文档键命名规范：\n\n- 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。\n- .和$有特别的意义，只有在特定环境下才能使用。\n- 以下划线\"_\"开头的键是保留的(不是严格要求的)。\n\n### 集合\n\n集合就是 MongoDB 文档组，集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。\n\n```\n{\"site\":\"www.baidu.com\"}\n{\"site\":\"www.google.com\",\"name\":\"Google\"}\n{\"site\":\"www.runoob.com\",\"name\":\"菜鸟教程\",\"num\":5}\n```\n\n当第一个文档插入时，集合就会被创建\n\n#### 合法的集合名\n\n- 集合名不能是空字符串\"\"。\n- 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。\n- 集合名不能以\"system.\"开头，这是为系统集合保留的前缀。\n- 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　\n\n\n#### MongoDB 数据类型\n\n数据类型 | 描述\n---|---\nString | 字符串\nInteger | 整数数值\nDouble | 双精度浮点值\nArray | 数组\nTimestamp | 时间戳\nObject | 用户内嵌文档\nNull | 空\nSymbol | 符号\nDate | 日期时间\nObject ID | 对象ID\nBinary Data | 二进制数据\nCode | 代码类型\nRegular expression | 正则表达式\n\n\n\n## 基本命令\n\n### 创建数据库\n#### 语法\n\n```\nuse DATABASE_NAME\n```\n\n如果数据库不存在，则创建数据库，否则切换到指定数据库\n\n### 删除数据库\n\n#### 语法\n```\ndb.dropDatabase()\n```\n### 创建集合\n\n##### 语法\n\n```\ndb.createCollection(name, options)\n```\n\n- name:要创建的集合名称\n- options：可选参数，指定内存大小和索引\n\n\n|字段 | 类型 | 描述|\n|---|---|---|\n|capped | boolean | （可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。|\n|autoIndexId | boolean |（可选）如为 true，自动在 _id 字段创建索引。默认为 false。|\n|size | number | 为固定集合指定一个最大值 |\n|max | number | 指定固定集合中包含文档的最大数量 |\n\n##### 实例\n\n创建test1实例，可以使用 show collections 或 show tables 命令\n\n```bash\n> use test1\nswitched to db test1\n> db.createCollection(\"abc\")\n{ \"ok\" : 1 }\n> show collections\nabc\n> show tables\nabc\n>\n```\n\n在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合\n\n\n```bash\n> db.abc3.insert({name:\"yupan\"})\nWriteResult({ \"nInserted\" : 1 })\n> show collections\nabc\nabc1\nabc2\nabc3\n>\n```\n\n### 删除集合\n\n#### 语法\n\n```\ndb.collection.drop()\n```\n\n#### 返回值\n\n如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。\n\n#### 实例\n\n```bash\n> db.abc1.drop()\ntrue\n> db.abc2.drop()\ntrue\n> db.abc4.drop()\nfalse\n> show collections\nabc\nabc3\n```\n\n### 插入文档\n\n#### 语法\n\nMongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下\n\n```\ndb.COLLECTION_NAME.insert(document)\n```\n##### 实例\n\n```\ndb.col1.insert({\"_id\":1, \"name\":\"111\"})\ndb.save.insert({\"_id\":1, \"name\":\"222\"})\n```\n\n查看已插入的文档用find()\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"222\" }\n{ \"_id\" : ObjectId(\"5da7313b00818179fd1c9b98\"), \"name\" : \"jin\" }\n>\n```\n#### save和update的区别\n\n当主健\"_id\"不存在时，都是添加一个新的文档，但是当主键\"_id\"存在时，\n\ninsert:当主键\"_id\"在集合中存在时，不做任何处理。\n\nsave:当主键\"_id\"在集合中存在时，进行更新。\n\n```bash\n> db.col1.insert({\"_id\":1, \"name\":\"yupan\"})\nWriteResult({ \"nInserted\" : 1 })\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n> db.col1.insert({\"_id\":1, \"name\":\"111\"})\nWriteResult({\n\t\"nInserted\" : 0,\n\t\"writeError\" : {\n\t\t\"code\" : 11000,\n\t\t\"errmsg\" : \"E11000 duplicate key error collection: test1.col1 index: _id_ dup key: { : 1.0 }\"\n\t}\n})\n> db.col1.save({\"_id\":1, \"name\":\"111\"})\nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })\n```\n\n### 更新文档\n\nMongoDB 使用 **update()** 和 **save()** 方法来更新集合中的文档\n\n#### update() 方法\n\nupdate() 方法用于更新已存在的文档\n\n##### 语法\n\n```bash\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明\n\n- query : update的查询条件，类似sql update查询内where后面的。\n- update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\n- upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n- multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n- writeConcern :可选，抛出异常的级别\n\n#### save() 方法\n\nsave() 方法通过传入的文档来替换已有文档。\n\n##### 语法\n\n```\ndb.collection.save(\n   <document>,\n   {\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明：\n\n- document : 文档数据。\n- writeConcern :可选，抛出异常的级别\n\n##### 实例\n\n```\n>db.col.save({\n    \"_id\" : 1,\n    \"name\":\"111\"\n})\n```\n\n> save 其实就是update的变种，通过设置upsert等即可使update实现save的功能\n\n\n### 删除文档\n\nMongoDB remove()函数是用来移除集合中的数据\n\n#### 语法\n\n```bash\n# 2.6之前\ndb.collection.remove(\n   <query>,\n   <justOne>\n)\n# 2.6之后\ndb.collection.remove(\n   <query>,\n   {\n     justOne: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n##### 参数说明\n\n- query :（可选）删除的文档的条件。\n- justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。\n- writeConcern :（可选）抛出异常的级别。\n\n#### 实例\n\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"nnn\" }\n{ \"_id\" : ObjectId(\"5da7313b00818179fd1c9b98\"), \"name\" : \"jin\" }\n{ \"_id\" : 2, \"name\" : \"nnn\" }\n> db.col1.remove({\"_id\":1})\nWriteResult({ \"nRemoved\" : 1 }) # 删除了一条数据\n> db.col1.find()\n{ \"_id\" : ObjectId(\"5da7313b00818179fd1c9b98\"), \"name\" : \"jin\" }\n{ \"_id\" : 2, \"name\" : \"nnn\" }\n```\n\n如果你想删除所有数据\n\n```\n> db.col1.remove({})\nWriteResult({ \"nRemoved\" : 2 })\n> db.col1.find()\n>\n```\n\n### 查询文档\n\nMongoDB 查询文档使用 find() 方法。\n\nfind() 方法以非结构化的方式来显示所有文档\n\npretty() 方法以格式化的方式来显示所有文档。\n\n#### 语法\n\n```bash\ndb.collection.find(query, projection)\n```\n\n- query ：可选，使用查询操作符指定查询条件\n- projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）\n\n易读pretty() 方法\n\n```\n> db.col1.find()\n{ \"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 100 }\n> db.col1.find().pretty()\n{\n\t\"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"),\n\t\"title\" : \"MongoDB 教程\",\n\t\"description\" : \"MongoDB 是一个 Nosql 数据库\",\n\t\"by\" : \"菜鸟教程\",\n\t\"url\" : \"http://www.runoob.com\",\n\t\"tags\" : [\n\t\t\"mongodb\",\n\t\t\"database\",\n\t\t\"NoSQL\"\n\t],\n\t\"likes\" : 100\n}\n\n```\n\n另外还有findOne()方法，只返回一个文档\n\n### 条件操作符\n\n#### AND 条件\n\nMongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件\n\n##### 语法\n\n```bash\n>db.col.find({key1:value1, key2:value2}).pretty()\n```\n\n#### OR 条件\n\nMongoDB OR 条件语句使用了关键字 $or\n\n##### 语法\n\n```bash\n>db.col.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n```\n\n##### 实例\n\n以下实例中，我们演示了查询键 name 值为yupan 或键 age 值为 20 的文档。\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n> db.col1.find({$or:[{\"name\":\"yupan\"}, {\"age\":20}]})\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n>\n```\n\n### AND 和 OR 联合使用\n\n#### 实例\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n{ \"_id\" : 3, \"name\" : \"messi\", \"age\" : 30 }\n> db.col1.find({\"age\":{$gt:10}, $or:[{\"name\":\"yupan\"}, {\"age\":20}]})\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n```\n\n### (>) 大于操作符 - $gt\n\n#### 语法\n\n```bash\ndb.col1.find({age : {$gt : 10}})\n```\n\n### （>=）大于等于操作符 - $gte\n\n#### 语法\n\n```bash\ndb.col1.find({age : {$gt : 10}})\n```\n\n### （<）小于操作符 - $lt\n\n#### 语法\n\n```bash\ndb.col1.find({age : {$gt : 10}})\n```\n\n### （<=）小于等于操作符 - $lte\n\n#### 语法\n\n```bash\ndb.col1.find({age : {$gt : 10}})\n```\n\n### limit（）和skip方法\n\n#### limit（）\n\n读取指定数量的数据记录。\n\n##### 语法\n\n```\n>db.COLLECTION_NAME.find().limit(NUMBER)\n```\n\n#### skip（）\n\n跳过指定数量的数据记录。默认为0\n\n##### 语法\n\n```bash\n>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n```\n\n### sort() \n\n在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。\n\n#### 语法\n\n```bash\n>db.COLLECTION_NAME.find().sort({KEY:1})\n```\n\n#### 实例\n\n```bash\n> db.col1.find()\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n{ \"_id\" : 3, \"name\" : \"messi\", \"age\" : 30 }\n> db.col1.find().sort({age: -1})\n{ \"_id\" : 3, \"name\" : \"messi\", \"age\" : 30 }\n{ \"_id\" : 2, \"name\" : \"jin\", \"age\" : 20 }\n{ \"_id\" : 1, \"name\" : \"yupan\" }\n>\n```\n\n\n\n","slug":"mongodb-basic-one","published":1,"updated":"2020-06-10T06:01:44.493Z","_id":"ck2yl0qcb000xh6q6a08qkhf5","layout":"post","photos":[],"link":"","content":"<h1 id=\"MongoDB基础教程\"><a href=\"#MongoDB基础教程\" class=\"headerlink\" title=\"MongoDB基础教程\"></a>MongoDB基础教程</h1><p><img src=\"https://img.fengjr.com/image/2019/10/17/76a8980ba092a2e602c20dc4498b0fdb.png\" alt=\"MongoDB\"></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://baike.baidu.com/item/MongoDB\" target=\"_blank\" rel=\"noopener\">MongoDB</a>是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的，它支持的数据结构非常松散，是类似json的bson（二进制JSON）格式。</p>\n<p>特点是高性能、易部署、易使用，存储数据非常方便，适用于敏捷开发。</p>\n<h2 id=\"安装和连接\"><a href=\"#安装和连接\" class=\"headerlink\" title=\"安装和连接\"></a>安装和连接</h2><h3 id=\"Mac-OSX-平台安装-MongoDB\"><a href=\"#Mac-OSX-平台安装-MongoDB\" class=\"headerlink\" title=\"Mac OSX 平台安装 MongoDB\"></a>Mac OSX 平台安装 MongoDB</h3><h4 id=\"官网\"><a href=\"#官网\" class=\"headerlink\" title=\"官网\"></a>官网</h4><p>官网下载地址 <a href=\"https://www.mongodb.com/download-center#community\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.com/download-center#community</a></p>\n<p>按照教程直接下载即可，命令行下载的方式如下。</p>\n<h4 id=\"使用-curl-命令安装\"><a href=\"#使用-curl-命令安装\" class=\"headerlink\" title=\"使用 curl 命令安装\"></a>使用 curl 命令安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入 /usr/local</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载</span></span><br><span class=\"line\">sudo curl -O https://fastdl.mongodb.org/osx/mongodb-osx-ssl-x86_64-4.0.11.tgz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">sudo tar -zxvf mongodb-osx-ssl-x86_64-4.0.9.tgz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重命名为 mongodb 目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo mv mongodb-osx-x86_64-4.0.9/ mongodb</span><br></pre></td></tr></table></figure>\n<p>安装完成后，我们可以把 MongoDB 的二进制命令文件目录（安装目录/bin）添加到 PATH 路径中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PATH=/usr/<span class=\"built_in\">local</span>/mongodb/bin:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-brew-安装\"><a href=\"#使用-brew-安装\" class=\"headerlink\" title=\"使用 brew 安装\"></a>使用 brew 安装</h4><p>此外，还可以使用macos的homebrew安装mongodb</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo brew install mongodb</span><br><span class=\"line\"><span class=\"comment\"># 如果要安装支持 TLS/SSL 命令如下：</span></span><br><span class=\"line\">sudo brew install mongodb --with-openssl</span><br><span class=\"line\"><span class=\"comment\"># 安装最新开发版本</span></span><br><span class=\"line\">sudo brew install mongodb --devel</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行MongoDB\"><a href=\"#运行MongoDB\" class=\"headerlink\" title=\"运行MongoDB\"></a>运行MongoDB</h3><p>1、首先我们创建一个数据库存储目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /data/db</span><br></pre></td></tr></table></figure>\n<p>2、启动 mongodb，默认数据库目录即为 /data/db</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mongod</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果没有创建全局路径 PATH，需要进入以下目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/mongodb/bin</span><br><span class=\"line\">sudo ./mongod</span><br></pre></td></tr></table></figure>\n<p>3、再打开一个终端进入执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/mongodb/bin </span><br><span class=\"line\">$ ./mongo</span><br><span class=\"line\">MongoDB shell version v4.0.11</span><br><span class=\"line\">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class=\"line\">Implicit session: session &#123; <span class=\"string\">\"id\"</span> : UUID(<span class=\"string\">\"27e2b200-fa7c-4463-8c5d-506b97004e97\"</span>) &#125;</span><br><span class=\"line\">MongoDB server version: 4.0.11</span><br><span class=\"line\">……</span><br><span class=\"line\">&gt; 1 + 1</span><br><span class=\"line\">2</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<p>如果你的数据库目录不是 /data/db，可以通过 –dbpath指定</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mongod --dbpath=/data/db</span><br></pre></td></tr></table></figure>\n<p>4、还可以通过工具 <a href=\"https://robomongo.org/\" target=\"_blank\" rel=\"noopener\">Robo 3T</a> 来创建连接</p>\n<p>如下图所示，自定义应用名称，mongodb默认端口为27017</p>\n<p><img src=\"https://img.fengjr.com/image/2019/10/16/58af404fd31241f2a6fb8d8195590f24.png\" alt></p>\n<p>5、node mongoose 连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const mongoose = require(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost:27017/test'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">const Cat = mongoose.model(<span class=\"string\">'Cat'</span>, &#123; name: String &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">const kitty = new Cat(&#123; name: <span class=\"string\">'Zildjian'</span> &#125;);</span><br><span class=\"line\">kitty.save().<span class=\"keyword\">then</span>(() =&gt; console.log(<span class=\"string\">'meow'</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"基础概念解析\"><a href=\"#基础概念解析\" class=\"headerlink\" title=\"基础概念解析\"></a>基础概念解析</h2><table>\n<thead>\n<tr>\n<th>SQL术语/概念</th>\n<th>MongoDB术语/概</th>\n<th>解释/说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>database</td>\n<td>database</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>row</td>\n<td>document</td>\n<td>数据记录行/文档</td>\n</tr>\n<tr>\n<td>column</td>\n<td>field</td>\n<td>数据字段/域</td>\n</tr>\n<tr>\n<td>index</td>\n<td>index</td>\n<td>索引</td>\n</tr>\n<tr>\n<td>table joins</td>\n<td></td>\n<td>表连接,MongoDB不支持</td>\n</tr>\n<tr>\n<td>primary key</td>\n<td>primary key</td>\n<td>主键,MongoDB自动将_id字段设置为主键</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>一个mongodb可以建立多个数据库</p>\n<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p>\n<p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中</p>\n<p>“show dbs” 命令可以显示所有数据的列表。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> show dbs</span></span><br><span class=\"line\">&lt;database&gt;  0.000GB</span><br><span class=\"line\">admin       0.000GB</span><br><span class=\"line\">config      0.000GB</span><br><span class=\"line\">fund-cms    0.000GB</span><br><span class=\"line\">local       0.000GB</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n<p>执行 “db” 命令可以显示当前数据库对象或集合。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./mongo</span><br><span class=\"line\">MongoDB shell version: 3.0.6</span><br><span class=\"line\">connecting to: <span class=\"built_in\">test</span></span><br><span class=\"line\">&gt; db</span><br><span class=\"line\"><span class=\"built_in\">test</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<p>运行”use”命令，可以连接到一个指定的数据库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use local</span><br><span class=\"line\">switched to db local</span><br><span class=\"line\">&gt; db</span><br><span class=\"line\">local</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文档-Document\"><a href=\"#文档-Document\" class=\"headerlink\" title=\"文档(Document)\"></a>文档(Document)</h3><p>文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p>\n<p>一个简单的文档例子如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"site\"</span>:<span class=\"string\">\"www.fengjr.com\"</span>, </span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>:<span class=\"string\">\"凤凰金融\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是：</p>\n<ol>\n<li>文档中的键/值对是有序的。</li>\n<li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li>\n<li>MongoDB区分类型和大小写。</li>\n<li>MongoDB的文档不能有重复的键。</li>\n<li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符</li>\n</ol>\n<p>文档键命名规范：</p>\n<ul>\n<li>键不能含有\\0 (空字符)。这个字符用来表示键的结尾。</li>\n<li>.和$有特别的意义，只有在特定环境下才能使用。</li>\n<li>以下划线”_”开头的键是保留的(不是严格要求的)。</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>集合就是 MongoDB 文档组，集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;site&quot;:&quot;www.baidu.com&quot;&#125;</span><br><span class=\"line\">&#123;&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;&#125;</span><br><span class=\"line\">&#123;&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5&#125;</span><br></pre></td></tr></table></figure>\n<p>当第一个文档插入时，集合就会被创建</p>\n<h4 id=\"合法的集合名\"><a href=\"#合法的集合名\" class=\"headerlink\" title=\"合法的集合名\"></a>合法的集合名</h4><ul>\n<li>集合名不能是空字符串””。</li>\n<li>集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。</li>\n<li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li>\n<li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　</li>\n</ul>\n<h4 id=\"MongoDB-数据类型\"><a href=\"#MongoDB-数据类型\" class=\"headerlink\" title=\"MongoDB 数据类型\"></a>MongoDB 数据类型</h4><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>Integer</td>\n<td>整数数值</td>\n</tr>\n<tr>\n<td>Double</td>\n<td>双精度浮点值</td>\n</tr>\n<tr>\n<td>Array</td>\n<td>数组</td>\n</tr>\n<tr>\n<td>Timestamp</td>\n<td>时间戳</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>用户内嵌文档</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>空</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>符号</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>日期时间</td>\n</tr>\n<tr>\n<td>Object ID</td>\n<td>对象ID</td>\n</tr>\n<tr>\n<td>Binary Data</td>\n<td>二进制数据</td>\n</tr>\n<tr>\n<td>Code</td>\n<td>代码类型</td>\n</tr>\n<tr>\n<td>Regular expression</td>\n<td>正则表达式</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use DATABASE_NAME</span><br></pre></td></tr></table></figure>\n<p>如果数据库不存在，则创建数据库，否则切换到指定数据库</p>\n<h3 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h3><h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.dropDatabase()</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建集合\"><a href=\"#创建集合\" class=\"headerlink\" title=\"创建集合\"></a>创建集合</h3><h5 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createCollection(name, options)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>name:要创建的集合名称</li>\n<li>options：可选参数，指定内存大小和索引</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>capped</td>\n<td>boolean</td>\n<td>（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。</td>\n</tr>\n<tr>\n<td>autoIndexId</td>\n<td>boolean</td>\n<td>（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td>\n</tr>\n<tr>\n<td>size</td>\n<td>number</td>\n<td>为固定集合指定一个最大值</td>\n</tr>\n<tr>\n<td>max</td>\n<td>number</td>\n<td>指定固定集合中包含文档的最大数量</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h5><p>创建test1实例，可以使用 show collections 或 show tables 命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use test1</span><br><span class=\"line\">switched to db test1</span><br><span class=\"line\">&gt; db.createCollection(<span class=\"string\">\"abc\"</span>)</span><br><span class=\"line\">&#123; <span class=\"string\">\"ok\"</span> : 1 &#125;</span><br><span class=\"line\">&gt; show collections</span><br><span class=\"line\">abc</span><br><span class=\"line\">&gt; show tables</span><br><span class=\"line\">abc</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<p>在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.abc3.insert(&#123;name:<span class=\"string\">\"yupan\"</span>&#125;)</span><br><span class=\"line\">WriteResult(&#123; <span class=\"string\">\"nInserted\"</span> : 1 &#125;)</span><br><span class=\"line\">&gt; show collections</span><br><span class=\"line\">abc</span><br><span class=\"line\">abc1</span><br><span class=\"line\">abc2</span><br><span class=\"line\">abc3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除集合\"><a href=\"#删除集合\" class=\"headerlink\" title=\"删除集合\"></a>删除集合</h3><h4 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.drop()</span><br></pre></td></tr></table></figure>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。</p>\n<h4 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.abc1.drop()</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\">&gt; db.abc2.drop()</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\">&gt; db.abc4.drop()</span><br><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\">&gt; show collections</span><br><span class=\"line\">abc</span><br><span class=\"line\">abc3</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入文档\"><a href=\"#插入文档\" class=\"headerlink\" title=\"插入文档\"></a>插入文档</h3><h4 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure>\n<h5 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.insert(&#123;&quot;_id&quot;:1, &quot;name&quot;:&quot;111&quot;&#125;)</span><br><span class=\"line\">db.save.insert(&#123;&quot;_id&quot;:1, &quot;name&quot;:&quot;222&quot;&#125;)</span><br></pre></td></tr></table></figure>\n<p>查看已插入的文档用find()</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"222\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5da7313b00818179fd1c9b98\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span> &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"save和update的区别\"><a href=\"#save和update的区别\" class=\"headerlink\" title=\"save和update的区别\"></a>save和update的区别</h4><p>当主健”_id”不存在时，都是添加一个新的文档，但是当主键”_id”存在时，</p>\n<p>insert:当主键”_id”在集合中存在时，不做任何处理。</p>\n<p>save:当主键”_id”在集合中存在时，进行更新。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.insert(&#123;<span class=\"string\">\"_id\"</span>:1, <span class=\"string\">\"name\"</span>:<span class=\"string\">\"yupan\"</span>&#125;)</span><br><span class=\"line\">WriteResult(&#123; <span class=\"string\">\"nInserted\"</span> : 1 &#125;)</span><br><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&gt; db.col1.insert(&#123;<span class=\"string\">\"_id\"</span>:1, <span class=\"string\">\"name\"</span>:<span class=\"string\">\"111\"</span>&#125;)</span><br><span class=\"line\">WriteResult(&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"nInserted\"</span> : 0,</span><br><span class=\"line\">\t<span class=\"string\">\"writeError\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"code\"</span> : 11000,</span><br><span class=\"line\">\t\t<span class=\"string\">\"errmsg\"</span> : <span class=\"string\">\"E11000 duplicate key error collection: test1.col1 index: _id_ dup key: &#123; : 1.0 &#125;\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&gt; db.col1.save(&#123;<span class=\"string\">\"_id\"</span>:1, <span class=\"string\">\"name\"</span>:<span class=\"string\">\"111\"</span>&#125;)</span><br><span class=\"line\">WriteResult(&#123; <span class=\"string\">\"nMatched\"</span> : 1, <span class=\"string\">\"nUpserted\"</span> : 0, <span class=\"string\">\"nModified\"</span> : 1 &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新文档\"><a href=\"#更新文档\" class=\"headerlink\" title=\"更新文档\"></a>更新文档</h3><p>MongoDB 使用 <strong>update()</strong> 和 <strong>save()</strong> 方法来更新集合中的文档</p>\n<h4 id=\"update-方法\"><a href=\"#update-方法\" class=\"headerlink\" title=\"update() 方法\"></a>update() 方法</h4><p>update() 方法用于更新已存在的文档</p>\n<h5 id=\"语法-5\"><a href=\"#语法-5\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.update(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &lt;update&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     upsert: &lt;boolean&gt;,</span><br><span class=\"line\">     multi: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>参数说明</p>\n<ul>\n<li>query : update的查询条件，类似sql update查询内where后面的。</li>\n<li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li>\n<li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>\n<li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>\n<li>writeConcern :可选，抛出异常的级别</li>\n</ul>\n<h4 id=\"save-方法\"><a href=\"#save-方法\" class=\"headerlink\" title=\"save() 方法\"></a>save() 方法</h4><p>save() 方法通过传入的文档来替换已有文档。</p>\n<h5 id=\"语法-6\"><a href=\"#语法-6\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.save(</span><br><span class=\"line\">   &lt;document&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>document : 文档数据。</li>\n<li>writeConcern :可选，抛出异常的级别</li>\n</ul>\n<h5 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.save(&#123;</span><br><span class=\"line\">    &quot;_id&quot; : 1,</span><br><span class=\"line\">    &quot;name&quot;:&quot;111&quot;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>save 其实就是update的变种，通过设置upsert等即可使update实现save的功能</p>\n</blockquote>\n<h3 id=\"删除文档\"><a href=\"#删除文档\" class=\"headerlink\" title=\"删除文档\"></a>删除文档</h3><p>MongoDB remove()函数是用来移除集合中的数据</p>\n<h4 id=\"语法-7\"><a href=\"#语法-7\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 2.6之前</span></span><br><span class=\"line\">db.collection.remove(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &lt;justOne&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\"># 2.6之后</span></span><br><span class=\"line\">db.collection.remove(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     justOne: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h5 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h5><ul>\n<li>query :（可选）删除的文档的条件。</li>\n<li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li>\n<li>writeConcern :（可选）抛出异常的级别。</li>\n</ul>\n<h4 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"nnn\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5da7313b00818179fd1c9b98\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"nnn\"</span> &#125;</span><br><span class=\"line\">&gt; db.col1.remove(&#123;<span class=\"string\">\"_id\"</span>:1&#125;)</span><br><span class=\"line\">WriteResult(&#123; <span class=\"string\">\"nRemoved\"</span> : 1 &#125;) <span class=\"comment\"># 删除了一条数据</span></span><br><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5da7313b00818179fd1c9b98\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"nnn\"</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>如果你想删除所有数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.remove(&#123;&#125;)</span><br><span class=\"line\">WriteResult(&#123; &quot;nRemoved&quot; : 2 &#125;)</span><br><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询文档\"><a href=\"#查询文档\" class=\"headerlink\" title=\"查询文档\"></a>查询文档</h3><p>MongoDB 查询文档使用 find() 方法。</p>\n<p>find() 方法以非结构化的方式来显示所有文档</p>\n<p>pretty() 方法以格式化的方式来显示所有文档。</p>\n<h4 id=\"语法-8\"><a href=\"#语法-8\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>query ：可选，使用查询操作符指定查询条件</li>\n<li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）</li>\n</ul>\n<p>易读pretty() 方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;56063f17ade2f21f36b03133&quot;), &quot;title&quot; : &quot;MongoDB 教程&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 100 &#125;</span><br><span class=\"line\">&gt; db.col1.find().pretty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;_id&quot; : ObjectId(&quot;56063f17ade2f21f36b03133&quot;),</span><br><span class=\"line\">\t&quot;title&quot; : &quot;MongoDB 教程&quot;,</span><br><span class=\"line\">\t&quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;,</span><br><span class=\"line\">\t&quot;by&quot; : &quot;菜鸟教程&quot;,</span><br><span class=\"line\">\t&quot;url&quot; : &quot;http://www.runoob.com&quot;,</span><br><span class=\"line\">\t&quot;tags&quot; : [</span><br><span class=\"line\">\t\t&quot;mongodb&quot;,</span><br><span class=\"line\">\t\t&quot;database&quot;,</span><br><span class=\"line\">\t\t&quot;NoSQL&quot;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t&quot;likes&quot; : 100</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外还有findOne()方法，只返回一个文档</p>\n<h3 id=\"条件操作符\"><a href=\"#条件操作符\" class=\"headerlink\" title=\"条件操作符\"></a>条件操作符</h3><h4 id=\"AND-条件\"><a href=\"#AND-条件\" class=\"headerlink\" title=\"AND 条件\"></a>AND 条件</h4><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件</p>\n<h5 id=\"语法-9\"><a href=\"#语法-9\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br></pre></td></tr></table></figure>\n<h4 id=\"OR-条件\"><a href=\"#OR-条件\" class=\"headerlink\" title=\"OR 条件\"></a>OR 条件</h4><p>MongoDB OR 条件语句使用了关键字 $or</p>\n<h5 id=\"语法-10\"><a href=\"#语法-10\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.find(</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"variable\">$or</span>: [</span><br><span class=\"line\">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">).pretty()</span><br></pre></td></tr></table></figure>\n<h5 id=\"实例-5\"><a href=\"#实例-5\" class=\"headerlink\" title=\"实例\"></a>实例</h5><p>以下实例中，我们演示了查询键 name 值为yupan 或键 age 值为 20 的文档。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&gt; db.col1.find(&#123;<span class=\"variable\">$or</span>:[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"yupan\"</span>&#125;, &#123;<span class=\"string\">\"age\"</span>:20&#125;]&#125;)</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AND-和-OR-联合使用\"><a href=\"#AND-和-OR-联合使用\" class=\"headerlink\" title=\"AND 和 OR 联合使用\"></a>AND 和 OR 联合使用</h3><h4 id=\"实例-6\"><a href=\"#实例-6\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 3, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"messi\"</span>, <span class=\"string\">\"age\"</span> : 30 &#125;</span><br><span class=\"line\">&gt; db.col1.find(&#123;<span class=\"string\">\"age\"</span>:&#123;<span class=\"variable\">$gt</span>:10&#125;, <span class=\"variable\">$or</span>:[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"yupan\"</span>&#125;, &#123;<span class=\"string\">\"age\"</span>:20&#125;]&#125;)</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"gt-大于操作符-gt\"><a href=\"#gt-大于操作符-gt\" class=\"headerlink\" title=\"(&gt;) 大于操作符 - $gt\"></a>(&gt;) 大于操作符 - $gt</h3><h4 id=\"语法-11\"><a href=\"#语法-11\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.find(&#123;age : &#123;<span class=\"variable\">$gt</span> : 10&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"（-gt-）大于等于操作符-gte\"><a href=\"#（-gt-）大于等于操作符-gte\" class=\"headerlink\" title=\"（&gt;=）大于等于操作符 - $gte\"></a>（&gt;=）大于等于操作符 - $gte</h3><h4 id=\"语法-12\"><a href=\"#语法-12\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.find(&#123;age : &#123;<span class=\"variable\">$gt</span> : 10&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"（-lt-）小于操作符-lt\"><a href=\"#（-lt-）小于操作符-lt\" class=\"headerlink\" title=\"（&lt;）小于操作符 - $lt\"></a>（&lt;）小于操作符 - $lt</h3><h4 id=\"语法-13\"><a href=\"#语法-13\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.find(&#123;age : &#123;<span class=\"variable\">$gt</span> : 10&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"（-lt-）小于等于操作符-lte\"><a href=\"#（-lt-）小于等于操作符-lte\" class=\"headerlink\" title=\"（&lt;=）小于等于操作符 - $lte\"></a>（&lt;=）小于等于操作符 - $lte</h3><h4 id=\"语法-14\"><a href=\"#语法-14\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.find(&#123;age : &#123;<span class=\"variable\">$gt</span> : 10&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"limit（）和skip方法\"><a href=\"#limit（）和skip方法\" class=\"headerlink\" title=\"limit（）和skip方法\"></a>limit（）和skip方法</h3><h4 id=\"limit（）\"><a href=\"#limit（）\" class=\"headerlink\" title=\"limit（）\"></a>limit（）</h4><p>读取指定数量的数据记录。</p>\n<h5 id=\"语法-15\"><a href=\"#语法-15\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure>\n<h4 id=\"skip（）\"><a href=\"#skip（）\" class=\"headerlink\" title=\"skip（）\"></a>skip（）</h4><p>跳过指定数量的数据记录。默认为0</p>\n<h5 id=\"语法-16\"><a href=\"#语法-16\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().<span class=\"built_in\">limit</span>(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p>在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>\n<h4 id=\"语法-17\"><a href=\"#语法-17\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"实例-7\"><a href=\"#实例-7\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 3, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"messi\"</span>, <span class=\"string\">\"age\"</span> : 30 &#125;</span><br><span class=\"line\">&gt; db.col1.find().sort(&#123;age: -1&#125;)</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 3, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"messi\"</span>, <span class=\"string\">\"age\"</span> : 30 &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MongoDB基础教程\"><a href=\"#MongoDB基础教程\" class=\"headerlink\" title=\"MongoDB基础教程\"></a>MongoDB基础教程</h1><p><img src=\"https://img.fengjr.com/image/2019/10/17/76a8980ba092a2e602c20dc4498b0fdb.png\" alt=\"MongoDB\"></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://baike.baidu.com/item/MongoDB\" target=\"_blank\" rel=\"noopener\">MongoDB</a>是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的，它支持的数据结构非常松散，是类似json的bson（二进制JSON）格式。</p>\n<p>特点是高性能、易部署、易使用，存储数据非常方便，适用于敏捷开发。</p>\n<h2 id=\"安装和连接\"><a href=\"#安装和连接\" class=\"headerlink\" title=\"安装和连接\"></a>安装和连接</h2><h3 id=\"Mac-OSX-平台安装-MongoDB\"><a href=\"#Mac-OSX-平台安装-MongoDB\" class=\"headerlink\" title=\"Mac OSX 平台安装 MongoDB\"></a>Mac OSX 平台安装 MongoDB</h3><h4 id=\"官网\"><a href=\"#官网\" class=\"headerlink\" title=\"官网\"></a>官网</h4><p>官网下载地址 <a href=\"https://www.mongodb.com/download-center#community\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.com/download-center#community</a></p>\n<p>按照教程直接下载即可，命令行下载的方式如下。</p>\n<h4 id=\"使用-curl-命令安装\"><a href=\"#使用-curl-命令安装\" class=\"headerlink\" title=\"使用 curl 命令安装\"></a>使用 curl 命令安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入 /usr/local</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载</span></span><br><span class=\"line\">sudo curl -O https://fastdl.mongodb.org/osx/mongodb-osx-ssl-x86_64-4.0.11.tgz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">sudo tar -zxvf mongodb-osx-ssl-x86_64-4.0.9.tgz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重命名为 mongodb 目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo mv mongodb-osx-x86_64-4.0.9/ mongodb</span><br></pre></td></tr></table></figure>\n<p>安装完成后，我们可以把 MongoDB 的二进制命令文件目录（安装目录/bin）添加到 PATH 路径中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PATH=/usr/<span class=\"built_in\">local</span>/mongodb/bin:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-brew-安装\"><a href=\"#使用-brew-安装\" class=\"headerlink\" title=\"使用 brew 安装\"></a>使用 brew 安装</h4><p>此外，还可以使用macos的homebrew安装mongodb</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo brew install mongodb</span><br><span class=\"line\"><span class=\"comment\"># 如果要安装支持 TLS/SSL 命令如下：</span></span><br><span class=\"line\">sudo brew install mongodb --with-openssl</span><br><span class=\"line\"><span class=\"comment\"># 安装最新开发版本</span></span><br><span class=\"line\">sudo brew install mongodb --devel</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行MongoDB\"><a href=\"#运行MongoDB\" class=\"headerlink\" title=\"运行MongoDB\"></a>运行MongoDB</h3><p>1、首先我们创建一个数据库存储目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /data/db</span><br></pre></td></tr></table></figure>\n<p>2、启动 mongodb，默认数据库目录即为 /data/db</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mongod</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果没有创建全局路径 PATH，需要进入以下目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/mongodb/bin</span><br><span class=\"line\">sudo ./mongod</span><br></pre></td></tr></table></figure>\n<p>3、再打开一个终端进入执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/mongodb/bin </span><br><span class=\"line\">$ ./mongo</span><br><span class=\"line\">MongoDB shell version v4.0.11</span><br><span class=\"line\">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class=\"line\">Implicit session: session &#123; <span class=\"string\">\"id\"</span> : UUID(<span class=\"string\">\"27e2b200-fa7c-4463-8c5d-506b97004e97\"</span>) &#125;</span><br><span class=\"line\">MongoDB server version: 4.0.11</span><br><span class=\"line\">……</span><br><span class=\"line\">&gt; 1 + 1</span><br><span class=\"line\">2</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<p>如果你的数据库目录不是 /data/db，可以通过 –dbpath指定</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mongod --dbpath=/data/db</span><br></pre></td></tr></table></figure>\n<p>4、还可以通过工具 <a href=\"https://robomongo.org/\" target=\"_blank\" rel=\"noopener\">Robo 3T</a> 来创建连接</p>\n<p>如下图所示，自定义应用名称，mongodb默认端口为27017</p>\n<p><img src=\"https://img.fengjr.com/image/2019/10/16/58af404fd31241f2a6fb8d8195590f24.png\" alt></p>\n<p>5、node mongoose 连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const mongoose = require(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost:27017/test'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">const Cat = mongoose.model(<span class=\"string\">'Cat'</span>, &#123; name: String &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">const kitty = new Cat(&#123; name: <span class=\"string\">'Zildjian'</span> &#125;);</span><br><span class=\"line\">kitty.save().<span class=\"keyword\">then</span>(() =&gt; console.log(<span class=\"string\">'meow'</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"基础概念解析\"><a href=\"#基础概念解析\" class=\"headerlink\" title=\"基础概念解析\"></a>基础概念解析</h2><table>\n<thead>\n<tr>\n<th>SQL术语/概念</th>\n<th>MongoDB术语/概</th>\n<th>解释/说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>database</td>\n<td>database</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>row</td>\n<td>document</td>\n<td>数据记录行/文档</td>\n</tr>\n<tr>\n<td>column</td>\n<td>field</td>\n<td>数据字段/域</td>\n</tr>\n<tr>\n<td>index</td>\n<td>index</td>\n<td>索引</td>\n</tr>\n<tr>\n<td>table joins</td>\n<td></td>\n<td>表连接,MongoDB不支持</td>\n</tr>\n<tr>\n<td>primary key</td>\n<td>primary key</td>\n<td>主键,MongoDB自动将_id字段设置为主键</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>一个mongodb可以建立多个数据库</p>\n<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p>\n<p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中</p>\n<p>“show dbs” 命令可以显示所有数据的列表。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> show dbs</span></span><br><span class=\"line\">&lt;database&gt;  0.000GB</span><br><span class=\"line\">admin       0.000GB</span><br><span class=\"line\">config      0.000GB</span><br><span class=\"line\">fund-cms    0.000GB</span><br><span class=\"line\">local       0.000GB</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n<p>执行 “db” 命令可以显示当前数据库对象或集合。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./mongo</span><br><span class=\"line\">MongoDB shell version: 3.0.6</span><br><span class=\"line\">connecting to: <span class=\"built_in\">test</span></span><br><span class=\"line\">&gt; db</span><br><span class=\"line\"><span class=\"built_in\">test</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<p>运行”use”命令，可以连接到一个指定的数据库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use local</span><br><span class=\"line\">switched to db local</span><br><span class=\"line\">&gt; db</span><br><span class=\"line\">local</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文档-Document\"><a href=\"#文档-Document\" class=\"headerlink\" title=\"文档(Document)\"></a>文档(Document)</h3><p>文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p>\n<p>一个简单的文档例子如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"site\"</span>:<span class=\"string\">\"www.fengjr.com\"</span>, </span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>:<span class=\"string\">\"凤凰金融\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是：</p>\n<ol>\n<li>文档中的键/值对是有序的。</li>\n<li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li>\n<li>MongoDB区分类型和大小写。</li>\n<li>MongoDB的文档不能有重复的键。</li>\n<li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符</li>\n</ol>\n<p>文档键命名规范：</p>\n<ul>\n<li>键不能含有\\0 (空字符)。这个字符用来表示键的结尾。</li>\n<li>.和$有特别的意义，只有在特定环境下才能使用。</li>\n<li>以下划线”_”开头的键是保留的(不是严格要求的)。</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>集合就是 MongoDB 文档组，集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;site&quot;:&quot;www.baidu.com&quot;&#125;</span><br><span class=\"line\">&#123;&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;&#125;</span><br><span class=\"line\">&#123;&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5&#125;</span><br></pre></td></tr></table></figure>\n<p>当第一个文档插入时，集合就会被创建</p>\n<h4 id=\"合法的集合名\"><a href=\"#合法的集合名\" class=\"headerlink\" title=\"合法的集合名\"></a>合法的集合名</h4><ul>\n<li>集合名不能是空字符串””。</li>\n<li>集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。</li>\n<li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li>\n<li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　</li>\n</ul>\n<h4 id=\"MongoDB-数据类型\"><a href=\"#MongoDB-数据类型\" class=\"headerlink\" title=\"MongoDB 数据类型\"></a>MongoDB 数据类型</h4><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>Integer</td>\n<td>整数数值</td>\n</tr>\n<tr>\n<td>Double</td>\n<td>双精度浮点值</td>\n</tr>\n<tr>\n<td>Array</td>\n<td>数组</td>\n</tr>\n<tr>\n<td>Timestamp</td>\n<td>时间戳</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>用户内嵌文档</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>空</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>符号</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>日期时间</td>\n</tr>\n<tr>\n<td>Object ID</td>\n<td>对象ID</td>\n</tr>\n<tr>\n<td>Binary Data</td>\n<td>二进制数据</td>\n</tr>\n<tr>\n<td>Code</td>\n<td>代码类型</td>\n</tr>\n<tr>\n<td>Regular expression</td>\n<td>正则表达式</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use DATABASE_NAME</span><br></pre></td></tr></table></figure>\n<p>如果数据库不存在，则创建数据库，否则切换到指定数据库</p>\n<h3 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h3><h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.dropDatabase()</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建集合\"><a href=\"#创建集合\" class=\"headerlink\" title=\"创建集合\"></a>创建集合</h3><h5 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createCollection(name, options)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>name:要创建的集合名称</li>\n<li>options：可选参数，指定内存大小和索引</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>capped</td>\n<td>boolean</td>\n<td>（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。</td>\n</tr>\n<tr>\n<td>autoIndexId</td>\n<td>boolean</td>\n<td>（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td>\n</tr>\n<tr>\n<td>size</td>\n<td>number</td>\n<td>为固定集合指定一个最大值</td>\n</tr>\n<tr>\n<td>max</td>\n<td>number</td>\n<td>指定固定集合中包含文档的最大数量</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h5><p>创建test1实例，可以使用 show collections 或 show tables 命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use test1</span><br><span class=\"line\">switched to db test1</span><br><span class=\"line\">&gt; db.createCollection(<span class=\"string\">\"abc\"</span>)</span><br><span class=\"line\">&#123; <span class=\"string\">\"ok\"</span> : 1 &#125;</span><br><span class=\"line\">&gt; show collections</span><br><span class=\"line\">abc</span><br><span class=\"line\">&gt; show tables</span><br><span class=\"line\">abc</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<p>在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.abc3.insert(&#123;name:<span class=\"string\">\"yupan\"</span>&#125;)</span><br><span class=\"line\">WriteResult(&#123; <span class=\"string\">\"nInserted\"</span> : 1 &#125;)</span><br><span class=\"line\">&gt; show collections</span><br><span class=\"line\">abc</span><br><span class=\"line\">abc1</span><br><span class=\"line\">abc2</span><br><span class=\"line\">abc3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除集合\"><a href=\"#删除集合\" class=\"headerlink\" title=\"删除集合\"></a>删除集合</h3><h4 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.drop()</span><br></pre></td></tr></table></figure>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。</p>\n<h4 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.abc1.drop()</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\">&gt; db.abc2.drop()</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\">&gt; db.abc4.drop()</span><br><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\">&gt; show collections</span><br><span class=\"line\">abc</span><br><span class=\"line\">abc3</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入文档\"><a href=\"#插入文档\" class=\"headerlink\" title=\"插入文档\"></a>插入文档</h3><h4 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure>\n<h5 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.insert(&#123;&quot;_id&quot;:1, &quot;name&quot;:&quot;111&quot;&#125;)</span><br><span class=\"line\">db.save.insert(&#123;&quot;_id&quot;:1, &quot;name&quot;:&quot;222&quot;&#125;)</span><br></pre></td></tr></table></figure>\n<p>查看已插入的文档用find()</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"222\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5da7313b00818179fd1c9b98\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span> &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"save和update的区别\"><a href=\"#save和update的区别\" class=\"headerlink\" title=\"save和update的区别\"></a>save和update的区别</h4><p>当主健”_id”不存在时，都是添加一个新的文档，但是当主键”_id”存在时，</p>\n<p>insert:当主键”_id”在集合中存在时，不做任何处理。</p>\n<p>save:当主键”_id”在集合中存在时，进行更新。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.insert(&#123;<span class=\"string\">\"_id\"</span>:1, <span class=\"string\">\"name\"</span>:<span class=\"string\">\"yupan\"</span>&#125;)</span><br><span class=\"line\">WriteResult(&#123; <span class=\"string\">\"nInserted\"</span> : 1 &#125;)</span><br><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&gt; db.col1.insert(&#123;<span class=\"string\">\"_id\"</span>:1, <span class=\"string\">\"name\"</span>:<span class=\"string\">\"111\"</span>&#125;)</span><br><span class=\"line\">WriteResult(&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"nInserted\"</span> : 0,</span><br><span class=\"line\">\t<span class=\"string\">\"writeError\"</span> : &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"code\"</span> : 11000,</span><br><span class=\"line\">\t\t<span class=\"string\">\"errmsg\"</span> : <span class=\"string\">\"E11000 duplicate key error collection: test1.col1 index: _id_ dup key: &#123; : 1.0 &#125;\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&gt; db.col1.save(&#123;<span class=\"string\">\"_id\"</span>:1, <span class=\"string\">\"name\"</span>:<span class=\"string\">\"111\"</span>&#125;)</span><br><span class=\"line\">WriteResult(&#123; <span class=\"string\">\"nMatched\"</span> : 1, <span class=\"string\">\"nUpserted\"</span> : 0, <span class=\"string\">\"nModified\"</span> : 1 &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新文档\"><a href=\"#更新文档\" class=\"headerlink\" title=\"更新文档\"></a>更新文档</h3><p>MongoDB 使用 <strong>update()</strong> 和 <strong>save()</strong> 方法来更新集合中的文档</p>\n<h4 id=\"update-方法\"><a href=\"#update-方法\" class=\"headerlink\" title=\"update() 方法\"></a>update() 方法</h4><p>update() 方法用于更新已存在的文档</p>\n<h5 id=\"语法-5\"><a href=\"#语法-5\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.update(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &lt;update&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     upsert: &lt;boolean&gt;,</span><br><span class=\"line\">     multi: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>参数说明</p>\n<ul>\n<li>query : update的查询条件，类似sql update查询内where后面的。</li>\n<li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li>\n<li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>\n<li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>\n<li>writeConcern :可选，抛出异常的级别</li>\n</ul>\n<h4 id=\"save-方法\"><a href=\"#save-方法\" class=\"headerlink\" title=\"save() 方法\"></a>save() 方法</h4><p>save() 方法通过传入的文档来替换已有文档。</p>\n<h5 id=\"语法-6\"><a href=\"#语法-6\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.save(</span><br><span class=\"line\">   &lt;document&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>document : 文档数据。</li>\n<li>writeConcern :可选，抛出异常的级别</li>\n</ul>\n<h5 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.save(&#123;</span><br><span class=\"line\">    &quot;_id&quot; : 1,</span><br><span class=\"line\">    &quot;name&quot;:&quot;111&quot;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>save 其实就是update的变种，通过设置upsert等即可使update实现save的功能</p>\n</blockquote>\n<h3 id=\"删除文档\"><a href=\"#删除文档\" class=\"headerlink\" title=\"删除文档\"></a>删除文档</h3><p>MongoDB remove()函数是用来移除集合中的数据</p>\n<h4 id=\"语法-7\"><a href=\"#语法-7\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 2.6之前</span></span><br><span class=\"line\">db.collection.remove(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &lt;justOne&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\"># 2.6之后</span></span><br><span class=\"line\">db.collection.remove(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     justOne: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h5 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h5><ul>\n<li>query :（可选）删除的文档的条件。</li>\n<li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li>\n<li>writeConcern :（可选）抛出异常的级别。</li>\n</ul>\n<h4 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"nnn\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5da7313b00818179fd1c9b98\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"nnn\"</span> &#125;</span><br><span class=\"line\">&gt; db.col1.remove(&#123;<span class=\"string\">\"_id\"</span>:1&#125;)</span><br><span class=\"line\">WriteResult(&#123; <span class=\"string\">\"nRemoved\"</span> : 1 &#125;) <span class=\"comment\"># 删除了一条数据</span></span><br><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5da7313b00818179fd1c9b98\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"nnn\"</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>如果你想删除所有数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.remove(&#123;&#125;)</span><br><span class=\"line\">WriteResult(&#123; &quot;nRemoved&quot; : 2 &#125;)</span><br><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询文档\"><a href=\"#查询文档\" class=\"headerlink\" title=\"查询文档\"></a>查询文档</h3><p>MongoDB 查询文档使用 find() 方法。</p>\n<p>find() 方法以非结构化的方式来显示所有文档</p>\n<p>pretty() 方法以格式化的方式来显示所有文档。</p>\n<h4 id=\"语法-8\"><a href=\"#语法-8\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>query ：可选，使用查询操作符指定查询条件</li>\n<li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）</li>\n</ul>\n<p>易读pretty() 方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;56063f17ade2f21f36b03133&quot;), &quot;title&quot; : &quot;MongoDB 教程&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 100 &#125;</span><br><span class=\"line\">&gt; db.col1.find().pretty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;_id&quot; : ObjectId(&quot;56063f17ade2f21f36b03133&quot;),</span><br><span class=\"line\">\t&quot;title&quot; : &quot;MongoDB 教程&quot;,</span><br><span class=\"line\">\t&quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;,</span><br><span class=\"line\">\t&quot;by&quot; : &quot;菜鸟教程&quot;,</span><br><span class=\"line\">\t&quot;url&quot; : &quot;http://www.runoob.com&quot;,</span><br><span class=\"line\">\t&quot;tags&quot; : [</span><br><span class=\"line\">\t\t&quot;mongodb&quot;,</span><br><span class=\"line\">\t\t&quot;database&quot;,</span><br><span class=\"line\">\t\t&quot;NoSQL&quot;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t&quot;likes&quot; : 100</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外还有findOne()方法，只返回一个文档</p>\n<h3 id=\"条件操作符\"><a href=\"#条件操作符\" class=\"headerlink\" title=\"条件操作符\"></a>条件操作符</h3><h4 id=\"AND-条件\"><a href=\"#AND-条件\" class=\"headerlink\" title=\"AND 条件\"></a>AND 条件</h4><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件</p>\n<h5 id=\"语法-9\"><a href=\"#语法-9\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br></pre></td></tr></table></figure>\n<h4 id=\"OR-条件\"><a href=\"#OR-条件\" class=\"headerlink\" title=\"OR 条件\"></a>OR 条件</h4><p>MongoDB OR 条件语句使用了关键字 $or</p>\n<h5 id=\"语法-10\"><a href=\"#语法-10\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.find(</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"variable\">$or</span>: [</span><br><span class=\"line\">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">).pretty()</span><br></pre></td></tr></table></figure>\n<h5 id=\"实例-5\"><a href=\"#实例-5\" class=\"headerlink\" title=\"实例\"></a>实例</h5><p>以下实例中，我们演示了查询键 name 值为yupan 或键 age 值为 20 的文档。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&gt; db.col1.find(&#123;<span class=\"variable\">$or</span>:[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"yupan\"</span>&#125;, &#123;<span class=\"string\">\"age\"</span>:20&#125;]&#125;)</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AND-和-OR-联合使用\"><a href=\"#AND-和-OR-联合使用\" class=\"headerlink\" title=\"AND 和 OR 联合使用\"></a>AND 和 OR 联合使用</h3><h4 id=\"实例-6\"><a href=\"#实例-6\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 3, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"messi\"</span>, <span class=\"string\">\"age\"</span> : 30 &#125;</span><br><span class=\"line\">&gt; db.col1.find(&#123;<span class=\"string\">\"age\"</span>:&#123;<span class=\"variable\">$gt</span>:10&#125;, <span class=\"variable\">$or</span>:[&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"yupan\"</span>&#125;, &#123;<span class=\"string\">\"age\"</span>:20&#125;]&#125;)</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"gt-大于操作符-gt\"><a href=\"#gt-大于操作符-gt\" class=\"headerlink\" title=\"(&gt;) 大于操作符 - $gt\"></a>(&gt;) 大于操作符 - $gt</h3><h4 id=\"语法-11\"><a href=\"#语法-11\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.find(&#123;age : &#123;<span class=\"variable\">$gt</span> : 10&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"（-gt-）大于等于操作符-gte\"><a href=\"#（-gt-）大于等于操作符-gte\" class=\"headerlink\" title=\"（&gt;=）大于等于操作符 - $gte\"></a>（&gt;=）大于等于操作符 - $gte</h3><h4 id=\"语法-12\"><a href=\"#语法-12\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.find(&#123;age : &#123;<span class=\"variable\">$gt</span> : 10&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"（-lt-）小于操作符-lt\"><a href=\"#（-lt-）小于操作符-lt\" class=\"headerlink\" title=\"（&lt;）小于操作符 - $lt\"></a>（&lt;）小于操作符 - $lt</h3><h4 id=\"语法-13\"><a href=\"#语法-13\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.find(&#123;age : &#123;<span class=\"variable\">$gt</span> : 10&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"（-lt-）小于等于操作符-lte\"><a href=\"#（-lt-）小于等于操作符-lte\" class=\"headerlink\" title=\"（&lt;=）小于等于操作符 - $lte\"></a>（&lt;=）小于等于操作符 - $lte</h3><h4 id=\"语法-14\"><a href=\"#语法-14\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col1.find(&#123;age : &#123;<span class=\"variable\">$gt</span> : 10&#125;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"limit（）和skip方法\"><a href=\"#limit（）和skip方法\" class=\"headerlink\" title=\"limit（）和skip方法\"></a>limit（）和skip方法</h3><h4 id=\"limit（）\"><a href=\"#limit（）\" class=\"headerlink\" title=\"limit（）\"></a>limit（）</h4><p>读取指定数量的数据记录。</p>\n<h5 id=\"语法-15\"><a href=\"#语法-15\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure>\n<h4 id=\"skip（）\"><a href=\"#skip（）\" class=\"headerlink\" title=\"skip（）\"></a>skip（）</h4><p>跳过指定数量的数据记录。默认为0</p>\n<h5 id=\"语法-16\"><a href=\"#语法-16\" class=\"headerlink\" title=\"语法\"></a>语法</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().<span class=\"built_in\">limit</span>(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p>在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>\n<h4 id=\"语法-17\"><a href=\"#语法-17\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"实例-7\"><a href=\"#实例-7\" class=\"headerlink\" title=\"实例\"></a>实例</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.col1.find()</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 3, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"messi\"</span>, <span class=\"string\">\"age\"</span> : 30 &#125;</span><br><span class=\"line\">&gt; db.col1.find().sort(&#123;age: -1&#125;)</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 3, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"messi\"</span>, <span class=\"string\">\"age\"</span> : 30 &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 2, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"jin\"</span>, <span class=\"string\">\"age\"</span> : 20 &#125;</span><br><span class=\"line\">&#123; <span class=\"string\">\"_id\"</span> : 1, <span class=\"string\">\"name\"</span> : <span class=\"string\">\"yupan\"</span> &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"vue及vue-element-amdin框架介绍","comments":1,"date":"2019-10-22T02:11:37.000Z","author":"jun.zhou","_content":"\n\n\n# 一、vue简介\nVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n##### 渐进式框架的理解\n提供足够的选择，并且没有很多强制性的要求。\n渐进也可以理解为一步一步的意思，大概意思就是使用Vue的时候，并不需要把整个框架的所有东西都用上，可以根据实际情况选择你需要的部分。\n\n##### 自底向上逐层应用\n由基层开始做起，把基础的东西写好，再逐层往上添加效果和功能。\n\nVue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。\n```\n<div id=\"app\">\n  {{ message }}\n</div>\n\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n```\n\n先看一个简单实例代码结构：\n```\n<template>\n  <div class=\"app-selection-banner\">\n    <el-row :gutter=\"16\">\n      <el-col :span=\"6\">\n        <banner-preview :list=\"list\" :show-user-types=\"showUserTypes\" />\n      </el-col>\n      <el-col :span=\"18\">\n        <banner-table :list=\"list\" :user-type-options=\"userTypeOptions\" @updateList=\"getList\" />\n      </el-col>\n    </el-row>\n  </div>\n</template>\n\n<script>\nimport BannerPreview from './components/BannerPreview'\nimport BannerTable from './components/BannerTable'\nimport { bannerList } from '@/api/selection'\nimport { userTypeInfo } from '@/api/common'\nexport default {\n  name: 'BannerSelection',\n  components: { BannerPreview, BannerTable },\n  data() {\n    return {\n      list: null,\n      userTypeOptions: [],\n      showUserTypes: []\n    }\n  },\n  created() {\n    this.getList()\n    userTypeInfo({ version: '1.0' }).then(response => {\n      this.userTypeOptions = response.data\n      this.showUserTypes = (response.data || []).filter((userType) => {\n        return userType.type !== '0'\n      })\n    })\n  },\n  methods: {\n    getList() {\n      bannerList().then(response => {\n        const { items } = response.data || []\n        this.list = items.sort((a, b) => b.status - a.status)\n      }).catch(err => console.log(err))\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.app-selection-banner{\n  background-color:#eee;\n  padding:16px;\n  .el-col {\n    padding: 0 6px;\n  }\n}\n</style>\n\n```\n\n组件BannerPreview.vue : \n```\n<template>\n  <div class=\"md-wrap\">\n    <div class=\"md-title\">预览区</div>\n    <div class=\"md-text\">\n      <div v-for=\"item in showUserTypes\" :key=\"item.type\" class=\"block\">\n        <span class=\"demonstration\">{{ item.name }}</span>\n        <el-carousel v-if=\"previewList(item.type).length\" :autoplay=\"false\" arrow=\"never\" trigger=\"click\" height=\"100px\">\n          <el-carousel-item v-for=\"(child, key) in previewList(item.type)\" :key=\"key\">\n            <a :href=\"child.link\" target=\"_blank\">\n              <img class=\"list-img\" :src=\"child.imgUrl\">\n            </a>\n          </el-carousel-item>\n        </el-carousel>\n        <div v-else class=\"no-data\">暂无数据</div>\n      </div>\n\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'BannerPreview',\n  props: {\n    list: {\n      type: Array,\n      default: null\n    },\n    showUserTypes: {\n      type: Array,\n      default: null\n    }\n  },\n  methods: {\n    previewList(type) {\n      const newArr = this.list || []\n      return newArr.length > 0 && newArr.filter((item) => {\n        const { userType } = item || ''\n        return item.status === '2' && (userType.includes(type) || userType.includes('0'))\n      }).slice(0, 5)\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.md-wrap{\n  background-color:#fff;\n  .md-title{\n    line-height: 50px;\n    border-bottom:1px #eee solid;\n    padding-left: 16px;\n  }\n  .md-text{\n    padding: 16px;\n    .no-data{\n      font-size: 14px;\n      color: #999;\n      padding: 10px 0;\n    }\n    .demonstration{\n      display: inline-block;\n      padding-bottom: 10px;\n    }\n    .block{\n      margin-bottom: 20px;\n    }\n    .list-img{\n      height: 100%;\n      width: 100%;\n    }\n  }\n\n  .el-carousel__item h3 {\n    color: #475669;\n    font-size: 14px;\n    opacity: 0.75;\n    line-height: 100px;\n    margin: 0;\n    text-align: center;\n  }\n\n  .el-carousel__item:nth-child(2n) {\n     background-color: #99a9bf;\n  }\n\n  .el-carousel__item:nth-child(2n+1) {\n     background-color: #d3dce6;\n  }\n}\n</style>\n\n```\n\n#### 生命周期\n\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n\n比如 created 钩子可以用来在一个实例被创建之后执行代码：\n```\nnew Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n// => \"a is: 1\"\n```\n也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。\n\n*<font color=\"red\">注意：</font>不要在选项属性或回调上使用箭头函数，比如 created: () => console.log(this.a) 或 vm.$watch('a', newValue => this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。*\n\n#### 生命周期图示\n下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。\n![](https://img.fengjr.com/image/2019/10/22/b3251a15e5779fcfec925b78a149f5c8.png)\n\n#### 计算属性\n模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：\n```\n<div id=\"example\">\n  {{ message.split('').reverse().join('') }}\n</div>\n```\n在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。\n\n所以，对于任何复杂逻辑，你都应当使用计算属性。\n\n基础例子:\n```\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // 计算属性的 getter\n    reversedMessage: function () {\n      // `this` 指向 vm 实例\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n\n```\nOriginal message: \"Hello\"\nComputed reversed message: \"olleH\"\n\n#### 计算属性缓存 vs 方法\n你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：\n```\n<p>Reversed message: \"{{ reversedMessage() }}\"</p>\n\n// 在组件中\nmethods: {\n  reversedMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖\n```\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。\n\n#### 计算属性 vs 侦听属性\nVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子：\n\n```\n<div id=\"demo\">{{ fullName }}</div>\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n\n```\n上面代码是命令式且重复的。将它与计算属性的版本进行比较：\n```\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})\n```\n好得多了，不是吗？\n\n#### 侦听器\n虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。\n\n例子：\n```\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 `question` 发生改变，这个函数就会运行\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。\n    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率\n    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于\n    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，\n    // 请参考：https://lodash.com/docs#debounce\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n</script>\n```\n在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n\n# 二、Vue与React两个框架的区别和优势对比\n\nVue和React两个JavaScript框架都是当下比较受欢迎的，他们两者之间的区别有哪些，各自的优缺点是什么？\n\n#### 简单介绍\n\n除非你一直不关注前端的发展，不然你肯定听说过由Facebook创建的JavaScript UI框架——React。它支撑着包括Instagram在内的大多数Facebook网站。React与当时流行的jQuery,Backbone.js和Angular 1等框架不同，它的诞生改变了JavaScript的世界。其中最大的变化是React推广了Virtual DOM并创造了新的语法——JSX，JSX允许开发者在JavaScript中书写HTML（译者注：即HTML in JavaScript）。\n\nVue致力解决的问题与React一致，但却提供了另外一套解决方案。Vue使用模板系统而不是JSX，使其对现有应用的升级更加容易。这是因为模板用的就是普通的HTML，通过Vue来整合现有的系统是比较容易的，不需要整体重构。同时Vue声称它更容易学习，我们最近接触Vue，就能证明所言非虚。关于Vue还需要说的是，Vue主要是由一位开发者进行维护的，而不像React一样由如Facebook这类大公司维护。\n\n#### 相似之处\nReact与Vue存在很多相似之处：\n- 使用 Virtual DOM\n- 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。\n- 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。\n\n#### Virtual DOM\n啊哈，人们经常说Virtual DOM是什么呢？\n\nVue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了一种叫'Virtual DOM'的东西。所谓的Virtual DOM基本上说就是它名字的意思：虚拟DOM，DOM树的虚拟表现。它的诞生是基于这么一个概念：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多。\n\nVirtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。\n\n例子如下，我们可以看看下面这个列表在HTML中的代码是如何写的：\n```\n<ul class=\"list\">\n  <li>item 1</li>\n  <li>item 2</li>\n</ul>\n```\n而在JavaScript中，我们可以用对象简单地创造一个针对上面例子的映射：\n```\n{\n    type: 'ul', \n    props: {'class': 'list'}, \n    children: [\n        { type: 'li', props: {}, children: ['item 1'] },\n        { type: 'li', props: {}, children: ['item 2'] }\n    ]\n}\n```\n\n真实的Virtual DOM会比上面的例子更复杂，但它本质上是一个嵌套着数组的原生对象。\n\n当新一项被加进去这个JavaScript对象时，一个函数会计算新旧Virtual DOM之间的差异并反应在真实的DOM上。计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。\n\nVue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n\n而对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。\n\n\n在react开发中，经常会遇到组件重复渲染的问题，父组件一个state的变化，就会导致以该组件的所有子组件都重写render，尽管绝大多数子组件的props没有变化\n\nrender什么时候会触发\n首先，先上一张react生命周期图：\n![](https://img.fengjr.com/file/2019/10/30/c7e8067e7fd11a07a1ecc0f643a4b90f.jpeg)\n这张图将react的生命周期分为了三个阶段：生成期、存在期、销毁期，这样在create、props、state、unMount状态变化时我们可以清楚的看到reacte触发了哪些生命周期钩子以及什么时候会render。\n\n如何避免这些不必要的render:\n- shouldComponentUpdate()\n\n```\nshouldComponentUpdate(nextProps, nextState)\n```\n使用shouldComponentUpdate()以让React知道当前状态或属性的改变是否不影响组件的输出，默认返回ture，返回false时不会重写render，而且该方法并不会在初始化渲染或当使用forceUpdate()时被调用，我们要做的只是这样：\n```\nshouldComponentUpdate(nextProps, nextState) {\n  return nextState.someData !== this.state.someData\n}\n```\n但是，state里的数据这么多，还有对象，还有复杂类型数据，react的理念就是拆分拆分再拆分，这么多子组件，我要每个组件都去自己一个一个对比吗？？不存在的，这么麻烦，要知道我们的终极目标是不劳而获-_-\n\n- React.PureComponent\n\nReact.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）\n\n关注点：无论组件是否是 PureComponent，如果定义了 shouldComponentUpdate()，那么会调用它并以它的执行结果来判断是否 update。在组件未定义 shouldComponentUpdate() 的情况下，会判断该组件是否是 PureComponent，如果是的话，会对新旧 props、state 进行 shallowEqual 比较，一旦新旧不一致，会触发 update。\n\n小结：如果你的应用中，交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果你更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。\n\n#### 组件化\n\nReact与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。关于组件化的例子可以在这篇文章的中间部分被找到:\n\n你可以认为组件就是用户界面中的一小块。如果让我来设计Facebook的UI界面，那么聊天窗口会是一个组件，评论会是另一个组件，不断更新的好友列表也会作为一个组件。\n\n在Vue中，如果你遵守一定的规则，你可以使用单文件组件.\n```\n<template>\n<li class=\"pasta-dish list-unstyled\">\n    <div class=\"row\">\n        <div class=\"col-md-3\">\n            <img :src=\"this.item.image\" :alt=\"this.item.name\" />\n        </div>\n        <div class=\"col-md-9 text-left\">\n            <h3>{{this.item.name}}</h3>\n            <p>\n                {{this.item.desc}}\n            </p>\n            <button v-on:click=\"addToOrderNew\" class=\"btn btn-primary\">Add to order</button> <mark>{{this.orders}}</mark>\n        </div>\n    </div>\n</li>\n</template>\n\n<script>\n\nexport default {\n    name: 'pasta-item',\n    props: ['item'],\n    data:  function(){\n        return{\n            orders: 0\n        }\n    },\n    methods: {\n        addToOrderNew: function(y){\n            this.orders += 1;\n            this.$emit('order');\n        }\n    }\n}\n\n</script>\n\n<style src=\"./Pasta.css\"></style>\n```\n正如上面你看到的例子中，HTML, JavaScript和CSS都写在一个文件之中。你不再需要在.vue组件文件中引入CSS，虽然这也是可以的。\n\nReact也是非常相似的，JavaScript与JSX被写入同一个组件文件中。\n```\nimport React from \"react\";\n\nclass PastaItem extends React.Component {\n\n    render() {\n        const { details, index } = this.props;\n\n        return (\n            <li className=\"pasta-dish list-unstyled\">\n                <div className=\"row\">\n                    <div className=\"col-md-3\">\n                        <img src={details.image} alt={details.name} />\n                    </div>\n                    <div className=\"col-md-9 text-left\">\n                        <h3>{details.name}</h3>\n                        <p>\n                            {details.desc}\n                        </p>\n                        <button onClick={() => this.props.addToOrder(index)} className=\"btn btn-primary\">Add to order</button> <mark>{this.props.orders || 0}</mark>\n                    </div>\n                </div>\n            </li>\n        );\n    }\n}\n\nexport default PastaItem;\n```\nProps\n在上面两个例子中，我们可以看到React和Vue都有'props'的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。\n```\nObject.keys(this.state.pastadishes).map(key =>\n    <PastaItem index={key} key={key} details={this.state.pastadishes[key]} addToOrder={this.addToOrder} orders={this.state.orders[key]} />\n)\n```\n上面的JSX库组中，index, key, details, orders 与 addToOrder都是props，数据会被下传到子组件PastaItem中去。\n\n在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”。\n\n而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。\n```\n<pasta-item v-for=\"(item, key) in samplePasta\" :item=\"item\" :key=\"key\" @order=\"handleOrder(key)\"></pasta-item>\n```\n这是模板的实现，但这代码完全能工作，然而在React中展现相同数据会更麻烦一点。\n\n#### 构建工具\nReact和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。\n\n由于CRA有很多选项，使用起来会稍微麻烦一点。这个工具会逼迫你使用Webpack和Babel。而vue-cli则有模板列表可选，能按需创造不同模板，使用起来更灵活一点。\n\n事实上说，两个工具都非常好用，都能为你建立一个好环境。而且如果可以不配置Webpack的话，我认为这是天大的好事。\n\n#### Chrome 开发工具\nReact和Vue都有很好的Chrome扩展工具去帮助你找出bug。它们会检查你的应用，让你看到Vue或者React中的变化。你也可以看到应用中的状态，并实时看到更新。\n\nReact的开发工具: https://cdn.deliciousbrains.com/content/uploads/2017/06/15151112/react-devtools.mp4\n\nVue的开发工具: https://cdn.deliciousbrains.com/content/uploads/2017/06/15151111/vue-devtools.mp4\n\n#### 配套框架\nVue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。\n\n而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。\n\n#### 主要区别\nVue与react有很多的相似之处，但他们也有完全不一致的地方。\n\n模板 vs JSX：\n\n在 React 中，一切都是 JavaScript。\n在 React 中，所有的组件的渲染功能都依靠 JSX。\nJSX 是使用 XML 语法编写 JavaScript 的一种语法糖。\n```\nimport React, { Component } from 'react'\n\nimport { \n  SearchContainer,\n  SearchContent\n} from './styledComponent.js'\n\nimport search from 'images/search.png'\n\nclass Search extends Component {\n  render () {\n    return (\n      <SearchContainer>\n        <SearchContent { ...this.props }>\n          <img src={search} alt=\"\"/>\n          <span>想吃什么搜这里，川菜</span>\n        </SearchContent>\n      </SearchContainer>\n    )\n  }\n}\n\nexport default Search\n```\n\nvue是把html，css，js组合到一起，用各自的处理方式\nVue 设置样式的默认方法是单文件组件里类似 style 的标签。\n```\n<template>\n  <div class=\"m-movie\">\n    <div class=\"white-bg topbar-bg\">\n      <div class=\"city-entry\">\n        <router-link tag=\"span\" to=\"/cities\" class=\"city-name\">北京</router-link>\n      </div>\n      \n      <div class=\"switch-hot\">\n        <router-link tag=\"div\" to=\"/home/movies/intheater\" active-class=\"active\" class=\"hot-item\">正在热映</router-link>\n        <router-link tag=\"div\" to=\"/home/movies/coming\" active-class=\"active\" class=\"hot-item\">即将上映</router-link>\n      </div>\n    </div>\n    <transition :name=\"transitionName\">\n      <router-view class=\"movies-outlet\"></router-view>\n    </transition>\n  </div>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      transitionName: ''\n    }\n  },\n  watch: {\n    $route (to, from) {\n      if ( to.meta > from.meta ) {\n        this.transitionName = 'slide-left'\n      } else {\n        this.transitionName = 'slide-right'\n      }\n    }\n  }\n}\n</script>\n\n\n<style lang=\"stylus\" scoped>\n@import '~styles/border.styl'\n@import '~styles/variables.styl'\n\n.slide-right-enter-active,\n.slide-right-leave-active,\n.slide-left-enter-active,\n.slide-left-leave-active {\n  transition: all 1s;\n}\n\n.slide-right-enter {\n  opacity: 0;\n  transform: translate3d(-100%, 0, 0);\n}\n.slide-right-leave-to {\n  opacity: 0;\n  transform: translate3d(100%, 0, 0);\n}\n.slide-left-enter {\n  opacity: 0;\n  transform: translate3d(100%, 0, 0);\n}\n.slide-left-leave-to {\n  opacity: 0;\n  transform: translate3d(-100%, 0, 0);\n}\n</style>\n```\n\n总结一下，我们发现\n\nVue的优势包括：\n- 模板和渲染函数的弹性选择\n- 简单的语法及项目创建\n- 更快的渲染速度和更小的体积\n\nReact的优势包括：\n- 更适用于大型应用和更好的可测试性\n- 同时适用于Web端和原生App\n- 更大的生态圈带来的更多支持和工具\n\n而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：\n\n- 利用虚拟DOM实现快速渲染\n- 轻量级\n- 响应式和组件化\n- 服务器端渲染\n- 易于集成路由工具，打包工具以及状态管理工具\n- 优秀的支持和社区\n\n# 三、vue-element-amdin介绍\n\nvue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui实现。它使用了最新的前端技术栈，内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。\n\n#### 功能\n```\n- 登录 / 注销\n\n- 权限验证\n  - 页面权限\n  - 指令权限\n  - 权限配置\n  - 二步登录\n\n- 多环境发布\n  - dev sit stage prod\n\n- 全局功能\n  - 国际化多语言\n  - 多种动态换肤\n  - 动态侧边栏（支持多级路由嵌套）\n  - 动态面包屑\n  - 快捷导航(标签页)\n  - Svg Sprite 图标\n  - 本地/后端 mock 数据\n  - Screenfull全屏\n  - 自适应收缩侧边栏\n\n- 编辑器\n  - 富文本\n  - Markdown\n  - JSON 等多格式\n\n- Excel\n  - 导出excel\n  - 导入excel\n  - 前端可视化excel\n  - 导出zip\n\n- 表格\n  - 动态表格\n  - 拖拽表格\n  - 内联编辑\n\n- 错误页面\n  - 401\n  - 404\n\n- 組件\n  - 头像上传\n  - 返回顶部\n  - 拖拽Dialog\n  - 拖拽Select\n  - 拖拽看板\n  - 列表拖拽\n  - SplitPane\n  - Dropzone\n  - Sticky\n  - CountTo\n\n- 综合实例\n- 错误日志\n- Dashboard\n- 引导页\n- ECharts 图表\n- Clipboard(剪贴复制)\n- Markdown2html\n```\n本项目不支持低版本浏览器(如 ie)，有需求请自行添加 polyfill [详情](https://github.com/PanJiaChen/vue-element-admin/wiki#babel-polyfill)\n\n\n#### 目录结构\n```\n├── build                      # 构建相关\n├── mock                       # 项目mock 模拟数据\n├── plop-templates             # 基本模板\n├── public                     # 静态资源\n│   │── favicon.ico            # favicon图标\n│   └── index.html             # html模板\n├── src                        # 源代码\n│   ├── api                    # 所有请求\n│   ├── assets                 # 主题 字体等静态资源\n│   ├── components             # 全局公用组件\n│   ├── directive              # 全局指令\n│   ├── filters                # 全局 filter\n│   ├── icons                  # 项目所有 svg icons\n│   ├── lang                   # 国际化 language\n│   ├── layout                 # 全局 layout\n│   ├── router                 # 路由\n│   ├── store                  # 全局 store管理\n│   ├── styles                 # 全局样式\n│   ├── utils                  # 全局公用方法\n│   ├── vendor                 # 公用vendor\n│   ├── views                  # views 所有页面\n│   ├── App.vue                # 入口页面\n│   ├── main.js                # 入口文件 加载组件 初始化等\n│   └── permission.js          # 权限管理\n├── tests                      # 测试\n├── .env.xxx                   # 环境变量配置\n├── .eslintrc.js               # eslint 配置项\n├── .babelrc                   # babel-loader 配置\n├── .travis.yml                # 自动化CI配置\n├── vue.config.js              # vue-cli 配置\n├── postcss.config.js          # postcss 配置\n└── package.json               # package.json\n```\n#### 安装\n```\n# 克隆项目\ngit clone https://github.com/PanJiaChen/vue-element-admin.git\n\n# 进入项目目录\ncd vue-element-admin\n\n# 安装依赖\nnpm install\n\n# 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题\nnpm install --registry=https://registry.npm.taobao.org\n\n# 本地开发 启动项目\nnpm run dev\n\n```\n\n[预览地址](https://panjiachen.github.io/vue-element-admin/)\n\n\n# 四、fund-cms前端项目实例\n\n基金cms管理系统是基于vue-element-amdin框架并通过upm单点登录方式实现的后台管理系统。数据库用的是mongodb实现并输出api接口。\n\n#### 单点登录\n进入页面判断cookie是否存在，不存在则跳到upm系统进行登录，登录成功自动跳回并带cookie参数。然后取到cookie值并手动种上，此时可以访问api接口。访问接口时如果cookie过期返回错误标识，前端判断自动调到upm登录系统重新登录。\n```\n// 获取upm单点登录 cookie\nconst { ticket } = param2Obj(window.location.search) || ''\nif (ticket) {\n  setToken(ticket)\n  const newUrl = location.href.replace(location.search, '')\n  window.location.href = newUrl\n}\n\n// 判断单点登录 cookie\nif (!getToken()) {\n  logoutRedirect()\n}\n```\n```\n/**\n * 退出并跳转\n */\nexport function logoutRedirect() {\n  const toUrl = process.env.VUE_APP_BASE_TOLOGIN + '/auth?appkey=fund-cms&return=' + window.location.href\n  if (process.env.NODE_ENV !== 'development') {\n    window.location.href = toUrl\n  }\n}\n```\n\n#### 路由\n静态路由：登录进入系统就可以看到的菜单\n```\n/**\n * constantRoutes\n * a base page that does not have permission requirements\n * all roles can be accessed\n */\nexport const constantRoutes = [\n  {\n    path: '/404',\n    component: () => import('@/views/error-page/404'),\n    hidden: true\n  },\n  {\n    path: '',\n    component: Layout,\n    redirect: 'dashboard',\n    children: [\n      {\n        path: 'dashboard',\n        component: () => import('@/views/dashboard/index'),\n        name: 'Dashboard',\n        meta: { title: 'dashboard', icon: 'dashboard', affix: true }\n      }\n    ]\n  },\n  {\n    path: '/selection',\n    component: Layout,\n    redirect: '/selection/module',\n    alwaysShow: true, // will always show the root menu\n    name: 'Selection',\n    meta: {\n      title: '精选',\n      icon: 'shopping'\n    },\n    children: [\n      {\n        path: 'module',\n        component: () => import('@/views/selection/module'),\n        name: 'ModuleSelection',\n        hidden: true,\n        meta: {\n          title: '模块管理'\n        }\n      }, {\n        path: 'search',\n        component: () => import('@/views/selection/search'),\n        name: 'SearchSelection',\n        meta: {\n          title: '搜索'\n        }\n      }, {\n        path: 'fengj',\n        component: () => import('@/views/selection/fengj'),\n        name: 'FengjSelection',\n        meta: {\n          title: '凤金精选'\n        }\n      }\n    }\n  }  \n]\n```\n\n动态路由：需要用户权限匹配才能显示\n```\nexport const asyncRoutes = [\n  {\n    path: '/permission',\n    component: Layout,\n    redirect: '/permission/page',\n    alwaysShow: true, // will always show the root menu\n    name: 'Permission',\n    meta: {\n      title: 'permission',\n      icon: 'lock',\n      roles: ['admin', 'editor'] // you can set roles in root nav\n    },\n    children: [\n      {\n        path: 'page',\n        component: () => import('@/views/permission/page'),\n        name: 'PagePermission',\n        meta: {\n          title: 'pagePermission',\n          roles: ['admin'] // or you can only set roles in sub nav\n        }\n      },\n      {\n        path: 'directive',\n        component: () => import('@/views/permission/directive'),\n        name: 'DirectivePermission',\n        meta: {\n          title: 'directivePermission'\n          // if do not set roles, means: this page does not require permission\n        }\n      },\n      {\n        path: 'role',\n        component: () => import('@/views/permission/role'),\n        name: 'RolePermission',\n        meta: {\n          title: 'rolePermission',\n          roles: ['admin']\n        }\n      }\n    ]\n  }\n]\n```\n\n#### api\n接口api通过axios封装，支持环境变量配置。\n```\nimport axios from 'axios'\nimport { Message } from 'element-ui'\n// import store from '@/store'\nimport { removeToken } from '@/utils/auth'\nimport { logoutRedirect } from '@/utils'\n// create an axios instance\nconst service = axios.create({\n  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url\n  // withCredentials: true, // send cookies when cross-domain requests\n  timeout: 5000 // request timeout\n})\n```\n配置：selection.js\n```\nimport request from '@/utils/request'\n//get api\nexport function fengjList(params) {\n  return request({\n    url: '/fengj-management/fengjlist',\n    method: 'get',\n    params\n  })\n}\n//post api\nexport function updateOpenStatus(data) {\n  return request({\n    url: '/module-management/openmodule/update',\n    method: 'post',\n    data\n  })\n}\n```\n调用：fengj.vue\n```\nimport { fengjList } from '@/api/selection'\nexport default {\n  name: 'FengjSelection',\n  components: { FengjPreview, FengjTable },\n  data() {\n    return {\n      list: null,\n      userTypeOptions: [],\n      showUserTypes: []\n    }\n  },\n  created() {\n    this.getList()\n  },\n  methods: {\n    getList() {\n      fengjList().then(response => {\n        const { items } = response.data || []\n        this.list = items.sort((a, b) => b.status - a.status)\n      })\n    }\n  }\n}\n```\n\n#### 开发遇到问题\n\n1.状态排序\n数据库里没有status字段，前端拿到数据后再重新排一下序。\n```\nmethods: {\n  getList() {\n    fengjList().then(response => {\n      const { items } = response.data || []\n      this.list = items.sort((a, b) => b.status - a.status)\n    })\n  }\n}\n```\n\n2.表单添加动态校验\n基金产品输入基金code读api异步获取联动。\n缺点是调两次api。\n```\nimport { searchFundInfo } from '@/api/common'\ndata() {\n  const checkCode = async(rule, value, callback) => {\n    try {\n      await searchFundInfo({ key: value })\n      callback()\n    } catch (err) {\n      return callback(new Error(err.message))\n    }\n  }\n  return {\n    rules: {\n      code: [{ required: true, message: '基金代码不能为空', trigger: 'blur' }, { validator: checkCode, trigger: 'blur' }]\n    }\n  }\n}\n```\n\n3.列表组件格式化\n```\n<el-table-column label=\"用户类型\" prop=\"userType\" align=\"center\" :formatter=\"formatter\" />\nmethods: {\n  formatter(row, column) {\n    const { userType } = row\n    const nameArr = []\n    this.userTypeOptions.forEach((item) => {\n      if (userType.includes(item.type)) {\n        nameArr.push(item.name)\n      }\n    }\n    return nameArr.join()\n  }\n}\n```\n\n4.子组件调用父组件方法\n表单更新后，预览区实现自动更新。\n```\nthis.$emit('updateList')\n//父组件\n<fengj-table :list=\"list\" :user-type-options=\"userTypeOptions\" @updateList=\"getList\" />\n```\n\n5.阻止冒泡方法@click.stop\n咨询列表点击显示预览区和字典联动，操作按钮需要做阻止冒泡处理。（阻止默认行为：@click.prevent）\n```\n<el-button type=\"success\" size=\"mini\" @click.stop=\"handleUpdate(row)\">\n  编辑\n</el-button>\n```\n\n6.文本编辑器缓存问题\n列表点编辑时候，文本编辑器缓存清不掉，显示上一次的内容,因为用的第三方插件。\n解决办法添加更新方法，传时间戳，组件内监听更新。\n```\n<Tinymce ref=\"editor\" v-model=\"temp.content\" :update-con=\"updateCon\" :height=\"200\" />\n//点编辑弹层显示时候\nhandleUpdate(row) {\n  this.temp = Object.assign({}, row) // copy obj\n  this.temp.startTime = new Date(this.temp.startTime)\n  this.dialogStatus = 'update'\n  this.dialogFormVisible = true\n  this.$nextTick(() => {\n    this.$refs['dataForm'].clearValidate()\n    this.updateCon = new Date().getTime()\n  })\n}\n```\nTinymce.vue\n```\nwatch: {\n    value(val) {\n      if (!this.hasChange && this.hasInit) {\n        this.$nextTick(() =>\n          window.tinymce.get(this.tinymceId).setContent(this.val || ''))\n      }\n    },\n    language() {\n      this.destroyTinymce()\n      this.$nextTick(() => this.initTinymce())\n    },\n    updateCon(val) {\n      this.$nextTick(() =>\n        window.tinymce && window.tinymce.get(this.tinymceId).setContent(this.newVal || ''))\n    }\n  }\n}\n```\n\n7.文本编辑器扩展上传图片功能\nTinymce.vue\n```\n<template>\n  <div :class=\"{fullscreen:fullscreen}\" class=\"tinymce-container\" :style=\"{width:containerWidth}\">\n    <textarea :id=\"tinymceId\" class=\"tinymce-textarea\" />\n    <div class=\"editor-custom-btn-container\">\n      <editorImage color=\"#1890ff\" class=\"editor-upload-btn\" @successCBK=\"imageSuccessCBK\" />\n    </div>\n  </div>\n</template>\n//上传成功图片插入文本编辑器中\nimageSuccessCBK(arr) {\n  const _this = this\n  arr.forEach(v => {\n    window.tinymce.get(_this.tinymceId).insertContent(`<img class=\"wscnph\" src=\"${v.url}\" >`)\n  })\n}\n```\n编辑上传图片组件：EditorImage.vue\n```\n<el-upload\n  :multiple=\"true\"\n  :file-list=\"fileList\"\n  :show-file-list=\"true\"\n  :on-remove=\"handleRemove\"\n  :on-success=\"handleSuccess\"\n  :before-upload=\"beforeUpload\"\n  class=\"editor-slide-upload\"\n  :action=\"uploadUrl\"\n  list-type=\"picture-card\"\n>\n  <el-button size=\"small\" type=\"primary\">\n    点击上传\n  </el-button>\n</el-upload>\n\ncomputed: {\n  uploadUrl() {\n    const url = process.env.VUE_APP_BASE_API + '/upload/uploadfile'\n    return url\n  }\n}\n```\n\n开发总结：vue-element-admin框架搭建后台管理系统还是比较不错，架构清晰，功能全面，上手快。结合mongodb就可以前端一站式完成项目开发。","source":"_posts/2019-10-22-vue-element-admin.md","raw":"---\ntitle: vue及vue-element-amdin框架介绍\ncomments: true\ndate: 2019-10-22 10:11:37\ntags:\n- vue\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n\n\n# 一、vue简介\nVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n##### 渐进式框架的理解\n提供足够的选择，并且没有很多强制性的要求。\n渐进也可以理解为一步一步的意思，大概意思就是使用Vue的时候，并不需要把整个框架的所有东西都用上，可以根据实际情况选择你需要的部分。\n\n##### 自底向上逐层应用\n由基层开始做起，把基础的东西写好，再逐层往上添加效果和功能。\n\nVue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。\n```\n<div id=\"app\">\n  {{ message }}\n</div>\n\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n```\n\n先看一个简单实例代码结构：\n```\n<template>\n  <div class=\"app-selection-banner\">\n    <el-row :gutter=\"16\">\n      <el-col :span=\"6\">\n        <banner-preview :list=\"list\" :show-user-types=\"showUserTypes\" />\n      </el-col>\n      <el-col :span=\"18\">\n        <banner-table :list=\"list\" :user-type-options=\"userTypeOptions\" @updateList=\"getList\" />\n      </el-col>\n    </el-row>\n  </div>\n</template>\n\n<script>\nimport BannerPreview from './components/BannerPreview'\nimport BannerTable from './components/BannerTable'\nimport { bannerList } from '@/api/selection'\nimport { userTypeInfo } from '@/api/common'\nexport default {\n  name: 'BannerSelection',\n  components: { BannerPreview, BannerTable },\n  data() {\n    return {\n      list: null,\n      userTypeOptions: [],\n      showUserTypes: []\n    }\n  },\n  created() {\n    this.getList()\n    userTypeInfo({ version: '1.0' }).then(response => {\n      this.userTypeOptions = response.data\n      this.showUserTypes = (response.data || []).filter((userType) => {\n        return userType.type !== '0'\n      })\n    })\n  },\n  methods: {\n    getList() {\n      bannerList().then(response => {\n        const { items } = response.data || []\n        this.list = items.sort((a, b) => b.status - a.status)\n      }).catch(err => console.log(err))\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.app-selection-banner{\n  background-color:#eee;\n  padding:16px;\n  .el-col {\n    padding: 0 6px;\n  }\n}\n</style>\n\n```\n\n组件BannerPreview.vue : \n```\n<template>\n  <div class=\"md-wrap\">\n    <div class=\"md-title\">预览区</div>\n    <div class=\"md-text\">\n      <div v-for=\"item in showUserTypes\" :key=\"item.type\" class=\"block\">\n        <span class=\"demonstration\">{{ item.name }}</span>\n        <el-carousel v-if=\"previewList(item.type).length\" :autoplay=\"false\" arrow=\"never\" trigger=\"click\" height=\"100px\">\n          <el-carousel-item v-for=\"(child, key) in previewList(item.type)\" :key=\"key\">\n            <a :href=\"child.link\" target=\"_blank\">\n              <img class=\"list-img\" :src=\"child.imgUrl\">\n            </a>\n          </el-carousel-item>\n        </el-carousel>\n        <div v-else class=\"no-data\">暂无数据</div>\n      </div>\n\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'BannerPreview',\n  props: {\n    list: {\n      type: Array,\n      default: null\n    },\n    showUserTypes: {\n      type: Array,\n      default: null\n    }\n  },\n  methods: {\n    previewList(type) {\n      const newArr = this.list || []\n      return newArr.length > 0 && newArr.filter((item) => {\n        const { userType } = item || ''\n        return item.status === '2' && (userType.includes(type) || userType.includes('0'))\n      }).slice(0, 5)\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.md-wrap{\n  background-color:#fff;\n  .md-title{\n    line-height: 50px;\n    border-bottom:1px #eee solid;\n    padding-left: 16px;\n  }\n  .md-text{\n    padding: 16px;\n    .no-data{\n      font-size: 14px;\n      color: #999;\n      padding: 10px 0;\n    }\n    .demonstration{\n      display: inline-block;\n      padding-bottom: 10px;\n    }\n    .block{\n      margin-bottom: 20px;\n    }\n    .list-img{\n      height: 100%;\n      width: 100%;\n    }\n  }\n\n  .el-carousel__item h3 {\n    color: #475669;\n    font-size: 14px;\n    opacity: 0.75;\n    line-height: 100px;\n    margin: 0;\n    text-align: center;\n  }\n\n  .el-carousel__item:nth-child(2n) {\n     background-color: #99a9bf;\n  }\n\n  .el-carousel__item:nth-child(2n+1) {\n     background-color: #d3dce6;\n  }\n}\n</style>\n\n```\n\n#### 生命周期\n\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n\n比如 created 钩子可以用来在一个实例被创建之后执行代码：\n```\nnew Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n// => \"a is: 1\"\n```\n也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。\n\n*<font color=\"red\">注意：</font>不要在选项属性或回调上使用箭头函数，比如 created: () => console.log(this.a) 或 vm.$watch('a', newValue => this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。*\n\n#### 生命周期图示\n下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。\n![](https://img.fengjr.com/image/2019/10/22/b3251a15e5779fcfec925b78a149f5c8.png)\n\n#### 计算属性\n模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：\n```\n<div id=\"example\">\n  {{ message.split('').reverse().join('') }}\n</div>\n```\n在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。\n\n所以，对于任何复杂逻辑，你都应当使用计算属性。\n\n基础例子:\n```\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // 计算属性的 getter\n    reversedMessage: function () {\n      // `this` 指向 vm 实例\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n\n```\nOriginal message: \"Hello\"\nComputed reversed message: \"olleH\"\n\n#### 计算属性缓存 vs 方法\n你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：\n```\n<p>Reversed message: \"{{ reversedMessage() }}\"</p>\n\n// 在组件中\nmethods: {\n  reversedMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖\n```\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。\n\n#### 计算属性 vs 侦听属性\nVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子：\n\n```\n<div id=\"demo\">{{ fullName }}</div>\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n\n```\n上面代码是命令式且重复的。将它与计算属性的版本进行比较：\n```\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})\n```\n好得多了，不是吗？\n\n#### 侦听器\n虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。\n\n例子：\n```\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // 如果 `question` 发生改变，这个函数就会运行\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。\n    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率\n    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于\n    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，\n    // 请参考：https://lodash.com/docs#debounce\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n</script>\n```\n在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n\n# 二、Vue与React两个框架的区别和优势对比\n\nVue和React两个JavaScript框架都是当下比较受欢迎的，他们两者之间的区别有哪些，各自的优缺点是什么？\n\n#### 简单介绍\n\n除非你一直不关注前端的发展，不然你肯定听说过由Facebook创建的JavaScript UI框架——React。它支撑着包括Instagram在内的大多数Facebook网站。React与当时流行的jQuery,Backbone.js和Angular 1等框架不同，它的诞生改变了JavaScript的世界。其中最大的变化是React推广了Virtual DOM并创造了新的语法——JSX，JSX允许开发者在JavaScript中书写HTML（译者注：即HTML in JavaScript）。\n\nVue致力解决的问题与React一致，但却提供了另外一套解决方案。Vue使用模板系统而不是JSX，使其对现有应用的升级更加容易。这是因为模板用的就是普通的HTML，通过Vue来整合现有的系统是比较容易的，不需要整体重构。同时Vue声称它更容易学习，我们最近接触Vue，就能证明所言非虚。关于Vue还需要说的是，Vue主要是由一位开发者进行维护的，而不像React一样由如Facebook这类大公司维护。\n\n#### 相似之处\nReact与Vue存在很多相似之处：\n- 使用 Virtual DOM\n- 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。\n- 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。\n\n#### Virtual DOM\n啊哈，人们经常说Virtual DOM是什么呢？\n\nVue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了一种叫'Virtual DOM'的东西。所谓的Virtual DOM基本上说就是它名字的意思：虚拟DOM，DOM树的虚拟表现。它的诞生是基于这么一个概念：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多。\n\nVirtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。\n\n例子如下，我们可以看看下面这个列表在HTML中的代码是如何写的：\n```\n<ul class=\"list\">\n  <li>item 1</li>\n  <li>item 2</li>\n</ul>\n```\n而在JavaScript中，我们可以用对象简单地创造一个针对上面例子的映射：\n```\n{\n    type: 'ul', \n    props: {'class': 'list'}, \n    children: [\n        { type: 'li', props: {}, children: ['item 1'] },\n        { type: 'li', props: {}, children: ['item 2'] }\n    ]\n}\n```\n\n真实的Virtual DOM会比上面的例子更复杂，但它本质上是一个嵌套着数组的原生对象。\n\n当新一项被加进去这个JavaScript对象时，一个函数会计算新旧Virtual DOM之间的差异并反应在真实的DOM上。计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。\n\nVue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n\n而对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。\n\n\n在react开发中，经常会遇到组件重复渲染的问题，父组件一个state的变化，就会导致以该组件的所有子组件都重写render，尽管绝大多数子组件的props没有变化\n\nrender什么时候会触发\n首先，先上一张react生命周期图：\n![](https://img.fengjr.com/file/2019/10/30/c7e8067e7fd11a07a1ecc0f643a4b90f.jpeg)\n这张图将react的生命周期分为了三个阶段：生成期、存在期、销毁期，这样在create、props、state、unMount状态变化时我们可以清楚的看到reacte触发了哪些生命周期钩子以及什么时候会render。\n\n如何避免这些不必要的render:\n- shouldComponentUpdate()\n\n```\nshouldComponentUpdate(nextProps, nextState)\n```\n使用shouldComponentUpdate()以让React知道当前状态或属性的改变是否不影响组件的输出，默认返回ture，返回false时不会重写render，而且该方法并不会在初始化渲染或当使用forceUpdate()时被调用，我们要做的只是这样：\n```\nshouldComponentUpdate(nextProps, nextState) {\n  return nextState.someData !== this.state.someData\n}\n```\n但是，state里的数据这么多，还有对象，还有复杂类型数据，react的理念就是拆分拆分再拆分，这么多子组件，我要每个组件都去自己一个一个对比吗？？不存在的，这么麻烦，要知道我们的终极目标是不劳而获-_-\n\n- React.PureComponent\n\nReact.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）\n\n关注点：无论组件是否是 PureComponent，如果定义了 shouldComponentUpdate()，那么会调用它并以它的执行结果来判断是否 update。在组件未定义 shouldComponentUpdate() 的情况下，会判断该组件是否是 PureComponent，如果是的话，会对新旧 props、state 进行 shallowEqual 比较，一旦新旧不一致，会触发 update。\n\n小结：如果你的应用中，交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果你更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。\n\n#### 组件化\n\nReact与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。关于组件化的例子可以在这篇文章的中间部分被找到:\n\n你可以认为组件就是用户界面中的一小块。如果让我来设计Facebook的UI界面，那么聊天窗口会是一个组件，评论会是另一个组件，不断更新的好友列表也会作为一个组件。\n\n在Vue中，如果你遵守一定的规则，你可以使用单文件组件.\n```\n<template>\n<li class=\"pasta-dish list-unstyled\">\n    <div class=\"row\">\n        <div class=\"col-md-3\">\n            <img :src=\"this.item.image\" :alt=\"this.item.name\" />\n        </div>\n        <div class=\"col-md-9 text-left\">\n            <h3>{{this.item.name}}</h3>\n            <p>\n                {{this.item.desc}}\n            </p>\n            <button v-on:click=\"addToOrderNew\" class=\"btn btn-primary\">Add to order</button> <mark>{{this.orders}}</mark>\n        </div>\n    </div>\n</li>\n</template>\n\n<script>\n\nexport default {\n    name: 'pasta-item',\n    props: ['item'],\n    data:  function(){\n        return{\n            orders: 0\n        }\n    },\n    methods: {\n        addToOrderNew: function(y){\n            this.orders += 1;\n            this.$emit('order');\n        }\n    }\n}\n\n</script>\n\n<style src=\"./Pasta.css\"></style>\n```\n正如上面你看到的例子中，HTML, JavaScript和CSS都写在一个文件之中。你不再需要在.vue组件文件中引入CSS，虽然这也是可以的。\n\nReact也是非常相似的，JavaScript与JSX被写入同一个组件文件中。\n```\nimport React from \"react\";\n\nclass PastaItem extends React.Component {\n\n    render() {\n        const { details, index } = this.props;\n\n        return (\n            <li className=\"pasta-dish list-unstyled\">\n                <div className=\"row\">\n                    <div className=\"col-md-3\">\n                        <img src={details.image} alt={details.name} />\n                    </div>\n                    <div className=\"col-md-9 text-left\">\n                        <h3>{details.name}</h3>\n                        <p>\n                            {details.desc}\n                        </p>\n                        <button onClick={() => this.props.addToOrder(index)} className=\"btn btn-primary\">Add to order</button> <mark>{this.props.orders || 0}</mark>\n                    </div>\n                </div>\n            </li>\n        );\n    }\n}\n\nexport default PastaItem;\n```\nProps\n在上面两个例子中，我们可以看到React和Vue都有'props'的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。\n```\nObject.keys(this.state.pastadishes).map(key =>\n    <PastaItem index={key} key={key} details={this.state.pastadishes[key]} addToOrder={this.addToOrder} orders={this.state.orders[key]} />\n)\n```\n上面的JSX库组中，index, key, details, orders 与 addToOrder都是props，数据会被下传到子组件PastaItem中去。\n\n在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”。\n\n而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。\n```\n<pasta-item v-for=\"(item, key) in samplePasta\" :item=\"item\" :key=\"key\" @order=\"handleOrder(key)\"></pasta-item>\n```\n这是模板的实现，但这代码完全能工作，然而在React中展现相同数据会更麻烦一点。\n\n#### 构建工具\nReact和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。\n\n由于CRA有很多选项，使用起来会稍微麻烦一点。这个工具会逼迫你使用Webpack和Babel。而vue-cli则有模板列表可选，能按需创造不同模板，使用起来更灵活一点。\n\n事实上说，两个工具都非常好用，都能为你建立一个好环境。而且如果可以不配置Webpack的话，我认为这是天大的好事。\n\n#### Chrome 开发工具\nReact和Vue都有很好的Chrome扩展工具去帮助你找出bug。它们会检查你的应用，让你看到Vue或者React中的变化。你也可以看到应用中的状态，并实时看到更新。\n\nReact的开发工具: https://cdn.deliciousbrains.com/content/uploads/2017/06/15151112/react-devtools.mp4\n\nVue的开发工具: https://cdn.deliciousbrains.com/content/uploads/2017/06/15151111/vue-devtools.mp4\n\n#### 配套框架\nVue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。\n\n而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。\n\n#### 主要区别\nVue与react有很多的相似之处，但他们也有完全不一致的地方。\n\n模板 vs JSX：\n\n在 React 中，一切都是 JavaScript。\n在 React 中，所有的组件的渲染功能都依靠 JSX。\nJSX 是使用 XML 语法编写 JavaScript 的一种语法糖。\n```\nimport React, { Component } from 'react'\n\nimport { \n  SearchContainer,\n  SearchContent\n} from './styledComponent.js'\n\nimport search from 'images/search.png'\n\nclass Search extends Component {\n  render () {\n    return (\n      <SearchContainer>\n        <SearchContent { ...this.props }>\n          <img src={search} alt=\"\"/>\n          <span>想吃什么搜这里，川菜</span>\n        </SearchContent>\n      </SearchContainer>\n    )\n  }\n}\n\nexport default Search\n```\n\nvue是把html，css，js组合到一起，用各自的处理方式\nVue 设置样式的默认方法是单文件组件里类似 style 的标签。\n```\n<template>\n  <div class=\"m-movie\">\n    <div class=\"white-bg topbar-bg\">\n      <div class=\"city-entry\">\n        <router-link tag=\"span\" to=\"/cities\" class=\"city-name\">北京</router-link>\n      </div>\n      \n      <div class=\"switch-hot\">\n        <router-link tag=\"div\" to=\"/home/movies/intheater\" active-class=\"active\" class=\"hot-item\">正在热映</router-link>\n        <router-link tag=\"div\" to=\"/home/movies/coming\" active-class=\"active\" class=\"hot-item\">即将上映</router-link>\n      </div>\n    </div>\n    <transition :name=\"transitionName\">\n      <router-view class=\"movies-outlet\"></router-view>\n    </transition>\n  </div>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      transitionName: ''\n    }\n  },\n  watch: {\n    $route (to, from) {\n      if ( to.meta > from.meta ) {\n        this.transitionName = 'slide-left'\n      } else {\n        this.transitionName = 'slide-right'\n      }\n    }\n  }\n}\n</script>\n\n\n<style lang=\"stylus\" scoped>\n@import '~styles/border.styl'\n@import '~styles/variables.styl'\n\n.slide-right-enter-active,\n.slide-right-leave-active,\n.slide-left-enter-active,\n.slide-left-leave-active {\n  transition: all 1s;\n}\n\n.slide-right-enter {\n  opacity: 0;\n  transform: translate3d(-100%, 0, 0);\n}\n.slide-right-leave-to {\n  opacity: 0;\n  transform: translate3d(100%, 0, 0);\n}\n.slide-left-enter {\n  opacity: 0;\n  transform: translate3d(100%, 0, 0);\n}\n.slide-left-leave-to {\n  opacity: 0;\n  transform: translate3d(-100%, 0, 0);\n}\n</style>\n```\n\n总结一下，我们发现\n\nVue的优势包括：\n- 模板和渲染函数的弹性选择\n- 简单的语法及项目创建\n- 更快的渲染速度和更小的体积\n\nReact的优势包括：\n- 更适用于大型应用和更好的可测试性\n- 同时适用于Web端和原生App\n- 更大的生态圈带来的更多支持和工具\n\n而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：\n\n- 利用虚拟DOM实现快速渲染\n- 轻量级\n- 响应式和组件化\n- 服务器端渲染\n- 易于集成路由工具，打包工具以及状态管理工具\n- 优秀的支持和社区\n\n# 三、vue-element-amdin介绍\n\nvue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui实现。它使用了最新的前端技术栈，内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。\n\n#### 功能\n```\n- 登录 / 注销\n\n- 权限验证\n  - 页面权限\n  - 指令权限\n  - 权限配置\n  - 二步登录\n\n- 多环境发布\n  - dev sit stage prod\n\n- 全局功能\n  - 国际化多语言\n  - 多种动态换肤\n  - 动态侧边栏（支持多级路由嵌套）\n  - 动态面包屑\n  - 快捷导航(标签页)\n  - Svg Sprite 图标\n  - 本地/后端 mock 数据\n  - Screenfull全屏\n  - 自适应收缩侧边栏\n\n- 编辑器\n  - 富文本\n  - Markdown\n  - JSON 等多格式\n\n- Excel\n  - 导出excel\n  - 导入excel\n  - 前端可视化excel\n  - 导出zip\n\n- 表格\n  - 动态表格\n  - 拖拽表格\n  - 内联编辑\n\n- 错误页面\n  - 401\n  - 404\n\n- 組件\n  - 头像上传\n  - 返回顶部\n  - 拖拽Dialog\n  - 拖拽Select\n  - 拖拽看板\n  - 列表拖拽\n  - SplitPane\n  - Dropzone\n  - Sticky\n  - CountTo\n\n- 综合实例\n- 错误日志\n- Dashboard\n- 引导页\n- ECharts 图表\n- Clipboard(剪贴复制)\n- Markdown2html\n```\n本项目不支持低版本浏览器(如 ie)，有需求请自行添加 polyfill [详情](https://github.com/PanJiaChen/vue-element-admin/wiki#babel-polyfill)\n\n\n#### 目录结构\n```\n├── build                      # 构建相关\n├── mock                       # 项目mock 模拟数据\n├── plop-templates             # 基本模板\n├── public                     # 静态资源\n│   │── favicon.ico            # favicon图标\n│   └── index.html             # html模板\n├── src                        # 源代码\n│   ├── api                    # 所有请求\n│   ├── assets                 # 主题 字体等静态资源\n│   ├── components             # 全局公用组件\n│   ├── directive              # 全局指令\n│   ├── filters                # 全局 filter\n│   ├── icons                  # 项目所有 svg icons\n│   ├── lang                   # 国际化 language\n│   ├── layout                 # 全局 layout\n│   ├── router                 # 路由\n│   ├── store                  # 全局 store管理\n│   ├── styles                 # 全局样式\n│   ├── utils                  # 全局公用方法\n│   ├── vendor                 # 公用vendor\n│   ├── views                  # views 所有页面\n│   ├── App.vue                # 入口页面\n│   ├── main.js                # 入口文件 加载组件 初始化等\n│   └── permission.js          # 权限管理\n├── tests                      # 测试\n├── .env.xxx                   # 环境变量配置\n├── .eslintrc.js               # eslint 配置项\n├── .babelrc                   # babel-loader 配置\n├── .travis.yml                # 自动化CI配置\n├── vue.config.js              # vue-cli 配置\n├── postcss.config.js          # postcss 配置\n└── package.json               # package.json\n```\n#### 安装\n```\n# 克隆项目\ngit clone https://github.com/PanJiaChen/vue-element-admin.git\n\n# 进入项目目录\ncd vue-element-admin\n\n# 安装依赖\nnpm install\n\n# 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题\nnpm install --registry=https://registry.npm.taobao.org\n\n# 本地开发 启动项目\nnpm run dev\n\n```\n\n[预览地址](https://panjiachen.github.io/vue-element-admin/)\n\n\n# 四、fund-cms前端项目实例\n\n基金cms管理系统是基于vue-element-amdin框架并通过upm单点登录方式实现的后台管理系统。数据库用的是mongodb实现并输出api接口。\n\n#### 单点登录\n进入页面判断cookie是否存在，不存在则跳到upm系统进行登录，登录成功自动跳回并带cookie参数。然后取到cookie值并手动种上，此时可以访问api接口。访问接口时如果cookie过期返回错误标识，前端判断自动调到upm登录系统重新登录。\n```\n// 获取upm单点登录 cookie\nconst { ticket } = param2Obj(window.location.search) || ''\nif (ticket) {\n  setToken(ticket)\n  const newUrl = location.href.replace(location.search, '')\n  window.location.href = newUrl\n}\n\n// 判断单点登录 cookie\nif (!getToken()) {\n  logoutRedirect()\n}\n```\n```\n/**\n * 退出并跳转\n */\nexport function logoutRedirect() {\n  const toUrl = process.env.VUE_APP_BASE_TOLOGIN + '/auth?appkey=fund-cms&return=' + window.location.href\n  if (process.env.NODE_ENV !== 'development') {\n    window.location.href = toUrl\n  }\n}\n```\n\n#### 路由\n静态路由：登录进入系统就可以看到的菜单\n```\n/**\n * constantRoutes\n * a base page that does not have permission requirements\n * all roles can be accessed\n */\nexport const constantRoutes = [\n  {\n    path: '/404',\n    component: () => import('@/views/error-page/404'),\n    hidden: true\n  },\n  {\n    path: '',\n    component: Layout,\n    redirect: 'dashboard',\n    children: [\n      {\n        path: 'dashboard',\n        component: () => import('@/views/dashboard/index'),\n        name: 'Dashboard',\n        meta: { title: 'dashboard', icon: 'dashboard', affix: true }\n      }\n    ]\n  },\n  {\n    path: '/selection',\n    component: Layout,\n    redirect: '/selection/module',\n    alwaysShow: true, // will always show the root menu\n    name: 'Selection',\n    meta: {\n      title: '精选',\n      icon: 'shopping'\n    },\n    children: [\n      {\n        path: 'module',\n        component: () => import('@/views/selection/module'),\n        name: 'ModuleSelection',\n        hidden: true,\n        meta: {\n          title: '模块管理'\n        }\n      }, {\n        path: 'search',\n        component: () => import('@/views/selection/search'),\n        name: 'SearchSelection',\n        meta: {\n          title: '搜索'\n        }\n      }, {\n        path: 'fengj',\n        component: () => import('@/views/selection/fengj'),\n        name: 'FengjSelection',\n        meta: {\n          title: '凤金精选'\n        }\n      }\n    }\n  }  \n]\n```\n\n动态路由：需要用户权限匹配才能显示\n```\nexport const asyncRoutes = [\n  {\n    path: '/permission',\n    component: Layout,\n    redirect: '/permission/page',\n    alwaysShow: true, // will always show the root menu\n    name: 'Permission',\n    meta: {\n      title: 'permission',\n      icon: 'lock',\n      roles: ['admin', 'editor'] // you can set roles in root nav\n    },\n    children: [\n      {\n        path: 'page',\n        component: () => import('@/views/permission/page'),\n        name: 'PagePermission',\n        meta: {\n          title: 'pagePermission',\n          roles: ['admin'] // or you can only set roles in sub nav\n        }\n      },\n      {\n        path: 'directive',\n        component: () => import('@/views/permission/directive'),\n        name: 'DirectivePermission',\n        meta: {\n          title: 'directivePermission'\n          // if do not set roles, means: this page does not require permission\n        }\n      },\n      {\n        path: 'role',\n        component: () => import('@/views/permission/role'),\n        name: 'RolePermission',\n        meta: {\n          title: 'rolePermission',\n          roles: ['admin']\n        }\n      }\n    ]\n  }\n]\n```\n\n#### api\n接口api通过axios封装，支持环境变量配置。\n```\nimport axios from 'axios'\nimport { Message } from 'element-ui'\n// import store from '@/store'\nimport { removeToken } from '@/utils/auth'\nimport { logoutRedirect } from '@/utils'\n// create an axios instance\nconst service = axios.create({\n  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url\n  // withCredentials: true, // send cookies when cross-domain requests\n  timeout: 5000 // request timeout\n})\n```\n配置：selection.js\n```\nimport request from '@/utils/request'\n//get api\nexport function fengjList(params) {\n  return request({\n    url: '/fengj-management/fengjlist',\n    method: 'get',\n    params\n  })\n}\n//post api\nexport function updateOpenStatus(data) {\n  return request({\n    url: '/module-management/openmodule/update',\n    method: 'post',\n    data\n  })\n}\n```\n调用：fengj.vue\n```\nimport { fengjList } from '@/api/selection'\nexport default {\n  name: 'FengjSelection',\n  components: { FengjPreview, FengjTable },\n  data() {\n    return {\n      list: null,\n      userTypeOptions: [],\n      showUserTypes: []\n    }\n  },\n  created() {\n    this.getList()\n  },\n  methods: {\n    getList() {\n      fengjList().then(response => {\n        const { items } = response.data || []\n        this.list = items.sort((a, b) => b.status - a.status)\n      })\n    }\n  }\n}\n```\n\n#### 开发遇到问题\n\n1.状态排序\n数据库里没有status字段，前端拿到数据后再重新排一下序。\n```\nmethods: {\n  getList() {\n    fengjList().then(response => {\n      const { items } = response.data || []\n      this.list = items.sort((a, b) => b.status - a.status)\n    })\n  }\n}\n```\n\n2.表单添加动态校验\n基金产品输入基金code读api异步获取联动。\n缺点是调两次api。\n```\nimport { searchFundInfo } from '@/api/common'\ndata() {\n  const checkCode = async(rule, value, callback) => {\n    try {\n      await searchFundInfo({ key: value })\n      callback()\n    } catch (err) {\n      return callback(new Error(err.message))\n    }\n  }\n  return {\n    rules: {\n      code: [{ required: true, message: '基金代码不能为空', trigger: 'blur' }, { validator: checkCode, trigger: 'blur' }]\n    }\n  }\n}\n```\n\n3.列表组件格式化\n```\n<el-table-column label=\"用户类型\" prop=\"userType\" align=\"center\" :formatter=\"formatter\" />\nmethods: {\n  formatter(row, column) {\n    const { userType } = row\n    const nameArr = []\n    this.userTypeOptions.forEach((item) => {\n      if (userType.includes(item.type)) {\n        nameArr.push(item.name)\n      }\n    }\n    return nameArr.join()\n  }\n}\n```\n\n4.子组件调用父组件方法\n表单更新后，预览区实现自动更新。\n```\nthis.$emit('updateList')\n//父组件\n<fengj-table :list=\"list\" :user-type-options=\"userTypeOptions\" @updateList=\"getList\" />\n```\n\n5.阻止冒泡方法@click.stop\n咨询列表点击显示预览区和字典联动，操作按钮需要做阻止冒泡处理。（阻止默认行为：@click.prevent）\n```\n<el-button type=\"success\" size=\"mini\" @click.stop=\"handleUpdate(row)\">\n  编辑\n</el-button>\n```\n\n6.文本编辑器缓存问题\n列表点编辑时候，文本编辑器缓存清不掉，显示上一次的内容,因为用的第三方插件。\n解决办法添加更新方法，传时间戳，组件内监听更新。\n```\n<Tinymce ref=\"editor\" v-model=\"temp.content\" :update-con=\"updateCon\" :height=\"200\" />\n//点编辑弹层显示时候\nhandleUpdate(row) {\n  this.temp = Object.assign({}, row) // copy obj\n  this.temp.startTime = new Date(this.temp.startTime)\n  this.dialogStatus = 'update'\n  this.dialogFormVisible = true\n  this.$nextTick(() => {\n    this.$refs['dataForm'].clearValidate()\n    this.updateCon = new Date().getTime()\n  })\n}\n```\nTinymce.vue\n```\nwatch: {\n    value(val) {\n      if (!this.hasChange && this.hasInit) {\n        this.$nextTick(() =>\n          window.tinymce.get(this.tinymceId).setContent(this.val || ''))\n      }\n    },\n    language() {\n      this.destroyTinymce()\n      this.$nextTick(() => this.initTinymce())\n    },\n    updateCon(val) {\n      this.$nextTick(() =>\n        window.tinymce && window.tinymce.get(this.tinymceId).setContent(this.newVal || ''))\n    }\n  }\n}\n```\n\n7.文本编辑器扩展上传图片功能\nTinymce.vue\n```\n<template>\n  <div :class=\"{fullscreen:fullscreen}\" class=\"tinymce-container\" :style=\"{width:containerWidth}\">\n    <textarea :id=\"tinymceId\" class=\"tinymce-textarea\" />\n    <div class=\"editor-custom-btn-container\">\n      <editorImage color=\"#1890ff\" class=\"editor-upload-btn\" @successCBK=\"imageSuccessCBK\" />\n    </div>\n  </div>\n</template>\n//上传成功图片插入文本编辑器中\nimageSuccessCBK(arr) {\n  const _this = this\n  arr.forEach(v => {\n    window.tinymce.get(_this.tinymceId).insertContent(`<img class=\"wscnph\" src=\"${v.url}\" >`)\n  })\n}\n```\n编辑上传图片组件：EditorImage.vue\n```\n<el-upload\n  :multiple=\"true\"\n  :file-list=\"fileList\"\n  :show-file-list=\"true\"\n  :on-remove=\"handleRemove\"\n  :on-success=\"handleSuccess\"\n  :before-upload=\"beforeUpload\"\n  class=\"editor-slide-upload\"\n  :action=\"uploadUrl\"\n  list-type=\"picture-card\"\n>\n  <el-button size=\"small\" type=\"primary\">\n    点击上传\n  </el-button>\n</el-upload>\n\ncomputed: {\n  uploadUrl() {\n    const url = process.env.VUE_APP_BASE_API + '/upload/uploadfile'\n    return url\n  }\n}\n```\n\n开发总结：vue-element-admin框架搭建后台管理系统还是比较不错，架构清晰，功能全面，上手快。结合mongodb就可以前端一站式完成项目开发。","slug":"vue-element-admin","published":1,"updated":"2020-06-10T06:01:43.566Z","_id":"ck2yl0qcc0010h6q6b67cdrs6","layout":"post","photos":[],"link":"","content":"<h1 id=\"一、vue简介\"><a href=\"#一、vue简介\" class=\"headerlink\" title=\"一、vue简介\"></a>一、vue简介</h1><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<h5 id=\"渐进式框架的理解\"><a href=\"#渐进式框架的理解\" class=\"headerlink\" title=\"渐进式框架的理解\"></a>渐进式框架的理解</h5><p>提供足够的选择，并且没有很多强制性的要求。<br>渐进也可以理解为一步一步的意思，大概意思就是使用Vue的时候，并不需要把整个框架的所有东西都用上，可以根据实际情况选择你需要的部分。</p>\n<h5 id=\"自底向上逐层应用\"><a href=\"#自底向上逐层应用\" class=\"headerlink\" title=\"自底向上逐层应用\"></a>自底向上逐层应用</h5><p>由基层开始做起，把基础的东西写好，再逐层往上添加效果和功能。</p>\n<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; message &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var app = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &apos;Hello Vue!&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>先看一个简单实例代码结构：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;app-selection-banner&quot;&gt;</span><br><span class=\"line\">    &lt;el-row :gutter=&quot;16&quot;&gt;</span><br><span class=\"line\">      &lt;el-col :span=&quot;6&quot;&gt;</span><br><span class=\"line\">        &lt;banner-preview :list=&quot;list&quot; :show-user-types=&quot;showUserTypes&quot; /&gt;</span><br><span class=\"line\">      &lt;/el-col&gt;</span><br><span class=\"line\">      &lt;el-col :span=&quot;18&quot;&gt;</span><br><span class=\"line\">        &lt;banner-table :list=&quot;list&quot; :user-type-options=&quot;userTypeOptions&quot; @updateList=&quot;getList&quot; /&gt;</span><br><span class=\"line\">      &lt;/el-col&gt;</span><br><span class=\"line\">    &lt;/el-row&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import BannerPreview from &apos;./components/BannerPreview&apos;</span><br><span class=\"line\">import BannerTable from &apos;./components/BannerTable&apos;</span><br><span class=\"line\">import &#123; bannerList &#125; from &apos;@/api/selection&apos;</span><br><span class=\"line\">import &#123; userTypeInfo &#125; from &apos;@/api/common&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;BannerSelection&apos;,</span><br><span class=\"line\">  components: &#123; BannerPreview, BannerTable &#125;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      list: null,</span><br><span class=\"line\">      userTypeOptions: [],</span><br><span class=\"line\">      showUserTypes: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created() &#123;</span><br><span class=\"line\">    this.getList()</span><br><span class=\"line\">    userTypeInfo(&#123; version: &apos;1.0&apos; &#125;).then(response =&gt; &#123;</span><br><span class=\"line\">      this.userTypeOptions = response.data</span><br><span class=\"line\">      this.showUserTypes = (response.data || []).filter((userType) =&gt; &#123;</span><br><span class=\"line\">        return userType.type !== &apos;0&apos;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getList() &#123;</span><br><span class=\"line\">      bannerList().then(response =&gt; &#123;</span><br><span class=\"line\">        const &#123; items &#125; = response.data || []</span><br><span class=\"line\">        this.list = items.sort((a, b) =&gt; b.status - a.status)</span><br><span class=\"line\">      &#125;).catch(err =&gt; console.log(err))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.app-selection-banner&#123;</span><br><span class=\"line\">  background-color:#eee;</span><br><span class=\"line\">  padding:16px;</span><br><span class=\"line\">  .el-col &#123;</span><br><span class=\"line\">    padding: 0 6px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>组件BannerPreview.vue :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;md-wrap&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;md-title&quot;&gt;预览区&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;md-text&quot;&gt;</span><br><span class=\"line\">      &lt;div v-for=&quot;item in showUserTypes&quot; :key=&quot;item.type&quot; class=&quot;block&quot;&gt;</span><br><span class=\"line\">        &lt;span class=&quot;demonstration&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;el-carousel v-if=&quot;previewList(item.type).length&quot; :autoplay=&quot;false&quot; arrow=&quot;never&quot; trigger=&quot;click&quot; height=&quot;100px&quot;&gt;</span><br><span class=\"line\">          &lt;el-carousel-item v-for=&quot;(child, key) in previewList(item.type)&quot; :key=&quot;key&quot;&gt;</span><br><span class=\"line\">            &lt;a :href=&quot;child.link&quot; target=&quot;_blank&quot;&gt;</span><br><span class=\"line\">              &lt;img class=&quot;list-img&quot; :src=&quot;child.imgUrl&quot;&gt;</span><br><span class=\"line\">            &lt;/a&gt;</span><br><span class=\"line\">          &lt;/el-carousel-item&gt;</span><br><span class=\"line\">        &lt;/el-carousel&gt;</span><br><span class=\"line\">        &lt;div v-else class=&quot;no-data&quot;&gt;暂无数据&lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;BannerPreview&apos;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    list: &#123;</span><br><span class=\"line\">      type: Array,</span><br><span class=\"line\">      default: null</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showUserTypes: &#123;</span><br><span class=\"line\">      type: Array,</span><br><span class=\"line\">      default: null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    previewList(type) &#123;</span><br><span class=\"line\">      const newArr = this.list || []</span><br><span class=\"line\">      return newArr.length &gt; 0 &amp;&amp; newArr.filter((item) =&gt; &#123;</span><br><span class=\"line\">        const &#123; userType &#125; = item || &apos;&apos;</span><br><span class=\"line\">        return item.status === &apos;2&apos; &amp;&amp; (userType.includes(type) || userType.includes(&apos;0&apos;))</span><br><span class=\"line\">      &#125;).slice(0, 5)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.md-wrap&#123;</span><br><span class=\"line\">  background-color:#fff;</span><br><span class=\"line\">  .md-title&#123;</span><br><span class=\"line\">    line-height: 50px;</span><br><span class=\"line\">    border-bottom:1px #eee solid;</span><br><span class=\"line\">    padding-left: 16px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .md-text&#123;</span><br><span class=\"line\">    padding: 16px;</span><br><span class=\"line\">    .no-data&#123;</span><br><span class=\"line\">      font-size: 14px;</span><br><span class=\"line\">      color: #999;</span><br><span class=\"line\">      padding: 10px 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .demonstration&#123;</span><br><span class=\"line\">      display: inline-block;</span><br><span class=\"line\">      padding-bottom: 10px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .block&#123;</span><br><span class=\"line\">      margin-bottom: 20px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .list-img&#123;</span><br><span class=\"line\">      height: 100%;</span><br><span class=\"line\">      width: 100%;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .el-carousel__item h3 &#123;</span><br><span class=\"line\">    color: #475669;</span><br><span class=\"line\">    font-size: 14px;</span><br><span class=\"line\">    opacity: 0.75;</span><br><span class=\"line\">    line-height: 100px;</span><br><span class=\"line\">    margin: 0;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .el-carousel__item:nth-child(2n) &#123;</span><br><span class=\"line\">     background-color: #99a9bf;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .el-carousel__item:nth-child(2n+1) &#123;</span><br><span class=\"line\">     background-color: #d3dce6;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p>\n<p>比如 created 钩子可以用来在一个实例被创建之后执行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created: function () &#123;</span><br><span class=\"line\">    // `this` 指向 vm 实例</span><br><span class=\"line\">    console.log(&apos;a is: &apos; + this.a)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// =&gt; &quot;a is: 1&quot;</span><br></pre></td></tr></table></figure></p>\n<p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。</p>\n<p><em><font color=\"red\">注意：</font>不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</em></p>\n<h4 id=\"生命周期图示\"><a href=\"#生命周期图示\" class=\"headerlink\" title=\"生命周期图示\"></a>生命周期图示</h4><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。<br><img src=\"https://img.fengjr.com/image/2019/10/22/b3251a15e5779fcfec925b78a149f5c8.png\" alt></p>\n<h4 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h4><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p>\n<p>所以，对于任何复杂逻辑，你都应当使用计算属性。</p>\n<p>基础例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &apos;Hello&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    // 计算属性的 getter</span><br><span class=\"line\">    reversedMessage: function () &#123;</span><br><span class=\"line\">      // `this` 指向 vm 实例</span><br><span class=\"line\">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Original message: “Hello”<br>Computed reversed message: “olleH”</p>\n<h4 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h4><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 在组件中</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  reversedMessage: function () &#123;</span><br><span class=\"line\">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>\n<p>这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  now: function () &#123;</span><br><span class=\"line\">    return Date.now()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p>\n<h4 id=\"计算属性-vs-侦听属性\"><a href=\"#计算属性-vs-侦听属性\" class=\"headerlink\" title=\"计算属性 vs 侦听属性\"></a>计算属性 vs 侦听属性</h4><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Foo&apos;,</span><br><span class=\"line\">    lastName: &apos;Bar&apos;,</span><br><span class=\"line\">    fullName: &apos;Foo Bar&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    firstName: function (val) &#123;</span><br><span class=\"line\">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    lastName: function (val) &#123;</span><br><span class=\"line\">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面代码是命令式且重复的。将它与计算属性的版本进行比较：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Foo&apos;,</span><br><span class=\"line\">    lastName: &apos;Bar&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    fullName: function () &#123;</span><br><span class=\"line\">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>好得多了，不是吗？</p>\n<h4 id=\"侦听器\"><a href=\"#侦听器\" class=\"headerlink\" title=\"侦听器\"></a>侦听器</h4><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>\n<p>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;watch-example&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;</span><br><span class=\"line\">    Ask a yes/no question:</span><br><span class=\"line\">    &lt;input v-model=&quot;question&quot;&gt;</span><br><span class=\"line\">  &lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var watchExampleVM = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#watch-example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    question: &apos;&apos;,</span><br><span class=\"line\">    answer: &apos;I cannot give you an answer until you ask a question!&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    // 如果 `question` 发生改变，这个函数就会运行</span><br><span class=\"line\">    question: function (newQuestion, oldQuestion) &#123;</span><br><span class=\"line\">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class=\"line\">      this.debouncedGetAnswer()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created: function () &#123;</span><br><span class=\"line\">    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span><br><span class=\"line\">    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span><br><span class=\"line\">    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span><br><span class=\"line\">    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span><br><span class=\"line\">    // 请参考：https://lodash.com/docs#debounce</span><br><span class=\"line\">    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getAnswer: function () &#123;</span><br><span class=\"line\">      if (this.question.indexOf(&apos;?&apos;) === -1) &#123;</span><br><span class=\"line\">        this.answer = &apos;Questions usually contain a question mark. ;-)&apos;</span><br><span class=\"line\">        return</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.answer = &apos;Thinking...&apos;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      axios.get(&apos;https://yesno.wtf/api&apos;)</span><br><span class=\"line\">        .then(function (response) &#123;</span><br><span class=\"line\">          vm.answer = _.capitalize(response.data.answer)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(function (error) &#123;</span><br><span class=\"line\">          vm.answer = &apos;Error! Could not reach the API. &apos; + error</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<h1 id=\"二、Vue与React两个框架的区别和优势对比\"><a href=\"#二、Vue与React两个框架的区别和优势对比\" class=\"headerlink\" title=\"二、Vue与React两个框架的区别和优势对比\"></a>二、Vue与React两个框架的区别和优势对比</h1><p>Vue和React两个JavaScript框架都是当下比较受欢迎的，他们两者之间的区别有哪些，各自的优缺点是什么？</p>\n<h4 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h4><p>除非你一直不关注前端的发展，不然你肯定听说过由Facebook创建的JavaScript UI框架——React。它支撑着包括Instagram在内的大多数Facebook网站。React与当时流行的jQuery,Backbone.js和Angular 1等框架不同，它的诞生改变了JavaScript的世界。其中最大的变化是React推广了Virtual DOM并创造了新的语法——JSX，JSX允许开发者在JavaScript中书写HTML（译者注：即HTML in JavaScript）。</p>\n<p>Vue致力解决的问题与React一致，但却提供了另外一套解决方案。Vue使用模板系统而不是JSX，使其对现有应用的升级更加容易。这是因为模板用的就是普通的HTML，通过Vue来整合现有的系统是比较容易的，不需要整体重构。同时Vue声称它更容易学习，我们最近接触Vue，就能证明所言非虚。关于Vue还需要说的是，Vue主要是由一位开发者进行维护的，而不像React一样由如Facebook这类大公司维护。</p>\n<h4 id=\"相似之处\"><a href=\"#相似之处\" class=\"headerlink\" title=\"相似之处\"></a>相似之处</h4><p>React与Vue存在很多相似之处：</p>\n<ul>\n<li>使用 Virtual DOM</li>\n<li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li>\n<li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li>\n</ul>\n<h4 id=\"Virtual-DOM\"><a href=\"#Virtual-DOM\" class=\"headerlink\" title=\"Virtual DOM\"></a>Virtual DOM</h4><p>啊哈，人们经常说Virtual DOM是什么呢？</p>\n<p>Vue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了一种叫’Virtual DOM’的东西。所谓的Virtual DOM基本上说就是它名字的意思：虚拟DOM，DOM树的虚拟表现。它的诞生是基于这么一个概念：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多。</p>\n<p>Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。</p>\n<p>例子如下，我们可以看看下面这个列表在HTML中的代码是如何写的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul class=&quot;list&quot;&gt;</span><br><span class=\"line\">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>\n<p>而在JavaScript中，我们可以用对象简单地创造一个针对上面例子的映射：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    type: &apos;ul&apos;, </span><br><span class=\"line\">    props: &#123;&apos;class&apos;: &apos;list&apos;&#125;, </span><br><span class=\"line\">    children: [</span><br><span class=\"line\">        &#123; type: &apos;li&apos;, props: &#123;&#125;, children: [&apos;item 1&apos;] &#125;,</span><br><span class=\"line\">        &#123; type: &apos;li&apos;, props: &#123;&#125;, children: [&apos;item 2&apos;] &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>真实的Virtual DOM会比上面的例子更复杂，但它本质上是一个嵌套着数组的原生对象。</p>\n<p>当新一项被加进去这个JavaScript对象时，一个函数会计算新旧Virtual DOM之间的差异并反应在真实的DOM上。计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。</p>\n<p>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p>\n<p>而对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</p>\n<p>在react开发中，经常会遇到组件重复渲染的问题，父组件一个state的变化，就会导致以该组件的所有子组件都重写render，尽管绝大多数子组件的props没有变化</p>\n<p>render什么时候会触发<br>首先，先上一张react生命周期图：<br><img src=\"https://img.fengjr.com/file/2019/10/30/c7e8067e7fd11a07a1ecc0f643a4b90f.jpeg\" alt><br>这张图将react的生命周期分为了三个阶段：生成期、存在期、销毁期，这样在create、props、state、unMount状态变化时我们可以清楚的看到reacte触发了哪些生命周期钩子以及什么时候会render。</p>\n<p>如何避免这些不必要的render:</p>\n<ul>\n<li>shouldComponentUpdate()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure>\n<p>使用shouldComponentUpdate()以让React知道当前状态或属性的改变是否不影响组件的输出，默认返回ture，返回false时不会重写render，而且该方法并不会在初始化渲染或当使用forceUpdate()时被调用，我们要做的只是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">  return nextState.someData !== this.state.someData</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是，state里的数据这么多，还有对象，还有复杂类型数据，react的理念就是拆分拆分再拆分，这么多子组件，我要每个组件都去自己一个一个对比吗？？不存在的，这么麻烦，要知道我们的终极目标是不劳而获-_-</p>\n<ul>\n<li>React.PureComponent</li>\n</ul>\n<p>React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）</p>\n<p>关注点：无论组件是否是 PureComponent，如果定义了 shouldComponentUpdate()，那么会调用它并以它的执行结果来判断是否 update。在组件未定义 shouldComponentUpdate() 的情况下，会判断该组件是否是 PureComponent，如果是的话，会对新旧 props、state 进行 shallowEqual 比较，一旦新旧不一致，会触发 update。</p>\n<p>小结：如果你的应用中，交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果你更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。</p>\n<h4 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h4><p>React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。关于组件化的例子可以在这篇文章的中间部分被找到:</p>\n<p>你可以认为组件就是用户界面中的一小块。如果让我来设计Facebook的UI界面，那么聊天窗口会是一个组件，评论会是另一个组件，不断更新的好友列表也会作为一个组件。</p>\n<p>在Vue中，如果你遵守一定的规则，你可以使用单文件组件.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">&lt;li class=&quot;pasta-dish list-unstyled&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;row&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;col-md-3&quot;&gt;</span><br><span class=\"line\">            &lt;img :src=&quot;this.item.image&quot; :alt=&quot;this.item.name&quot; /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;col-md-9 text-left&quot;&gt;</span><br><span class=\"line\">            &lt;h3&gt;&#123;&#123;this.item.name&#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">            &lt;p&gt;</span><br><span class=\"line\">                &#123;&#123;this.item.desc&#125;&#125;</span><br><span class=\"line\">            &lt;/p&gt;</span><br><span class=\"line\">            &lt;button v-on:click=&quot;addToOrderNew&quot; class=&quot;btn btn-primary&quot;&gt;Add to order&lt;/button&gt; &lt;mark&gt;&#123;&#123;this.orders&#125;&#125;&lt;/mark&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/li&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    name: &apos;pasta-item&apos;,</span><br><span class=\"line\">    props: [&apos;item&apos;],</span><br><span class=\"line\">    data:  function()&#123;</span><br><span class=\"line\">        return&#123;</span><br><span class=\"line\">            orders: 0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        addToOrderNew: function(y)&#123;</span><br><span class=\"line\">            this.orders += 1;</span><br><span class=\"line\">            this.$emit(&apos;order&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style src=&quot;./Pasta.css&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>正如上面你看到的例子中，HTML, JavaScript和CSS都写在一个文件之中。你不再需要在.vue组件文件中引入CSS，虽然这也是可以的。</p>\n<p>React也是非常相似的，JavaScript与JSX被写入同一个组件文件中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class PastaItem extends React.Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        const &#123; details, index &#125; = this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;li className=&quot;pasta-dish list-unstyled&quot;&gt;</span><br><span class=\"line\">                &lt;div className=&quot;row&quot;&gt;</span><br><span class=\"line\">                    &lt;div className=&quot;col-md-3&quot;&gt;</span><br><span class=\"line\">                        &lt;img src=&#123;details.image&#125; alt=&#123;details.name&#125; /&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                    &lt;div className=&quot;col-md-9 text-left&quot;&gt;</span><br><span class=\"line\">                        &lt;h3&gt;&#123;details.name&#125;&lt;/h3&gt;</span><br><span class=\"line\">                        &lt;p&gt;</span><br><span class=\"line\">                            &#123;details.desc&#125;</span><br><span class=\"line\">                        &lt;/p&gt;</span><br><span class=\"line\">                        &lt;button onClick=&#123;() =&gt; this.props.addToOrder(index)&#125; className=&quot;btn btn-primary&quot;&gt;Add to order&lt;/button&gt; &lt;mark&gt;&#123;this.props.orders || 0&#125;&lt;/mark&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default PastaItem;</span><br></pre></td></tr></table></figure></p>\n<p>Props<br>在上面两个例子中，我们可以看到React和Vue都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.keys(this.state.pastadishes).map(key =&gt;</span><br><span class=\"line\">    &lt;PastaItem index=&#123;key&#125; key=&#123;key&#125; details=&#123;this.state.pastadishes[key]&#125; addToOrder=&#123;this.addToOrder&#125; orders=&#123;this.state.orders[key]&#125; /&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>上面的JSX库组中，index, key, details, orders 与 addToOrder都是props，数据会被下传到子组件PastaItem中去。</p>\n<p>在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”。</p>\n<p>而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pasta-item v-for=&quot;(item, key) in samplePasta&quot; :item=&quot;item&quot; :key=&quot;key&quot; @order=&quot;handleOrder(key)&quot;&gt;&lt;/pasta-item&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这是模板的实现，但这代码完全能工作，然而在React中展现相同数据会更麻烦一点。</p>\n<h4 id=\"构建工具\"><a href=\"#构建工具\" class=\"headerlink\" title=\"构建工具\"></a>构建工具</h4><p>React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。</p>\n<p>由于CRA有很多选项，使用起来会稍微麻烦一点。这个工具会逼迫你使用Webpack和Babel。而vue-cli则有模板列表可选，能按需创造不同模板，使用起来更灵活一点。</p>\n<p>事实上说，两个工具都非常好用，都能为你建立一个好环境。而且如果可以不配置Webpack的话，我认为这是天大的好事。</p>\n<h4 id=\"Chrome-开发工具\"><a href=\"#Chrome-开发工具\" class=\"headerlink\" title=\"Chrome 开发工具\"></a>Chrome 开发工具</h4><p>React和Vue都有很好的Chrome扩展工具去帮助你找出bug。它们会检查你的应用，让你看到Vue或者React中的变化。你也可以看到应用中的状态，并实时看到更新。</p>\n<p>React的开发工具: <a href=\"https://cdn.deliciousbrains.com/content/uploads/2017/06/15151112/react-devtools.mp4\" target=\"_blank\" rel=\"noopener\">https://cdn.deliciousbrains.com/content/uploads/2017/06/15151112/react-devtools.mp4</a></p>\n<p>Vue的开发工具: <a href=\"https://cdn.deliciousbrains.com/content/uploads/2017/06/15151111/vue-devtools.mp4\" target=\"_blank\" rel=\"noopener\">https://cdn.deliciousbrains.com/content/uploads/2017/06/15151111/vue-devtools.mp4</a></p>\n<h4 id=\"配套框架\"><a href=\"#配套框架\" class=\"headerlink\" title=\"配套框架\"></a>配套框架</h4><p>Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。</p>\n<p>而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。</p>\n<h4 id=\"主要区别\"><a href=\"#主要区别\" class=\"headerlink\" title=\"主要区别\"></a>主要区别</h4><p>Vue与react有很多的相似之处，但他们也有完全不一致的地方。</p>\n<p>模板 vs JSX：</p>\n<p>在 React 中，一切都是 JavaScript。<br>在 React 中，所有的组件的渲染功能都依靠 JSX。<br>JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; </span><br><span class=\"line\">  SearchContainer,</span><br><span class=\"line\">  SearchContent</span><br><span class=\"line\">&#125; from &apos;./styledComponent.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">import search from &apos;images/search.png&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class Search extends Component &#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;SearchContainer&gt;</span><br><span class=\"line\">        &lt;SearchContent &#123; ...this.props &#125;&gt;</span><br><span class=\"line\">          &lt;img src=&#123;search&#125; alt=&quot;&quot;/&gt;</span><br><span class=\"line\">          &lt;span&gt;想吃什么搜这里，川菜&lt;/span&gt;</span><br><span class=\"line\">        &lt;/SearchContent&gt;</span><br><span class=\"line\">      &lt;/SearchContainer&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Search</span><br></pre></td></tr></table></figure></p>\n<p>vue是把html，css，js组合到一起，用各自的处理方式<br>Vue 设置样式的默认方法是单文件组件里类似 style 的标签。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;m-movie&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;white-bg topbar-bg&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;city-entry&quot;&gt;</span><br><span class=\"line\">        &lt;router-link tag=&quot;span&quot; to=&quot;/cities&quot; class=&quot;city-name&quot;&gt;北京&lt;/router-link&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      </span><br><span class=\"line\">      &lt;div class=&quot;switch-hot&quot;&gt;</span><br><span class=\"line\">        &lt;router-link tag=&quot;div&quot; to=&quot;/home/movies/intheater&quot; active-class=&quot;active&quot; class=&quot;hot-item&quot;&gt;正在热映&lt;/router-link&gt;</span><br><span class=\"line\">        &lt;router-link tag=&quot;div&quot; to=&quot;/home/movies/coming&quot; active-class=&quot;active&quot; class=&quot;hot-item&quot;&gt;即将上映&lt;/router-link&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;transition :name=&quot;transitionName&quot;&gt;</span><br><span class=\"line\">      &lt;router-view class=&quot;movies-outlet&quot;&gt;&lt;/router-view&gt;</span><br><span class=\"line\">    &lt;/transition&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      transitionName: &apos;&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    $route (to, from) &#123;</span><br><span class=\"line\">      if ( to.meta &gt; from.meta ) &#123;</span><br><span class=\"line\">        this.transitionName = &apos;slide-left&apos;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        this.transitionName = &apos;slide-right&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class=\"line\">@import &apos;~styles/border.styl&apos;</span><br><span class=\"line\">@import &apos;~styles/variables.styl&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">.slide-right-enter-active,</span><br><span class=\"line\">.slide-right-leave-active,</span><br><span class=\"line\">.slide-left-enter-active,</span><br><span class=\"line\">.slide-left-leave-active &#123;</span><br><span class=\"line\">  transition: all 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.slide-right-enter &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translate3d(-100%, 0, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.slide-right-leave-to &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translate3d(100%, 0, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.slide-left-enter &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translate3d(100%, 0, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.slide-left-leave-to &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translate3d(-100%, 0, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>总结一下，我们发现</p>\n<p>Vue的优势包括：</p>\n<ul>\n<li>模板和渲染函数的弹性选择</li>\n<li>简单的语法及项目创建</li>\n<li>更快的渲染速度和更小的体积</li>\n</ul>\n<p>React的优势包括：</p>\n<ul>\n<li>更适用于大型应用和更好的可测试性</li>\n<li>同时适用于Web端和原生App</li>\n<li>更大的生态圈带来的更多支持和工具</li>\n</ul>\n<p>而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：</p>\n<ul>\n<li>利用虚拟DOM实现快速渲染</li>\n<li>轻量级</li>\n<li>响应式和组件化</li>\n<li>服务器端渲染</li>\n<li>易于集成路由工具，打包工具以及状态管理工具</li>\n<li>优秀的支持和社区</li>\n</ul>\n<h1 id=\"三、vue-element-amdin介绍\"><a href=\"#三、vue-element-amdin介绍\" class=\"headerlink\" title=\"三、vue-element-amdin介绍\"></a>三、vue-element-amdin介绍</h1><p>vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui实现。它使用了最新的前端技术栈，内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。</p>\n<h4 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 登录 / 注销</span><br><span class=\"line\"></span><br><span class=\"line\">- 权限验证</span><br><span class=\"line\">  - 页面权限</span><br><span class=\"line\">  - 指令权限</span><br><span class=\"line\">  - 权限配置</span><br><span class=\"line\">  - 二步登录</span><br><span class=\"line\"></span><br><span class=\"line\">- 多环境发布</span><br><span class=\"line\">  - dev sit stage prod</span><br><span class=\"line\"></span><br><span class=\"line\">- 全局功能</span><br><span class=\"line\">  - 国际化多语言</span><br><span class=\"line\">  - 多种动态换肤</span><br><span class=\"line\">  - 动态侧边栏（支持多级路由嵌套）</span><br><span class=\"line\">  - 动态面包屑</span><br><span class=\"line\">  - 快捷导航(标签页)</span><br><span class=\"line\">  - Svg Sprite 图标</span><br><span class=\"line\">  - 本地/后端 mock 数据</span><br><span class=\"line\">  - Screenfull全屏</span><br><span class=\"line\">  - 自适应收缩侧边栏</span><br><span class=\"line\"></span><br><span class=\"line\">- 编辑器</span><br><span class=\"line\">  - 富文本</span><br><span class=\"line\">  - Markdown</span><br><span class=\"line\">  - JSON 等多格式</span><br><span class=\"line\"></span><br><span class=\"line\">- Excel</span><br><span class=\"line\">  - 导出excel</span><br><span class=\"line\">  - 导入excel</span><br><span class=\"line\">  - 前端可视化excel</span><br><span class=\"line\">  - 导出zip</span><br><span class=\"line\"></span><br><span class=\"line\">- 表格</span><br><span class=\"line\">  - 动态表格</span><br><span class=\"line\">  - 拖拽表格</span><br><span class=\"line\">  - 内联编辑</span><br><span class=\"line\"></span><br><span class=\"line\">- 错误页面</span><br><span class=\"line\">  - 401</span><br><span class=\"line\">  - 404</span><br><span class=\"line\"></span><br><span class=\"line\">- 組件</span><br><span class=\"line\">  - 头像上传</span><br><span class=\"line\">  - 返回顶部</span><br><span class=\"line\">  - 拖拽Dialog</span><br><span class=\"line\">  - 拖拽Select</span><br><span class=\"line\">  - 拖拽看板</span><br><span class=\"line\">  - 列表拖拽</span><br><span class=\"line\">  - SplitPane</span><br><span class=\"line\">  - Dropzone</span><br><span class=\"line\">  - Sticky</span><br><span class=\"line\">  - CountTo</span><br><span class=\"line\"></span><br><span class=\"line\">- 综合实例</span><br><span class=\"line\">- 错误日志</span><br><span class=\"line\">- Dashboard</span><br><span class=\"line\">- 引导页</span><br><span class=\"line\">- ECharts 图表</span><br><span class=\"line\">- Clipboard(剪贴复制)</span><br><span class=\"line\">- Markdown2html</span><br></pre></td></tr></table></figure>\n<p>本项目不支持低版本浏览器(如 ie)，有需求请自行添加 polyfill <a href=\"https://github.com/PanJiaChen/vue-element-admin/wiki#babel-polyfill\" target=\"_blank\" rel=\"noopener\">详情</a></p>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── build                      # 构建相关</span><br><span class=\"line\">├── mock                       # 项目mock 模拟数据</span><br><span class=\"line\">├── plop-templates             # 基本模板</span><br><span class=\"line\">├── public                     # 静态资源</span><br><span class=\"line\">│   │── favicon.ico            # favicon图标</span><br><span class=\"line\">│   └── index.html             # html模板</span><br><span class=\"line\">├── src                        # 源代码</span><br><span class=\"line\">│   ├── api                    # 所有请求</span><br><span class=\"line\">│   ├── assets                 # 主题 字体等静态资源</span><br><span class=\"line\">│   ├── components             # 全局公用组件</span><br><span class=\"line\">│   ├── directive              # 全局指令</span><br><span class=\"line\">│   ├── filters                # 全局 filter</span><br><span class=\"line\">│   ├── icons                  # 项目所有 svg icons</span><br><span class=\"line\">│   ├── lang                   # 国际化 language</span><br><span class=\"line\">│   ├── layout                 # 全局 layout</span><br><span class=\"line\">│   ├── router                 # 路由</span><br><span class=\"line\">│   ├── store                  # 全局 store管理</span><br><span class=\"line\">│   ├── styles                 # 全局样式</span><br><span class=\"line\">│   ├── utils                  # 全局公用方法</span><br><span class=\"line\">│   ├── vendor                 # 公用vendor</span><br><span class=\"line\">│   ├── views                  # views 所有页面</span><br><span class=\"line\">│   ├── App.vue                # 入口页面</span><br><span class=\"line\">│   ├── main.js                # 入口文件 加载组件 初始化等</span><br><span class=\"line\">│   └── permission.js          # 权限管理</span><br><span class=\"line\">├── tests                      # 测试</span><br><span class=\"line\">├── .env.xxx                   # 环境变量配置</span><br><span class=\"line\">├── .eslintrc.js               # eslint 配置项</span><br><span class=\"line\">├── .babelrc                   # babel-loader 配置</span><br><span class=\"line\">├── .travis.yml                # 自动化CI配置</span><br><span class=\"line\">├── vue.config.js              # vue-cli 配置</span><br><span class=\"line\">├── postcss.config.js          # postcss 配置</span><br><span class=\"line\">└── package.json               # package.json</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目</span><br><span class=\"line\">git clone https://github.com/PanJiaChen/vue-element-admin.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 进入项目目录</span><br><span class=\"line\">cd vue-element-admin</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装依赖</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"># 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题</span><br><span class=\"line\">npm install --registry=https://registry.npm.taobao.org</span><br><span class=\"line\"></span><br><span class=\"line\"># 本地开发 启动项目</span><br><span class=\"line\">npm run dev</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://panjiachen.github.io/vue-element-admin/\" target=\"_blank\" rel=\"noopener\">预览地址</a></p>\n<h1 id=\"四、fund-cms前端项目实例\"><a href=\"#四、fund-cms前端项目实例\" class=\"headerlink\" title=\"四、fund-cms前端项目实例\"></a>四、fund-cms前端项目实例</h1><p>基金cms管理系统是基于vue-element-amdin框架并通过upm单点登录方式实现的后台管理系统。数据库用的是mongodb实现并输出api接口。</p>\n<h4 id=\"单点登录\"><a href=\"#单点登录\" class=\"headerlink\" title=\"单点登录\"></a>单点登录</h4><p>进入页面判断cookie是否存在，不存在则跳到upm系统进行登录，登录成功自动跳回并带cookie参数。然后取到cookie值并手动种上，此时可以访问api接口。访问接口时如果cookie过期返回错误标识，前端判断自动调到upm登录系统重新登录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取upm单点登录 cookie</span><br><span class=\"line\">const &#123; ticket &#125; = param2Obj(window.location.search) || &apos;&apos;</span><br><span class=\"line\">if (ticket) &#123;</span><br><span class=\"line\">  setToken(ticket)</span><br><span class=\"line\">  const newUrl = location.href.replace(location.search, &apos;&apos;)</span><br><span class=\"line\">  window.location.href = newUrl</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断单点登录 cookie</span><br><span class=\"line\">if (!getToken()) &#123;</span><br><span class=\"line\">  logoutRedirect()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 退出并跳转</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function logoutRedirect() &#123;</span><br><span class=\"line\">  const toUrl = process.env.VUE_APP_BASE_TOLOGIN + &apos;/auth?appkey=fund-cms&amp;return=&apos; + window.location.href</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;development&apos;) &#123;</span><br><span class=\"line\">    window.location.href = toUrl</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><p>静态路由：登录进入系统就可以看到的菜单<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * constantRoutes</span><br><span class=\"line\"> * a base page that does not have permission requirements</span><br><span class=\"line\"> * all roles can be accessed</span><br><span class=\"line\"> */</span><br><span class=\"line\">export const constantRoutes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &apos;/404&apos;,</span><br><span class=\"line\">    component: () =&gt; import(&apos;@/views/error-page/404&apos;),</span><br><span class=\"line\">    hidden: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &apos;&apos;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    redirect: &apos;dashboard&apos;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;dashboard&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/dashboard/index&apos;),</span><br><span class=\"line\">        name: &apos;Dashboard&apos;,</span><br><span class=\"line\">        meta: &#123; title: &apos;dashboard&apos;, icon: &apos;dashboard&apos;, affix: true &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &apos;/selection&apos;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    redirect: &apos;/selection/module&apos;,</span><br><span class=\"line\">    alwaysShow: true, // will always show the root menu</span><br><span class=\"line\">    name: &apos;Selection&apos;,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &apos;精选&apos;,</span><br><span class=\"line\">      icon: &apos;shopping&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;module&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/selection/module&apos;),</span><br><span class=\"line\">        name: &apos;ModuleSelection&apos;,</span><br><span class=\"line\">        hidden: true,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;模块管理&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        path: &apos;search&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/selection/search&apos;),</span><br><span class=\"line\">        name: &apos;SearchSelection&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;搜索&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        path: &apos;fengj&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/selection/fengj&apos;),</span><br><span class=\"line\">        name: &apos;FengjSelection&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;凤金精选&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>动态路由：需要用户权限匹配才能显示<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const asyncRoutes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &apos;/permission&apos;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    redirect: &apos;/permission/page&apos;,</span><br><span class=\"line\">    alwaysShow: true, // will always show the root menu</span><br><span class=\"line\">    name: &apos;Permission&apos;,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &apos;permission&apos;,</span><br><span class=\"line\">      icon: &apos;lock&apos;,</span><br><span class=\"line\">      roles: [&apos;admin&apos;, &apos;editor&apos;] // you can set roles in root nav</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;page&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/permission/page&apos;),</span><br><span class=\"line\">        name: &apos;PagePermission&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;pagePermission&apos;,</span><br><span class=\"line\">          roles: [&apos;admin&apos;] // or you can only set roles in sub nav</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;directive&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/permission/directive&apos;),</span><br><span class=\"line\">        name: &apos;DirectivePermission&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;directivePermission&apos;</span><br><span class=\"line\">          // if do not set roles, means: this page does not require permission</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;role&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/permission/role&apos;),</span><br><span class=\"line\">        name: &apos;RolePermission&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;rolePermission&apos;,</span><br><span class=\"line\">          roles: [&apos;admin&apos;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h4><p>接口api通过axios封装，支持环境变量配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &apos;axios&apos;</span><br><span class=\"line\">import &#123; Message &#125; from &apos;element-ui&apos;</span><br><span class=\"line\">// import store from &apos;@/store&apos;</span><br><span class=\"line\">import &#123; removeToken &#125; from &apos;@/utils/auth&apos;</span><br><span class=\"line\">import &#123; logoutRedirect &#125; from &apos;@/utils&apos;</span><br><span class=\"line\">// create an axios instance</span><br><span class=\"line\">const service = axios.create(&#123;</span><br><span class=\"line\">  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url</span><br><span class=\"line\">  // withCredentials: true, // send cookies when cross-domain requests</span><br><span class=\"line\">  timeout: 5000 // request timeout</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>配置：selection.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import request from &apos;@/utils/request&apos;</span><br><span class=\"line\">//get api</span><br><span class=\"line\">export function fengjList(params) &#123;</span><br><span class=\"line\">  return request(&#123;</span><br><span class=\"line\">    url: &apos;/fengj-management/fengjlist&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//post api</span><br><span class=\"line\">export function updateOpenStatus(data) &#123;</span><br><span class=\"line\">  return request(&#123;</span><br><span class=\"line\">    url: &apos;/module-management/openmodule/update&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用：fengj.vue<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; fengjList &#125; from &apos;@/api/selection&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;FengjSelection&apos;,</span><br><span class=\"line\">  components: &#123; FengjPreview, FengjTable &#125;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      list: null,</span><br><span class=\"line\">      userTypeOptions: [],</span><br><span class=\"line\">      showUserTypes: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created() &#123;</span><br><span class=\"line\">    this.getList()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getList() &#123;</span><br><span class=\"line\">      fengjList().then(response =&gt; &#123;</span><br><span class=\"line\">        const &#123; items &#125; = response.data || []</span><br><span class=\"line\">        this.list = items.sort((a, b) =&gt; b.status - a.status)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"开发遇到问题\"><a href=\"#开发遇到问题\" class=\"headerlink\" title=\"开发遇到问题\"></a>开发遇到问题</h4><p>1.状态排序<br>数据库里没有status字段，前端拿到数据后再重新排一下序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  getList() &#123;</span><br><span class=\"line\">    fengjList().then(response =&gt; &#123;</span><br><span class=\"line\">      const &#123; items &#125; = response.data || []</span><br><span class=\"line\">      this.list = items.sort((a, b) =&gt; b.status - a.status)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.表单添加动态校验<br>基金产品输入基金code读api异步获取联动。<br>缺点是调两次api。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; searchFundInfo &#125; from &apos;@/api/common&apos;</span><br><span class=\"line\">data() &#123;</span><br><span class=\"line\">  const checkCode = async(rule, value, callback) =&gt; &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      await searchFundInfo(&#123; key: value &#125;)</span><br><span class=\"line\">      callback()</span><br><span class=\"line\">    &#125; catch (err) &#123;</span><br><span class=\"line\">      return callback(new Error(err.message))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    rules: &#123;</span><br><span class=\"line\">      code: [&#123; required: true, message: &apos;基金代码不能为空&apos;, trigger: &apos;blur&apos; &#125;, &#123; validator: checkCode, trigger: &apos;blur&apos; &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.列表组件格式化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-table-column label=&quot;用户类型&quot; prop=&quot;userType&quot; align=&quot;center&quot; :formatter=&quot;formatter&quot; /&gt;</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  formatter(row, column) &#123;</span><br><span class=\"line\">    const &#123; userType &#125; = row</span><br><span class=\"line\">    const nameArr = []</span><br><span class=\"line\">    this.userTypeOptions.forEach((item) =&gt; &#123;</span><br><span class=\"line\">      if (userType.includes(item.type)) &#123;</span><br><span class=\"line\">        nameArr.push(item.name)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return nameArr.join()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.子组件调用父组件方法<br>表单更新后，预览区实现自动更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$emit(&apos;updateList&apos;)</span><br><span class=\"line\">//父组件</span><br><span class=\"line\">&lt;fengj-table :list=&quot;list&quot; :user-type-options=&quot;userTypeOptions&quot; @updateList=&quot;getList&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>5.阻止冒泡方法@click.stop<br>咨询列表点击显示预览区和字典联动，操作按钮需要做阻止冒泡处理。（阻止默认行为：@click.prevent）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-button type=&quot;success&quot; size=&quot;mini&quot; @click.stop=&quot;handleUpdate(row)&quot;&gt;</span><br><span class=\"line\">  编辑</span><br><span class=\"line\">&lt;/el-button&gt;</span><br></pre></td></tr></table></figure></p>\n<p>6.文本编辑器缓存问题<br>列表点编辑时候，文本编辑器缓存清不掉，显示上一次的内容,因为用的第三方插件。<br>解决办法添加更新方法，传时间戳，组件内监听更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Tinymce ref=&quot;editor&quot; v-model=&quot;temp.content&quot; :update-con=&quot;updateCon&quot; :height=&quot;200&quot; /&gt;</span><br><span class=\"line\">//点编辑弹层显示时候</span><br><span class=\"line\">handleUpdate(row) &#123;</span><br><span class=\"line\">  this.temp = Object.assign(&#123;&#125;, row) // copy obj</span><br><span class=\"line\">  this.temp.startTime = new Date(this.temp.startTime)</span><br><span class=\"line\">  this.dialogStatus = &apos;update&apos;</span><br><span class=\"line\">  this.dialogFormVisible = true</span><br><span class=\"line\">  this.$nextTick(() =&gt; &#123;</span><br><span class=\"line\">    this.$refs[&apos;dataForm&apos;].clearValidate()</span><br><span class=\"line\">    this.updateCon = new Date().getTime()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tinymce.vue<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">    value(val) &#123;</span><br><span class=\"line\">      if (!this.hasChange &amp;&amp; this.hasInit) &#123;</span><br><span class=\"line\">        this.$nextTick(() =&gt;</span><br><span class=\"line\">          window.tinymce.get(this.tinymceId).setContent(this.val || &apos;&apos;))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    language() &#123;</span><br><span class=\"line\">      this.destroyTinymce()</span><br><span class=\"line\">      this.$nextTick(() =&gt; this.initTinymce())</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    updateCon(val) &#123;</span><br><span class=\"line\">      this.$nextTick(() =&gt;</span><br><span class=\"line\">        window.tinymce &amp;&amp; window.tinymce.get(this.tinymceId).setContent(this.newVal || &apos;&apos;))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>7.文本编辑器扩展上传图片功能<br>Tinymce.vue<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div :class=&quot;&#123;fullscreen:fullscreen&#125;&quot; class=&quot;tinymce-container&quot; :style=&quot;&#123;width:containerWidth&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;textarea :id=&quot;tinymceId&quot; class=&quot;tinymce-textarea&quot; /&gt;</span><br><span class=\"line\">    &lt;div class=&quot;editor-custom-btn-container&quot;&gt;</span><br><span class=\"line\">      &lt;editorImage color=&quot;#1890ff&quot; class=&quot;editor-upload-btn&quot; @successCBK=&quot;imageSuccessCBK&quot; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">//上传成功图片插入文本编辑器中</span><br><span class=\"line\">imageSuccessCBK(arr) &#123;</span><br><span class=\"line\">  const _this = this</span><br><span class=\"line\">  arr.forEach(v =&gt; &#123;</span><br><span class=\"line\">    window.tinymce.get(_this.tinymceId).insertContent(`&lt;img class=&quot;wscnph&quot; src=&quot;$&#123;v.url&#125;&quot; &gt;`)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编辑上传图片组件：EditorImage.vue<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-upload</span><br><span class=\"line\">  :multiple=&quot;true&quot;</span><br><span class=\"line\">  :file-list=&quot;fileList&quot;</span><br><span class=\"line\">  :show-file-list=&quot;true&quot;</span><br><span class=\"line\">  :on-remove=&quot;handleRemove&quot;</span><br><span class=\"line\">  :on-success=&quot;handleSuccess&quot;</span><br><span class=\"line\">  :before-upload=&quot;beforeUpload&quot;</span><br><span class=\"line\">  class=&quot;editor-slide-upload&quot;</span><br><span class=\"line\">  :action=&quot;uploadUrl&quot;</span><br><span class=\"line\">  list-type=&quot;picture-card&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">  &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;</span><br><span class=\"line\">    点击上传</span><br><span class=\"line\">  &lt;/el-button&gt;</span><br><span class=\"line\">&lt;/el-upload&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  uploadUrl() &#123;</span><br><span class=\"line\">    const url = process.env.VUE_APP_BASE_API + &apos;/upload/uploadfile&apos;</span><br><span class=\"line\">    return url</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>开发总结：vue-element-admin框架搭建后台管理系统还是比较不错，架构清晰，功能全面，上手快。结合mongodb就可以前端一站式完成项目开发。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、vue简介\"><a href=\"#一、vue简介\" class=\"headerlink\" title=\"一、vue简介\"></a>一、vue简介</h1><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<h5 id=\"渐进式框架的理解\"><a href=\"#渐进式框架的理解\" class=\"headerlink\" title=\"渐进式框架的理解\"></a>渐进式框架的理解</h5><p>提供足够的选择，并且没有很多强制性的要求。<br>渐进也可以理解为一步一步的意思，大概意思就是使用Vue的时候，并不需要把整个框架的所有东西都用上，可以根据实际情况选择你需要的部分。</p>\n<h5 id=\"自底向上逐层应用\"><a href=\"#自底向上逐层应用\" class=\"headerlink\" title=\"自底向上逐层应用\"></a>自底向上逐层应用</h5><p>由基层开始做起，把基础的东西写好，再逐层往上添加效果和功能。</p>\n<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; message &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var app = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &apos;Hello Vue!&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>先看一个简单实例代码结构：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;app-selection-banner&quot;&gt;</span><br><span class=\"line\">    &lt;el-row :gutter=&quot;16&quot;&gt;</span><br><span class=\"line\">      &lt;el-col :span=&quot;6&quot;&gt;</span><br><span class=\"line\">        &lt;banner-preview :list=&quot;list&quot; :show-user-types=&quot;showUserTypes&quot; /&gt;</span><br><span class=\"line\">      &lt;/el-col&gt;</span><br><span class=\"line\">      &lt;el-col :span=&quot;18&quot;&gt;</span><br><span class=\"line\">        &lt;banner-table :list=&quot;list&quot; :user-type-options=&quot;userTypeOptions&quot; @updateList=&quot;getList&quot; /&gt;</span><br><span class=\"line\">      &lt;/el-col&gt;</span><br><span class=\"line\">    &lt;/el-row&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import BannerPreview from &apos;./components/BannerPreview&apos;</span><br><span class=\"line\">import BannerTable from &apos;./components/BannerTable&apos;</span><br><span class=\"line\">import &#123; bannerList &#125; from &apos;@/api/selection&apos;</span><br><span class=\"line\">import &#123; userTypeInfo &#125; from &apos;@/api/common&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;BannerSelection&apos;,</span><br><span class=\"line\">  components: &#123; BannerPreview, BannerTable &#125;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      list: null,</span><br><span class=\"line\">      userTypeOptions: [],</span><br><span class=\"line\">      showUserTypes: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created() &#123;</span><br><span class=\"line\">    this.getList()</span><br><span class=\"line\">    userTypeInfo(&#123; version: &apos;1.0&apos; &#125;).then(response =&gt; &#123;</span><br><span class=\"line\">      this.userTypeOptions = response.data</span><br><span class=\"line\">      this.showUserTypes = (response.data || []).filter((userType) =&gt; &#123;</span><br><span class=\"line\">        return userType.type !== &apos;0&apos;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getList() &#123;</span><br><span class=\"line\">      bannerList().then(response =&gt; &#123;</span><br><span class=\"line\">        const &#123; items &#125; = response.data || []</span><br><span class=\"line\">        this.list = items.sort((a, b) =&gt; b.status - a.status)</span><br><span class=\"line\">      &#125;).catch(err =&gt; console.log(err))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.app-selection-banner&#123;</span><br><span class=\"line\">  background-color:#eee;</span><br><span class=\"line\">  padding:16px;</span><br><span class=\"line\">  .el-col &#123;</span><br><span class=\"line\">    padding: 0 6px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>组件BannerPreview.vue :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;md-wrap&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;md-title&quot;&gt;预览区&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;md-text&quot;&gt;</span><br><span class=\"line\">      &lt;div v-for=&quot;item in showUserTypes&quot; :key=&quot;item.type&quot; class=&quot;block&quot;&gt;</span><br><span class=\"line\">        &lt;span class=&quot;demonstration&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;el-carousel v-if=&quot;previewList(item.type).length&quot; :autoplay=&quot;false&quot; arrow=&quot;never&quot; trigger=&quot;click&quot; height=&quot;100px&quot;&gt;</span><br><span class=\"line\">          &lt;el-carousel-item v-for=&quot;(child, key) in previewList(item.type)&quot; :key=&quot;key&quot;&gt;</span><br><span class=\"line\">            &lt;a :href=&quot;child.link&quot; target=&quot;_blank&quot;&gt;</span><br><span class=\"line\">              &lt;img class=&quot;list-img&quot; :src=&quot;child.imgUrl&quot;&gt;</span><br><span class=\"line\">            &lt;/a&gt;</span><br><span class=\"line\">          &lt;/el-carousel-item&gt;</span><br><span class=\"line\">        &lt;/el-carousel&gt;</span><br><span class=\"line\">        &lt;div v-else class=&quot;no-data&quot;&gt;暂无数据&lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;BannerPreview&apos;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    list: &#123;</span><br><span class=\"line\">      type: Array,</span><br><span class=\"line\">      default: null</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showUserTypes: &#123;</span><br><span class=\"line\">      type: Array,</span><br><span class=\"line\">      default: null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    previewList(type) &#123;</span><br><span class=\"line\">      const newArr = this.list || []</span><br><span class=\"line\">      return newArr.length &gt; 0 &amp;&amp; newArr.filter((item) =&gt; &#123;</span><br><span class=\"line\">        const &#123; userType &#125; = item || &apos;&apos;</span><br><span class=\"line\">        return item.status === &apos;2&apos; &amp;&amp; (userType.includes(type) || userType.includes(&apos;0&apos;))</span><br><span class=\"line\">      &#125;).slice(0, 5)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.md-wrap&#123;</span><br><span class=\"line\">  background-color:#fff;</span><br><span class=\"line\">  .md-title&#123;</span><br><span class=\"line\">    line-height: 50px;</span><br><span class=\"line\">    border-bottom:1px #eee solid;</span><br><span class=\"line\">    padding-left: 16px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .md-text&#123;</span><br><span class=\"line\">    padding: 16px;</span><br><span class=\"line\">    .no-data&#123;</span><br><span class=\"line\">      font-size: 14px;</span><br><span class=\"line\">      color: #999;</span><br><span class=\"line\">      padding: 10px 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .demonstration&#123;</span><br><span class=\"line\">      display: inline-block;</span><br><span class=\"line\">      padding-bottom: 10px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .block&#123;</span><br><span class=\"line\">      margin-bottom: 20px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .list-img&#123;</span><br><span class=\"line\">      height: 100%;</span><br><span class=\"line\">      width: 100%;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .el-carousel__item h3 &#123;</span><br><span class=\"line\">    color: #475669;</span><br><span class=\"line\">    font-size: 14px;</span><br><span class=\"line\">    opacity: 0.75;</span><br><span class=\"line\">    line-height: 100px;</span><br><span class=\"line\">    margin: 0;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .el-carousel__item:nth-child(2n) &#123;</span><br><span class=\"line\">     background-color: #99a9bf;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .el-carousel__item:nth-child(2n+1) &#123;</span><br><span class=\"line\">     background-color: #d3dce6;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p>\n<p>比如 created 钩子可以用来在一个实例被创建之后执行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created: function () &#123;</span><br><span class=\"line\">    // `this` 指向 vm 实例</span><br><span class=\"line\">    console.log(&apos;a is: &apos; + this.a)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// =&gt; &quot;a is: 1&quot;</span><br></pre></td></tr></table></figure></p>\n<p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。</p>\n<p><em><font color=\"red\">注意：</font>不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</em></p>\n<h4 id=\"生命周期图示\"><a href=\"#生命周期图示\" class=\"headerlink\" title=\"生命周期图示\"></a>生命周期图示</h4><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。<br><img src=\"https://img.fengjr.com/image/2019/10/22/b3251a15e5779fcfec925b78a149f5c8.png\" alt></p>\n<h4 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h4><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p>\n<p>所以，对于任何复杂逻辑，你都应当使用计算属性。</p>\n<p>基础例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &apos;Hello&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    // 计算属性的 getter</span><br><span class=\"line\">    reversedMessage: function () &#123;</span><br><span class=\"line\">      // `this` 指向 vm 实例</span><br><span class=\"line\">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Original message: “Hello”<br>Computed reversed message: “olleH”</p>\n<h4 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h4><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 在组件中</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  reversedMessage: function () &#123;</span><br><span class=\"line\">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>\n<p>这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  now: function () &#123;</span><br><span class=\"line\">    return Date.now()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p>\n<h4 id=\"计算属性-vs-侦听属性\"><a href=\"#计算属性-vs-侦听属性\" class=\"headerlink\" title=\"计算属性 vs 侦听属性\"></a>计算属性 vs 侦听属性</h4><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Foo&apos;,</span><br><span class=\"line\">    lastName: &apos;Bar&apos;,</span><br><span class=\"line\">    fullName: &apos;Foo Bar&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    firstName: function (val) &#123;</span><br><span class=\"line\">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    lastName: function (val) &#123;</span><br><span class=\"line\">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面代码是命令式且重复的。将它与计算属性的版本进行比较：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Foo&apos;,</span><br><span class=\"line\">    lastName: &apos;Bar&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    fullName: function () &#123;</span><br><span class=\"line\">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>好得多了，不是吗？</p>\n<h4 id=\"侦听器\"><a href=\"#侦听器\" class=\"headerlink\" title=\"侦听器\"></a>侦听器</h4><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>\n<p>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;watch-example&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;</span><br><span class=\"line\">    Ask a yes/no question:</span><br><span class=\"line\">    &lt;input v-model=&quot;question&quot;&gt;</span><br><span class=\"line\">  &lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var watchExampleVM = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#watch-example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    question: &apos;&apos;,</span><br><span class=\"line\">    answer: &apos;I cannot give you an answer until you ask a question!&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    // 如果 `question` 发生改变，这个函数就会运行</span><br><span class=\"line\">    question: function (newQuestion, oldQuestion) &#123;</span><br><span class=\"line\">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class=\"line\">      this.debouncedGetAnswer()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created: function () &#123;</span><br><span class=\"line\">    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span><br><span class=\"line\">    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span><br><span class=\"line\">    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span><br><span class=\"line\">    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span><br><span class=\"line\">    // 请参考：https://lodash.com/docs#debounce</span><br><span class=\"line\">    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getAnswer: function () &#123;</span><br><span class=\"line\">      if (this.question.indexOf(&apos;?&apos;) === -1) &#123;</span><br><span class=\"line\">        this.answer = &apos;Questions usually contain a question mark. ;-)&apos;</span><br><span class=\"line\">        return</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.answer = &apos;Thinking...&apos;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      axios.get(&apos;https://yesno.wtf/api&apos;)</span><br><span class=\"line\">        .then(function (response) &#123;</span><br><span class=\"line\">          vm.answer = _.capitalize(response.data.answer)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(function (error) &#123;</span><br><span class=\"line\">          vm.answer = &apos;Error! Could not reach the API. &apos; + error</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<h1 id=\"二、Vue与React两个框架的区别和优势对比\"><a href=\"#二、Vue与React两个框架的区别和优势对比\" class=\"headerlink\" title=\"二、Vue与React两个框架的区别和优势对比\"></a>二、Vue与React两个框架的区别和优势对比</h1><p>Vue和React两个JavaScript框架都是当下比较受欢迎的，他们两者之间的区别有哪些，各自的优缺点是什么？</p>\n<h4 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h4><p>除非你一直不关注前端的发展，不然你肯定听说过由Facebook创建的JavaScript UI框架——React。它支撑着包括Instagram在内的大多数Facebook网站。React与当时流行的jQuery,Backbone.js和Angular 1等框架不同，它的诞生改变了JavaScript的世界。其中最大的变化是React推广了Virtual DOM并创造了新的语法——JSX，JSX允许开发者在JavaScript中书写HTML（译者注：即HTML in JavaScript）。</p>\n<p>Vue致力解决的问题与React一致，但却提供了另外一套解决方案。Vue使用模板系统而不是JSX，使其对现有应用的升级更加容易。这是因为模板用的就是普通的HTML，通过Vue来整合现有的系统是比较容易的，不需要整体重构。同时Vue声称它更容易学习，我们最近接触Vue，就能证明所言非虚。关于Vue还需要说的是，Vue主要是由一位开发者进行维护的，而不像React一样由如Facebook这类大公司维护。</p>\n<h4 id=\"相似之处\"><a href=\"#相似之处\" class=\"headerlink\" title=\"相似之处\"></a>相似之处</h4><p>React与Vue存在很多相似之处：</p>\n<ul>\n<li>使用 Virtual DOM</li>\n<li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li>\n<li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li>\n</ul>\n<h4 id=\"Virtual-DOM\"><a href=\"#Virtual-DOM\" class=\"headerlink\" title=\"Virtual DOM\"></a>Virtual DOM</h4><p>啊哈，人们经常说Virtual DOM是什么呢？</p>\n<p>Vue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了一种叫’Virtual DOM’的东西。所谓的Virtual DOM基本上说就是它名字的意思：虚拟DOM，DOM树的虚拟表现。它的诞生是基于这么一个概念：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多。</p>\n<p>Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。</p>\n<p>例子如下，我们可以看看下面这个列表在HTML中的代码是如何写的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul class=&quot;list&quot;&gt;</span><br><span class=\"line\">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>\n<p>而在JavaScript中，我们可以用对象简单地创造一个针对上面例子的映射：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    type: &apos;ul&apos;, </span><br><span class=\"line\">    props: &#123;&apos;class&apos;: &apos;list&apos;&#125;, </span><br><span class=\"line\">    children: [</span><br><span class=\"line\">        &#123; type: &apos;li&apos;, props: &#123;&#125;, children: [&apos;item 1&apos;] &#125;,</span><br><span class=\"line\">        &#123; type: &apos;li&apos;, props: &#123;&#125;, children: [&apos;item 2&apos;] &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>真实的Virtual DOM会比上面的例子更复杂，但它本质上是一个嵌套着数组的原生对象。</p>\n<p>当新一项被加进去这个JavaScript对象时，一个函数会计算新旧Virtual DOM之间的差异并反应在真实的DOM上。计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。</p>\n<p>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p>\n<p>而对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</p>\n<p>在react开发中，经常会遇到组件重复渲染的问题，父组件一个state的变化，就会导致以该组件的所有子组件都重写render，尽管绝大多数子组件的props没有变化</p>\n<p>render什么时候会触发<br>首先，先上一张react生命周期图：<br><img src=\"https://img.fengjr.com/file/2019/10/30/c7e8067e7fd11a07a1ecc0f643a4b90f.jpeg\" alt><br>这张图将react的生命周期分为了三个阶段：生成期、存在期、销毁期，这样在create、props、state、unMount状态变化时我们可以清楚的看到reacte触发了哪些生命周期钩子以及什么时候会render。</p>\n<p>如何避免这些不必要的render:</p>\n<ul>\n<li>shouldComponentUpdate()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure>\n<p>使用shouldComponentUpdate()以让React知道当前状态或属性的改变是否不影响组件的输出，默认返回ture，返回false时不会重写render，而且该方法并不会在初始化渲染或当使用forceUpdate()时被调用，我们要做的只是这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">  return nextState.someData !== this.state.someData</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是，state里的数据这么多，还有对象，还有复杂类型数据，react的理念就是拆分拆分再拆分，这么多子组件，我要每个组件都去自己一个一个对比吗？？不存在的，这么麻烦，要知道我们的终极目标是不劳而获-_-</p>\n<ul>\n<li>React.PureComponent</li>\n</ul>\n<p>React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）</p>\n<p>关注点：无论组件是否是 PureComponent，如果定义了 shouldComponentUpdate()，那么会调用它并以它的执行结果来判断是否 update。在组件未定义 shouldComponentUpdate() 的情况下，会判断该组件是否是 PureComponent，如果是的话，会对新旧 props、state 进行 shallowEqual 比较，一旦新旧不一致，会触发 update。</p>\n<p>小结：如果你的应用中，交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果你更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。</p>\n<h4 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h4><p>React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。关于组件化的例子可以在这篇文章的中间部分被找到:</p>\n<p>你可以认为组件就是用户界面中的一小块。如果让我来设计Facebook的UI界面，那么聊天窗口会是一个组件，评论会是另一个组件，不断更新的好友列表也会作为一个组件。</p>\n<p>在Vue中，如果你遵守一定的规则，你可以使用单文件组件.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">&lt;li class=&quot;pasta-dish list-unstyled&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;row&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;col-md-3&quot;&gt;</span><br><span class=\"line\">            &lt;img :src=&quot;this.item.image&quot; :alt=&quot;this.item.name&quot; /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;col-md-9 text-left&quot;&gt;</span><br><span class=\"line\">            &lt;h3&gt;&#123;&#123;this.item.name&#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">            &lt;p&gt;</span><br><span class=\"line\">                &#123;&#123;this.item.desc&#125;&#125;</span><br><span class=\"line\">            &lt;/p&gt;</span><br><span class=\"line\">            &lt;button v-on:click=&quot;addToOrderNew&quot; class=&quot;btn btn-primary&quot;&gt;Add to order&lt;/button&gt; &lt;mark&gt;&#123;&#123;this.orders&#125;&#125;&lt;/mark&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/li&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    name: &apos;pasta-item&apos;,</span><br><span class=\"line\">    props: [&apos;item&apos;],</span><br><span class=\"line\">    data:  function()&#123;</span><br><span class=\"line\">        return&#123;</span><br><span class=\"line\">            orders: 0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        addToOrderNew: function(y)&#123;</span><br><span class=\"line\">            this.orders += 1;</span><br><span class=\"line\">            this.$emit(&apos;order&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style src=&quot;./Pasta.css&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>正如上面你看到的例子中，HTML, JavaScript和CSS都写在一个文件之中。你不再需要在.vue组件文件中引入CSS，虽然这也是可以的。</p>\n<p>React也是非常相似的，JavaScript与JSX被写入同一个组件文件中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">class PastaItem extends React.Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        const &#123; details, index &#125; = this.props;</span><br><span class=\"line\"></span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;li className=&quot;pasta-dish list-unstyled&quot;&gt;</span><br><span class=\"line\">                &lt;div className=&quot;row&quot;&gt;</span><br><span class=\"line\">                    &lt;div className=&quot;col-md-3&quot;&gt;</span><br><span class=\"line\">                        &lt;img src=&#123;details.image&#125; alt=&#123;details.name&#125; /&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                    &lt;div className=&quot;col-md-9 text-left&quot;&gt;</span><br><span class=\"line\">                        &lt;h3&gt;&#123;details.name&#125;&lt;/h3&gt;</span><br><span class=\"line\">                        &lt;p&gt;</span><br><span class=\"line\">                            &#123;details.desc&#125;</span><br><span class=\"line\">                        &lt;/p&gt;</span><br><span class=\"line\">                        &lt;button onClick=&#123;() =&gt; this.props.addToOrder(index)&#125; className=&quot;btn btn-primary&quot;&gt;Add to order&lt;/button&gt; &lt;mark&gt;&#123;this.props.orders || 0&#125;&lt;/mark&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default PastaItem;</span><br></pre></td></tr></table></figure></p>\n<p>Props<br>在上面两个例子中，我们可以看到React和Vue都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.keys(this.state.pastadishes).map(key =&gt;</span><br><span class=\"line\">    &lt;PastaItem index=&#123;key&#125; key=&#123;key&#125; details=&#123;this.state.pastadishes[key]&#125; addToOrder=&#123;this.addToOrder&#125; orders=&#123;this.state.orders[key]&#125; /&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>上面的JSX库组中，index, key, details, orders 与 addToOrder都是props，数据会被下传到子组件PastaItem中去。</p>\n<p>在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”。</p>\n<p>而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pasta-item v-for=&quot;(item, key) in samplePasta&quot; :item=&quot;item&quot; :key=&quot;key&quot; @order=&quot;handleOrder(key)&quot;&gt;&lt;/pasta-item&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这是模板的实现，但这代码完全能工作，然而在React中展现相同数据会更麻烦一点。</p>\n<h4 id=\"构建工具\"><a href=\"#构建工具\" class=\"headerlink\" title=\"构建工具\"></a>构建工具</h4><p>React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。</p>\n<p>由于CRA有很多选项，使用起来会稍微麻烦一点。这个工具会逼迫你使用Webpack和Babel。而vue-cli则有模板列表可选，能按需创造不同模板，使用起来更灵活一点。</p>\n<p>事实上说，两个工具都非常好用，都能为你建立一个好环境。而且如果可以不配置Webpack的话，我认为这是天大的好事。</p>\n<h4 id=\"Chrome-开发工具\"><a href=\"#Chrome-开发工具\" class=\"headerlink\" title=\"Chrome 开发工具\"></a>Chrome 开发工具</h4><p>React和Vue都有很好的Chrome扩展工具去帮助你找出bug。它们会检查你的应用，让你看到Vue或者React中的变化。你也可以看到应用中的状态，并实时看到更新。</p>\n<p>React的开发工具: <a href=\"https://cdn.deliciousbrains.com/content/uploads/2017/06/15151112/react-devtools.mp4\" target=\"_blank\" rel=\"noopener\">https://cdn.deliciousbrains.com/content/uploads/2017/06/15151112/react-devtools.mp4</a></p>\n<p>Vue的开发工具: <a href=\"https://cdn.deliciousbrains.com/content/uploads/2017/06/15151111/vue-devtools.mp4\" target=\"_blank\" rel=\"noopener\">https://cdn.deliciousbrains.com/content/uploads/2017/06/15151111/vue-devtools.mp4</a></p>\n<h4 id=\"配套框架\"><a href=\"#配套框架\" class=\"headerlink\" title=\"配套框架\"></a>配套框架</h4><p>Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。</p>\n<p>而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。</p>\n<h4 id=\"主要区别\"><a href=\"#主要区别\" class=\"headerlink\" title=\"主要区别\"></a>主要区别</h4><p>Vue与react有很多的相似之处，但他们也有完全不一致的地方。</p>\n<p>模板 vs JSX：</p>\n<p>在 React 中，一切都是 JavaScript。<br>在 React 中，所有的组件的渲染功能都依靠 JSX。<br>JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; </span><br><span class=\"line\">  SearchContainer,</span><br><span class=\"line\">  SearchContent</span><br><span class=\"line\">&#125; from &apos;./styledComponent.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">import search from &apos;images/search.png&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class Search extends Component &#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;SearchContainer&gt;</span><br><span class=\"line\">        &lt;SearchContent &#123; ...this.props &#125;&gt;</span><br><span class=\"line\">          &lt;img src=&#123;search&#125; alt=&quot;&quot;/&gt;</span><br><span class=\"line\">          &lt;span&gt;想吃什么搜这里，川菜&lt;/span&gt;</span><br><span class=\"line\">        &lt;/SearchContent&gt;</span><br><span class=\"line\">      &lt;/SearchContainer&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Search</span><br></pre></td></tr></table></figure></p>\n<p>vue是把html，css，js组合到一起，用各自的处理方式<br>Vue 设置样式的默认方法是单文件组件里类似 style 的标签。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;m-movie&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;white-bg topbar-bg&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;city-entry&quot;&gt;</span><br><span class=\"line\">        &lt;router-link tag=&quot;span&quot; to=&quot;/cities&quot; class=&quot;city-name&quot;&gt;北京&lt;/router-link&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      </span><br><span class=\"line\">      &lt;div class=&quot;switch-hot&quot;&gt;</span><br><span class=\"line\">        &lt;router-link tag=&quot;div&quot; to=&quot;/home/movies/intheater&quot; active-class=&quot;active&quot; class=&quot;hot-item&quot;&gt;正在热映&lt;/router-link&gt;</span><br><span class=\"line\">        &lt;router-link tag=&quot;div&quot; to=&quot;/home/movies/coming&quot; active-class=&quot;active&quot; class=&quot;hot-item&quot;&gt;即将上映&lt;/router-link&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;transition :name=&quot;transitionName&quot;&gt;</span><br><span class=\"line\">      &lt;router-view class=&quot;movies-outlet&quot;&gt;&lt;/router-view&gt;</span><br><span class=\"line\">    &lt;/transition&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      transitionName: &apos;&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    $route (to, from) &#123;</span><br><span class=\"line\">      if ( to.meta &gt; from.meta ) &#123;</span><br><span class=\"line\">        this.transitionName = &apos;slide-left&apos;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        this.transitionName = &apos;slide-right&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class=\"line\">@import &apos;~styles/border.styl&apos;</span><br><span class=\"line\">@import &apos;~styles/variables.styl&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">.slide-right-enter-active,</span><br><span class=\"line\">.slide-right-leave-active,</span><br><span class=\"line\">.slide-left-enter-active,</span><br><span class=\"line\">.slide-left-leave-active &#123;</span><br><span class=\"line\">  transition: all 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.slide-right-enter &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translate3d(-100%, 0, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.slide-right-leave-to &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translate3d(100%, 0, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.slide-left-enter &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translate3d(100%, 0, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.slide-left-leave-to &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translate3d(-100%, 0, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>总结一下，我们发现</p>\n<p>Vue的优势包括：</p>\n<ul>\n<li>模板和渲染函数的弹性选择</li>\n<li>简单的语法及项目创建</li>\n<li>更快的渲染速度和更小的体积</li>\n</ul>\n<p>React的优势包括：</p>\n<ul>\n<li>更适用于大型应用和更好的可测试性</li>\n<li>同时适用于Web端和原生App</li>\n<li>更大的生态圈带来的更多支持和工具</li>\n</ul>\n<p>而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：</p>\n<ul>\n<li>利用虚拟DOM实现快速渲染</li>\n<li>轻量级</li>\n<li>响应式和组件化</li>\n<li>服务器端渲染</li>\n<li>易于集成路由工具，打包工具以及状态管理工具</li>\n<li>优秀的支持和社区</li>\n</ul>\n<h1 id=\"三、vue-element-amdin介绍\"><a href=\"#三、vue-element-amdin介绍\" class=\"headerlink\" title=\"三、vue-element-amdin介绍\"></a>三、vue-element-amdin介绍</h1><p>vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui实现。它使用了最新的前端技术栈，内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。</p>\n<h4 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 登录 / 注销</span><br><span class=\"line\"></span><br><span class=\"line\">- 权限验证</span><br><span class=\"line\">  - 页面权限</span><br><span class=\"line\">  - 指令权限</span><br><span class=\"line\">  - 权限配置</span><br><span class=\"line\">  - 二步登录</span><br><span class=\"line\"></span><br><span class=\"line\">- 多环境发布</span><br><span class=\"line\">  - dev sit stage prod</span><br><span class=\"line\"></span><br><span class=\"line\">- 全局功能</span><br><span class=\"line\">  - 国际化多语言</span><br><span class=\"line\">  - 多种动态换肤</span><br><span class=\"line\">  - 动态侧边栏（支持多级路由嵌套）</span><br><span class=\"line\">  - 动态面包屑</span><br><span class=\"line\">  - 快捷导航(标签页)</span><br><span class=\"line\">  - Svg Sprite 图标</span><br><span class=\"line\">  - 本地/后端 mock 数据</span><br><span class=\"line\">  - Screenfull全屏</span><br><span class=\"line\">  - 自适应收缩侧边栏</span><br><span class=\"line\"></span><br><span class=\"line\">- 编辑器</span><br><span class=\"line\">  - 富文本</span><br><span class=\"line\">  - Markdown</span><br><span class=\"line\">  - JSON 等多格式</span><br><span class=\"line\"></span><br><span class=\"line\">- Excel</span><br><span class=\"line\">  - 导出excel</span><br><span class=\"line\">  - 导入excel</span><br><span class=\"line\">  - 前端可视化excel</span><br><span class=\"line\">  - 导出zip</span><br><span class=\"line\"></span><br><span class=\"line\">- 表格</span><br><span class=\"line\">  - 动态表格</span><br><span class=\"line\">  - 拖拽表格</span><br><span class=\"line\">  - 内联编辑</span><br><span class=\"line\"></span><br><span class=\"line\">- 错误页面</span><br><span class=\"line\">  - 401</span><br><span class=\"line\">  - 404</span><br><span class=\"line\"></span><br><span class=\"line\">- 組件</span><br><span class=\"line\">  - 头像上传</span><br><span class=\"line\">  - 返回顶部</span><br><span class=\"line\">  - 拖拽Dialog</span><br><span class=\"line\">  - 拖拽Select</span><br><span class=\"line\">  - 拖拽看板</span><br><span class=\"line\">  - 列表拖拽</span><br><span class=\"line\">  - SplitPane</span><br><span class=\"line\">  - Dropzone</span><br><span class=\"line\">  - Sticky</span><br><span class=\"line\">  - CountTo</span><br><span class=\"line\"></span><br><span class=\"line\">- 综合实例</span><br><span class=\"line\">- 错误日志</span><br><span class=\"line\">- Dashboard</span><br><span class=\"line\">- 引导页</span><br><span class=\"line\">- ECharts 图表</span><br><span class=\"line\">- Clipboard(剪贴复制)</span><br><span class=\"line\">- Markdown2html</span><br></pre></td></tr></table></figure>\n<p>本项目不支持低版本浏览器(如 ie)，有需求请自行添加 polyfill <a href=\"https://github.com/PanJiaChen/vue-element-admin/wiki#babel-polyfill\" target=\"_blank\" rel=\"noopener\">详情</a></p>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── build                      # 构建相关</span><br><span class=\"line\">├── mock                       # 项目mock 模拟数据</span><br><span class=\"line\">├── plop-templates             # 基本模板</span><br><span class=\"line\">├── public                     # 静态资源</span><br><span class=\"line\">│   │── favicon.ico            # favicon图标</span><br><span class=\"line\">│   └── index.html             # html模板</span><br><span class=\"line\">├── src                        # 源代码</span><br><span class=\"line\">│   ├── api                    # 所有请求</span><br><span class=\"line\">│   ├── assets                 # 主题 字体等静态资源</span><br><span class=\"line\">│   ├── components             # 全局公用组件</span><br><span class=\"line\">│   ├── directive              # 全局指令</span><br><span class=\"line\">│   ├── filters                # 全局 filter</span><br><span class=\"line\">│   ├── icons                  # 项目所有 svg icons</span><br><span class=\"line\">│   ├── lang                   # 国际化 language</span><br><span class=\"line\">│   ├── layout                 # 全局 layout</span><br><span class=\"line\">│   ├── router                 # 路由</span><br><span class=\"line\">│   ├── store                  # 全局 store管理</span><br><span class=\"line\">│   ├── styles                 # 全局样式</span><br><span class=\"line\">│   ├── utils                  # 全局公用方法</span><br><span class=\"line\">│   ├── vendor                 # 公用vendor</span><br><span class=\"line\">│   ├── views                  # views 所有页面</span><br><span class=\"line\">│   ├── App.vue                # 入口页面</span><br><span class=\"line\">│   ├── main.js                # 入口文件 加载组件 初始化等</span><br><span class=\"line\">│   └── permission.js          # 权限管理</span><br><span class=\"line\">├── tests                      # 测试</span><br><span class=\"line\">├── .env.xxx                   # 环境变量配置</span><br><span class=\"line\">├── .eslintrc.js               # eslint 配置项</span><br><span class=\"line\">├── .babelrc                   # babel-loader 配置</span><br><span class=\"line\">├── .travis.yml                # 自动化CI配置</span><br><span class=\"line\">├── vue.config.js              # vue-cli 配置</span><br><span class=\"line\">├── postcss.config.js          # postcss 配置</span><br><span class=\"line\">└── package.json               # package.json</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目</span><br><span class=\"line\">git clone https://github.com/PanJiaChen/vue-element-admin.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 进入项目目录</span><br><span class=\"line\">cd vue-element-admin</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装依赖</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"># 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题</span><br><span class=\"line\">npm install --registry=https://registry.npm.taobao.org</span><br><span class=\"line\"></span><br><span class=\"line\"># 本地开发 启动项目</span><br><span class=\"line\">npm run dev</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://panjiachen.github.io/vue-element-admin/\" target=\"_blank\" rel=\"noopener\">预览地址</a></p>\n<h1 id=\"四、fund-cms前端项目实例\"><a href=\"#四、fund-cms前端项目实例\" class=\"headerlink\" title=\"四、fund-cms前端项目实例\"></a>四、fund-cms前端项目实例</h1><p>基金cms管理系统是基于vue-element-amdin框架并通过upm单点登录方式实现的后台管理系统。数据库用的是mongodb实现并输出api接口。</p>\n<h4 id=\"单点登录\"><a href=\"#单点登录\" class=\"headerlink\" title=\"单点登录\"></a>单点登录</h4><p>进入页面判断cookie是否存在，不存在则跳到upm系统进行登录，登录成功自动跳回并带cookie参数。然后取到cookie值并手动种上，此时可以访问api接口。访问接口时如果cookie过期返回错误标识，前端判断自动调到upm登录系统重新登录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取upm单点登录 cookie</span><br><span class=\"line\">const &#123; ticket &#125; = param2Obj(window.location.search) || &apos;&apos;</span><br><span class=\"line\">if (ticket) &#123;</span><br><span class=\"line\">  setToken(ticket)</span><br><span class=\"line\">  const newUrl = location.href.replace(location.search, &apos;&apos;)</span><br><span class=\"line\">  window.location.href = newUrl</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断单点登录 cookie</span><br><span class=\"line\">if (!getToken()) &#123;</span><br><span class=\"line\">  logoutRedirect()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 退出并跳转</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function logoutRedirect() &#123;</span><br><span class=\"line\">  const toUrl = process.env.VUE_APP_BASE_TOLOGIN + &apos;/auth?appkey=fund-cms&amp;return=&apos; + window.location.href</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;development&apos;) &#123;</span><br><span class=\"line\">    window.location.href = toUrl</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><p>静态路由：登录进入系统就可以看到的菜单<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * constantRoutes</span><br><span class=\"line\"> * a base page that does not have permission requirements</span><br><span class=\"line\"> * all roles can be accessed</span><br><span class=\"line\"> */</span><br><span class=\"line\">export const constantRoutes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &apos;/404&apos;,</span><br><span class=\"line\">    component: () =&gt; import(&apos;@/views/error-page/404&apos;),</span><br><span class=\"line\">    hidden: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &apos;&apos;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    redirect: &apos;dashboard&apos;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;dashboard&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/dashboard/index&apos;),</span><br><span class=\"line\">        name: &apos;Dashboard&apos;,</span><br><span class=\"line\">        meta: &#123; title: &apos;dashboard&apos;, icon: &apos;dashboard&apos;, affix: true &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &apos;/selection&apos;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    redirect: &apos;/selection/module&apos;,</span><br><span class=\"line\">    alwaysShow: true, // will always show the root menu</span><br><span class=\"line\">    name: &apos;Selection&apos;,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &apos;精选&apos;,</span><br><span class=\"line\">      icon: &apos;shopping&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;module&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/selection/module&apos;),</span><br><span class=\"line\">        name: &apos;ModuleSelection&apos;,</span><br><span class=\"line\">        hidden: true,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;模块管理&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        path: &apos;search&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/selection/search&apos;),</span><br><span class=\"line\">        name: &apos;SearchSelection&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;搜索&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        path: &apos;fengj&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/selection/fengj&apos;),</span><br><span class=\"line\">        name: &apos;FengjSelection&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;凤金精选&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>动态路由：需要用户权限匹配才能显示<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const asyncRoutes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &apos;/permission&apos;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    redirect: &apos;/permission/page&apos;,</span><br><span class=\"line\">    alwaysShow: true, // will always show the root menu</span><br><span class=\"line\">    name: &apos;Permission&apos;,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &apos;permission&apos;,</span><br><span class=\"line\">      icon: &apos;lock&apos;,</span><br><span class=\"line\">      roles: [&apos;admin&apos;, &apos;editor&apos;] // you can set roles in root nav</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;page&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/permission/page&apos;),</span><br><span class=\"line\">        name: &apos;PagePermission&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;pagePermission&apos;,</span><br><span class=\"line\">          roles: [&apos;admin&apos;] // or you can only set roles in sub nav</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;directive&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/permission/directive&apos;),</span><br><span class=\"line\">        name: &apos;DirectivePermission&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;directivePermission&apos;</span><br><span class=\"line\">          // if do not set roles, means: this page does not require permission</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &apos;role&apos;,</span><br><span class=\"line\">        component: () =&gt; import(&apos;@/views/permission/role&apos;),</span><br><span class=\"line\">        name: &apos;RolePermission&apos;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">          title: &apos;rolePermission&apos;,</span><br><span class=\"line\">          roles: [&apos;admin&apos;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h4><p>接口api通过axios封装，支持环境变量配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &apos;axios&apos;</span><br><span class=\"line\">import &#123; Message &#125; from &apos;element-ui&apos;</span><br><span class=\"line\">// import store from &apos;@/store&apos;</span><br><span class=\"line\">import &#123; removeToken &#125; from &apos;@/utils/auth&apos;</span><br><span class=\"line\">import &#123; logoutRedirect &#125; from &apos;@/utils&apos;</span><br><span class=\"line\">// create an axios instance</span><br><span class=\"line\">const service = axios.create(&#123;</span><br><span class=\"line\">  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url</span><br><span class=\"line\">  // withCredentials: true, // send cookies when cross-domain requests</span><br><span class=\"line\">  timeout: 5000 // request timeout</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>配置：selection.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import request from &apos;@/utils/request&apos;</span><br><span class=\"line\">//get api</span><br><span class=\"line\">export function fengjList(params) &#123;</span><br><span class=\"line\">  return request(&#123;</span><br><span class=\"line\">    url: &apos;/fengj-management/fengjlist&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//post api</span><br><span class=\"line\">export function updateOpenStatus(data) &#123;</span><br><span class=\"line\">  return request(&#123;</span><br><span class=\"line\">    url: &apos;/module-management/openmodule/update&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用：fengj.vue<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; fengjList &#125; from &apos;@/api/selection&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;FengjSelection&apos;,</span><br><span class=\"line\">  components: &#123; FengjPreview, FengjTable &#125;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      list: null,</span><br><span class=\"line\">      userTypeOptions: [],</span><br><span class=\"line\">      showUserTypes: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created() &#123;</span><br><span class=\"line\">    this.getList()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getList() &#123;</span><br><span class=\"line\">      fengjList().then(response =&gt; &#123;</span><br><span class=\"line\">        const &#123; items &#125; = response.data || []</span><br><span class=\"line\">        this.list = items.sort((a, b) =&gt; b.status - a.status)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"开发遇到问题\"><a href=\"#开发遇到问题\" class=\"headerlink\" title=\"开发遇到问题\"></a>开发遇到问题</h4><p>1.状态排序<br>数据库里没有status字段，前端拿到数据后再重新排一下序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  getList() &#123;</span><br><span class=\"line\">    fengjList().then(response =&gt; &#123;</span><br><span class=\"line\">      const &#123; items &#125; = response.data || []</span><br><span class=\"line\">      this.list = items.sort((a, b) =&gt; b.status - a.status)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.表单添加动态校验<br>基金产品输入基金code读api异步获取联动。<br>缺点是调两次api。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; searchFundInfo &#125; from &apos;@/api/common&apos;</span><br><span class=\"line\">data() &#123;</span><br><span class=\"line\">  const checkCode = async(rule, value, callback) =&gt; &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      await searchFundInfo(&#123; key: value &#125;)</span><br><span class=\"line\">      callback()</span><br><span class=\"line\">    &#125; catch (err) &#123;</span><br><span class=\"line\">      return callback(new Error(err.message))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    rules: &#123;</span><br><span class=\"line\">      code: [&#123; required: true, message: &apos;基金代码不能为空&apos;, trigger: &apos;blur&apos; &#125;, &#123; validator: checkCode, trigger: &apos;blur&apos; &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.列表组件格式化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-table-column label=&quot;用户类型&quot; prop=&quot;userType&quot; align=&quot;center&quot; :formatter=&quot;formatter&quot; /&gt;</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  formatter(row, column) &#123;</span><br><span class=\"line\">    const &#123; userType &#125; = row</span><br><span class=\"line\">    const nameArr = []</span><br><span class=\"line\">    this.userTypeOptions.forEach((item) =&gt; &#123;</span><br><span class=\"line\">      if (userType.includes(item.type)) &#123;</span><br><span class=\"line\">        nameArr.push(item.name)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return nameArr.join()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.子组件调用父组件方法<br>表单更新后，预览区实现自动更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$emit(&apos;updateList&apos;)</span><br><span class=\"line\">//父组件</span><br><span class=\"line\">&lt;fengj-table :list=&quot;list&quot; :user-type-options=&quot;userTypeOptions&quot; @updateList=&quot;getList&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>5.阻止冒泡方法@click.stop<br>咨询列表点击显示预览区和字典联动，操作按钮需要做阻止冒泡处理。（阻止默认行为：@click.prevent）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-button type=&quot;success&quot; size=&quot;mini&quot; @click.stop=&quot;handleUpdate(row)&quot;&gt;</span><br><span class=\"line\">  编辑</span><br><span class=\"line\">&lt;/el-button&gt;</span><br></pre></td></tr></table></figure></p>\n<p>6.文本编辑器缓存问题<br>列表点编辑时候，文本编辑器缓存清不掉，显示上一次的内容,因为用的第三方插件。<br>解决办法添加更新方法，传时间戳，组件内监听更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Tinymce ref=&quot;editor&quot; v-model=&quot;temp.content&quot; :update-con=&quot;updateCon&quot; :height=&quot;200&quot; /&gt;</span><br><span class=\"line\">//点编辑弹层显示时候</span><br><span class=\"line\">handleUpdate(row) &#123;</span><br><span class=\"line\">  this.temp = Object.assign(&#123;&#125;, row) // copy obj</span><br><span class=\"line\">  this.temp.startTime = new Date(this.temp.startTime)</span><br><span class=\"line\">  this.dialogStatus = &apos;update&apos;</span><br><span class=\"line\">  this.dialogFormVisible = true</span><br><span class=\"line\">  this.$nextTick(() =&gt; &#123;</span><br><span class=\"line\">    this.$refs[&apos;dataForm&apos;].clearValidate()</span><br><span class=\"line\">    this.updateCon = new Date().getTime()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tinymce.vue<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">    value(val) &#123;</span><br><span class=\"line\">      if (!this.hasChange &amp;&amp; this.hasInit) &#123;</span><br><span class=\"line\">        this.$nextTick(() =&gt;</span><br><span class=\"line\">          window.tinymce.get(this.tinymceId).setContent(this.val || &apos;&apos;))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    language() &#123;</span><br><span class=\"line\">      this.destroyTinymce()</span><br><span class=\"line\">      this.$nextTick(() =&gt; this.initTinymce())</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    updateCon(val) &#123;</span><br><span class=\"line\">      this.$nextTick(() =&gt;</span><br><span class=\"line\">        window.tinymce &amp;&amp; window.tinymce.get(this.tinymceId).setContent(this.newVal || &apos;&apos;))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>7.文本编辑器扩展上传图片功能<br>Tinymce.vue<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div :class=&quot;&#123;fullscreen:fullscreen&#125;&quot; class=&quot;tinymce-container&quot; :style=&quot;&#123;width:containerWidth&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;textarea :id=&quot;tinymceId&quot; class=&quot;tinymce-textarea&quot; /&gt;</span><br><span class=\"line\">    &lt;div class=&quot;editor-custom-btn-container&quot;&gt;</span><br><span class=\"line\">      &lt;editorImage color=&quot;#1890ff&quot; class=&quot;editor-upload-btn&quot; @successCBK=&quot;imageSuccessCBK&quot; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">//上传成功图片插入文本编辑器中</span><br><span class=\"line\">imageSuccessCBK(arr) &#123;</span><br><span class=\"line\">  const _this = this</span><br><span class=\"line\">  arr.forEach(v =&gt; &#123;</span><br><span class=\"line\">    window.tinymce.get(_this.tinymceId).insertContent(`&lt;img class=&quot;wscnph&quot; src=&quot;$&#123;v.url&#125;&quot; &gt;`)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编辑上传图片组件：EditorImage.vue<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-upload</span><br><span class=\"line\">  :multiple=&quot;true&quot;</span><br><span class=\"line\">  :file-list=&quot;fileList&quot;</span><br><span class=\"line\">  :show-file-list=&quot;true&quot;</span><br><span class=\"line\">  :on-remove=&quot;handleRemove&quot;</span><br><span class=\"line\">  :on-success=&quot;handleSuccess&quot;</span><br><span class=\"line\">  :before-upload=&quot;beforeUpload&quot;</span><br><span class=\"line\">  class=&quot;editor-slide-upload&quot;</span><br><span class=\"line\">  :action=&quot;uploadUrl&quot;</span><br><span class=\"line\">  list-type=&quot;picture-card&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">  &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;</span><br><span class=\"line\">    点击上传</span><br><span class=\"line\">  &lt;/el-button&gt;</span><br><span class=\"line\">&lt;/el-upload&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  uploadUrl() &#123;</span><br><span class=\"line\">    const url = process.env.VUE_APP_BASE_API + &apos;/upload/uploadfile&apos;</span><br><span class=\"line\">    return url</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>开发总结：vue-element-admin框架搭建后台管理系统还是比较不错，架构清晰，功能全面，上手快。结合mongodb就可以前端一站式完成项目开发。</p>\n"},{"title":"react-hook介绍及应用","comments":1,"date":"2019-11-14T16:00:00.000Z","author":"jun.zhou","_content":"\n![](https://img.fengjr.com/image/2019/12/13/cbdd0825ad6d689bfc8b572387788dec.jpg)\n\n# 一、React Hooks 简介\nHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\nReact Hooks就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理state，有Hooks可以不再使用类的形式定义组件了。这时候你的认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。\n### React Hooks 编写形式对比\n先来写一个最简单的有状体组件，点我们点击按钮时，点击数量不断增加。\n\n```js\n//原始写法\nimport React, { Component } from 'react';\n\nclass Example extends Component {\n    constructor(props) {\n        super(props);\n        this.state = { count:0 }\n    }\n    render() { \n        return (\n            <div>\n                <p>You clicked {this.state.count} times</p>\n                <button onClick={this.addCount.bind(this)}>Chlick me</button>\n            </div>\n        );\n    }\n    addCount(){\n        this.setState({count:this.state.count+1})\n    }\n}\n \nexport default Example;\n```\n```js\n//hook写法\nimport React, { useState } from 'react';\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n        </div>\n    )\n}\nexport default Example;\n```\n从这两个程序的对比上可以看出Hooks本质上就是一类特殊的函数，他们可以为你的函数型组件（function component）注入一些特殊的功能。hooks的目的就是让你不再写class，让function一统江湖。\n\n# 二、useState 的介绍和多状态声明\n### useState的介绍\nuseState是react自带的一个hook函数，它的作用是用来声明状态变量。\n我们从三个方面来看useState的用法，分别是声明、读取、使用（修改）。这三个方面掌握了，你基本也就会使用useState了.\n\n先来看一下声明的方式，代码如下\n```js\nconst [ count , setCount ] = useState(0);\n```\n这种方法是ES6语法中的数组解构，这样看起来代码变的简单易懂。 如果不写成数组解构，上边的语法要写成下面的三行:\n```js\nlet _useState = userState(0)\nlet count = _useState[0]\nlet setCount = _useState[1]\n```\n\nuseState这个函数，需要传入一个参数作为状态的初始值(Initial state)，当函数执行后会返回两个值，一个是当前状态的属性，一个是修改状态的方法。且返回的是一个数组，这个数组的第0位是当前的状态值，第1位是可以改变状态值的方法函数。 所以上面的代码的意思就是声明了一个状态变量为count，并把它的初始值设为0，同时提供了一个可以改变count的状态值的方法函数。\n\n这时候你已经会声明一个状态了，接下来我们看看如何读取状态中的值。\n```html\n<p>You clicked {count} times</p>\n```\n你可以发现，我们读取是很简单的。只要使用{count}就可以，因为这时候的count就是JS里的一个变量，想在JSX中使用，值用加上{}就可以。\n\n最后看看如果改变State中的值,看下面的代码:\n```html\n<button onClick={()=>{setCount(count+1)}}>click me</button>\n```\n直接调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给React,他会重新渲染组件。React自动帮助我们记忆了组件的上一次状态值。\n### 多状态声明的注意事项\n比如现在我们要声明多个状态，有年龄（age）、性别(sex)和工作(work)。代码可以这么写.\n```js\nimport React, { useState } from 'react';\nfunction Example(){\n    const [ age , setAge ] = useState(18)\n    const [ sex , setSex ] = useState('男')\n    const [ work , setWork ] = useState('前端程序员')\n    return (\n        <div>\n            <p>JSPang 今年:{age}岁</p>\n            <p>性别:{sex}</p>\n            <p>工作是:{work}</p>\n            \n        </div>\n    )\n}\nexport default Example;\n```\n从上面的代码可以发现，在使用useState的时候只赋了初始值，并没有绑定任何的key,那React是怎么保证这三个useState找到它自己对应的state呢？\n\n**答案是：React是根据useState出现的顺序来确定的**\n\n比如我们把代码改成下面的样子：\n```js\nimport React, { useState } from 'react';\n\nlet showSex = true\nfunction Example(){\n    const [ age , setAge ] = useState(18)\n    if(showSex){\n        const [ sex , setSex ] = useState('男')\n        showSex=false\n    }\n   \n    const [ work , setWork ] = useState('前端程序员')\n    return (\n        <div>\n            <p>JSPang 今年:{age}岁</p>\n            <p>性别:{sex}</p>\n            <p>工作是:{work}</p>\n            \n        </div>\n    )\n}\nexport default Example;\n```\n这时候控制台就会直接给我们报错，错误如下：\n```\nReact Hook \"useState\" is called conditionally. React Hooks must be called in the exact same order in every component render \n```\n意思就是useState不能在if...else...这样的条件语句中进行调用，必须要按照相同的顺序进行渲染。因为这是hook的规则：\n- **只能在顶层调用hooks,不能在循环、条件或嵌套方法中调用**\n- **仅在React功能组件中使用hooks。不能在常规的JavaScript方法中调用**\n\n\n# 三、useEffect代替常用生命周期函数\n在用Class制作组件时，经常会用生命周期函数，来处理一些额外的事情（副作用：和函数业务主逻辑关联不大，特定时间或事件中执行的动作，比如Ajax请求后端数据，添加登录监听和取消登录，手动修改DOM等等）。在React Hooks中也需要这样类似的生命周期函数，比如在每次状态（State）更新时执行，它为我们准备了useEffect。\n### 用Class的方式为计数器增加生命周期函数\n为了让你更好的理解useEffect的使用，先用原始的方式把计数器的Demo增加两个生命周期函数componentDidMount和componentDidUpdate。分别在组件第一次渲染后在浏览器控制台打印出计数器结果和在每次计数器状态发生变化后打印出结果。代码如下：\n```js\nimport React, { Component } from 'react';\nclass Example extends Component {\n    constructor(props) {\n        super(props);\n        this.state = { count:0 }\n    }\n    componentDidMount(){\n        console.log(`ComponentDidMount=>You clicked ${this.state.count} times`)\n    }\n    componentDidUpdate(){\n        console.log(`componentDidUpdate=>You clicked ${this.state.count} times`)\n    }\n    render() {\n        return (\n            <div>\n                <p>You clicked {this.state.count} times</p>\n                <button onClick={this.addCount.bind(this)}>Chlick me</button>\n            </div>\n        );\n    }\n    addCount(){\n        this.setState({count:this.state.count+1})\n    }\n}\nexport default Example;\n```\n这就是在不使用Hooks情况下的写法，那如何用Hooks来代替这段代码，并产生一样的效果那。\n### 用useEffect函数来代替生命周期函数\n在使用React Hooks的情况下，我们可以使用下面的代码来完成上边代码的生命周期效果，代码如下（修改了以前的diamond）： 记得要先引入useEffect后，才可以正常使用。\n```js\nimport React, { useState , useEffect } from 'react';\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    //---关键代码---------start-------\n    useEffect(()=>{\n        console.log(`useEffect=>You clicked ${count} times`)\n    })\n    //---关键代码---------end-------\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n        </div>\n    )\n}\nexport default Example;\n```\n在浏览器中进行预览一下，可以看出跟class形式的生命周期函数是完全一样的，这代表第一次组件渲染和每次组件更新都会执行这个函数。那这段代码逻辑是什么？我们梳理一下:首先，我们声明了一个状态变量count,将它的初始值设为0，然后我们告诉react，我们的这个组件有一个副作用。给useEffecthook传了一个匿名函数，这个匿名函数就是我们的副作用。在这里我们打印了一句话，当然你也可以手动的去修改一个DOM元素。当React要渲染组件时，它会记住用到的副作用，然后执行一次。等Reat更新了State状态时，它再一词执行定义的副作用函数。\n\n### useEffect两个注意点\n- React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。\n\n- useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。\n\n# 四、useEffect 实现 componentWillUnmount生命周期函数\n在写React应用的时候，在组件中经常用到componentWillUnmount生命周期函数（组件将要被卸载时执行）。比如我们的定时器要清空，避免发生内存泄漏;比如登录状态要取消掉，避免下次进入信息出错。所以这个生命周期函数也是必不可少的，这节就来用useEffect来实现这个生命周期函数,并讲解一下useEffect容易踩的坑。\n\n### useEffect解绑副作用\n学习React Hooks 时，我们要改掉生命周期函数的概念，因为Hooks叫它副作用，所以componentWillUnmount也可以理解成解绑副作用。这里为了演示用useEffect来实现类似componentWillUnmount效果，在此之前我们先得安装React-Router路由。\n\n然后编写两个新组件(由于这两个组件都非常的简单，所以就不单独建立一个新的文件来写了),然后两个新组件中分别加入useEffect()函数:。\n\n```js\nimport React, { useState , useEffect } from 'react';\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\"\nfunction Index() {\n    return <h2>www.justyouxx.top</h2>;\n}\nfunction List() {\n    return <h2>List-Page</h2>;\n}\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    useEffect(()=>{\n        console.log(`useEffect=>You clicked ${count} times`)\n    })\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n\n            <Router>\n                <ul>\n                    <li> <Link to=\"/\">首页</Link> </li>\n                    <li><Link to=\"/list/\">列表</Link> </li>\n                </ul>\n                <Route path=\"/\" exact component={Index} />\n                <Route path=\"/list/\" component={List} />\n            </Router>\n        </div>\n    )\n}\nexport default Example;\n```\n这时候我们点击Link进入任何一个组件，在浏览器中都会打印出对应的一段话。这时候可以用**返回一个函数的形式进行解绑，代码如下：**\n```js\nfunction Index() {\n    useEffect(()=>{\n        console.log('useEffect=>老弟你来了！Index页面')\n        return ()=>{\n            console.log('老弟，你走了!Index页面')\n        }\n    })\n    return <h2>www.justyouxx.top</h2>;\n  }\n```\n这时候你在浏览器中预览，我们仿佛实现了componentWillUnmount方法。但这只是好像实现了，当点击计数器按钮时，你会发现老弟，你走了!Index页面，也出现了。这到底是怎么回事那？其实每次状态发生变化，useEffect都进行了解绑。\n\n### useEffect的第二个参数\n\n那到底要如何实现类似componentWillUnmount的效果呢?这就需要useEffect的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组[]时，就是当组件将被销毁时才进行解绑，这也就实现了componentWillUnmount的生命周期函数。\n\n```js\nfunction Index() {\n    useEffect(()=>{\n        console.log('useEffect=>老弟你来了！Index页面')\n        return ()=>{\n            console.log('老弟，你走了!Index页面')\n        }\n    },[])\n    return <h2>www.justyouxx.top</h2>;\n}\n```\n为了更加深入了解第二个参数的作用，把计数器的代码也加上useEffect和解绑方法，并加入第二个参数为空数组。代码如下：\n```js\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    useEffect(()=>{\n        console.log(`useEffect=>You clicked ${count} times`)\n\n        return ()=>{\n            console.log('====================')\n        }\n    },[])\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n\n            <Router>\n                <ul>\n                    <li> <Link to=\"/\">首页</Link> </li>\n                    <li><Link to=\"/list/\">列表</Link> </li>\n                </ul>\n                <Route path=\"/\" exact component={Index} />\n                <Route path=\"/list/\" component={List} />\n            </Router>\n        </div>\n    )\n}\n```\n这时候的代码是不能执行解绑副作用函数的。但是如果我们想每次count发生变化，我们都进行解绑，只需要在第二个参数的数组里加入count变量就可以了。代码如下：\n```js\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n\n    useEffect(()=>{\n        console.log(`useEffect=>You clicked ${count} times`)\n\n        return ()=>{\n            console.log('====================')\n        }\n    },[count])\n\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n\n            <Router>\n                <ul>\n                    <li> <Link to=\"/\">首页</Link> </li>\n                    <li><Link to=\"/list/\">列表</Link> </li>\n                </ul>\n                <Route path=\"/\" exact component={Index} />\n                <Route path=\"/list/\" component={List} />\n            </Router>\n        </div>\n    )\n}\n```\n这时候只要count状态发生变化，都会执行解绑副作用函数，浏览器的控制台也就打印出了一串=================。\n\n从这里开始我们对useEffect函数有了一个比较深入的了解，并且可以通过useEffect实现生命周期函数了，现在用React Hooks这种函数的方法编写组件，对比以前用Class编写组件几乎一样了。但这并不是Hooks的所有东西，它还有一些让我们惊喜的新特性。\n\n# 五、useContext 让父子组件传值更简单\n有了useState和useEffect已经可以实现大部分的业务逻辑了，但是React Hooks中还是有很多好用的Hooks函数的，比如useContext和useReducer。\n\n在用类声明组件时，父子组件的传值是通过组件属性和props进行的，那现在使用方法(Function)来声明组件，已经没有了constructor构造函数也就没有了props的接收，那父子组件的传值就成了一个问题。React Hooks 为我们准备了useContext。这节就学习一下useContext，它可以帮助我们跨越组件层级直接传递变量，实现共享。需要注意的是useContext和redux的作用是不同的，一个解决的是组件之间值传递的问题，一个是应用中统一管理状态的问题，但通过和useReducer的配合使用，可以实现类似Redux的作用。\n\nContext的作用就是对它所包含的组件树提供全局共享数据的一种技术。\n\n### createContext 函数创建context\n在src目录下新建一个文件contextDemo.js,然后拷贝example.js里的代码，并进行修改，删除路由部分和副作用的代码，只留计数器的核心代码就可以了。\n```js\nimport React, { useState , useEffect } from 'react';\n\nfunction ContextDemo(){\n    const [ count , setCount ] = useState(0);\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n        </div>\n    )\n}\nexport default ContextDemo;\n```\n然后修改一下index.js让它渲染这个contextDemo.js组件，修改的代码如下\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Example from './ContextDemo'\nReactDOM.render(<Example />, document.getElementById('root'));\n```\n之后在contextDemo.js中引入createContext函数，并使用得到一个组件，然后在return方法中进行使用。\n```js\nimport React, { useState , createContext } from 'react';\n//===关键代码\nconst CountContext = createContext()\n\nfunction ContextDemo(){\n    const [ count , setCount ] = useState(0);\n\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n            {/*======关键代码 */}\n            <CountContext.Provider value={count}>\n            </CountContext.Provider>\n\n        </div>\n    )\n}\nexport default ContextDemo;\n```\n这段代码就相当于把count变量允许跨层级实现传递和使用了（也就是实现了上下文），当父组件的count变量发生变化时，子组件也会发生变化。接下来我们就看看一个React Hooks的组件如何接收到这个变量。\n\n### useContext 接收上下文变量\n已经有了上下文变量，剩下的就时如何接收了，接收这个直接使用useContext就可以，但是在使用前需要新进行引入useContext（不引入是没办法使用的）。\n```js\nimport React, { useState , createContext , useContext } from 'react';\n```\n引入后写一个Counter组件，只是显示上下文中的count变量代码如下：\n```js\nfunction Counter(){\n    const count = useContext(CountContext)  //一句话就可以得到count\n    return (<h2>{count}</h2>)\n}\n```\n得到后就可以显示出来了，但是要记得在<CountContext.Provider>的闭合标签中,代码如下。\n```js\n<CountContext.Provider value={count}>\n    <Counter />\n</CountContext.Provider>\n```\n\n# 六、useReducer介绍和简单使用\n上节学习了useContext函数，那这节开始学习一下useReducer，因为他们两个很像，并且合作可以完成类似的Redux库的操作。在开发中使用useReducer可以让代码具有更好的可读性和可维护性，并且会给测试提供方便。那现在来学习一下useReducer。这节我们只是简单的学习一下useReducer语法和使用方法，尽量避免Redux的一些操作。这样讲更容易让不了解Redux的小伙伴接受。\n\n### reducer到底是什么？\n为了更好的理解useReducer，所以先要了解JavaScript里的Reducer是什么。它的兴起是从Redux广泛使用开始的，但不仅仅存在Redux中，可以使用JavaScript来完成Reducer操作。那reducer其实就是一个函数，这个函数接收两个参数，一个是状态，一个用来控制业务逻辑的判断参数。我们举一个最简单的例子。\n```js\nfunction countReducer(state, action) {\n    switch(action.type) {\n        case 'add':\n            return state + 1;\n        case 'sub':\n            return state - 1;\n        default: \n            return state;\n    }\n}\n```\n上面的代码就是Reducer，你主要理解的就是这种形式和两个参数的作用，一个参数是状态，一个参数是如何控制状态。\n\n### useReducer的使用\n了解reducer的含义后，就可以讲useReducer了，它也是React hooks提供的函数，可以增强我们的Reducer，实现类似Redux的功能。我们用useReducer实现计数器的加减双向操作，如下代码：\n```js\nimport React, { useReducer } from 'react';\nfunction ReducerDemo(){\n    const [ count , dispatch ] =useReducer((state,action)=>{\n        switch(action){\n            case 'add':\n                return state+1\n            case 'sub':\n                return state-1\n            default:\n                return state\n        }\n    },0)\n    return (\n       <div>\n           <h2>现在的分数是{count}</h2>\n           <button onClick={()=>dispatch('add')}>Increment</button>\n           <button onClick={()=>dispatch('sub')}>Decrement</button>\n       </div>\n    )\n\n}\n\nexport default ReducerDemo\n```\n这段代码是useReducer的最简单实现了，这时候可以在浏览器中实现了计数器的增加减少。\n\n# 七、useMemo优化React Hooks程序性能\nuseMemo主要用来解决使用React hooks产生的无用渲染的性能问题。使用function的形式来声明组件，失去了shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。useMemo和useCallback都是解决上述性能问题的，这节先学习useMemo.\n\n### 性能问题展示案例\n先编写一下刚才所说的性能问题，建立两个组件,一个父组件一个子组件，组件上由两个按钮，一个是A，一个是B，点击哪个，哪个就向我们走来了。然后先写第一个父组件。\n```js\nimport React , {useState,useMemo} from 'react';\n\nfunction Example(){\n    const [a , setA] = useState('A状态')\n    const [b , setB] = useState('B状态')\n    return (\n        <div>\n            <button onClick={()=>{setA(new Date().getTime())}}>A</button>\n            <button onClick={()=>{setB(new Date().getTime()+',B向我们走来了')}}>B</button>\n            <ChildComponent name={a}>{b}</ChildComponent>\n        <div/>\n    )\n}\n```\n父组件调用了子组件，子组件我们输出组件的状态，显示在界面上。代码如下：\n```js\nfunction ChildComponent({name,children}){\n    function changeA(name){\n        console.log('她来了，她来了。A向我们走来了')\n        return name+',A向我们走来了'\n    }\n\n    const actionA = changeA(name)\n    return (\n        <div>\n            <div>{actionA}</div>\n            <div>{children}</div>\n        </div>\n    )\n}\n```\n这时候你会发现在浏览器中点击B按钮，A对应的方法都会执行，结果虽然没变，但是每次都执行，这就是性能的损耗。目前只有子组件，业务逻辑也非常简单，如果是一个后台查询，这将产生严重的后果。所以这个问题必须解决。当我们点击B按钮时，对应的changeA方法不能执行，只有在点击A按钮时才能执行。\n\n### useMemo 优化性能\n其实只要使用useMemo，然后给A组件传递第二个参数，参数匹配成功，才会执行。代码如下：\n```js\nfunction ChildComponent({name,children}){\n    function changeA(name){\n        console.log('来了，来了。A向我们走来了')\n        return name+',A向我们走来了'\n    }\n\n    const actionA = useMemo(()=>changeA(name),[name]) \n    return (\n        <div>\n            <div>{actionA}</div>\n            <div>{children}</div>\n        </div>\n    )\n}\n```\n这时在浏览器中点击一下B按钮，changeA就不再执行了。也节省了性能的消耗。案例只是让你更好理解，你还要从程序本身看到优化的作用。好的程序员对自己写的程序都是会进行不断优化的，这种没必要的性能浪费也是绝对不允许的，所以useMemo的使用在工作中还是比较多的。\n\n### useMemo和useCallback对比\n\nuseCallback和useMemo的参数跟useEffect一致，他们之间最大的区别有是useEffect会用于处理副作用，而前两个hooks不能。\n\nuseMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。\n\nuseCallback跟useMemo比较类似，但它返回的是缓存的函数。我们看一下最简单的用法：\n```js\nuseMemo( ()=>{fn} ) 等价于 useCallback(fn)\n```\n这里就不多介绍了，如有想了解更多关于两者区别，可查找相关资料~\n\n# 八、useRef获取DOM元素和保存变量\nuseRef在工作中虽然用的不多，但是也不能缺少。它有两个主要的作用:\n- 用useRef获取React JSX中的DOM元素，获取后你就可以控制DOM的任何东西了。但是一般不建议这样来做，React界面的变化可以通过状态来控制。\n\n- 用useRef来保存变量，这个在工作中也很少能用到，我们有了useContext这样的保存其实意义不大，简单的提一下。\n\n### useRef获取DOM元素\n界面上有一个文本框，在文本框的旁边有一个按钮，当我们点击按钮时，在控制台打印出input的DOM元素，并进行复制到DOM中的value上。这一切都是通过useRef来实现。\n```js\nimport React, { useRef} from 'react';\nfunction Example(){\n    const inputEl = useRef(null)\n    const onButtonClick=()=>{ \n        inputEl.current.value=\"Hello World\"\n        console.log(inputEl) //输出获取到的DOM节点\n    }\n    return (\n        <div>\n            {/*保存input的ref到inputEl */}\n            <input ref={inputEl} type=\"text\"/>\n            <button onClick = {onButtonClick}>在input上展示文字</button>\n        </div>\n    )\n}\nexport default Example\n```\n当点击按钮时，你可以看到在浏览器中的控制台完整的打印出了DOM的所有东西，并且界面上的<input/>框的value值也输出了我们写好的Hello World。这一切说明我们可以使用useRef获取DOM元素，并且可以通过useRefu控制DOM的属性和值。\n\n### useRef保存普通变量\n这个操作在实际开发中用的并不多，但我们还是要讲解一下。就是useRef可以保存React中的变量。我们这里就写一个文本框，文本框用来改变text状态。又用useRef把text状态进行保存，最后打印在控制台上。写这段代码你会觉的很绕，其实显示开发中没必要这样写，用一个state状态就可以搞定，这里只是为了展示知识点。\n\n接着上面的代码来写，就没必要重新写一个文件了。先用useState声明了一个text状态和setText函数。然后编写界面，界面就是一个文本框。然后输入的时候不断变化。\n```js\nimport React, { useRef ,useState,useEffect } from 'react';\n\n\n\nfunction Example(){\n    const inputEl = useRef(null)\n    const onButtonClick=()=>{ \n        inputEl.current.value=\"Hello ,useRef\"\n        console.log(inputEl)\n    }\n    const [text, setText] = useState('jspang')\n    return (\n        <div>\n            {/*保存input的ref到inputEl */}\n            <input ref={inputEl} type=\"text\"/>\n            <button onClick = {onButtonClick}>在input上展示文字</button>\n            <br/>\n            <br/>\n            <input value={text} onChange={(e)=>{setText(e.target.value)}} />\n         \n        </div>\n    )\n}\n\nexport default Example\n```\n这时想每次text发生状态改变，保存到一个变量中或者说是useRef中，这时候就可以使用useRef了。先声明一个textRef变量，他其实就是useRef函数。然后使用useEffect函数实现每次状态变化都进行变量修改，并打印。最后的全部代码如下.\n```js\nimport React, { useRef ,useState,useEffect } from 'react';\nfunction Example(){\n    const inputEl = useRef(null)\n    const onButtonClick=()=>{ \n        inputEl.current.value=\"Hello ,useRef\"\n        console.log(inputEl)\n    }\n    //-----------关键代码--------start\n    const [text, setText] = useState('jspang')\n    const textRef = useRef()\n\n    useEffect(()=>{\n        textRef.current = text;\n        console.log('textRef.current:', textRef.current)\n    })\n    //----------关键代码--------------end\n    return (\n        <div>\n            {/*保存input的ref到inputEl */}\n            <input ref={inputEl} type=\"text\"/>\n            <button onClick = {onButtonClick}>在input上展示文字</button>\n            <br/>\n            <br/>\n            <input value={text} onChange={(e)=>{setText(e.target.value)}} />\n        </div>\n    )\n}\n\nexport default Example\n```\n这时候就可以实现每次状态修改，同时保存到useRef中了。也就是我们说的保存变量的功能。那useRef的主要功能就是获得DOM和变量保存，我们都已经讲过了。\n\n# 九、自定义Hooks函数获取窗口大小\n其实自定义Hooks函数和用Hooks创建组件很相似，跟我们平时用JavaScript写函数几乎一模一样，可能就是多了些React Hooks的特性，自定义Hooks函数偏向于功能，而组件偏向于界面和业务逻辑。由于差别不大，所以使用起来也是很随意的。如果是小型项目是可以的，但是如果项目足够复杂，这会让项目结构不够清晰。所以学习自定义Hooks函数还是很有必要的。\n\n### 编写自定义函数\n在实际开发中，为了界面更加美观。获取浏览器窗口的尺寸是一个经常使用的功能，这样经常使用的功能，就可以封装成一个自定义Hooks函数，记住一定要用use开头，这样才能区分出什么是组件，什么是自定义函数。\n\n编写一个useWinSize,编写时我们会用到useState、useEffect和useCallback所以先用import进行引入。\n```js\nimport React, { useState ,useEffect ,useCallback } from 'react';\n```\n然后编写函数，函数中先用useState设置size状态，然后编写一个每次修改状态的方法onResize，这个方法使用useCallback，目的是为了缓存方法(useMemo是为了缓存变量)。 然后在第一次进入方法时用useEffect来注册resize监听时间。为了防止一直监听所以在方法移除时，使用return的方式移除监听。最后返回size变量就可以了。\n```js\nfunction useWinSize(){\n    const [ size , setSize] = useState({\n        width:document.documentElement.clientWidth,\n        height:document.documentElement.clientHeight\n    })\n\n    const onResize = useCallback(()=>{\n        setSize({\n            width: document.documentElement.clientWidth,\n            height: document.documentElement.clientHeight\n        })\n    },[]) \n    useEffect(()=>{\n        window.addEventListener('resize',onResize)\n        return ()=>{\n            window.removeEventListener('resize',onResize)\n        }\n    },[])\n\n    return size;\n\n}\n```\n这就是一个自定义函数，其实和我们以前写的JS函数没什么区别，所以这里也不做太多的介绍。\n\n### 编写组件并使用自定义函数\n自定义Hooks函数已经写好了，可以直接进行使用，用法和JavaScript的普通函数用起来是一样的。直接在Example组件使用useWinSize并把结果实时展示在页面上。\n```js\nfunction Example(){\n\n    const size = useWinSize()\n    return (\n        <div>页面Size:{size.width}x{size.height}</div>\n    )\n}\n\nexport default Example\n```\n之后就可以在浏览器中预览一下结果，可以看到当我们放大缩小浏览器窗口时，页面上的结果都会跟着进行变化。说明自定义的函数起到了作用。","source":"_posts/2019-11-15-React-hook.md","raw":"---\ntitle: react-hook介绍及应用\ncomments: true\ndate: 2019-11-15\ntags:\n- react hooks\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n![](https://img.fengjr.com/image/2019/12/13/cbdd0825ad6d689bfc8b572387788dec.jpg)\n\n# 一、React Hooks 简介\nHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\nReact Hooks就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理state，有Hooks可以不再使用类的形式定义组件了。这时候你的认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。\n### React Hooks 编写形式对比\n先来写一个最简单的有状体组件，点我们点击按钮时，点击数量不断增加。\n\n```js\n//原始写法\nimport React, { Component } from 'react';\n\nclass Example extends Component {\n    constructor(props) {\n        super(props);\n        this.state = { count:0 }\n    }\n    render() { \n        return (\n            <div>\n                <p>You clicked {this.state.count} times</p>\n                <button onClick={this.addCount.bind(this)}>Chlick me</button>\n            </div>\n        );\n    }\n    addCount(){\n        this.setState({count:this.state.count+1})\n    }\n}\n \nexport default Example;\n```\n```js\n//hook写法\nimport React, { useState } from 'react';\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n        </div>\n    )\n}\nexport default Example;\n```\n从这两个程序的对比上可以看出Hooks本质上就是一类特殊的函数，他们可以为你的函数型组件（function component）注入一些特殊的功能。hooks的目的就是让你不再写class，让function一统江湖。\n\n# 二、useState 的介绍和多状态声明\n### useState的介绍\nuseState是react自带的一个hook函数，它的作用是用来声明状态变量。\n我们从三个方面来看useState的用法，分别是声明、读取、使用（修改）。这三个方面掌握了，你基本也就会使用useState了.\n\n先来看一下声明的方式，代码如下\n```js\nconst [ count , setCount ] = useState(0);\n```\n这种方法是ES6语法中的数组解构，这样看起来代码变的简单易懂。 如果不写成数组解构，上边的语法要写成下面的三行:\n```js\nlet _useState = userState(0)\nlet count = _useState[0]\nlet setCount = _useState[1]\n```\n\nuseState这个函数，需要传入一个参数作为状态的初始值(Initial state)，当函数执行后会返回两个值，一个是当前状态的属性，一个是修改状态的方法。且返回的是一个数组，这个数组的第0位是当前的状态值，第1位是可以改变状态值的方法函数。 所以上面的代码的意思就是声明了一个状态变量为count，并把它的初始值设为0，同时提供了一个可以改变count的状态值的方法函数。\n\n这时候你已经会声明一个状态了，接下来我们看看如何读取状态中的值。\n```html\n<p>You clicked {count} times</p>\n```\n你可以发现，我们读取是很简单的。只要使用{count}就可以，因为这时候的count就是JS里的一个变量，想在JSX中使用，值用加上{}就可以。\n\n最后看看如果改变State中的值,看下面的代码:\n```html\n<button onClick={()=>{setCount(count+1)}}>click me</button>\n```\n直接调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给React,他会重新渲染组件。React自动帮助我们记忆了组件的上一次状态值。\n### 多状态声明的注意事项\n比如现在我们要声明多个状态，有年龄（age）、性别(sex)和工作(work)。代码可以这么写.\n```js\nimport React, { useState } from 'react';\nfunction Example(){\n    const [ age , setAge ] = useState(18)\n    const [ sex , setSex ] = useState('男')\n    const [ work , setWork ] = useState('前端程序员')\n    return (\n        <div>\n            <p>JSPang 今年:{age}岁</p>\n            <p>性别:{sex}</p>\n            <p>工作是:{work}</p>\n            \n        </div>\n    )\n}\nexport default Example;\n```\n从上面的代码可以发现，在使用useState的时候只赋了初始值，并没有绑定任何的key,那React是怎么保证这三个useState找到它自己对应的state呢？\n\n**答案是：React是根据useState出现的顺序来确定的**\n\n比如我们把代码改成下面的样子：\n```js\nimport React, { useState } from 'react';\n\nlet showSex = true\nfunction Example(){\n    const [ age , setAge ] = useState(18)\n    if(showSex){\n        const [ sex , setSex ] = useState('男')\n        showSex=false\n    }\n   \n    const [ work , setWork ] = useState('前端程序员')\n    return (\n        <div>\n            <p>JSPang 今年:{age}岁</p>\n            <p>性别:{sex}</p>\n            <p>工作是:{work}</p>\n            \n        </div>\n    )\n}\nexport default Example;\n```\n这时候控制台就会直接给我们报错，错误如下：\n```\nReact Hook \"useState\" is called conditionally. React Hooks must be called in the exact same order in every component render \n```\n意思就是useState不能在if...else...这样的条件语句中进行调用，必须要按照相同的顺序进行渲染。因为这是hook的规则：\n- **只能在顶层调用hooks,不能在循环、条件或嵌套方法中调用**\n- **仅在React功能组件中使用hooks。不能在常规的JavaScript方法中调用**\n\n\n# 三、useEffect代替常用生命周期函数\n在用Class制作组件时，经常会用生命周期函数，来处理一些额外的事情（副作用：和函数业务主逻辑关联不大，特定时间或事件中执行的动作，比如Ajax请求后端数据，添加登录监听和取消登录，手动修改DOM等等）。在React Hooks中也需要这样类似的生命周期函数，比如在每次状态（State）更新时执行，它为我们准备了useEffect。\n### 用Class的方式为计数器增加生命周期函数\n为了让你更好的理解useEffect的使用，先用原始的方式把计数器的Demo增加两个生命周期函数componentDidMount和componentDidUpdate。分别在组件第一次渲染后在浏览器控制台打印出计数器结果和在每次计数器状态发生变化后打印出结果。代码如下：\n```js\nimport React, { Component } from 'react';\nclass Example extends Component {\n    constructor(props) {\n        super(props);\n        this.state = { count:0 }\n    }\n    componentDidMount(){\n        console.log(`ComponentDidMount=>You clicked ${this.state.count} times`)\n    }\n    componentDidUpdate(){\n        console.log(`componentDidUpdate=>You clicked ${this.state.count} times`)\n    }\n    render() {\n        return (\n            <div>\n                <p>You clicked {this.state.count} times</p>\n                <button onClick={this.addCount.bind(this)}>Chlick me</button>\n            </div>\n        );\n    }\n    addCount(){\n        this.setState({count:this.state.count+1})\n    }\n}\nexport default Example;\n```\n这就是在不使用Hooks情况下的写法，那如何用Hooks来代替这段代码，并产生一样的效果那。\n### 用useEffect函数来代替生命周期函数\n在使用React Hooks的情况下，我们可以使用下面的代码来完成上边代码的生命周期效果，代码如下（修改了以前的diamond）： 记得要先引入useEffect后，才可以正常使用。\n```js\nimport React, { useState , useEffect } from 'react';\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    //---关键代码---------start-------\n    useEffect(()=>{\n        console.log(`useEffect=>You clicked ${count} times`)\n    })\n    //---关键代码---------end-------\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n        </div>\n    )\n}\nexport default Example;\n```\n在浏览器中进行预览一下，可以看出跟class形式的生命周期函数是完全一样的，这代表第一次组件渲染和每次组件更新都会执行这个函数。那这段代码逻辑是什么？我们梳理一下:首先，我们声明了一个状态变量count,将它的初始值设为0，然后我们告诉react，我们的这个组件有一个副作用。给useEffecthook传了一个匿名函数，这个匿名函数就是我们的副作用。在这里我们打印了一句话，当然你也可以手动的去修改一个DOM元素。当React要渲染组件时，它会记住用到的副作用，然后执行一次。等Reat更新了State状态时，它再一词执行定义的副作用函数。\n\n### useEffect两个注意点\n- React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。\n\n- useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。\n\n# 四、useEffect 实现 componentWillUnmount生命周期函数\n在写React应用的时候，在组件中经常用到componentWillUnmount生命周期函数（组件将要被卸载时执行）。比如我们的定时器要清空，避免发生内存泄漏;比如登录状态要取消掉，避免下次进入信息出错。所以这个生命周期函数也是必不可少的，这节就来用useEffect来实现这个生命周期函数,并讲解一下useEffect容易踩的坑。\n\n### useEffect解绑副作用\n学习React Hooks 时，我们要改掉生命周期函数的概念，因为Hooks叫它副作用，所以componentWillUnmount也可以理解成解绑副作用。这里为了演示用useEffect来实现类似componentWillUnmount效果，在此之前我们先得安装React-Router路由。\n\n然后编写两个新组件(由于这两个组件都非常的简单，所以就不单独建立一个新的文件来写了),然后两个新组件中分别加入useEffect()函数:。\n\n```js\nimport React, { useState , useEffect } from 'react';\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\"\nfunction Index() {\n    return <h2>www.justyouxx.top</h2>;\n}\nfunction List() {\n    return <h2>List-Page</h2>;\n}\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    useEffect(()=>{\n        console.log(`useEffect=>You clicked ${count} times`)\n    })\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n\n            <Router>\n                <ul>\n                    <li> <Link to=\"/\">首页</Link> </li>\n                    <li><Link to=\"/list/\">列表</Link> </li>\n                </ul>\n                <Route path=\"/\" exact component={Index} />\n                <Route path=\"/list/\" component={List} />\n            </Router>\n        </div>\n    )\n}\nexport default Example;\n```\n这时候我们点击Link进入任何一个组件，在浏览器中都会打印出对应的一段话。这时候可以用**返回一个函数的形式进行解绑，代码如下：**\n```js\nfunction Index() {\n    useEffect(()=>{\n        console.log('useEffect=>老弟你来了！Index页面')\n        return ()=>{\n            console.log('老弟，你走了!Index页面')\n        }\n    })\n    return <h2>www.justyouxx.top</h2>;\n  }\n```\n这时候你在浏览器中预览，我们仿佛实现了componentWillUnmount方法。但这只是好像实现了，当点击计数器按钮时，你会发现老弟，你走了!Index页面，也出现了。这到底是怎么回事那？其实每次状态发生变化，useEffect都进行了解绑。\n\n### useEffect的第二个参数\n\n那到底要如何实现类似componentWillUnmount的效果呢?这就需要useEffect的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组[]时，就是当组件将被销毁时才进行解绑，这也就实现了componentWillUnmount的生命周期函数。\n\n```js\nfunction Index() {\n    useEffect(()=>{\n        console.log('useEffect=>老弟你来了！Index页面')\n        return ()=>{\n            console.log('老弟，你走了!Index页面')\n        }\n    },[])\n    return <h2>www.justyouxx.top</h2>;\n}\n```\n为了更加深入了解第二个参数的作用，把计数器的代码也加上useEffect和解绑方法，并加入第二个参数为空数组。代码如下：\n```js\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n    useEffect(()=>{\n        console.log(`useEffect=>You clicked ${count} times`)\n\n        return ()=>{\n            console.log('====================')\n        }\n    },[])\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n\n            <Router>\n                <ul>\n                    <li> <Link to=\"/\">首页</Link> </li>\n                    <li><Link to=\"/list/\">列表</Link> </li>\n                </ul>\n                <Route path=\"/\" exact component={Index} />\n                <Route path=\"/list/\" component={List} />\n            </Router>\n        </div>\n    )\n}\n```\n这时候的代码是不能执行解绑副作用函数的。但是如果我们想每次count发生变化，我们都进行解绑，只需要在第二个参数的数组里加入count变量就可以了。代码如下：\n```js\nfunction Example(){\n    const [ count , setCount ] = useState(0);\n\n    useEffect(()=>{\n        console.log(`useEffect=>You clicked ${count} times`)\n\n        return ()=>{\n            console.log('====================')\n        }\n    },[count])\n\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n\n            <Router>\n                <ul>\n                    <li> <Link to=\"/\">首页</Link> </li>\n                    <li><Link to=\"/list/\">列表</Link> </li>\n                </ul>\n                <Route path=\"/\" exact component={Index} />\n                <Route path=\"/list/\" component={List} />\n            </Router>\n        </div>\n    )\n}\n```\n这时候只要count状态发生变化，都会执行解绑副作用函数，浏览器的控制台也就打印出了一串=================。\n\n从这里开始我们对useEffect函数有了一个比较深入的了解，并且可以通过useEffect实现生命周期函数了，现在用React Hooks这种函数的方法编写组件，对比以前用Class编写组件几乎一样了。但这并不是Hooks的所有东西，它还有一些让我们惊喜的新特性。\n\n# 五、useContext 让父子组件传值更简单\n有了useState和useEffect已经可以实现大部分的业务逻辑了，但是React Hooks中还是有很多好用的Hooks函数的，比如useContext和useReducer。\n\n在用类声明组件时，父子组件的传值是通过组件属性和props进行的，那现在使用方法(Function)来声明组件，已经没有了constructor构造函数也就没有了props的接收，那父子组件的传值就成了一个问题。React Hooks 为我们准备了useContext。这节就学习一下useContext，它可以帮助我们跨越组件层级直接传递变量，实现共享。需要注意的是useContext和redux的作用是不同的，一个解决的是组件之间值传递的问题，一个是应用中统一管理状态的问题，但通过和useReducer的配合使用，可以实现类似Redux的作用。\n\nContext的作用就是对它所包含的组件树提供全局共享数据的一种技术。\n\n### createContext 函数创建context\n在src目录下新建一个文件contextDemo.js,然后拷贝example.js里的代码，并进行修改，删除路由部分和副作用的代码，只留计数器的核心代码就可以了。\n```js\nimport React, { useState , useEffect } from 'react';\n\nfunction ContextDemo(){\n    const [ count , setCount ] = useState(0);\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n        </div>\n    )\n}\nexport default ContextDemo;\n```\n然后修改一下index.js让它渲染这个contextDemo.js组件，修改的代码如下\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Example from './ContextDemo'\nReactDOM.render(<Example />, document.getElementById('root'));\n```\n之后在contextDemo.js中引入createContext函数，并使用得到一个组件，然后在return方法中进行使用。\n```js\nimport React, { useState , createContext } from 'react';\n//===关键代码\nconst CountContext = createContext()\n\nfunction ContextDemo(){\n    const [ count , setCount ] = useState(0);\n\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={()=>{setCount(count+1)}}>click me</button>\n            {/*======关键代码 */}\n            <CountContext.Provider value={count}>\n            </CountContext.Provider>\n\n        </div>\n    )\n}\nexport default ContextDemo;\n```\n这段代码就相当于把count变量允许跨层级实现传递和使用了（也就是实现了上下文），当父组件的count变量发生变化时，子组件也会发生变化。接下来我们就看看一个React Hooks的组件如何接收到这个变量。\n\n### useContext 接收上下文变量\n已经有了上下文变量，剩下的就时如何接收了，接收这个直接使用useContext就可以，但是在使用前需要新进行引入useContext（不引入是没办法使用的）。\n```js\nimport React, { useState , createContext , useContext } from 'react';\n```\n引入后写一个Counter组件，只是显示上下文中的count变量代码如下：\n```js\nfunction Counter(){\n    const count = useContext(CountContext)  //一句话就可以得到count\n    return (<h2>{count}</h2>)\n}\n```\n得到后就可以显示出来了，但是要记得在<CountContext.Provider>的闭合标签中,代码如下。\n```js\n<CountContext.Provider value={count}>\n    <Counter />\n</CountContext.Provider>\n```\n\n# 六、useReducer介绍和简单使用\n上节学习了useContext函数，那这节开始学习一下useReducer，因为他们两个很像，并且合作可以完成类似的Redux库的操作。在开发中使用useReducer可以让代码具有更好的可读性和可维护性，并且会给测试提供方便。那现在来学习一下useReducer。这节我们只是简单的学习一下useReducer语法和使用方法，尽量避免Redux的一些操作。这样讲更容易让不了解Redux的小伙伴接受。\n\n### reducer到底是什么？\n为了更好的理解useReducer，所以先要了解JavaScript里的Reducer是什么。它的兴起是从Redux广泛使用开始的，但不仅仅存在Redux中，可以使用JavaScript来完成Reducer操作。那reducer其实就是一个函数，这个函数接收两个参数，一个是状态，一个用来控制业务逻辑的判断参数。我们举一个最简单的例子。\n```js\nfunction countReducer(state, action) {\n    switch(action.type) {\n        case 'add':\n            return state + 1;\n        case 'sub':\n            return state - 1;\n        default: \n            return state;\n    }\n}\n```\n上面的代码就是Reducer，你主要理解的就是这种形式和两个参数的作用，一个参数是状态，一个参数是如何控制状态。\n\n### useReducer的使用\n了解reducer的含义后，就可以讲useReducer了，它也是React hooks提供的函数，可以增强我们的Reducer，实现类似Redux的功能。我们用useReducer实现计数器的加减双向操作，如下代码：\n```js\nimport React, { useReducer } from 'react';\nfunction ReducerDemo(){\n    const [ count , dispatch ] =useReducer((state,action)=>{\n        switch(action){\n            case 'add':\n                return state+1\n            case 'sub':\n                return state-1\n            default:\n                return state\n        }\n    },0)\n    return (\n       <div>\n           <h2>现在的分数是{count}</h2>\n           <button onClick={()=>dispatch('add')}>Increment</button>\n           <button onClick={()=>dispatch('sub')}>Decrement</button>\n       </div>\n    )\n\n}\n\nexport default ReducerDemo\n```\n这段代码是useReducer的最简单实现了，这时候可以在浏览器中实现了计数器的增加减少。\n\n# 七、useMemo优化React Hooks程序性能\nuseMemo主要用来解决使用React hooks产生的无用渲染的性能问题。使用function的形式来声明组件，失去了shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。useMemo和useCallback都是解决上述性能问题的，这节先学习useMemo.\n\n### 性能问题展示案例\n先编写一下刚才所说的性能问题，建立两个组件,一个父组件一个子组件，组件上由两个按钮，一个是A，一个是B，点击哪个，哪个就向我们走来了。然后先写第一个父组件。\n```js\nimport React , {useState,useMemo} from 'react';\n\nfunction Example(){\n    const [a , setA] = useState('A状态')\n    const [b , setB] = useState('B状态')\n    return (\n        <div>\n            <button onClick={()=>{setA(new Date().getTime())}}>A</button>\n            <button onClick={()=>{setB(new Date().getTime()+',B向我们走来了')}}>B</button>\n            <ChildComponent name={a}>{b}</ChildComponent>\n        <div/>\n    )\n}\n```\n父组件调用了子组件，子组件我们输出组件的状态，显示在界面上。代码如下：\n```js\nfunction ChildComponent({name,children}){\n    function changeA(name){\n        console.log('她来了，她来了。A向我们走来了')\n        return name+',A向我们走来了'\n    }\n\n    const actionA = changeA(name)\n    return (\n        <div>\n            <div>{actionA}</div>\n            <div>{children}</div>\n        </div>\n    )\n}\n```\n这时候你会发现在浏览器中点击B按钮，A对应的方法都会执行，结果虽然没变，但是每次都执行，这就是性能的损耗。目前只有子组件，业务逻辑也非常简单，如果是一个后台查询，这将产生严重的后果。所以这个问题必须解决。当我们点击B按钮时，对应的changeA方法不能执行，只有在点击A按钮时才能执行。\n\n### useMemo 优化性能\n其实只要使用useMemo，然后给A组件传递第二个参数，参数匹配成功，才会执行。代码如下：\n```js\nfunction ChildComponent({name,children}){\n    function changeA(name){\n        console.log('来了，来了。A向我们走来了')\n        return name+',A向我们走来了'\n    }\n\n    const actionA = useMemo(()=>changeA(name),[name]) \n    return (\n        <div>\n            <div>{actionA}</div>\n            <div>{children}</div>\n        </div>\n    )\n}\n```\n这时在浏览器中点击一下B按钮，changeA就不再执行了。也节省了性能的消耗。案例只是让你更好理解，你还要从程序本身看到优化的作用。好的程序员对自己写的程序都是会进行不断优化的，这种没必要的性能浪费也是绝对不允许的，所以useMemo的使用在工作中还是比较多的。\n\n### useMemo和useCallback对比\n\nuseCallback和useMemo的参数跟useEffect一致，他们之间最大的区别有是useEffect会用于处理副作用，而前两个hooks不能。\n\nuseMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。\n\nuseCallback跟useMemo比较类似，但它返回的是缓存的函数。我们看一下最简单的用法：\n```js\nuseMemo( ()=>{fn} ) 等价于 useCallback(fn)\n```\n这里就不多介绍了，如有想了解更多关于两者区别，可查找相关资料~\n\n# 八、useRef获取DOM元素和保存变量\nuseRef在工作中虽然用的不多，但是也不能缺少。它有两个主要的作用:\n- 用useRef获取React JSX中的DOM元素，获取后你就可以控制DOM的任何东西了。但是一般不建议这样来做，React界面的变化可以通过状态来控制。\n\n- 用useRef来保存变量，这个在工作中也很少能用到，我们有了useContext这样的保存其实意义不大，简单的提一下。\n\n### useRef获取DOM元素\n界面上有一个文本框，在文本框的旁边有一个按钮，当我们点击按钮时，在控制台打印出input的DOM元素，并进行复制到DOM中的value上。这一切都是通过useRef来实现。\n```js\nimport React, { useRef} from 'react';\nfunction Example(){\n    const inputEl = useRef(null)\n    const onButtonClick=()=>{ \n        inputEl.current.value=\"Hello World\"\n        console.log(inputEl) //输出获取到的DOM节点\n    }\n    return (\n        <div>\n            {/*保存input的ref到inputEl */}\n            <input ref={inputEl} type=\"text\"/>\n            <button onClick = {onButtonClick}>在input上展示文字</button>\n        </div>\n    )\n}\nexport default Example\n```\n当点击按钮时，你可以看到在浏览器中的控制台完整的打印出了DOM的所有东西，并且界面上的<input/>框的value值也输出了我们写好的Hello World。这一切说明我们可以使用useRef获取DOM元素，并且可以通过useRefu控制DOM的属性和值。\n\n### useRef保存普通变量\n这个操作在实际开发中用的并不多，但我们还是要讲解一下。就是useRef可以保存React中的变量。我们这里就写一个文本框，文本框用来改变text状态。又用useRef把text状态进行保存，最后打印在控制台上。写这段代码你会觉的很绕，其实显示开发中没必要这样写，用一个state状态就可以搞定，这里只是为了展示知识点。\n\n接着上面的代码来写，就没必要重新写一个文件了。先用useState声明了一个text状态和setText函数。然后编写界面，界面就是一个文本框。然后输入的时候不断变化。\n```js\nimport React, { useRef ,useState,useEffect } from 'react';\n\n\n\nfunction Example(){\n    const inputEl = useRef(null)\n    const onButtonClick=()=>{ \n        inputEl.current.value=\"Hello ,useRef\"\n        console.log(inputEl)\n    }\n    const [text, setText] = useState('jspang')\n    return (\n        <div>\n            {/*保存input的ref到inputEl */}\n            <input ref={inputEl} type=\"text\"/>\n            <button onClick = {onButtonClick}>在input上展示文字</button>\n            <br/>\n            <br/>\n            <input value={text} onChange={(e)=>{setText(e.target.value)}} />\n         \n        </div>\n    )\n}\n\nexport default Example\n```\n这时想每次text发生状态改变，保存到一个变量中或者说是useRef中，这时候就可以使用useRef了。先声明一个textRef变量，他其实就是useRef函数。然后使用useEffect函数实现每次状态变化都进行变量修改，并打印。最后的全部代码如下.\n```js\nimport React, { useRef ,useState,useEffect } from 'react';\nfunction Example(){\n    const inputEl = useRef(null)\n    const onButtonClick=()=>{ \n        inputEl.current.value=\"Hello ,useRef\"\n        console.log(inputEl)\n    }\n    //-----------关键代码--------start\n    const [text, setText] = useState('jspang')\n    const textRef = useRef()\n\n    useEffect(()=>{\n        textRef.current = text;\n        console.log('textRef.current:', textRef.current)\n    })\n    //----------关键代码--------------end\n    return (\n        <div>\n            {/*保存input的ref到inputEl */}\n            <input ref={inputEl} type=\"text\"/>\n            <button onClick = {onButtonClick}>在input上展示文字</button>\n            <br/>\n            <br/>\n            <input value={text} onChange={(e)=>{setText(e.target.value)}} />\n        </div>\n    )\n}\n\nexport default Example\n```\n这时候就可以实现每次状态修改，同时保存到useRef中了。也就是我们说的保存变量的功能。那useRef的主要功能就是获得DOM和变量保存，我们都已经讲过了。\n\n# 九、自定义Hooks函数获取窗口大小\n其实自定义Hooks函数和用Hooks创建组件很相似，跟我们平时用JavaScript写函数几乎一模一样，可能就是多了些React Hooks的特性，自定义Hooks函数偏向于功能，而组件偏向于界面和业务逻辑。由于差别不大，所以使用起来也是很随意的。如果是小型项目是可以的，但是如果项目足够复杂，这会让项目结构不够清晰。所以学习自定义Hooks函数还是很有必要的。\n\n### 编写自定义函数\n在实际开发中，为了界面更加美观。获取浏览器窗口的尺寸是一个经常使用的功能，这样经常使用的功能，就可以封装成一个自定义Hooks函数，记住一定要用use开头，这样才能区分出什么是组件，什么是自定义函数。\n\n编写一个useWinSize,编写时我们会用到useState、useEffect和useCallback所以先用import进行引入。\n```js\nimport React, { useState ,useEffect ,useCallback } from 'react';\n```\n然后编写函数，函数中先用useState设置size状态，然后编写一个每次修改状态的方法onResize，这个方法使用useCallback，目的是为了缓存方法(useMemo是为了缓存变量)。 然后在第一次进入方法时用useEffect来注册resize监听时间。为了防止一直监听所以在方法移除时，使用return的方式移除监听。最后返回size变量就可以了。\n```js\nfunction useWinSize(){\n    const [ size , setSize] = useState({\n        width:document.documentElement.clientWidth,\n        height:document.documentElement.clientHeight\n    })\n\n    const onResize = useCallback(()=>{\n        setSize({\n            width: document.documentElement.clientWidth,\n            height: document.documentElement.clientHeight\n        })\n    },[]) \n    useEffect(()=>{\n        window.addEventListener('resize',onResize)\n        return ()=>{\n            window.removeEventListener('resize',onResize)\n        }\n    },[])\n\n    return size;\n\n}\n```\n这就是一个自定义函数，其实和我们以前写的JS函数没什么区别，所以这里也不做太多的介绍。\n\n### 编写组件并使用自定义函数\n自定义Hooks函数已经写好了，可以直接进行使用，用法和JavaScript的普通函数用起来是一样的。直接在Example组件使用useWinSize并把结果实时展示在页面上。\n```js\nfunction Example(){\n\n    const size = useWinSize()\n    return (\n        <div>页面Size:{size.width}x{size.height}</div>\n    )\n}\n\nexport default Example\n```\n之后就可以在浏览器中预览一下结果，可以看到当我们放大缩小浏览器窗口时，页面上的结果都会跟着进行变化。说明自定义的函数起到了作用。","slug":"React-hook","published":1,"updated":"2020-06-10T06:01:42.323Z","_id":"ck4249z8200004aq64yty071v","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/12/13/cbdd0825ad6d689bfc8b572387788dec.jpg\" alt></p>\n<h1 id=\"一、React-Hooks-简介\"><a href=\"#一、React-Hooks-简介\" class=\"headerlink\" title=\"一、React Hooks 简介\"></a>一、React Hooks 简介</h1><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性<br>React Hooks就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理state，有Hooks可以不再使用类的形式定义组件了。这时候你的认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。</p>\n<h3 id=\"React-Hooks-编写形式对比\"><a href=\"#React-Hooks-编写形式对比\" class=\"headerlink\" title=\"React Hooks 编写形式对比\"></a>React Hooks 编写形式对比</h3><p>先来写一个最简单的有状体组件，点我们点击按钮时，点击数量不断增加。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//原始写法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">count</span>:<span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;p&gt;You clicked &#123;<span class=\"keyword\">this</span>.state.count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;button onClick=&#123;this.addCount.bind(this)&#125;&gt;Chlick me&lt;/</span>button&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    addCount()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        this.setState(&#123;count:this.state.count+1&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"> </span></span><br><span class=\"line\"><span class=\"regexp\">export default Example;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//hook写法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Example;</span></span><br></pre></td></tr></table></figure>\n<p>从这两个程序的对比上可以看出Hooks本质上就是一类特殊的函数，他们可以为你的函数型组件（function component）注入一些特殊的功能。hooks的目的就是让你不再写class，让function一统江湖。</p>\n<h1 id=\"二、useState-的介绍和多状态声明\"><a href=\"#二、useState-的介绍和多状态声明\" class=\"headerlink\" title=\"二、useState 的介绍和多状态声明\"></a>二、useState 的介绍和多状态声明</h1><h3 id=\"useState的介绍\"><a href=\"#useState的介绍\" class=\"headerlink\" title=\"useState的介绍\"></a>useState的介绍</h3><p>useState是react自带的一个hook函数，它的作用是用来声明状态变量。<br>我们从三个方面来看useState的用法，分别是声明、读取、使用（修改）。这三个方面掌握了，你基本也就会使用useState了.</p>\n<p>先来看一下声明的方式，代码如下<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这种方法是ES6语法中的数组解构，这样看起来代码变的简单易懂。 如果不写成数组解构，上边的语法要写成下面的三行:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _useState = userState(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> count = _useState[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> setCount = _useState[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure></p>\n<p>useState这个函数，需要传入一个参数作为状态的初始值(Initial state)，当函数执行后会返回两个值，一个是当前状态的属性，一个是修改状态的方法。且返回的是一个数组，这个数组的第0位是当前的状态值，第1位是可以改变状态值的方法函数。 所以上面的代码的意思就是声明了一个状态变量为count，并把它的初始值设为0，同时提供了一个可以改变count的状态值的方法函数。</p>\n<p>这时候你已经会声明一个状态了，接下来我们看看如何读取状态中的值。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>你可以发现，我们读取是很简单的。只要使用{count}就可以，因为这时候的count就是JS里的一个变量，想在JSX中使用，值用加上{}就可以。</p>\n<p>最后看看如果改变State中的值,看下面的代码:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;setCount(count+1)&#125;&#125;&gt;click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>直接调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给React,他会重新渲染组件。React自动帮助我们记忆了组件的上一次状态值。</p>\n<h3 id=\"多状态声明的注意事项\"><a href=\"#多状态声明的注意事项\" class=\"headerlink\" title=\"多状态声明的注意事项\"></a>多状态声明的注意事项</h3><p>比如现在我们要声明多个状态，有年龄（age）、性别(sex)和工作(work)。代码可以这么写.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ age , setAge ] = useState(<span class=\"number\">18</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ sex , setSex ] = useState(<span class=\"string\">'男'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ work , setWork ] = useState(<span class=\"string\">'前端程序员'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;JSPang 今年:&#123;age&#125;岁&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;p&gt;性别:&#123;sex&#125;&lt;/</span>p&gt;</span><br><span class=\"line\">            &lt;p&gt;工作是:&#123;work&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            </span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Example;</span><br></pre></td></tr></table></figure></p>\n<p>从上面的代码可以发现，在使用useState的时候只赋了初始值，并没有绑定任何的key,那React是怎么保证这三个useState找到它自己对应的state呢？</p>\n<p><strong>答案是：React是根据useState出现的顺序来确定的</strong></p>\n<p>比如我们把代码改成下面的样子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> showSex = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ age , setAge ] = useState(<span class=\"number\">18</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(showSex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [ sex , setSex ] = useState(<span class=\"string\">'男'</span>)</span><br><span class=\"line\">        showSex=<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ work , setWork ] = useState(<span class=\"string\">'前端程序员'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;JSPang 今年:&#123;age&#125;岁&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;p&gt;性别:&#123;sex&#125;&lt;/</span>p&gt;</span><br><span class=\"line\">            &lt;p&gt;工作是:&#123;work&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            </span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Example;</span><br></pre></td></tr></table></figure></p>\n<p>这时候控制台就会直接给我们报错，错误如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React Hook &quot;useState&quot; is called conditionally. React Hooks must be called in the exact same order in every component render</span><br></pre></td></tr></table></figure></p>\n<p>意思就是useState不能在if…else…这样的条件语句中进行调用，必须要按照相同的顺序进行渲染。因为这是hook的规则：</p>\n<ul>\n<li><strong>只能在顶层调用hooks,不能在循环、条件或嵌套方法中调用</strong></li>\n<li><strong>仅在React功能组件中使用hooks。不能在常规的JavaScript方法中调用</strong></li>\n</ul>\n<h1 id=\"三、useEffect代替常用生命周期函数\"><a href=\"#三、useEffect代替常用生命周期函数\" class=\"headerlink\" title=\"三、useEffect代替常用生命周期函数\"></a>三、useEffect代替常用生命周期函数</h1><p>在用Class制作组件时，经常会用生命周期函数，来处理一些额外的事情（副作用：和函数业务主逻辑关联不大，特定时间或事件中执行的动作，比如Ajax请求后端数据，添加登录监听和取消登录，手动修改DOM等等）。在React Hooks中也需要这样类似的生命周期函数，比如在每次状态（State）更新时执行，它为我们准备了useEffect。</p>\n<h3 id=\"用Class的方式为计数器增加生命周期函数\"><a href=\"#用Class的方式为计数器增加生命周期函数\" class=\"headerlink\" title=\"用Class的方式为计数器增加生命周期函数\"></a>用Class的方式为计数器增加生命周期函数</h3><p>为了让你更好的理解useEffect的使用，先用原始的方式把计数器的Demo增加两个生命周期函数componentDidMount和componentDidUpdate。分别在组件第一次渲染后在浏览器控制台打印出计数器结果和在每次计数器状态发生变化后打印出结果。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">count</span>:<span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`ComponentDidMount=&gt;You clicked <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.state.count&#125;</span> times`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidUpdate()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`componentDidUpdate=&gt;You clicked <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.state.count&#125;</span> times`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;p&gt;You clicked &#123;<span class=\"keyword\">this</span>.state.count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;button onClick=&#123;this.addCount.bind(this)&#125;&gt;Chlick me&lt;/</span>button&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    addCount()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        this.setState(&#123;count:this.state.count+1&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Example;</span></span><br></pre></td></tr></table></figure></p>\n<p>这就是在不使用Hooks情况下的写法，那如何用Hooks来代替这段代码，并产生一样的效果那。</p>\n<h3 id=\"用useEffect函数来代替生命周期函数\"><a href=\"#用useEffect函数来代替生命周期函数\" class=\"headerlink\" title=\"用useEffect函数来代替生命周期函数\"></a>用useEffect函数来代替生命周期函数</h3><p>在使用React Hooks的情况下，我们可以使用下面的代码来完成上边代码的生命周期效果，代码如下（修改了以前的diamond）： 记得要先引入useEffect后，才可以正常使用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">//---关键代码---------start-------</span></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`useEffect=&gt;You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">//---关键代码---------end-------</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Example;</span></span><br></pre></td></tr></table></figure></p>\n<p>在浏览器中进行预览一下，可以看出跟class形式的生命周期函数是完全一样的，这代表第一次组件渲染和每次组件更新都会执行这个函数。那这段代码逻辑是什么？我们梳理一下:首先，我们声明了一个状态变量count,将它的初始值设为0，然后我们告诉react，我们的这个组件有一个副作用。给useEffecthook传了一个匿名函数，这个匿名函数就是我们的副作用。在这里我们打印了一句话，当然你也可以手动的去修改一个DOM元素。当React要渲染组件时，它会记住用到的副作用，然后执行一次。等Reat更新了State状态时，它再一词执行定义的副作用函数。</p>\n<h3 id=\"useEffect两个注意点\"><a href=\"#useEffect两个注意点\" class=\"headerlink\" title=\"useEffect两个注意点\"></a>useEffect两个注意点</h3><ul>\n<li><p>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。</p>\n</li>\n<li><p>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。</p>\n</li>\n</ul>\n<h1 id=\"四、useEffect-实现-componentWillUnmount生命周期函数\"><a href=\"#四、useEffect-实现-componentWillUnmount生命周期函数\" class=\"headerlink\" title=\"四、useEffect 实现 componentWillUnmount生命周期函数\"></a>四、useEffect 实现 componentWillUnmount生命周期函数</h1><p>在写React应用的时候，在组件中经常用到componentWillUnmount生命周期函数（组件将要被卸载时执行）。比如我们的定时器要清空，避免发生内存泄漏;比如登录状态要取消掉，避免下次进入信息出错。所以这个生命周期函数也是必不可少的，这节就来用useEffect来实现这个生命周期函数,并讲解一下useEffect容易踩的坑。</p>\n<h3 id=\"useEffect解绑副作用\"><a href=\"#useEffect解绑副作用\" class=\"headerlink\" title=\"useEffect解绑副作用\"></a>useEffect解绑副作用</h3><p>学习React Hooks 时，我们要改掉生命周期函数的概念，因为Hooks叫它副作用，所以componentWillUnmount也可以理解成解绑副作用。这里为了演示用useEffect来实现类似componentWillUnmount效果，在此之前我们先得安装React-Router路由。</p>\n<p>然后编写两个新组件(由于这两个组件都非常的简单，所以就不单独建立一个新的文件来写了),然后两个新组件中分别加入useEffect()函数:。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserRouter <span class=\"keyword\">as</span> Router, Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-dom\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Index</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>www.justyouxx.top<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">List</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>List-Page<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`useEffect=&gt;You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;ul&gt;</span><br><span class=\"line\">                    &lt;li&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                    &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/list/\"</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;Route path=\"/</span><span class=\"string\">\" exact component=&#123;Index&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;Route path=\"</span>/list/<span class=\"string\">\" component=&#123;List&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;/Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">export default Example;</span></span><br></pre></td></tr></table></figure>\n<p>这时候我们点击Link进入任何一个组件，在浏览器中都会打印出对应的一段话。这时候可以用<strong>返回一个函数的形式进行解绑，代码如下：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Index</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'useEffect=&gt;老弟你来了！Index页面'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'老弟，你走了!Index页面'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>www.justyouxx.top<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候你在浏览器中预览，我们仿佛实现了componentWillUnmount方法。但这只是好像实现了，当点击计数器按钮时，你会发现老弟，你走了!Index页面，也出现了。这到底是怎么回事那？其实每次状态发生变化，useEffect都进行了解绑。</p>\n<h3 id=\"useEffect的第二个参数\"><a href=\"#useEffect的第二个参数\" class=\"headerlink\" title=\"useEffect的第二个参数\"></a>useEffect的第二个参数</h3><p>那到底要如何实现类似componentWillUnmount的效果呢?这就需要useEffect的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组[]时，就是当组件将被销毁时才进行解绑，这也就实现了componentWillUnmount的生命周期函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Index</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'useEffect=&gt;老弟你来了！Index页面'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'老弟，你走了!Index页面'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>www.justyouxx.top<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了更加深入了解第二个参数的作用，把计数器的代码也加上useEffect和解绑方法，并加入第二个参数为空数组。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`useEffect=&gt;You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'===================='</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;ul&gt;</span><br><span class=\"line\">                    &lt;li&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                    &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/list/\"</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;Route path=\"/</span><span class=\"string\">\" exact component=&#123;Index&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;Route path=\"</span>/list/<span class=\"string\">\" component=&#123;List&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;/Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候的代码是不能执行解绑副作用函数的。但是如果我们想每次count发生变化，我们都进行解绑，只需要在第二个参数的数组里加入count变量就可以了。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`useEffect=&gt;You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'===================='</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[count])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;ul&gt;</span><br><span class=\"line\">                    &lt;li&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                    &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/list/\"</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;Route path=\"/</span><span class=\"string\">\" exact component=&#123;Index&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;Route path=\"</span>/list/<span class=\"string\">\" component=&#123;List&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;/Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候只要count状态发生变化，都会执行解绑副作用函数，浏览器的控制台也就打印出了一串=================。</p>\n<p>从这里开始我们对useEffect函数有了一个比较深入的了解，并且可以通过useEffect实现生命周期函数了，现在用React Hooks这种函数的方法编写组件，对比以前用Class编写组件几乎一样了。但这并不是Hooks的所有东西，它还有一些让我们惊喜的新特性。</p>\n<h1 id=\"五、useContext-让父子组件传值更简单\"><a href=\"#五、useContext-让父子组件传值更简单\" class=\"headerlink\" title=\"五、useContext 让父子组件传值更简单\"></a>五、useContext 让父子组件传值更简单</h1><p>有了useState和useEffect已经可以实现大部分的业务逻辑了，但是React Hooks中还是有很多好用的Hooks函数的，比如useContext和useReducer。</p>\n<p>在用类声明组件时，父子组件的传值是通过组件属性和props进行的，那现在使用方法(Function)来声明组件，已经没有了constructor构造函数也就没有了props的接收，那父子组件的传值就成了一个问题。React Hooks 为我们准备了useContext。这节就学习一下useContext，它可以帮助我们跨越组件层级直接传递变量，实现共享。需要注意的是useContext和redux的作用是不同的，一个解决的是组件之间值传递的问题，一个是应用中统一管理状态的问题，但通过和useReducer的配合使用，可以实现类似Redux的作用。</p>\n<p>Context的作用就是对它所包含的组件树提供全局共享数据的一种技术。</p>\n<h3 id=\"createContext-函数创建context\"><a href=\"#createContext-函数创建context\" class=\"headerlink\" title=\"createContext 函数创建context\"></a>createContext 函数创建context</h3><p>在src目录下新建一个文件contextDemo.js,然后拷贝example.js里的代码，并进行修改，删除路由部分和副作用的代码，只留计数器的核心代码就可以了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ContextDemo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default ContextDemo;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后修改一下index.js让它渲染这个contextDemo.js组件，修改的代码如下<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Example <span class=\"keyword\">from</span> <span class=\"string\">'./ContextDemo'</span></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Example</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure></p>\n<p>之后在contextDemo.js中引入createContext函数，并使用得到一个组件，然后在return方法中进行使用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , createContext &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"comment\">//===关键代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> CountContext = createContext()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ContextDemo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\">            &#123;<span class=\"comment\">/*======关键代码 */</span>&#125;</span><br><span class=\"line\">            &lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/CountContext.Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ContextDemo;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码就相当于把count变量允许跨层级实现传递和使用了（也就是实现了上下文），当父组件的count变量发生变化时，子组件也会发生变化。接下来我们就看看一个React Hooks的组件如何接收到这个变量。</p>\n<h3 id=\"useContext-接收上下文变量\"><a href=\"#useContext-接收上下文变量\" class=\"headerlink\" title=\"useContext 接收上下文变量\"></a>useContext 接收上下文变量</h3><p>已经有了上下文变量，剩下的就时如何接收了，接收这个直接使用useContext就可以，但是在使用前需要新进行引入useContext（不引入是没办法使用的）。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , createContext , useContext &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>引入后写一个Counter组件，只是显示上下文中的count变量代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = useContext(CountContext)  <span class=\"comment\">//一句话就可以得到count</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>得到后就可以显示出来了，但是要记得在&lt;CountContext.Provider&gt;的闭合标签中,代码如下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class=\"line\">    &lt;Counter /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/CountContext.Provider&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"六、useReducer介绍和简单使用\"><a href=\"#六、useReducer介绍和简单使用\" class=\"headerlink\" title=\"六、useReducer介绍和简单使用\"></a>六、useReducer介绍和简单使用</h1><p>上节学习了useContext函数，那这节开始学习一下useReducer，因为他们两个很像，并且合作可以完成类似的Redux库的操作。在开发中使用useReducer可以让代码具有更好的可读性和可维护性，并且会给测试提供方便。那现在来学习一下useReducer。这节我们只是简单的学习一下useReducer语法和使用方法，尽量避免Redux的一些操作。这样讲更容易让不了解Redux的小伙伴接受。</p>\n<h3 id=\"reducer到底是什么？\"><a href=\"#reducer到底是什么？\" class=\"headerlink\" title=\"reducer到底是什么？\"></a>reducer到底是什么？</h3><p>为了更好的理解useReducer，所以先要了解JavaScript里的Reducer是什么。它的兴起是从Redux广泛使用开始的，但不仅仅存在Redux中，可以使用JavaScript来完成Reducer操作。那reducer其实就是一个函数，这个函数接收两个参数，一个是状态，一个用来控制业务逻辑的判断参数。我们举一个最简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countReducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'add'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'sub'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码就是Reducer，你主要理解的就是这种形式和两个参数的作用，一个参数是状态，一个参数是如何控制状态。</p>\n<h3 id=\"useReducer的使用\"><a href=\"#useReducer的使用\" class=\"headerlink\" title=\"useReducer的使用\"></a>useReducer的使用</h3><p>了解reducer的含义后，就可以讲useReducer了，它也是React hooks提供的函数，可以增强我们的Reducer，实现类似Redux的功能。我们用useReducer实现计数器的加减双向操作，如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useReducer &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ReducerDemo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , dispatch ] =useReducer(<span class=\"function\">(<span class=\"params\">state,action</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(action)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'add'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'sub'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state<span class=\"number\">-1</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">       &lt;div&gt;</span><br><span class=\"line\">           &lt;h2&gt;现在的分数是&#123;count&#125;&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">           &lt;button onClick=&#123;()=&gt;dispatch('add')&#125;&gt;Increment&lt;/</span>button&gt;</span><br><span class=\"line\">           &lt;button onClick=&#123;()=&gt;dispatch(<span class=\"string\">'sub'</span>)&#125;&gt;Decrement&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">       &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ReducerDemo</span><br></pre></td></tr></table></figure></p>\n<p>这段代码是useReducer的最简单实现了，这时候可以在浏览器中实现了计数器的增加减少。</p>\n<h1 id=\"七、useMemo优化React-Hooks程序性能\"><a href=\"#七、useMemo优化React-Hooks程序性能\" class=\"headerlink\" title=\"七、useMemo优化React Hooks程序性能\"></a>七、useMemo优化React Hooks程序性能</h1><p>useMemo主要用来解决使用React hooks产生的无用渲染的性能问题。使用function的形式来声明组件，失去了shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。useMemo和useCallback都是解决上述性能问题的，这节先学习useMemo.</p>\n<h3 id=\"性能问题展示案例\"><a href=\"#性能问题展示案例\" class=\"headerlink\" title=\"性能问题展示案例\"></a>性能问题展示案例</h3><p>先编写一下刚才所说的性能问题，建立两个组件,一个父组件一个子组件，组件上由两个按钮，一个是A，一个是B，点击哪个，哪个就向我们走来了。然后先写第一个父组件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React , &#123;useState,useMemo&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [a , setA] = useState(<span class=\"string\">'A状态'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [b , setB] = useState(<span class=\"string\">'B状态'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;()=&gt;&#123;setA(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime())&#125;&#125;&gt;A&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setB(new Date().getTime()+',B向我们走来了')&#125;&#125;&gt;B&lt;/</span>button&gt;</span><br><span class=\"line\">            &lt;ChildComponent name=&#123;a&#125;&gt;&#123;b&#125;&lt;<span class=\"regexp\">/ChildComponent&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;div/</span>&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>父组件调用了子组件，子组件我们输出组件的状态，显示在界面上。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ChildComponent</span>(<span class=\"params\">&#123;name,children&#125;</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeA</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'她来了，她来了。A向我们走来了'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name+<span class=\"string\">',A向我们走来了'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> actionA = changeA(name)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;div&gt;&#123;actionA&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div&gt;&#123;children&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候你会发现在浏览器中点击B按钮，A对应的方法都会执行，结果虽然没变，但是每次都执行，这就是性能的损耗。目前只有子组件，业务逻辑也非常简单，如果是一个后台查询，这将产生严重的后果。所以这个问题必须解决。当我们点击B按钮时，对应的changeA方法不能执行，只有在点击A按钮时才能执行。</p>\n<h3 id=\"useMemo-优化性能\"><a href=\"#useMemo-优化性能\" class=\"headerlink\" title=\"useMemo 优化性能\"></a>useMemo 优化性能</h3><p>其实只要使用useMemo，然后给A组件传递第二个参数，参数匹配成功，才会执行。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ChildComponent</span>(<span class=\"params\">&#123;name,children&#125;</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeA</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'来了，来了。A向我们走来了'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name+<span class=\"string\">',A向我们走来了'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> actionA = useMemo(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>changeA(name),[name]) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;div&gt;&#123;actionA&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div&gt;&#123;children&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时在浏览器中点击一下B按钮，changeA就不再执行了。也节省了性能的消耗。案例只是让你更好理解，你还要从程序本身看到优化的作用。好的程序员对自己写的程序都是会进行不断优化的，这种没必要的性能浪费也是绝对不允许的，所以useMemo的使用在工作中还是比较多的。</p>\n<h3 id=\"useMemo和useCallback对比\"><a href=\"#useMemo和useCallback对比\" class=\"headerlink\" title=\"useMemo和useCallback对比\"></a>useMemo和useCallback对比</h3><p>useCallback和useMemo的参数跟useEffect一致，他们之间最大的区别有是useEffect会用于处理副作用，而前两个hooks不能。</p>\n<p>useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。</p>\n<p>useCallback跟useMemo比较类似，但它返回的是缓存的函数。我们看一下最简单的用法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useMemo( <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;fn&#125; ) 等价于 useCallback(fn)</span><br></pre></td></tr></table></figure></p>\n<p>这里就不多介绍了，如有想了解更多关于两者区别，可查找相关资料~</p>\n<h1 id=\"八、useRef获取DOM元素和保存变量\"><a href=\"#八、useRef获取DOM元素和保存变量\" class=\"headerlink\" title=\"八、useRef获取DOM元素和保存变量\"></a>八、useRef获取DOM元素和保存变量</h1><p>useRef在工作中虽然用的不多，但是也不能缺少。它有两个主要的作用:</p>\n<ul>\n<li><p>用useRef获取React JSX中的DOM元素，获取后你就可以控制DOM的任何东西了。但是一般不建议这样来做，React界面的变化可以通过状态来控制。</p>\n</li>\n<li><p>用useRef来保存变量，这个在工作中也很少能用到，我们有了useContext这样的保存其实意义不大，简单的提一下。</p>\n</li>\n</ul>\n<h3 id=\"useRef获取DOM元素\"><a href=\"#useRef获取DOM元素\" class=\"headerlink\" title=\"useRef获取DOM元素\"></a>useRef获取DOM元素</h3><p>界面上有一个文本框，在文本框的旁边有一个按钮，当我们点击按钮时，在控制台打印出input的DOM元素，并进行复制到DOM中的value上。这一切都是通过useRef来实现。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useRef&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> inputEl = useRef(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onButtonClick=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; </span><br><span class=\"line\">        inputEl.current.value=<span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(inputEl) <span class=\"comment\">//输出获取到的DOM节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &#123;<span class=\"comment\">/*保存input的ref到inputEl */</span>&#125;</span><br><span class=\"line\">            &lt;input ref=&#123;inputEl&#125; type=<span class=\"string\">\"text\"</span>/&gt;</span><br><span class=\"line\">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Example</span><br></pre></td></tr></table></figure></p>\n<p>当点击按钮时，你可以看到在浏览器中的控制台完整的打印出了DOM的所有东西，并且界面上的<input>框的value值也输出了我们写好的Hello World。这一切说明我们可以使用useRef获取DOM元素，并且可以通过useRefu控制DOM的属性和值。</p>\n<h3 id=\"useRef保存普通变量\"><a href=\"#useRef保存普通变量\" class=\"headerlink\" title=\"useRef保存普通变量\"></a>useRef保存普通变量</h3><p>这个操作在实际开发中用的并不多，但我们还是要讲解一下。就是useRef可以保存React中的变量。我们这里就写一个文本框，文本框用来改变text状态。又用useRef把text状态进行保存，最后打印在控制台上。写这段代码你会觉的很绕，其实显示开发中没必要这样写，用一个state状态就可以搞定，这里只是为了展示知识点。</p>\n<p>接着上面的代码来写，就没必要重新写一个文件了。先用useState声明了一个text状态和setText函数。然后编写界面，界面就是一个文本框。然后输入的时候不断变化。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useRef ,useState,useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> inputEl = useRef(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onButtonClick=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; </span><br><span class=\"line\">        inputEl.current.value=<span class=\"string\">\"Hello ,useRef\"</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(inputEl)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [text, setText] = useState(<span class=\"string\">'jspang'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &#123;<span class=\"comment\">/*保存input的ref到inputEl */</span>&#125;</span><br><span class=\"line\">            &lt;input ref=&#123;inputEl&#125; type=<span class=\"string\">\"text\"</span>/&gt;</span><br><span class=\"line\">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;br/</span>&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;input value=&#123;text&#125; onChange=&#123;(e)=&gt;&#123;setText(e.target.value)&#125;&#125; /&gt;</span><br><span class=\"line\">         </span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Example</span></span><br></pre></td></tr></table></figure></p>\n<p>这时想每次text发生状态改变，保存到一个变量中或者说是useRef中，这时候就可以使用useRef了。先声明一个textRef变量，他其实就是useRef函数。然后使用useEffect函数实现每次状态变化都进行变量修改，并打印。最后的全部代码如下.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useRef ,useState,useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> inputEl = useRef(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onButtonClick=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; </span><br><span class=\"line\">        inputEl.current.value=<span class=\"string\">\"Hello ,useRef\"</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(inputEl)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//-----------关键代码--------start</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> [text, setText] = useState(<span class=\"string\">'jspang'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> textRef = useRef()</span><br><span class=\"line\"></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        textRef.current = text;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'textRef.current:'</span>, textRef.current)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">//----------关键代码--------------end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &#123;<span class=\"comment\">/*保存input的ref到inputEl */</span>&#125;</span><br><span class=\"line\">            &lt;input ref=&#123;inputEl&#125; type=<span class=\"string\">\"text\"</span>/&gt;</span><br><span class=\"line\">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;br/</span>&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;input value=&#123;text&#125; onChange=&#123;(e)=&gt;&#123;setText(e.target.value)&#125;&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Example</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候就可以实现每次状态修改，同时保存到useRef中了。也就是我们说的保存变量的功能。那useRef的主要功能就是获得DOM和变量保存，我们都已经讲过了。</p>\n<h1 id=\"九、自定义Hooks函数获取窗口大小\"><a href=\"#九、自定义Hooks函数获取窗口大小\" class=\"headerlink\" title=\"九、自定义Hooks函数获取窗口大小\"></a>九、自定义Hooks函数获取窗口大小</h1><p>其实自定义Hooks函数和用Hooks创建组件很相似，跟我们平时用JavaScript写函数几乎一模一样，可能就是多了些React Hooks的特性，自定义Hooks函数偏向于功能，而组件偏向于界面和业务逻辑。由于差别不大，所以使用起来也是很随意的。如果是小型项目是可以的，但是如果项目足够复杂，这会让项目结构不够清晰。所以学习自定义Hooks函数还是很有必要的。</p>\n<h3 id=\"编写自定义函数\"><a href=\"#编写自定义函数\" class=\"headerlink\" title=\"编写自定义函数\"></a>编写自定义函数</h3><p>在实际开发中，为了界面更加美观。获取浏览器窗口的尺寸是一个经常使用的功能，这样经常使用的功能，就可以封装成一个自定义Hooks函数，记住一定要用use开头，这样才能区分出什么是组件，什么是自定义函数。</p>\n<p>编写一个useWinSize,编写时我们会用到useState、useEffect和useCallback所以先用import进行引入。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState ,useEffect ,useCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>然后编写函数，函数中先用useState设置size状态，然后编写一个每次修改状态的方法onResize，这个方法使用useCallback，目的是为了缓存方法(useMemo是为了缓存变量)。 然后在第一次进入方法时用useEffect来注册resize监听时间。为了防止一直监听所以在方法移除时，使用return的方式移除监听。最后返回size变量就可以了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useWinSize</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ size , setSize] = useState(&#123;</span><br><span class=\"line\">        width:<span class=\"built_in\">document</span>.documentElement.clientWidth,</span><br><span class=\"line\">        height:<span class=\"built_in\">document</span>.documentElement.clientHeight</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> onResize = useCallback(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        setSize(&#123;</span><br><span class=\"line\">            width: <span class=\"built_in\">document</span>.documentElement.clientWidth,</span><br><span class=\"line\">            height: <span class=\"built_in\">document</span>.documentElement.clientHeight</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,[]) </span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>,onResize)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'resize'</span>,onResize)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这就是一个自定义函数，其实和我们以前写的JS函数没什么区别，所以这里也不做太多的介绍。</p>\n<h3 id=\"编写组件并使用自定义函数\"><a href=\"#编写组件并使用自定义函数\" class=\"headerlink\" title=\"编写组件并使用自定义函数\"></a>编写组件并使用自定义函数</h3><p>自定义Hooks函数已经写好了，可以直接进行使用，用法和JavaScript的普通函数用起来是一样的。直接在Example组件使用useWinSize并把结果实时展示在页面上。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> size = useWinSize()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;页面Size:&#123;size.width&#125;x&#123;size.height&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Example</span></span><br></pre></td></tr></table></figure></p>\n<p>之后就可以在浏览器中预览一下结果，可以看到当我们放大缩小浏览器窗口时，页面上的结果都会跟着进行变化。说明自定义的函数起到了作用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/12/13/cbdd0825ad6d689bfc8b572387788dec.jpg\" alt></p>\n<h1 id=\"一、React-Hooks-简介\"><a href=\"#一、React-Hooks-简介\" class=\"headerlink\" title=\"一、React Hooks 简介\"></a>一、React Hooks 简介</h1><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性<br>React Hooks就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理state，有Hooks可以不再使用类的形式定义组件了。这时候你的认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。</p>\n<h3 id=\"React-Hooks-编写形式对比\"><a href=\"#React-Hooks-编写形式对比\" class=\"headerlink\" title=\"React Hooks 编写形式对比\"></a>React Hooks 编写形式对比</h3><p>先来写一个最简单的有状体组件，点我们点击按钮时，点击数量不断增加。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//原始写法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">count</span>:<span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;p&gt;You clicked &#123;<span class=\"keyword\">this</span>.state.count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;button onClick=&#123;this.addCount.bind(this)&#125;&gt;Chlick me&lt;/</span>button&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    addCount()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        this.setState(&#123;count:this.state.count+1&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"> </span></span><br><span class=\"line\"><span class=\"regexp\">export default Example;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//hook写法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Example;</span></span><br></pre></td></tr></table></figure>\n<p>从这两个程序的对比上可以看出Hooks本质上就是一类特殊的函数，他们可以为你的函数型组件（function component）注入一些特殊的功能。hooks的目的就是让你不再写class，让function一统江湖。</p>\n<h1 id=\"二、useState-的介绍和多状态声明\"><a href=\"#二、useState-的介绍和多状态声明\" class=\"headerlink\" title=\"二、useState 的介绍和多状态声明\"></a>二、useState 的介绍和多状态声明</h1><h3 id=\"useState的介绍\"><a href=\"#useState的介绍\" class=\"headerlink\" title=\"useState的介绍\"></a>useState的介绍</h3><p>useState是react自带的一个hook函数，它的作用是用来声明状态变量。<br>我们从三个方面来看useState的用法，分别是声明、读取、使用（修改）。这三个方面掌握了，你基本也就会使用useState了.</p>\n<p>先来看一下声明的方式，代码如下<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这种方法是ES6语法中的数组解构，这样看起来代码变的简单易懂。 如果不写成数组解构，上边的语法要写成下面的三行:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _useState = userState(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> count = _useState[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> setCount = _useState[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure></p>\n<p>useState这个函数，需要传入一个参数作为状态的初始值(Initial state)，当函数执行后会返回两个值，一个是当前状态的属性，一个是修改状态的方法。且返回的是一个数组，这个数组的第0位是当前的状态值，第1位是可以改变状态值的方法函数。 所以上面的代码的意思就是声明了一个状态变量为count，并把它的初始值设为0，同时提供了一个可以改变count的状态值的方法函数。</p>\n<p>这时候你已经会声明一个状态了，接下来我们看看如何读取状态中的值。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>你可以发现，我们读取是很简单的。只要使用{count}就可以，因为这时候的count就是JS里的一个变量，想在JSX中使用，值用加上{}就可以。</p>\n<p>最后看看如果改变State中的值,看下面的代码:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;setCount(count+1)&#125;&#125;&gt;click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>直接调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给React,他会重新渲染组件。React自动帮助我们记忆了组件的上一次状态值。</p>\n<h3 id=\"多状态声明的注意事项\"><a href=\"#多状态声明的注意事项\" class=\"headerlink\" title=\"多状态声明的注意事项\"></a>多状态声明的注意事项</h3><p>比如现在我们要声明多个状态，有年龄（age）、性别(sex)和工作(work)。代码可以这么写.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ age , setAge ] = useState(<span class=\"number\">18</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ sex , setSex ] = useState(<span class=\"string\">'男'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ work , setWork ] = useState(<span class=\"string\">'前端程序员'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;JSPang 今年:&#123;age&#125;岁&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;p&gt;性别:&#123;sex&#125;&lt;/</span>p&gt;</span><br><span class=\"line\">            &lt;p&gt;工作是:&#123;work&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            </span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Example;</span><br></pre></td></tr></table></figure></p>\n<p>从上面的代码可以发现，在使用useState的时候只赋了初始值，并没有绑定任何的key,那React是怎么保证这三个useState找到它自己对应的state呢？</p>\n<p><strong>答案是：React是根据useState出现的顺序来确定的</strong></p>\n<p>比如我们把代码改成下面的样子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> showSex = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ age , setAge ] = useState(<span class=\"number\">18</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(showSex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [ sex , setSex ] = useState(<span class=\"string\">'男'</span>)</span><br><span class=\"line\">        showSex=<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ work , setWork ] = useState(<span class=\"string\">'前端程序员'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;JSPang 今年:&#123;age&#125;岁&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;p&gt;性别:&#123;sex&#125;&lt;/</span>p&gt;</span><br><span class=\"line\">            &lt;p&gt;工作是:&#123;work&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            </span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Example;</span><br></pre></td></tr></table></figure></p>\n<p>这时候控制台就会直接给我们报错，错误如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React Hook &quot;useState&quot; is called conditionally. React Hooks must be called in the exact same order in every component render</span><br></pre></td></tr></table></figure></p>\n<p>意思就是useState不能在if…else…这样的条件语句中进行调用，必须要按照相同的顺序进行渲染。因为这是hook的规则：</p>\n<ul>\n<li><strong>只能在顶层调用hooks,不能在循环、条件或嵌套方法中调用</strong></li>\n<li><strong>仅在React功能组件中使用hooks。不能在常规的JavaScript方法中调用</strong></li>\n</ul>\n<h1 id=\"三、useEffect代替常用生命周期函数\"><a href=\"#三、useEffect代替常用生命周期函数\" class=\"headerlink\" title=\"三、useEffect代替常用生命周期函数\"></a>三、useEffect代替常用生命周期函数</h1><p>在用Class制作组件时，经常会用生命周期函数，来处理一些额外的事情（副作用：和函数业务主逻辑关联不大，特定时间或事件中执行的动作，比如Ajax请求后端数据，添加登录监听和取消登录，手动修改DOM等等）。在React Hooks中也需要这样类似的生命周期函数，比如在每次状态（State）更新时执行，它为我们准备了useEffect。</p>\n<h3 id=\"用Class的方式为计数器增加生命周期函数\"><a href=\"#用Class的方式为计数器增加生命周期函数\" class=\"headerlink\" title=\"用Class的方式为计数器增加生命周期函数\"></a>用Class的方式为计数器增加生命周期函数</h3><p>为了让你更好的理解useEffect的使用，先用原始的方式把计数器的Demo增加两个生命周期函数componentDidMount和componentDidUpdate。分别在组件第一次渲染后在浏览器控制台打印出计数器结果和在每次计数器状态发生变化后打印出结果。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">count</span>:<span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`ComponentDidMount=&gt;You clicked <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.state.count&#125;</span> times`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidUpdate()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`componentDidUpdate=&gt;You clicked <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.state.count&#125;</span> times`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;p&gt;You clicked &#123;<span class=\"keyword\">this</span>.state.count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;button onClick=&#123;this.addCount.bind(this)&#125;&gt;Chlick me&lt;/</span>button&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    addCount()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        this.setState(&#123;count:this.state.count+1&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Example;</span></span><br></pre></td></tr></table></figure></p>\n<p>这就是在不使用Hooks情况下的写法，那如何用Hooks来代替这段代码，并产生一样的效果那。</p>\n<h3 id=\"用useEffect函数来代替生命周期函数\"><a href=\"#用useEffect函数来代替生命周期函数\" class=\"headerlink\" title=\"用useEffect函数来代替生命周期函数\"></a>用useEffect函数来代替生命周期函数</h3><p>在使用React Hooks的情况下，我们可以使用下面的代码来完成上边代码的生命周期效果，代码如下（修改了以前的diamond）： 记得要先引入useEffect后，才可以正常使用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">//---关键代码---------start-------</span></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`useEffect=&gt;You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">//---关键代码---------end-------</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Example;</span></span><br></pre></td></tr></table></figure></p>\n<p>在浏览器中进行预览一下，可以看出跟class形式的生命周期函数是完全一样的，这代表第一次组件渲染和每次组件更新都会执行这个函数。那这段代码逻辑是什么？我们梳理一下:首先，我们声明了一个状态变量count,将它的初始值设为0，然后我们告诉react，我们的这个组件有一个副作用。给useEffecthook传了一个匿名函数，这个匿名函数就是我们的副作用。在这里我们打印了一句话，当然你也可以手动的去修改一个DOM元素。当React要渲染组件时，它会记住用到的副作用，然后执行一次。等Reat更新了State状态时，它再一词执行定义的副作用函数。</p>\n<h3 id=\"useEffect两个注意点\"><a href=\"#useEffect两个注意点\" class=\"headerlink\" title=\"useEffect两个注意点\"></a>useEffect两个注意点</h3><ul>\n<li><p>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。</p>\n</li>\n<li><p>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。</p>\n</li>\n</ul>\n<h1 id=\"四、useEffect-实现-componentWillUnmount生命周期函数\"><a href=\"#四、useEffect-实现-componentWillUnmount生命周期函数\" class=\"headerlink\" title=\"四、useEffect 实现 componentWillUnmount生命周期函数\"></a>四、useEffect 实现 componentWillUnmount生命周期函数</h1><p>在写React应用的时候，在组件中经常用到componentWillUnmount生命周期函数（组件将要被卸载时执行）。比如我们的定时器要清空，避免发生内存泄漏;比如登录状态要取消掉，避免下次进入信息出错。所以这个生命周期函数也是必不可少的，这节就来用useEffect来实现这个生命周期函数,并讲解一下useEffect容易踩的坑。</p>\n<h3 id=\"useEffect解绑副作用\"><a href=\"#useEffect解绑副作用\" class=\"headerlink\" title=\"useEffect解绑副作用\"></a>useEffect解绑副作用</h3><p>学习React Hooks 时，我们要改掉生命周期函数的概念，因为Hooks叫它副作用，所以componentWillUnmount也可以理解成解绑副作用。这里为了演示用useEffect来实现类似componentWillUnmount效果，在此之前我们先得安装React-Router路由。</p>\n<p>然后编写两个新组件(由于这两个组件都非常的简单，所以就不单独建立一个新的文件来写了),然后两个新组件中分别加入useEffect()函数:。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserRouter <span class=\"keyword\">as</span> Router, Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-dom\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Index</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>www.justyouxx.top<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">List</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>List-Page<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`useEffect=&gt;You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;ul&gt;</span><br><span class=\"line\">                    &lt;li&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                    &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/list/\"</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;Route path=\"/</span><span class=\"string\">\" exact component=&#123;Index&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;Route path=\"</span>/list/<span class=\"string\">\" component=&#123;List&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;/Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">export default Example;</span></span><br></pre></td></tr></table></figure>\n<p>这时候我们点击Link进入任何一个组件，在浏览器中都会打印出对应的一段话。这时候可以用<strong>返回一个函数的形式进行解绑，代码如下：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Index</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'useEffect=&gt;老弟你来了！Index页面'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'老弟，你走了!Index页面'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>www.justyouxx.top<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这时候你在浏览器中预览，我们仿佛实现了componentWillUnmount方法。但这只是好像实现了，当点击计数器按钮时，你会发现老弟，你走了!Index页面，也出现了。这到底是怎么回事那？其实每次状态发生变化，useEffect都进行了解绑。</p>\n<h3 id=\"useEffect的第二个参数\"><a href=\"#useEffect的第二个参数\" class=\"headerlink\" title=\"useEffect的第二个参数\"></a>useEffect的第二个参数</h3><p>那到底要如何实现类似componentWillUnmount的效果呢?这就需要useEffect的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组[]时，就是当组件将被销毁时才进行解绑，这也就实现了componentWillUnmount的生命周期函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Index</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'useEffect=&gt;老弟你来了！Index页面'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'老弟，你走了!Index页面'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>www.justyouxx.top<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了更加深入了解第二个参数的作用，把计数器的代码也加上useEffect和解绑方法，并加入第二个参数为空数组。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`useEffect=&gt;You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'===================='</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;ul&gt;</span><br><span class=\"line\">                    &lt;li&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                    &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/list/\"</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;Route path=\"/</span><span class=\"string\">\" exact component=&#123;Index&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;Route path=\"</span>/list/<span class=\"string\">\" component=&#123;List&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;/Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候的代码是不能执行解绑副作用函数的。但是如果我们想每次count发生变化，我们都进行解绑，只需要在第二个参数的数组里加入count变量就可以了。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`useEffect=&gt;You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'===================='</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[count])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Router&gt;</span><br><span class=\"line\">                &lt;ul&gt;</span><br><span class=\"line\">                    &lt;li&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                    &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/list/\"</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span> <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">                &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;Route path=\"/</span><span class=\"string\">\" exact component=&#123;Index&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;Route path=\"</span>/list/<span class=\"string\">\" component=&#123;List&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;/Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候只要count状态发生变化，都会执行解绑副作用函数，浏览器的控制台也就打印出了一串=================。</p>\n<p>从这里开始我们对useEffect函数有了一个比较深入的了解，并且可以通过useEffect实现生命周期函数了，现在用React Hooks这种函数的方法编写组件，对比以前用Class编写组件几乎一样了。但这并不是Hooks的所有东西，它还有一些让我们惊喜的新特性。</p>\n<h1 id=\"五、useContext-让父子组件传值更简单\"><a href=\"#五、useContext-让父子组件传值更简单\" class=\"headerlink\" title=\"五、useContext 让父子组件传值更简单\"></a>五、useContext 让父子组件传值更简单</h1><p>有了useState和useEffect已经可以实现大部分的业务逻辑了，但是React Hooks中还是有很多好用的Hooks函数的，比如useContext和useReducer。</p>\n<p>在用类声明组件时，父子组件的传值是通过组件属性和props进行的，那现在使用方法(Function)来声明组件，已经没有了constructor构造函数也就没有了props的接收，那父子组件的传值就成了一个问题。React Hooks 为我们准备了useContext。这节就学习一下useContext，它可以帮助我们跨越组件层级直接传递变量，实现共享。需要注意的是useContext和redux的作用是不同的，一个解决的是组件之间值传递的问题，一个是应用中统一管理状态的问题，但通过和useReducer的配合使用，可以实现类似Redux的作用。</p>\n<p>Context的作用就是对它所包含的组件树提供全局共享数据的一种技术。</p>\n<h3 id=\"createContext-函数创建context\"><a href=\"#createContext-函数创建context\" class=\"headerlink\" title=\"createContext 函数创建context\"></a>createContext 函数创建context</h3><p>在src目录下新建一个文件contextDemo.js,然后拷贝example.js里的代码，并进行修改，删除路由部分和副作用的代码，只留计数器的核心代码就可以了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ContextDemo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default ContextDemo;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后修改一下index.js让它渲染这个contextDemo.js组件，修改的代码如下<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Example <span class=\"keyword\">from</span> <span class=\"string\">'./ContextDemo'</span></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Example</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure></p>\n<p>之后在contextDemo.js中引入createContext函数，并使用得到一个组件，然后在return方法中进行使用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , createContext &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"comment\">//===关键代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> CountContext = createContext()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ContextDemo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , setCount ] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class=\"line\">            &#123;<span class=\"comment\">/*======关键代码 */</span>&#125;</span><br><span class=\"line\">            &lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/CountContext.Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ContextDemo;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码就相当于把count变量允许跨层级实现传递和使用了（也就是实现了上下文），当父组件的count变量发生变化时，子组件也会发生变化。接下来我们就看看一个React Hooks的组件如何接收到这个变量。</p>\n<h3 id=\"useContext-接收上下文变量\"><a href=\"#useContext-接收上下文变量\" class=\"headerlink\" title=\"useContext 接收上下文变量\"></a>useContext 接收上下文变量</h3><p>已经有了上下文变量，剩下的就时如何接收了，接收这个直接使用useContext就可以，但是在使用前需要新进行引入useContext（不引入是没办法使用的）。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState , createContext , useContext &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>引入后写一个Counter组件，只是显示上下文中的count变量代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = useContext(CountContext)  <span class=\"comment\">//一句话就可以得到count</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>得到后就可以显示出来了，但是要记得在&lt;CountContext.Provider&gt;的闭合标签中,代码如下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class=\"line\">    &lt;Counter /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/CountContext.Provider&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"六、useReducer介绍和简单使用\"><a href=\"#六、useReducer介绍和简单使用\" class=\"headerlink\" title=\"六、useReducer介绍和简单使用\"></a>六、useReducer介绍和简单使用</h1><p>上节学习了useContext函数，那这节开始学习一下useReducer，因为他们两个很像，并且合作可以完成类似的Redux库的操作。在开发中使用useReducer可以让代码具有更好的可读性和可维护性，并且会给测试提供方便。那现在来学习一下useReducer。这节我们只是简单的学习一下useReducer语法和使用方法，尽量避免Redux的一些操作。这样讲更容易让不了解Redux的小伙伴接受。</p>\n<h3 id=\"reducer到底是什么？\"><a href=\"#reducer到底是什么？\" class=\"headerlink\" title=\"reducer到底是什么？\"></a>reducer到底是什么？</h3><p>为了更好的理解useReducer，所以先要了解JavaScript里的Reducer是什么。它的兴起是从Redux广泛使用开始的，但不仅仅存在Redux中，可以使用JavaScript来完成Reducer操作。那reducer其实就是一个函数，这个函数接收两个参数，一个是状态，一个用来控制业务逻辑的判断参数。我们举一个最简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countReducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'add'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'sub'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码就是Reducer，你主要理解的就是这种形式和两个参数的作用，一个参数是状态，一个参数是如何控制状态。</p>\n<h3 id=\"useReducer的使用\"><a href=\"#useReducer的使用\" class=\"headerlink\" title=\"useReducer的使用\"></a>useReducer的使用</h3><p>了解reducer的含义后，就可以讲useReducer了，它也是React hooks提供的函数，可以增强我们的Reducer，实现类似Redux的功能。我们用useReducer实现计数器的加减双向操作，如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useReducer &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ReducerDemo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ count , dispatch ] =useReducer(<span class=\"function\">(<span class=\"params\">state,action</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(action)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'add'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'sub'</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state<span class=\"number\">-1</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">       &lt;div&gt;</span><br><span class=\"line\">           &lt;h2&gt;现在的分数是&#123;count&#125;&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">           &lt;button onClick=&#123;()=&gt;dispatch('add')&#125;&gt;Increment&lt;/</span>button&gt;</span><br><span class=\"line\">           &lt;button onClick=&#123;()=&gt;dispatch(<span class=\"string\">'sub'</span>)&#125;&gt;Decrement&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">       &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ReducerDemo</span><br></pre></td></tr></table></figure></p>\n<p>这段代码是useReducer的最简单实现了，这时候可以在浏览器中实现了计数器的增加减少。</p>\n<h1 id=\"七、useMemo优化React-Hooks程序性能\"><a href=\"#七、useMemo优化React-Hooks程序性能\" class=\"headerlink\" title=\"七、useMemo优化React Hooks程序性能\"></a>七、useMemo优化React Hooks程序性能</h1><p>useMemo主要用来解决使用React hooks产生的无用渲染的性能问题。使用function的形式来声明组件，失去了shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。useMemo和useCallback都是解决上述性能问题的，这节先学习useMemo.</p>\n<h3 id=\"性能问题展示案例\"><a href=\"#性能问题展示案例\" class=\"headerlink\" title=\"性能问题展示案例\"></a>性能问题展示案例</h3><p>先编写一下刚才所说的性能问题，建立两个组件,一个父组件一个子组件，组件上由两个按钮，一个是A，一个是B，点击哪个，哪个就向我们走来了。然后先写第一个父组件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React , &#123;useState,useMemo&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [a , setA] = useState(<span class=\"string\">'A状态'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [b , setB] = useState(<span class=\"string\">'B状态'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;()=&gt;&#123;setA(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime())&#125;&#125;&gt;A&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;()=&gt;&#123;setB(new Date().getTime()+',B向我们走来了')&#125;&#125;&gt;B&lt;/</span>button&gt;</span><br><span class=\"line\">            &lt;ChildComponent name=&#123;a&#125;&gt;&#123;b&#125;&lt;<span class=\"regexp\">/ChildComponent&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;div/</span>&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>父组件调用了子组件，子组件我们输出组件的状态，显示在界面上。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ChildComponent</span>(<span class=\"params\">&#123;name,children&#125;</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeA</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'她来了，她来了。A向我们走来了'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name+<span class=\"string\">',A向我们走来了'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> actionA = changeA(name)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;div&gt;&#123;actionA&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div&gt;&#123;children&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候你会发现在浏览器中点击B按钮，A对应的方法都会执行，结果虽然没变，但是每次都执行，这就是性能的损耗。目前只有子组件，业务逻辑也非常简单，如果是一个后台查询，这将产生严重的后果。所以这个问题必须解决。当我们点击B按钮时，对应的changeA方法不能执行，只有在点击A按钮时才能执行。</p>\n<h3 id=\"useMemo-优化性能\"><a href=\"#useMemo-优化性能\" class=\"headerlink\" title=\"useMemo 优化性能\"></a>useMemo 优化性能</h3><p>其实只要使用useMemo，然后给A组件传递第二个参数，参数匹配成功，才会执行。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ChildComponent</span>(<span class=\"params\">&#123;name,children&#125;</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeA</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'来了，来了。A向我们走来了'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name+<span class=\"string\">',A向我们走来了'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> actionA = useMemo(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>changeA(name),[name]) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;div&gt;&#123;actionA&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div&gt;&#123;children&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时在浏览器中点击一下B按钮，changeA就不再执行了。也节省了性能的消耗。案例只是让你更好理解，你还要从程序本身看到优化的作用。好的程序员对自己写的程序都是会进行不断优化的，这种没必要的性能浪费也是绝对不允许的，所以useMemo的使用在工作中还是比较多的。</p>\n<h3 id=\"useMemo和useCallback对比\"><a href=\"#useMemo和useCallback对比\" class=\"headerlink\" title=\"useMemo和useCallback对比\"></a>useMemo和useCallback对比</h3><p>useCallback和useMemo的参数跟useEffect一致，他们之间最大的区别有是useEffect会用于处理副作用，而前两个hooks不能。</p>\n<p>useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。</p>\n<p>useCallback跟useMemo比较类似，但它返回的是缓存的函数。我们看一下最简单的用法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useMemo( <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;fn&#125; ) 等价于 useCallback(fn)</span><br></pre></td></tr></table></figure></p>\n<p>这里就不多介绍了，如有想了解更多关于两者区别，可查找相关资料~</p>\n<h1 id=\"八、useRef获取DOM元素和保存变量\"><a href=\"#八、useRef获取DOM元素和保存变量\" class=\"headerlink\" title=\"八、useRef获取DOM元素和保存变量\"></a>八、useRef获取DOM元素和保存变量</h1><p>useRef在工作中虽然用的不多，但是也不能缺少。它有两个主要的作用:</p>\n<ul>\n<li><p>用useRef获取React JSX中的DOM元素，获取后你就可以控制DOM的任何东西了。但是一般不建议这样来做，React界面的变化可以通过状态来控制。</p>\n</li>\n<li><p>用useRef来保存变量，这个在工作中也很少能用到，我们有了useContext这样的保存其实意义不大，简单的提一下。</p>\n</li>\n</ul>\n<h3 id=\"useRef获取DOM元素\"><a href=\"#useRef获取DOM元素\" class=\"headerlink\" title=\"useRef获取DOM元素\"></a>useRef获取DOM元素</h3><p>界面上有一个文本框，在文本框的旁边有一个按钮，当我们点击按钮时，在控制台打印出input的DOM元素，并进行复制到DOM中的value上。这一切都是通过useRef来实现。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useRef&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> inputEl = useRef(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onButtonClick=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; </span><br><span class=\"line\">        inputEl.current.value=<span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(inputEl) <span class=\"comment\">//输出获取到的DOM节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &#123;<span class=\"comment\">/*保存input的ref到inputEl */</span>&#125;</span><br><span class=\"line\">            &lt;input ref=&#123;inputEl&#125; type=<span class=\"string\">\"text\"</span>/&gt;</span><br><span class=\"line\">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Example</span><br></pre></td></tr></table></figure></p>\n<p>当点击按钮时，你可以看到在浏览器中的控制台完整的打印出了DOM的所有东西，并且界面上的<input>框的value值也输出了我们写好的Hello World。这一切说明我们可以使用useRef获取DOM元素，并且可以通过useRefu控制DOM的属性和值。</p>\n<h3 id=\"useRef保存普通变量\"><a href=\"#useRef保存普通变量\" class=\"headerlink\" title=\"useRef保存普通变量\"></a>useRef保存普通变量</h3><p>这个操作在实际开发中用的并不多，但我们还是要讲解一下。就是useRef可以保存React中的变量。我们这里就写一个文本框，文本框用来改变text状态。又用useRef把text状态进行保存，最后打印在控制台上。写这段代码你会觉的很绕，其实显示开发中没必要这样写，用一个state状态就可以搞定，这里只是为了展示知识点。</p>\n<p>接着上面的代码来写，就没必要重新写一个文件了。先用useState声明了一个text状态和setText函数。然后编写界面，界面就是一个文本框。然后输入的时候不断变化。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useRef ,useState,useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> inputEl = useRef(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onButtonClick=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; </span><br><span class=\"line\">        inputEl.current.value=<span class=\"string\">\"Hello ,useRef\"</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(inputEl)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [text, setText] = useState(<span class=\"string\">'jspang'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &#123;<span class=\"comment\">/*保存input的ref到inputEl */</span>&#125;</span><br><span class=\"line\">            &lt;input ref=&#123;inputEl&#125; type=<span class=\"string\">\"text\"</span>/&gt;</span><br><span class=\"line\">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;br/</span>&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;input value=&#123;text&#125; onChange=&#123;(e)=&gt;&#123;setText(e.target.value)&#125;&#125; /&gt;</span><br><span class=\"line\">         </span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Example</span></span><br></pre></td></tr></table></figure></p>\n<p>这时想每次text发生状态改变，保存到一个变量中或者说是useRef中，这时候就可以使用useRef了。先声明一个textRef变量，他其实就是useRef函数。然后使用useEffect函数实现每次状态变化都进行变量修改，并打印。最后的全部代码如下.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useRef ,useState,useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> inputEl = useRef(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onButtonClick=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; </span><br><span class=\"line\">        inputEl.current.value=<span class=\"string\">\"Hello ,useRef\"</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(inputEl)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//-----------关键代码--------start</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> [text, setText] = useState(<span class=\"string\">'jspang'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> textRef = useRef()</span><br><span class=\"line\"></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        textRef.current = text;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'textRef.current:'</span>, textRef.current)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">//----------关键代码--------------end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &#123;<span class=\"comment\">/*保存input的ref到inputEl */</span>&#125;</span><br><span class=\"line\">            &lt;input ref=&#123;inputEl&#125; type=<span class=\"string\">\"text\"</span>/&gt;</span><br><span class=\"line\">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;br/</span>&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;input value=&#123;text&#125; onChange=&#123;(e)=&gt;&#123;setText(e.target.value)&#125;&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Example</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候就可以实现每次状态修改，同时保存到useRef中了。也就是我们说的保存变量的功能。那useRef的主要功能就是获得DOM和变量保存，我们都已经讲过了。</p>\n<h1 id=\"九、自定义Hooks函数获取窗口大小\"><a href=\"#九、自定义Hooks函数获取窗口大小\" class=\"headerlink\" title=\"九、自定义Hooks函数获取窗口大小\"></a>九、自定义Hooks函数获取窗口大小</h1><p>其实自定义Hooks函数和用Hooks创建组件很相似，跟我们平时用JavaScript写函数几乎一模一样，可能就是多了些React Hooks的特性，自定义Hooks函数偏向于功能，而组件偏向于界面和业务逻辑。由于差别不大，所以使用起来也是很随意的。如果是小型项目是可以的，但是如果项目足够复杂，这会让项目结构不够清晰。所以学习自定义Hooks函数还是很有必要的。</p>\n<h3 id=\"编写自定义函数\"><a href=\"#编写自定义函数\" class=\"headerlink\" title=\"编写自定义函数\"></a>编写自定义函数</h3><p>在实际开发中，为了界面更加美观。获取浏览器窗口的尺寸是一个经常使用的功能，这样经常使用的功能，就可以封装成一个自定义Hooks函数，记住一定要用use开头，这样才能区分出什么是组件，什么是自定义函数。</p>\n<p>编写一个useWinSize,编写时我们会用到useState、useEffect和useCallback所以先用import进行引入。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState ,useEffect ,useCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>然后编写函数，函数中先用useState设置size状态，然后编写一个每次修改状态的方法onResize，这个方法使用useCallback，目的是为了缓存方法(useMemo是为了缓存变量)。 然后在第一次进入方法时用useEffect来注册resize监听时间。为了防止一直监听所以在方法移除时，使用return的方式移除监听。最后返回size变量就可以了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useWinSize</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ size , setSize] = useState(&#123;</span><br><span class=\"line\">        width:<span class=\"built_in\">document</span>.documentElement.clientWidth,</span><br><span class=\"line\">        height:<span class=\"built_in\">document</span>.documentElement.clientHeight</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> onResize = useCallback(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        setSize(&#123;</span><br><span class=\"line\">            width: <span class=\"built_in\">document</span>.documentElement.clientWidth,</span><br><span class=\"line\">            height: <span class=\"built_in\">document</span>.documentElement.clientHeight</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,[]) </span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>,onResize)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'resize'</span>,onResize)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这就是一个自定义函数，其实和我们以前写的JS函数没什么区别，所以这里也不做太多的介绍。</p>\n<h3 id=\"编写组件并使用自定义函数\"><a href=\"#编写组件并使用自定义函数\" class=\"headerlink\" title=\"编写组件并使用自定义函数\"></a>编写组件并使用自定义函数</h3><p>自定义Hooks函数已经写好了，可以直接进行使用，用法和JavaScript的普通函数用起来是一样的。直接在Example组件使用useWinSize并把结果实时展示在页面上。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> size = useWinSize()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;页面Size:&#123;size.width&#125;x&#123;size.height&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Example</span></span><br></pre></td></tr></table></figure></p>\n<p>之后就可以在浏览器中预览一下结果，可以看到当我们放大缩小浏览器窗口时，页面上的结果都会跟着进行变化。说明自定义的函数起到了作用。</p>\n"},{"title":"vuex使用","comments":1,"date":"2019-12-12T16:00:00.000Z","author":"jun.zhou","_content":"\n\n![](https://img.fengjr.com/image/2019/12/16/996bff0793c3475550ae970c45594526.jpg)\n### 前言\n2017年对于Vue注定是不平凡的一年。凭借着自身简介、轻量、快速等特点，Vue俨然成为最火的前端MVVM开发框架。随着Vue2.0的release，越来越多的项目开始采用Vue作为他们的前端框架。而作为Vue生态中最重要的一环，Vuex渐渐进入大家的视野。\n\n数据状态管理模式\n\n在正式开始介绍Vuex之前，有必要介绍一下数据管理模式的前世今生。\n\n当你在开发应用程序时，你一定会分解出很多组件进行开发，而各个组件之间想必在逻辑上多少是有关系的。那么组件之间的“通信”，就成了待解决问题。以前我们试图用事件广播来做，但随之而来的问题是，在应用不断的扩展、变化中，事件变得越来越复杂，越来越不可预料，以至于越来越难调试，越来越难追踪错误。这当然不是我们想要的，我们希望应用的各个部分都易维护、可扩展、好调试、能预测。于是数据管理模式应运而生。\n\n![图1](https://img.fengjr.com/image/2019/12/12/5393db1d0f12db64a970b650fc0bb01c.png)\n图1是最简单的组件关系，b是a的子组件，而c是b的子组件。在我们不引入任何数据管理模式之前，c组件要拿到a组件的数据只能由a先传给b，在由b传给c。如果组件树变得复杂，可想而知这将是一场灾难。看似严谨的父子结构其实严格限制了数据的流动方式。\n\n![图2](https://img.fengjr.com/image/2019/12/12/4e8fc64545bbc98dbbc1b3009d4a973b.png)\n图2是最简单的数据管理模式，所有数据将统一交给全局store来管理。a和c组件现在直接修改store里的数据，并且通过mapState从store中抓取自己感兴趣的数据到自己的组件中。而b组件，如果它对a、c组件的数据毫无兴趣，则可以做到完全解耦。\n\n![图3](https://img.fengjr.com/image/2019/12/12/cd038fa734d54c58068b40bd86c29884.gif)\n随着数据管理的进一步发展和演变，有一种叫单向数据流的东西冒了出来。图3就是一个表示“单向数据流”理念的极简示意。单向数据流要求各组件间的数据走向永远是单向的，可预期的。你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交Actions。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够更好地了解我们的应用。\n\n\n### 一、什么是vuex？\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex背后的基本思想，就是前面所说的单向数据流。图4就是Vuex实现单向数据流的示意图。\n![图4](https://img.fengjr.com/image/2019/12/12/cef1e7181629d335d2d0f179b9adb5ca.gif)\n\n\n### 二、vuex安装及简单使用\n安装命令\n```js\n//npm\nnpm install vuex --save\n//yarn\nyarn add vuex\n```\n新建一个vuex文件夹（这个不是必须的），并在文件夹下新建store.js文件，文件中引入我们的vue和vuex。\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n```\n在vue项目中使用我们vuex，在main.js引入之后用store，然后挂在在vue上，这样所有的组件都能用了。\n```js\nimport Vue from 'vue'\nimport App from './App'\nimport router from './router'\nimport store from './vuex/store.js'\n\nnew Vue({\n  el: '#app',\n  router,\n  store,\n  components: { App },\n  template: '<App/>'\n})\n\n```\n##### vuex五种状态属性\n1、state ——》储存初始化数据（基本数据）\n2、getters ——》对State 里面的数据二次处理（对数据进行过滤类似filter的作用）比如State返回的为一个对象，我们想取对象中一个键的值用这个方法 （基本数据派生的数据）\n3、mutations ——》对数据进行计算的方法全部写在里面（类似computed） 在页面中触发时使用\nthis.$store.commit('mutationName')触发Mutations方法改变state的值 （提交更改数据的方法，同步！ ）\n4、actions ——》 处理Mutations中已经写好的方法 其直接触发方式是 this.$store.dispatch(actionName)（像一个装饰器，包裹mutations，使之可以异步。 ）\n5、modules ——》模块化Vuex\n\n##### 初出茅庐 来个小demo\n1.store.js文件里增加一个常量对象。store.js文件就是我们在引入vuex时的那个文件。\n```js\nconst state={\n    count:1\n}\n```\n2.用export default 封装代码，让外部可以引用。\n```js\nexport default new Vuex.Store({\n    state\n})\n```\n3.新建一个vue的模板，位置在components文件夹下，名字叫demo.vue。在模板中我们引入我们刚建的store.js文件，并在模板中用$store.state.count输出count 的值。\n```html\n<template>\n    <div>\n        <h2>{{msg}}</h2>\n        <hr/>\n        <h3>{{$store.state.count}}</h3>\n    </div>\n</template>\n<script>\n    import store from '@/vuex/store'\n    export default{\n        data(){\n            return{\n                msg:'Hello Vuex',\n\n            }\n        },\n        store\n\n    }\n</script>\n```\n4.在store.js文件中加入两个改变state的方法。\n```js\nconst mutations={\n    add(state){\n        state.count++;\n    },\n    reduce(state){\n        state.count--;\n    }\n}\n```\n这里的mutations是固定的写法，意思是改变的，我们到时候会用一节课专门讲这个mutations，所以你先不用着急，只知道我们要改变state的数值的方法，必须写在mutations里就可以了。\n\n5.demo.vue模板中加入两个按钮，并调用mutations中的方法。\n```html\n<div>\n    <button @click=\"$store.commit('add')\">+</button>\n    <button @click=\"$store.commit('reduce')\">-</button>\n</div>\n```\n这样进行预览就可以实现对vuex中的count进行加减了。\n\n\n### 三、state访问状态对象\nstate即Vuex中的基本数据！\nVuex使用单一状态树，即用一个对象就包含了全部的状态数据。state作为构造器选项，定义了所有我们需要的基本状态参数。\n现在我们主要学习状态对象赋值给内部对象，也就是把stroe.js中的值，赋值给我们模板里data中的值。我们有三种赋值方式\n\n** 一、通过computed的计算属性直接赋值**\ncomputed属性可以在输出前，对data中的值进行改变，我们就利用这种特性把store.js中的state值赋值给我们模板中的data值。\n```js\ncomputed:{\n    count(){\n        return this.$store.state.count;\n    }\n}\n```\n这里需要注意的是return this.$store.state.count这一句，一定要写this，要不你会找不到$store的。这种写法很好理解，但是写起来是比较麻烦的\n** 二、通过mapState的对象来赋值(辅助函数)**\n当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。\n\n我们首先要用import引入mapState。\n```js\nimport {mapState} from 'vuex';\n```\n然后还在computed计算属性里写如下代码：\n```js\ncomputed:mapState({\n    count:state=>state.count\n})\n\n//对象展开运算符\ncomputed: {\n    ...mapState(['count']),\n}\n```\n** 三、通过mapState的数组来赋值 **\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。\n```js\ncomputed:mapState([\"count\"])\n```\n这个算是最简单的写法了，在实际项目开发当中也经常这样使用。\n\n### 四、Mutations修改状态\n提交mutation是更改Vuex中的store中的状态的唯一方法。\n\nmutation必须是同步的，如果要异步需要使用action。\n\n每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    //无提交荷载\n    increment(state) {\n        state.count++\n    }\n    //提交荷载\n    incrementN(state, obj) {\n      state.count += obj.n\n    }\n  }\n})\n\n//无提交荷载\nstore.commit('increment')\n//提交荷载\nstore.commit('incrementN', {\n    n: 100\n})\n```\n\n** $store.commit( ) **\nVuex提供了commit方法来修改状态，我们在button上的修改方法。\n```html\n<button @click=\"$store.commit('add')\">+</button>\n<button @click=\"$store.commit('reduce')\">-</button>\n```\nstore.js文件\n```js\nconst mutations={\n    add(state){\n        state.count++;\n    },\n    reduce(state){\n        state.count--;\n    }\n}\n```\n*传值： *\n这只是一个最简单的修改状态的操作，在实际项目中我们常常需要在修改状态时传值。比如上边的例子，是我们每次只加1，而现在我们要通过所传的值进行相加。其实我们只需要在Mutations里再加上一个参数，并在commit的时候传递就就可以了。我们来看具体代码：\n现在store.js文件里给add方法加上一个参数n。\n```js\nconst mutations={\n    add(state,n){\n        state.count+=n;\n    },\n    reduce(state){\n        state.count--;\n    }\n}\n```\n在demo.vue里修改按钮的commit( )方法传递的参数，我们传递10，意思就是每次加10.\n```html\n<p>\n   <button @click=\"$store.commit('add',10)\">+</button>\n   <button @click=\"$store.commit('reduce')\">-</button>\n</p>\n```\n这样两个简单的修改我们就完成了传值\n** 模板获取Mutations方法(辅助函数) **\n实际开发中我们也不喜欢看到$store.commit( )这样的方法出现，我们希望跟调用模板里的方法一样调用。\n\n例如：@click=”reduce” 就和没引用vuex插件一样。\n\n要达到这种写法，只需要简单的两部就可以了：\n\n1.在模板demo.vue里用import 引入我们的mapMutations：\n```js\nimport { mapState,mapMutations } from 'vuex';\n```\n2.在模板的script标签里添加methods属性，并加入mapMutations\n```js\nmethods:mapMutations([\n    'add','reduce'\n])\n```\n通过上边两步，我们已经可以在模板中直接使用我们的reduce或者add方法了，就像下面这样。\n```html\n<button @click=\"reduce\">-</button>\n```\n### 五、getters计算过滤操作\n即从store的state中派生出的状态。\ngetters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工\ngetters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：\n```js\nconst store = new Vuex.Store({\n    state: {\n        count:0\n    }，\n    getters: {\n        // 单个参数\n        countDouble: function(state){\n            return state.count * 2\n        },\n        // 两个参数\n        countDoubleAndDouble: function(state, getters) {\n            return getters.countDouble * 2\n        }\n    }\n})\n```\n** getters基本用法：**\n比如我们现在要对store.js文件中的count进行一个计算属性的操作，就是在它输出前，给它加上100.\n\n我们首先要在store.js里用const声明我们的getters属性。\n```js\nconst getters = {\n    count:function(state){\n        return state.count +=100;\n    }\n}\n```\n写好了gettters之后，我们还需要在Vuex.Store()里引入，由于之前我们已经引入了state盒mutations，所以引入里有三个引入属性。代码如下，\n```js\nexport default new Vuex.Store({\n    state,mutations,getters\n})\n```\n在store.js里的配置算是完成了，我们需要到模板页对computed进行配置。在vue 的构造器里边只能有一个computed属性，如果你写多个，只有最后一个computed属性可用，所以要对上节课写的computed属性进行一个改造。改造时我们使用ES6中的展开运算符”…”。\n```js\ncomputed:{\n    ...mapState([\"count\"]),\n    count(){\n        return this.$store.getters.count;\n    }\n}\n```\n需要注意的是，你写了这个配置后，在每次count 的值发生变化的时候，都会进行加100的操作。\n** 用mapGetters简化模板写法： **\n我们都知道state和mutations都有map的引用方法把我们模板中的编码进行简化，我们的getters也是有的，我们来看一下代码。\n\n首先用import引入我们的`mapGetters\n```js\nimport { mapState,mapMutations,mapGetters } from 'vuex';\n```\n在computed属性中加入mapGetters\n```js\n...mapGetters([\"count\"])\n```\n\n### 六、Action异步修改状态\nAction 类似于 mutation，不同在于：\nAction 是异步的改变state状态，而Mutations是同步改变状态。\nAction 提交的是 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\n\n在store.js中声明actions actions是可以调用Mutations里的方法的，在actions里调用add和reduce两个方法。\n```js\nconst actions ={\n    addAction(context){\n        context.commit('add',10)\n    },\n    reduceAction({commit}){\n        commit('reduce')\n    }\n}\n```\n在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations里边的方法。我们会发现这两个方法传递的参数也不一样。\n- context：上下文对象，这里你可以理解称store本身。\n- {commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。\n** 模板中的使用** \n我们需要在demo.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的actions里的方法名，分别是：addAction和reduceAction。\n```html\n<p>\n  <button @click=\"addAction\">+</button>\n  <button @click=\"reduceAction\">-</button>\n</p>\n```\n改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。\n```js\nmethods:{\n    ...mapMutations([  \n        'add','reduce'\n    ]),\n    ...mapActions(['addAction','reduceAction'])\n}\n```\n你还要记得用import把我们的mapActions引入才可以使用。\n** 增加异步检验 ** \n我们现在看的效果和我们用Mutations作的一模一样，那actions有什么用\b呢，我们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用setTimeOut进行延迟执行。\n```js\nsetTimeOut(()=>{context.commit(reduce)},3000);\nconsole.log('我比reduce提前执行');\n```\n我们可以看到在控制台先打印出了‘我比reduce提前执行’这句话。\n\n### 七、module模块组\n随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。\n\n使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。\n\n为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n** 声明模块组： **\n在vuex/store.js中声明模块组，我们还是用我们的const常量的方法声明模块组。代码如下：\n```js\nconst moduleA={\n    state,mutations,getters,actions\n}\n```\n声明好后，我们需要修改原来 Vuex.Stroe里的值：\n```js\nexport default new Vuex.Store({\n    modules:{a:moduleA}\n})\n```\n** 在模板中使用 **\n现在我们要在模板中使用count状态，要用插值的形式写入。\n```html\n<h3>{{$store.state.a.count}}</h3>\n```\n如果想用简单的方法引入，还是要在我们的计算属性中rutrun我们的状态。写法如下：\n```js\ncomputed:{\n    count(){\n        return this.$store.state.a.count;\n    }\n}\n```","source":"_posts/2019-12-13-Vuex使用.md","raw":"---\ntitle: vuex使用\ncomments: true\ndate: 2019-12-13\ntags:\n- vue vuex\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n\n![](https://img.fengjr.com/image/2019/12/16/996bff0793c3475550ae970c45594526.jpg)\n### 前言\n2017年对于Vue注定是不平凡的一年。凭借着自身简介、轻量、快速等特点，Vue俨然成为最火的前端MVVM开发框架。随着Vue2.0的release，越来越多的项目开始采用Vue作为他们的前端框架。而作为Vue生态中最重要的一环，Vuex渐渐进入大家的视野。\n\n数据状态管理模式\n\n在正式开始介绍Vuex之前，有必要介绍一下数据管理模式的前世今生。\n\n当你在开发应用程序时，你一定会分解出很多组件进行开发，而各个组件之间想必在逻辑上多少是有关系的。那么组件之间的“通信”，就成了待解决问题。以前我们试图用事件广播来做，但随之而来的问题是，在应用不断的扩展、变化中，事件变得越来越复杂，越来越不可预料，以至于越来越难调试，越来越难追踪错误。这当然不是我们想要的，我们希望应用的各个部分都易维护、可扩展、好调试、能预测。于是数据管理模式应运而生。\n\n![图1](https://img.fengjr.com/image/2019/12/12/5393db1d0f12db64a970b650fc0bb01c.png)\n图1是最简单的组件关系，b是a的子组件，而c是b的子组件。在我们不引入任何数据管理模式之前，c组件要拿到a组件的数据只能由a先传给b，在由b传给c。如果组件树变得复杂，可想而知这将是一场灾难。看似严谨的父子结构其实严格限制了数据的流动方式。\n\n![图2](https://img.fengjr.com/image/2019/12/12/4e8fc64545bbc98dbbc1b3009d4a973b.png)\n图2是最简单的数据管理模式，所有数据将统一交给全局store来管理。a和c组件现在直接修改store里的数据，并且通过mapState从store中抓取自己感兴趣的数据到自己的组件中。而b组件，如果它对a、c组件的数据毫无兴趣，则可以做到完全解耦。\n\n![图3](https://img.fengjr.com/image/2019/12/12/cd038fa734d54c58068b40bd86c29884.gif)\n随着数据管理的进一步发展和演变，有一种叫单向数据流的东西冒了出来。图3就是一个表示“单向数据流”理念的极简示意。单向数据流要求各组件间的数据走向永远是单向的，可预期的。你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交Actions。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够更好地了解我们的应用。\n\n\n### 一、什么是vuex？\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex背后的基本思想，就是前面所说的单向数据流。图4就是Vuex实现单向数据流的示意图。\n![图4](https://img.fengjr.com/image/2019/12/12/cef1e7181629d335d2d0f179b9adb5ca.gif)\n\n\n### 二、vuex安装及简单使用\n安装命令\n```js\n//npm\nnpm install vuex --save\n//yarn\nyarn add vuex\n```\n新建一个vuex文件夹（这个不是必须的），并在文件夹下新建store.js文件，文件中引入我们的vue和vuex。\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n```\n在vue项目中使用我们vuex，在main.js引入之后用store，然后挂在在vue上，这样所有的组件都能用了。\n```js\nimport Vue from 'vue'\nimport App from './App'\nimport router from './router'\nimport store from './vuex/store.js'\n\nnew Vue({\n  el: '#app',\n  router,\n  store,\n  components: { App },\n  template: '<App/>'\n})\n\n```\n##### vuex五种状态属性\n1、state ——》储存初始化数据（基本数据）\n2、getters ——》对State 里面的数据二次处理（对数据进行过滤类似filter的作用）比如State返回的为一个对象，我们想取对象中一个键的值用这个方法 （基本数据派生的数据）\n3、mutations ——》对数据进行计算的方法全部写在里面（类似computed） 在页面中触发时使用\nthis.$store.commit('mutationName')触发Mutations方法改变state的值 （提交更改数据的方法，同步！ ）\n4、actions ——》 处理Mutations中已经写好的方法 其直接触发方式是 this.$store.dispatch(actionName)（像一个装饰器，包裹mutations，使之可以异步。 ）\n5、modules ——》模块化Vuex\n\n##### 初出茅庐 来个小demo\n1.store.js文件里增加一个常量对象。store.js文件就是我们在引入vuex时的那个文件。\n```js\nconst state={\n    count:1\n}\n```\n2.用export default 封装代码，让外部可以引用。\n```js\nexport default new Vuex.Store({\n    state\n})\n```\n3.新建一个vue的模板，位置在components文件夹下，名字叫demo.vue。在模板中我们引入我们刚建的store.js文件，并在模板中用$store.state.count输出count 的值。\n```html\n<template>\n    <div>\n        <h2>{{msg}}</h2>\n        <hr/>\n        <h3>{{$store.state.count}}</h3>\n    </div>\n</template>\n<script>\n    import store from '@/vuex/store'\n    export default{\n        data(){\n            return{\n                msg:'Hello Vuex',\n\n            }\n        },\n        store\n\n    }\n</script>\n```\n4.在store.js文件中加入两个改变state的方法。\n```js\nconst mutations={\n    add(state){\n        state.count++;\n    },\n    reduce(state){\n        state.count--;\n    }\n}\n```\n这里的mutations是固定的写法，意思是改变的，我们到时候会用一节课专门讲这个mutations，所以你先不用着急，只知道我们要改变state的数值的方法，必须写在mutations里就可以了。\n\n5.demo.vue模板中加入两个按钮，并调用mutations中的方法。\n```html\n<div>\n    <button @click=\"$store.commit('add')\">+</button>\n    <button @click=\"$store.commit('reduce')\">-</button>\n</div>\n```\n这样进行预览就可以实现对vuex中的count进行加减了。\n\n\n### 三、state访问状态对象\nstate即Vuex中的基本数据！\nVuex使用单一状态树，即用一个对象就包含了全部的状态数据。state作为构造器选项，定义了所有我们需要的基本状态参数。\n现在我们主要学习状态对象赋值给内部对象，也就是把stroe.js中的值，赋值给我们模板里data中的值。我们有三种赋值方式\n\n** 一、通过computed的计算属性直接赋值**\ncomputed属性可以在输出前，对data中的值进行改变，我们就利用这种特性把store.js中的state值赋值给我们模板中的data值。\n```js\ncomputed:{\n    count(){\n        return this.$store.state.count;\n    }\n}\n```\n这里需要注意的是return this.$store.state.count这一句，一定要写this，要不你会找不到$store的。这种写法很好理解，但是写起来是比较麻烦的\n** 二、通过mapState的对象来赋值(辅助函数)**\n当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。\n\n我们首先要用import引入mapState。\n```js\nimport {mapState} from 'vuex';\n```\n然后还在computed计算属性里写如下代码：\n```js\ncomputed:mapState({\n    count:state=>state.count\n})\n\n//对象展开运算符\ncomputed: {\n    ...mapState(['count']),\n}\n```\n** 三、通过mapState的数组来赋值 **\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。\n```js\ncomputed:mapState([\"count\"])\n```\n这个算是最简单的写法了，在实际项目开发当中也经常这样使用。\n\n### 四、Mutations修改状态\n提交mutation是更改Vuex中的store中的状态的唯一方法。\n\nmutation必须是同步的，如果要异步需要使用action。\n\n每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    //无提交荷载\n    increment(state) {\n        state.count++\n    }\n    //提交荷载\n    incrementN(state, obj) {\n      state.count += obj.n\n    }\n  }\n})\n\n//无提交荷载\nstore.commit('increment')\n//提交荷载\nstore.commit('incrementN', {\n    n: 100\n})\n```\n\n** $store.commit( ) **\nVuex提供了commit方法来修改状态，我们在button上的修改方法。\n```html\n<button @click=\"$store.commit('add')\">+</button>\n<button @click=\"$store.commit('reduce')\">-</button>\n```\nstore.js文件\n```js\nconst mutations={\n    add(state){\n        state.count++;\n    },\n    reduce(state){\n        state.count--;\n    }\n}\n```\n*传值： *\n这只是一个最简单的修改状态的操作，在实际项目中我们常常需要在修改状态时传值。比如上边的例子，是我们每次只加1，而现在我们要通过所传的值进行相加。其实我们只需要在Mutations里再加上一个参数，并在commit的时候传递就就可以了。我们来看具体代码：\n现在store.js文件里给add方法加上一个参数n。\n```js\nconst mutations={\n    add(state,n){\n        state.count+=n;\n    },\n    reduce(state){\n        state.count--;\n    }\n}\n```\n在demo.vue里修改按钮的commit( )方法传递的参数，我们传递10，意思就是每次加10.\n```html\n<p>\n   <button @click=\"$store.commit('add',10)\">+</button>\n   <button @click=\"$store.commit('reduce')\">-</button>\n</p>\n```\n这样两个简单的修改我们就完成了传值\n** 模板获取Mutations方法(辅助函数) **\n实际开发中我们也不喜欢看到$store.commit( )这样的方法出现，我们希望跟调用模板里的方法一样调用。\n\n例如：@click=”reduce” 就和没引用vuex插件一样。\n\n要达到这种写法，只需要简单的两部就可以了：\n\n1.在模板demo.vue里用import 引入我们的mapMutations：\n```js\nimport { mapState,mapMutations } from 'vuex';\n```\n2.在模板的script标签里添加methods属性，并加入mapMutations\n```js\nmethods:mapMutations([\n    'add','reduce'\n])\n```\n通过上边两步，我们已经可以在模板中直接使用我们的reduce或者add方法了，就像下面这样。\n```html\n<button @click=\"reduce\">-</button>\n```\n### 五、getters计算过滤操作\n即从store的state中派生出的状态。\ngetters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工\ngetters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：\n```js\nconst store = new Vuex.Store({\n    state: {\n        count:0\n    }，\n    getters: {\n        // 单个参数\n        countDouble: function(state){\n            return state.count * 2\n        },\n        // 两个参数\n        countDoubleAndDouble: function(state, getters) {\n            return getters.countDouble * 2\n        }\n    }\n})\n```\n** getters基本用法：**\n比如我们现在要对store.js文件中的count进行一个计算属性的操作，就是在它输出前，给它加上100.\n\n我们首先要在store.js里用const声明我们的getters属性。\n```js\nconst getters = {\n    count:function(state){\n        return state.count +=100;\n    }\n}\n```\n写好了gettters之后，我们还需要在Vuex.Store()里引入，由于之前我们已经引入了state盒mutations，所以引入里有三个引入属性。代码如下，\n```js\nexport default new Vuex.Store({\n    state,mutations,getters\n})\n```\n在store.js里的配置算是完成了，我们需要到模板页对computed进行配置。在vue 的构造器里边只能有一个computed属性，如果你写多个，只有最后一个computed属性可用，所以要对上节课写的computed属性进行一个改造。改造时我们使用ES6中的展开运算符”…”。\n```js\ncomputed:{\n    ...mapState([\"count\"]),\n    count(){\n        return this.$store.getters.count;\n    }\n}\n```\n需要注意的是，你写了这个配置后，在每次count 的值发生变化的时候，都会进行加100的操作。\n** 用mapGetters简化模板写法： **\n我们都知道state和mutations都有map的引用方法把我们模板中的编码进行简化，我们的getters也是有的，我们来看一下代码。\n\n首先用import引入我们的`mapGetters\n```js\nimport { mapState,mapMutations,mapGetters } from 'vuex';\n```\n在computed属性中加入mapGetters\n```js\n...mapGetters([\"count\"])\n```\n\n### 六、Action异步修改状态\nAction 类似于 mutation，不同在于：\nAction 是异步的改变state状态，而Mutations是同步改变状态。\nAction 提交的是 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\n\n在store.js中声明actions actions是可以调用Mutations里的方法的，在actions里调用add和reduce两个方法。\n```js\nconst actions ={\n    addAction(context){\n        context.commit('add',10)\n    },\n    reduceAction({commit}){\n        commit('reduce')\n    }\n}\n```\n在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations里边的方法。我们会发现这两个方法传递的参数也不一样。\n- context：上下文对象，这里你可以理解称store本身。\n- {commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。\n** 模板中的使用** \n我们需要在demo.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的actions里的方法名，分别是：addAction和reduceAction。\n```html\n<p>\n  <button @click=\"addAction\">+</button>\n  <button @click=\"reduceAction\">-</button>\n</p>\n```\n改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。\n```js\nmethods:{\n    ...mapMutations([  \n        'add','reduce'\n    ]),\n    ...mapActions(['addAction','reduceAction'])\n}\n```\n你还要记得用import把我们的mapActions引入才可以使用。\n** 增加异步检验 ** \n我们现在看的效果和我们用Mutations作的一模一样，那actions有什么用\b呢，我们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用setTimeOut进行延迟执行。\n```js\nsetTimeOut(()=>{context.commit(reduce)},3000);\nconsole.log('我比reduce提前执行');\n```\n我们可以看到在控制台先打印出了‘我比reduce提前执行’这句话。\n\n### 七、module模块组\n随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。\n\n使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。\n\n为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n** 声明模块组： **\n在vuex/store.js中声明模块组，我们还是用我们的const常量的方法声明模块组。代码如下：\n```js\nconst moduleA={\n    state,mutations,getters,actions\n}\n```\n声明好后，我们需要修改原来 Vuex.Stroe里的值：\n```js\nexport default new Vuex.Store({\n    modules:{a:moduleA}\n})\n```\n** 在模板中使用 **\n现在我们要在模板中使用count状态，要用插值的形式写入。\n```html\n<h3>{{$store.state.a.count}}</h3>\n```\n如果想用简单的方法引入，还是要在我们的计算属性中rutrun我们的状态。写法如下：\n```js\ncomputed:{\n    count(){\n        return this.$store.state.a.count;\n    }\n}\n```","slug":"Vuex使用","published":1,"updated":"2020-06-10T06:01:35.895Z","_id":"ck4249zag00044aq61xceapmh","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/12/16/996bff0793c3475550ae970c45594526.jpg\" alt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>2017年对于Vue注定是不平凡的一年。凭借着自身简介、轻量、快速等特点，Vue俨然成为最火的前端MVVM开发框架。随着Vue2.0的release，越来越多的项目开始采用Vue作为他们的前端框架。而作为Vue生态中最重要的一环，Vuex渐渐进入大家的视野。</p>\n<p>数据状态管理模式</p>\n<p>在正式开始介绍Vuex之前，有必要介绍一下数据管理模式的前世今生。</p>\n<p>当你在开发应用程序时，你一定会分解出很多组件进行开发，而各个组件之间想必在逻辑上多少是有关系的。那么组件之间的“通信”，就成了待解决问题。以前我们试图用事件广播来做，但随之而来的问题是，在应用不断的扩展、变化中，事件变得越来越复杂，越来越不可预料，以至于越来越难调试，越来越难追踪错误。这当然不是我们想要的，我们希望应用的各个部分都易维护、可扩展、好调试、能预测。于是数据管理模式应运而生。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/12/12/5393db1d0f12db64a970b650fc0bb01c.png\" alt=\"图1\"><br>图1是最简单的组件关系，b是a的子组件，而c是b的子组件。在我们不引入任何数据管理模式之前，c组件要拿到a组件的数据只能由a先传给b，在由b传给c。如果组件树变得复杂，可想而知这将是一场灾难。看似严谨的父子结构其实严格限制了数据的流动方式。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/12/12/4e8fc64545bbc98dbbc1b3009d4a973b.png\" alt=\"图2\"><br>图2是最简单的数据管理模式，所有数据将统一交给全局store来管理。a和c组件现在直接修改store里的数据，并且通过mapState从store中抓取自己感兴趣的数据到自己的组件中。而b组件，如果它对a、c组件的数据毫无兴趣，则可以做到完全解耦。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/12/12/cd038fa734d54c58068b40bd86c29884.gif\" alt=\"图3\"><br>随着数据管理的进一步发展和演变，有一种叫单向数据流的东西冒了出来。图3就是一个表示“单向数据流”理念的极简示意。单向数据流要求各组件间的数据走向永远是单向的，可预期的。你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交Actions。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够更好地了解我们的应用。</p>\n<h3 id=\"一、什么是vuex？\"><a href=\"#一、什么是vuex？\" class=\"headerlink\" title=\"一、什么是vuex？\"></a>一、什么是vuex？</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex背后的基本思想，就是前面所说的单向数据流。图4就是Vuex实现单向数据流的示意图。<br><img src=\"https://img.fengjr.com/image/2019/12/12/cef1e7181629d335d2d0f179b9adb5ca.gif\" alt=\"图4\"></p>\n<h3 id=\"二、vuex安装及简单使用\"><a href=\"#二、vuex安装及简单使用\" class=\"headerlink\" title=\"二、vuex安装及简单使用\"></a>二、vuex安装及简单使用</h3><p>安装命令<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//npm</span></span><br><span class=\"line\">npm install vuex --save</span><br><span class=\"line\"><span class=\"comment\">//yarn</span></span><br><span class=\"line\">yarn add vuex</span><br></pre></td></tr></table></figure></p>\n<p>新建一个vuex文件夹（这个不是必须的），并在文件夹下新建store.js文件，文件中引入我们的vue和vuex。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex);</span><br></pre></td></tr></table></figure></p>\n<p>在vue项目中使用我们vuex，在main.js引入之后用store，然后挂在在vue上，这样所有的组件都能用了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./vuex/store.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  store,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;App/&gt;'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"vuex五种状态属性\"><a href=\"#vuex五种状态属性\" class=\"headerlink\" title=\"vuex五种状态属性\"></a>vuex五种状态属性</h5><p>1、state ——》储存初始化数据（基本数据）<br>2、getters ——》对State 里面的数据二次处理（对数据进行过滤类似filter的作用）比如State返回的为一个对象，我们想取对象中一个键的值用这个方法 （基本数据派生的数据）<br>3、mutations ——》对数据进行计算的方法全部写在里面（类似computed） 在页面中触发时使用<br>this.$store.commit(‘mutationName’)触发Mutations方法改变state的值 （提交更改数据的方法，同步！ ）<br>4、actions ——》 处理Mutations中已经写好的方法 其直接触发方式是 this.$store.dispatch(actionName)（像一个装饰器，包裹mutations，使之可以异步。 ）<br>5、modules ——》模块化Vuex</p>\n<h5 id=\"初出茅庐-来个小demo\"><a href=\"#初出茅庐-来个小demo\" class=\"headerlink\" title=\"初出茅庐 来个小demo\"></a>初出茅庐 来个小demo</h5><p>1.store.js文件里增加一个常量对象。store.js文件就是我们在引入vuex时的那个文件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state=&#123;</span><br><span class=\"line\">    count:<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.用export default 封装代码，让外部可以引用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    state</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>3.新建一个vue的模板，位置在components文件夹下，名字叫demo.vue。在模板中我们引入我们刚建的store.js文件，并在模板中用$store.state.count输出count 的值。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">hr</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>&#123;&#123;$store.state.count&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'@/vuex/store'</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span>&#123;</span></span><br><span class=\"line\">        data()&#123;</span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                msg:<span class=\"string\">'Hello Vuex'</span>,</span></span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        store</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>4.在store.js文件中加入两个改变state的方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mutations=&#123;</span><br><span class=\"line\">    add(state)&#123;</span><br><span class=\"line\">        state.count++;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    reduce(state)&#123;</span><br><span class=\"line\">        state.count--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的mutations是固定的写法，意思是改变的，我们到时候会用一节课专门讲这个mutations，所以你先不用着急，只知道我们要改变state的数值的方法，必须写在mutations里就可以了。</p>\n<p>5.demo.vue模板中加入两个按钮，并调用mutations中的方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('add')\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('reduce')\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这样进行预览就可以实现对vuex中的count进行加减了。</p>\n<h3 id=\"三、state访问状态对象\"><a href=\"#三、state访问状态对象\" class=\"headerlink\" title=\"三、state访问状态对象\"></a>三、state访问状态对象</h3><p>state即Vuex中的基本数据！<br>Vuex使用单一状态树，即用一个对象就包含了全部的状态数据。state作为构造器选项，定义了所有我们需要的基本状态参数。<br>现在我们主要学习状态对象赋值给内部对象，也就是把stroe.js中的值，赋值给我们模板里data中的值。我们有三种赋值方式</p>\n<p><strong> 一、通过computed的计算属性直接赋值</strong><br>computed属性可以在输出前，对data中的值进行改变，我们就利用这种特性把store.js中的state值赋值给我们模板中的data值。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    count()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意的是return this.$store.state.count这一句，一定要写this，要不你会找不到$store的。这种写法很好理解，但是写起来是比较麻烦的<br><strong> 二、通过mapState的对象来赋值(辅助函数)</strong><br>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。</p>\n<p>我们首先要用import引入mapState。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;mapState&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>然后还在computed计算属性里写如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:mapState(&#123;</span><br><span class=\"line\">    count:<span class=\"function\"><span class=\"params\">state</span>=&gt;</span>state.count</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对象展开运算符</span></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    ...mapState([<span class=\"string\">'count'</span>]),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong> 三、通过mapState的数组来赋值 </strong><br>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:mapState([<span class=\"string\">\"count\"</span>])</span><br></pre></td></tr></table></figure></p>\n<p>这个算是最简单的写法了，在实际项目开发当中也经常这样使用。</p>\n<h3 id=\"四、Mutations修改状态\"><a href=\"#四、Mutations修改状态\" class=\"headerlink\" title=\"四、Mutations修改状态\"></a>四、Mutations修改状态</h3><p>提交mutation是更改Vuex中的store中的状态的唯一方法。</p>\n<p>mutation必须是同步的，如果要异步需要使用action。</p>\n<p>每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//无提交荷载</span></span><br><span class=\"line\">    increment(state) &#123;</span><br><span class=\"line\">        state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//提交荷载</span></span><br><span class=\"line\">    incrementN(state, obj) &#123;</span><br><span class=\"line\">      state.count += obj.n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//无提交荷载</span></span><br><span class=\"line\">store.commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\"><span class=\"comment\">//提交荷载</span></span><br><span class=\"line\">store.commit(<span class=\"string\">'incrementN'</span>, &#123;</span><br><span class=\"line\">    n: <span class=\"number\">100</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> $store.commit( ) </strong><br>Vuex提供了commit方法来修改状态，我们在button上的修改方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('add')\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('reduce')\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>store.js文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mutations=&#123;</span><br><span class=\"line\">    add(state)&#123;</span><br><span class=\"line\">        state.count++;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    reduce(state)&#123;</span><br><span class=\"line\">        state.count--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>传值： </em><br>这只是一个最简单的修改状态的操作，在实际项目中我们常常需要在修改状态时传值。比如上边的例子，是我们每次只加1，而现在我们要通过所传的值进行相加。其实我们只需要在Mutations里再加上一个参数，并在commit的时候传递就就可以了。我们来看具体代码：<br>现在store.js文件里给add方法加上一个参数n。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mutations=&#123;</span><br><span class=\"line\">    add(state,n)&#123;</span><br><span class=\"line\">        state.count+=n;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    reduce(state)&#123;</span><br><span class=\"line\">        state.count--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在demo.vue里修改按钮的commit( )方法传递的参数，我们传递10，意思就是每次加10.<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('add',10)\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('reduce')\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这样两个简单的修改我们就完成了传值<br><strong> 模板获取Mutations方法(辅助函数) </strong><br>实际开发中我们也不喜欢看到$store.commit( )这样的方法出现，我们希望跟调用模板里的方法一样调用。</p>\n<p>例如：@click=”reduce” 就和没引用vuex插件一样。</p>\n<p>要达到这种写法，只需要简单的两部就可以了：</p>\n<p>1.在模板demo.vue里用import 引入我们的mapMutations：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState,mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>2.在模板的script标签里添加methods属性，并加入mapMutations<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:mapMutations([</span><br><span class=\"line\">    <span class=\"string\">'add'</span>,<span class=\"string\">'reduce'</span></span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure></p>\n<p>通过上边两步，我们已经可以在模板中直接使用我们的reduce或者add方法了，就像下面这样。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"reduce\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、getters计算过滤操作\"><a href=\"#五、getters计算过滤操作\" class=\"headerlink\" title=\"五、getters计算过滤操作\"></a>五、getters计算过滤操作</h3><p>即从store的state中派生出的状态。<br>getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工<br>getters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    state: &#123;</span><br><span class=\"line\">        count:<span class=\"number\">0</span></span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    getters: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单个参数</span></span><br><span class=\"line\">        countDouble: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state.count * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">// 两个参数</span></span><br><span class=\"line\">        countDoubleAndDouble: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state, getters</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getters.countDouble * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> getters基本用法：</strong><br>比如我们现在要对store.js文件中的count进行一个计算属性的操作，就是在它输出前，给它加上100.</p>\n<p>我们首先要在store.js里用const声明我们的getters属性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getters = &#123;</span><br><span class=\"line\">    count:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state.count +=<span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>写好了gettters之后，我们还需要在Vuex.Store()里引入，由于之前我们已经引入了state盒mutations，所以引入里有三个引入属性。代码如下，<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    state,mutations,getters</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在store.js里的配置算是完成了，我们需要到模板页对computed进行配置。在vue 的构造器里边只能有一个computed属性，如果你写多个，只有最后一个computed属性可用，所以要对上节课写的computed属性进行一个改造。改造时我们使用ES6中的展开运算符”…”。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    ...mapState([<span class=\"string\">\"count\"</span>]),</span><br><span class=\"line\">    count()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，你写了这个配置后，在每次count 的值发生变化的时候，都会进行加100的操作。<br><strong> 用mapGetters简化模板写法： </strong><br>我们都知道state和mutations都有map的引用方法把我们模板中的编码进行简化，我们的getters也是有的，我们来看一下代码。</p>\n<p>首先用import引入我们的`mapGetters<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState,mapMutations,mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>在computed属性中加入mapGetters<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...mapGetters([<span class=\"string\">\"count\"</span>])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"六、Action异步修改状态\"><a href=\"#六、Action异步修改状态\" class=\"headerlink\" title=\"六、Action异步修改状态\"></a>六、Action异步修改状态</h3><p>Action 类似于 mutation，不同在于：<br>Action 是异步的改变state状态，而Mutations是同步改变状态。<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。</p>\n<p>在store.js中声明actions actions是可以调用Mutations里的方法的，在actions里调用add和reduce两个方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> actions =&#123;</span><br><span class=\"line\">    addAction(context)&#123;</span><br><span class=\"line\">        context.commit(<span class=\"string\">'add'</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    reduceAction(&#123;commit&#125;)&#123;</span><br><span class=\"line\">        commit(<span class=\"string\">'reduce'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations里边的方法。我们会发现这两个方法传递的参数也不一样。</p>\n<ul>\n<li>context：上下文对象，这里你可以理解称store本身。</li>\n<li>{commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。<br><strong> 模板中的使用</strong><br>我们需要在demo.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的actions里的方法名，分别是：addAction和reduceAction。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"addAction\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"reduceAction\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    ...mapMutations([  </span><br><span class=\"line\">        <span class=\"string\">'add'</span>,<span class=\"string\">'reduce'</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions([<span class=\"string\">'addAction'</span>,<span class=\"string\">'reduceAction'</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你还要记得用import把我们的mapActions引入才可以使用。<br><strong> 增加异步检验 </strong><br>我们现在看的效果和我们用Mutations作的一模一样，那actions有什么用\b呢，我们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用setTimeOut进行延迟执行。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeOut(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;context.commit(reduce)&#125;,<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'我比reduce提前执行'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到在控制台先打印出了‘我比reduce提前执行’这句话。</p>\n<h3 id=\"七、module模块组\"><a href=\"#七、module模块组\" class=\"headerlink\" title=\"七、module模块组\"></a>七、module模块组</h3><p>随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。</p>\n<p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure></p>\n<p><strong> 声明模块组： </strong><br>在vuex/store.js中声明模块组，我们还是用我们的const常量的方法声明模块组。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA=&#123;</span><br><span class=\"line\">    state,mutations,getters,actions</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明好后，我们需要修改原来 Vuex.Stroe里的值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    modules:&#123;<span class=\"attr\">a</span>:moduleA&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> 在模板中使用 </strong><br>现在我们要在模板中使用count状态，要用插值的形式写入。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>&#123;&#123;$store.state.a.count&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果想用简单的方法引入，还是要在我们的计算属性中rutrun我们的状态。写法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    count()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.a.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/12/16/996bff0793c3475550ae970c45594526.jpg\" alt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>2017年对于Vue注定是不平凡的一年。凭借着自身简介、轻量、快速等特点，Vue俨然成为最火的前端MVVM开发框架。随着Vue2.0的release，越来越多的项目开始采用Vue作为他们的前端框架。而作为Vue生态中最重要的一环，Vuex渐渐进入大家的视野。</p>\n<p>数据状态管理模式</p>\n<p>在正式开始介绍Vuex之前，有必要介绍一下数据管理模式的前世今生。</p>\n<p>当你在开发应用程序时，你一定会分解出很多组件进行开发，而各个组件之间想必在逻辑上多少是有关系的。那么组件之间的“通信”，就成了待解决问题。以前我们试图用事件广播来做，但随之而来的问题是，在应用不断的扩展、变化中，事件变得越来越复杂，越来越不可预料，以至于越来越难调试，越来越难追踪错误。这当然不是我们想要的，我们希望应用的各个部分都易维护、可扩展、好调试、能预测。于是数据管理模式应运而生。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/12/12/5393db1d0f12db64a970b650fc0bb01c.png\" alt=\"图1\"><br>图1是最简单的组件关系，b是a的子组件，而c是b的子组件。在我们不引入任何数据管理模式之前，c组件要拿到a组件的数据只能由a先传给b，在由b传给c。如果组件树变得复杂，可想而知这将是一场灾难。看似严谨的父子结构其实严格限制了数据的流动方式。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/12/12/4e8fc64545bbc98dbbc1b3009d4a973b.png\" alt=\"图2\"><br>图2是最简单的数据管理模式，所有数据将统一交给全局store来管理。a和c组件现在直接修改store里的数据，并且通过mapState从store中抓取自己感兴趣的数据到自己的组件中。而b组件，如果它对a、c组件的数据毫无兴趣，则可以做到完全解耦。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/12/12/cd038fa734d54c58068b40bd86c29884.gif\" alt=\"图3\"><br>随着数据管理的进一步发展和演变，有一种叫单向数据流的东西冒了出来。图3就是一个表示“单向数据流”理念的极简示意。单向数据流要求各组件间的数据走向永远是单向的，可预期的。你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交Actions。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够更好地了解我们的应用。</p>\n<h3 id=\"一、什么是vuex？\"><a href=\"#一、什么是vuex？\" class=\"headerlink\" title=\"一、什么是vuex？\"></a>一、什么是vuex？</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex背后的基本思想，就是前面所说的单向数据流。图4就是Vuex实现单向数据流的示意图。<br><img src=\"https://img.fengjr.com/image/2019/12/12/cef1e7181629d335d2d0f179b9adb5ca.gif\" alt=\"图4\"></p>\n<h3 id=\"二、vuex安装及简单使用\"><a href=\"#二、vuex安装及简单使用\" class=\"headerlink\" title=\"二、vuex安装及简单使用\"></a>二、vuex安装及简单使用</h3><p>安装命令<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//npm</span></span><br><span class=\"line\">npm install vuex --save</span><br><span class=\"line\"><span class=\"comment\">//yarn</span></span><br><span class=\"line\">yarn add vuex</span><br></pre></td></tr></table></figure></p>\n<p>新建一个vuex文件夹（这个不是必须的），并在文件夹下新建store.js文件，文件中引入我们的vue和vuex。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex);</span><br></pre></td></tr></table></figure></p>\n<p>在vue项目中使用我们vuex，在main.js引入之后用store，然后挂在在vue上，这样所有的组件都能用了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./vuex/store.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  store,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;App/&gt;'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"vuex五种状态属性\"><a href=\"#vuex五种状态属性\" class=\"headerlink\" title=\"vuex五种状态属性\"></a>vuex五种状态属性</h5><p>1、state ——》储存初始化数据（基本数据）<br>2、getters ——》对State 里面的数据二次处理（对数据进行过滤类似filter的作用）比如State返回的为一个对象，我们想取对象中一个键的值用这个方法 （基本数据派生的数据）<br>3、mutations ——》对数据进行计算的方法全部写在里面（类似computed） 在页面中触发时使用<br>this.$store.commit(‘mutationName’)触发Mutations方法改变state的值 （提交更改数据的方法，同步！ ）<br>4、actions ——》 处理Mutations中已经写好的方法 其直接触发方式是 this.$store.dispatch(actionName)（像一个装饰器，包裹mutations，使之可以异步。 ）<br>5、modules ——》模块化Vuex</p>\n<h5 id=\"初出茅庐-来个小demo\"><a href=\"#初出茅庐-来个小demo\" class=\"headerlink\" title=\"初出茅庐 来个小demo\"></a>初出茅庐 来个小demo</h5><p>1.store.js文件里增加一个常量对象。store.js文件就是我们在引入vuex时的那个文件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state=&#123;</span><br><span class=\"line\">    count:<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.用export default 封装代码，让外部可以引用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    state</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>3.新建一个vue的模板，位置在components文件夹下，名字叫demo.vue。在模板中我们引入我们刚建的store.js文件，并在模板中用$store.state.count输出count 的值。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">hr</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>&#123;&#123;$store.state.count&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'@/vuex/store'</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span>&#123;</span></span><br><span class=\"line\">        data()&#123;</span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                msg:<span class=\"string\">'Hello Vuex'</span>,</span></span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        store</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>4.在store.js文件中加入两个改变state的方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mutations=&#123;</span><br><span class=\"line\">    add(state)&#123;</span><br><span class=\"line\">        state.count++;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    reduce(state)&#123;</span><br><span class=\"line\">        state.count--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的mutations是固定的写法，意思是改变的，我们到时候会用一节课专门讲这个mutations，所以你先不用着急，只知道我们要改变state的数值的方法，必须写在mutations里就可以了。</p>\n<p>5.demo.vue模板中加入两个按钮，并调用mutations中的方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('add')\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('reduce')\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这样进行预览就可以实现对vuex中的count进行加减了。</p>\n<h3 id=\"三、state访问状态对象\"><a href=\"#三、state访问状态对象\" class=\"headerlink\" title=\"三、state访问状态对象\"></a>三、state访问状态对象</h3><p>state即Vuex中的基本数据！<br>Vuex使用单一状态树，即用一个对象就包含了全部的状态数据。state作为构造器选项，定义了所有我们需要的基本状态参数。<br>现在我们主要学习状态对象赋值给内部对象，也就是把stroe.js中的值，赋值给我们模板里data中的值。我们有三种赋值方式</p>\n<p><strong> 一、通过computed的计算属性直接赋值</strong><br>computed属性可以在输出前，对data中的值进行改变，我们就利用这种特性把store.js中的state值赋值给我们模板中的data值。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    count()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意的是return this.$store.state.count这一句，一定要写this，要不你会找不到$store的。这种写法很好理解，但是写起来是比较麻烦的<br><strong> 二、通过mapState的对象来赋值(辅助函数)</strong><br>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。</p>\n<p>我们首先要用import引入mapState。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;mapState&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>然后还在computed计算属性里写如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:mapState(&#123;</span><br><span class=\"line\">    count:<span class=\"function\"><span class=\"params\">state</span>=&gt;</span>state.count</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对象展开运算符</span></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    ...mapState([<span class=\"string\">'count'</span>]),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong> 三、通过mapState的数组来赋值 </strong><br>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:mapState([<span class=\"string\">\"count\"</span>])</span><br></pre></td></tr></table></figure></p>\n<p>这个算是最简单的写法了，在实际项目开发当中也经常这样使用。</p>\n<h3 id=\"四、Mutations修改状态\"><a href=\"#四、Mutations修改状态\" class=\"headerlink\" title=\"四、Mutations修改状态\"></a>四、Mutations修改状态</h3><p>提交mutation是更改Vuex中的store中的状态的唯一方法。</p>\n<p>mutation必须是同步的，如果要异步需要使用action。</p>\n<p>每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//无提交荷载</span></span><br><span class=\"line\">    increment(state) &#123;</span><br><span class=\"line\">        state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//提交荷载</span></span><br><span class=\"line\">    incrementN(state, obj) &#123;</span><br><span class=\"line\">      state.count += obj.n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//无提交荷载</span></span><br><span class=\"line\">store.commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\"><span class=\"comment\">//提交荷载</span></span><br><span class=\"line\">store.commit(<span class=\"string\">'incrementN'</span>, &#123;</span><br><span class=\"line\">    n: <span class=\"number\">100</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> $store.commit( ) </strong><br>Vuex提供了commit方法来修改状态，我们在button上的修改方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('add')\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('reduce')\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>store.js文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mutations=&#123;</span><br><span class=\"line\">    add(state)&#123;</span><br><span class=\"line\">        state.count++;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    reduce(state)&#123;</span><br><span class=\"line\">        state.count--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>传值： </em><br>这只是一个最简单的修改状态的操作，在实际项目中我们常常需要在修改状态时传值。比如上边的例子，是我们每次只加1，而现在我们要通过所传的值进行相加。其实我们只需要在Mutations里再加上一个参数，并在commit的时候传递就就可以了。我们来看具体代码：<br>现在store.js文件里给add方法加上一个参数n。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mutations=&#123;</span><br><span class=\"line\">    add(state,n)&#123;</span><br><span class=\"line\">        state.count+=n;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    reduce(state)&#123;</span><br><span class=\"line\">        state.count--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在demo.vue里修改按钮的commit( )方法传递的参数，我们传递10，意思就是每次加10.<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('add',10)\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"$store.commit('reduce')\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这样两个简单的修改我们就完成了传值<br><strong> 模板获取Mutations方法(辅助函数) </strong><br>实际开发中我们也不喜欢看到$store.commit( )这样的方法出现，我们希望跟调用模板里的方法一样调用。</p>\n<p>例如：@click=”reduce” 就和没引用vuex插件一样。</p>\n<p>要达到这种写法，只需要简单的两部就可以了：</p>\n<p>1.在模板demo.vue里用import 引入我们的mapMutations：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState,mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>2.在模板的script标签里添加methods属性，并加入mapMutations<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:mapMutations([</span><br><span class=\"line\">    <span class=\"string\">'add'</span>,<span class=\"string\">'reduce'</span></span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure></p>\n<p>通过上边两步，我们已经可以在模板中直接使用我们的reduce或者add方法了，就像下面这样。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"reduce\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、getters计算过滤操作\"><a href=\"#五、getters计算过滤操作\" class=\"headerlink\" title=\"五、getters计算过滤操作\"></a>五、getters计算过滤操作</h3><p>即从store的state中派生出的状态。<br>getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工<br>getters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    state: &#123;</span><br><span class=\"line\">        count:<span class=\"number\">0</span></span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    getters: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单个参数</span></span><br><span class=\"line\">        countDouble: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state.count * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">// 两个参数</span></span><br><span class=\"line\">        countDoubleAndDouble: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state, getters</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getters.countDouble * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> getters基本用法：</strong><br>比如我们现在要对store.js文件中的count进行一个计算属性的操作，就是在它输出前，给它加上100.</p>\n<p>我们首先要在store.js里用const声明我们的getters属性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getters = &#123;</span><br><span class=\"line\">    count:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state.count +=<span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>写好了gettters之后，我们还需要在Vuex.Store()里引入，由于之前我们已经引入了state盒mutations，所以引入里有三个引入属性。代码如下，<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    state,mutations,getters</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在store.js里的配置算是完成了，我们需要到模板页对computed进行配置。在vue 的构造器里边只能有一个computed属性，如果你写多个，只有最后一个computed属性可用，所以要对上节课写的computed属性进行一个改造。改造时我们使用ES6中的展开运算符”…”。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    ...mapState([<span class=\"string\">\"count\"</span>]),</span><br><span class=\"line\">    count()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，你写了这个配置后，在每次count 的值发生变化的时候，都会进行加100的操作。<br><strong> 用mapGetters简化模板写法： </strong><br>我们都知道state和mutations都有map的引用方法把我们模板中的编码进行简化，我们的getters也是有的，我们来看一下代码。</p>\n<p>首先用import引入我们的`mapGetters<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState,mapMutations,mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>在computed属性中加入mapGetters<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...mapGetters([<span class=\"string\">\"count\"</span>])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"六、Action异步修改状态\"><a href=\"#六、Action异步修改状态\" class=\"headerlink\" title=\"六、Action异步修改状态\"></a>六、Action异步修改状态</h3><p>Action 类似于 mutation，不同在于：<br>Action 是异步的改变state状态，而Mutations是同步改变状态。<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。</p>\n<p>在store.js中声明actions actions是可以调用Mutations里的方法的，在actions里调用add和reduce两个方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> actions =&#123;</span><br><span class=\"line\">    addAction(context)&#123;</span><br><span class=\"line\">        context.commit(<span class=\"string\">'add'</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    reduceAction(&#123;commit&#125;)&#123;</span><br><span class=\"line\">        commit(<span class=\"string\">'reduce'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations里边的方法。我们会发现这两个方法传递的参数也不一样。</p>\n<ul>\n<li>context：上下文对象，这里你可以理解称store本身。</li>\n<li>{commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。<br><strong> 模板中的使用</strong><br>我们需要在demo.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的actions里的方法名，分别是：addAction和reduceAction。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"addAction\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"reduceAction\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    ...mapMutations([  </span><br><span class=\"line\">        <span class=\"string\">'add'</span>,<span class=\"string\">'reduce'</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions([<span class=\"string\">'addAction'</span>,<span class=\"string\">'reduceAction'</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你还要记得用import把我们的mapActions引入才可以使用。<br><strong> 增加异步检验 </strong><br>我们现在看的效果和我们用Mutations作的一模一样，那actions有什么用\b呢，我们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用setTimeOut进行延迟执行。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeOut(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;context.commit(reduce)&#125;,<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'我比reduce提前执行'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到在控制台先打印出了‘我比reduce提前执行’这句话。</p>\n<h3 id=\"七、module模块组\"><a href=\"#七、module模块组\" class=\"headerlink\" title=\"七、module模块组\"></a>七、module模块组</h3><p>随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。</p>\n<p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure></p>\n<p><strong> 声明模块组： </strong><br>在vuex/store.js中声明模块组，我们还是用我们的const常量的方法声明模块组。代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA=&#123;</span><br><span class=\"line\">    state,mutations,getters,actions</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明好后，我们需要修改原来 Vuex.Stroe里的值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    modules:&#123;<span class=\"attr\">a</span>:moduleA&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> 在模板中使用 </strong><br>现在我们要在模板中使用count状态，要用插值的形式写入。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>&#123;&#123;$store.state.a.count&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>如果想用简单的方法引入，还是要在我们的计算属性中rutrun我们的状态。写法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    count()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.a.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"基于Nginx-rtmp-module直播实战","comments":1,"date":"2019-11-21T06:00:11.000Z","author":"jun.zhou","_content":"\n# 基于Nginx-rtmp-module直播实战\n\n![Nginx-rtmp-module](https://img.fengjr.com/image/2019/11/20/336537d7e80764f5a6a297f9a0546822.png)\n\n随着流量资费的降低和网路带宽的增加，直播已经深入到我们的方方面面，从最开始的游戏主播，到后来的生活主播、没事主播，从PC到移动端，出现了很多很多知名平台和主播。技术媒体的进步，让人们可以进一步与明星和主播进行沟通和互动。下面我给大家介绍一种基于Nginx 的流媒体服务器，它的特点是安装简单，并且可以基于Nginx进行分布式部署，能够实现高并发、易扩展、占用内存小的特点。\n\n# 1、协议介绍\n\n我们大家都知道WEB网站内容的获取用的是HTTP协议，它是基于TCP层上的应用层协议，那么直播领域也用到一些常用的协议，如RTMP、HTTP-FLV、HLS，还有一些其它的协议。\n\n## RMTP协议\nRTMP（Real Time Messaging Protocol）是基于TCP协议的应用层协议，它主要是给Adobe公司为flash播放器和服务器进行音视频传输而开发的协议，默认使用1935端口，它是一种流式协议，流式协议就是将一整帧完成数据切割成大小基本相等的块（chunk）进行传输，支持推流和拉流操作，目前adobe已经停止了该协议进行升级，所以RTMP不支持一些新的音视频编码（例如H265、VP8、VP9等），国内CDN厂商会对RTMP进行扩展，使其支持H265协议\n\n## HTTP-FLV协议\n\n这是一种更简单的协议，它的实现是基于HTTP下载的，如果http头中没有content-length字段，那么http客户端就会一直接受服务端传过来的数据，知道服务器主动将TCP链接断开。所以，试想一下，如果服务器下发给客户端一个flv头，然后返回直播内容，那么客户端将一直接受到该直播内容，知道直播结束，服务端断开连接。\n\n## HLS协议\n\nHLS（HTTP Live Streaming）它也是一种基于HTTP下载的媒体协议，它是由Apple公司开发，应用在apple产品上的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。\n\n## 其它协议\n\n其它的直播协议还有DASH、HTTP-TS、HTTP-FMP4等\n\n## 总结\n\n\n|协议 |\t场景|\t延时|\n|---|---|---|\n|rtmp |\tflash、ffplay、vlc等终端播放器 | 2s+（（如果取消缓存也可以做到1s左右延时））|\n|http-flv |\tflash、ffplay、vlc等终端播放器，当然也有h5播放方案（利用mes方案，如flv.js，以后会介绍具体实现方式）|\t2s+（如果取消缓存也可以做到1s左右延时）|\n|hls  |\t几乎支持所有终端播放器（包括html5）|\t5s+|\n|http-ts  |\t与http-flv非常类似，只不过是利用http协议分发ts媒体流 | 同http-flv|\n\n# 2、Nginx-rtmp-module安装\n\n简单的直播系统的架构图也很简单，基本长这样\n\n![image](https://img.fengjr.com/image/2019/11/20/c795ffb45b720b47e0031d1994761f6b.png)\n\n\nNginx-rtmp-module的安装也比较简单，我目前用的是基于Nginx-rtmp-module的做的扩展库，这个扩展库支持以下功能\n\n## 服务器功能\n\n1. 接收RTMP流\n2. 支持rtmp、http-flv、http-ts、hls、hls+（内存切片） 直播服务\n3. 支持实时录制功能\n4. 支持流状态监控\n\n## 搭建环境\n\n### 环境\n\n以Centos、MacOS、Linux 为例\n\n### 安装依赖\n\n```\nyum install -y gcc gcc-c++ openssl openssl-devel pcre-devel\n```\n\n### 安装资源包\n\n```\ngit clone https://github.com/im-pingo/nginx-client-module.git\ngit clone https://github.com/im-pingo/nginx-multiport-module.git\ngit clone https://github.com/im-pingo/nginx-toolkit-module.git\ngit clone https://github.com/im-pingo/nginx-rtmp-module.git\n\n// 如果已经安装过nginx的可以，可以找到nginx的安装目录，执行以下操作\ngit clone https://github.com/nginx/nginx.git\ncd nginx\n./auto/configure --add-module=../nginx-client-module   \\\n    --add-module=../nginx-multiport-module             \\\n    --add-module=../nginx-toolkit-module               \\\n    --add-module=../nginx-rtmp-module\n\nmake && sudo make install\n```\n\n# 3、Nginx-rtmp-module配置介绍\n\n\n## 配置文件介绍\n```\nuser  root;\ndaemon on;\nmaster_process on;\nworker_processes  1;\n#worker_rlimit 4g;\n#working_directory /usr/local/openresty/nginx/logs;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\nerror_log  logs/error.log  info;\n\nworker_rlimit_nofile 102400;\nworker_rlimit_core   2G;\nworking_directory    /tmp;\n\n#pid        logs/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\nstream_zone buckets=1024 streams=4096;\n\nrtmp {\n    server {\n        listen 1935;\n        application live {\n            send_all off;\n            zero_start off;\n            live on;\n            hls on;\n            hls_path /tmp/hls;\n  \n            hls2memory on;\n            mpegts_cache_time 20s;\n            hls2_fragment 1300ms;\n            hls2_max_fragment 1800ms;\n            hls2_playlist_length 3900ms;\n            wait_key on;\n            wait_video on;\n            cache_time 2s;\n            low_latency on;\n            fix_timestamp 2000ms;\n            # h265 codecid, default 12\n            hevc_codecid  12;\n        }\n    }\n}\n\nhttp {\n    server {\n        listen     80;\n\t    location / {\n           chunked_transfer_encoding on;\n            root html/;\n        }\n        location /flv {\n            flv_live 1935 app=live;\n        }\n        location /ts {\n            ts_live 1935 app=live;\n        }\n        location /rtmp_stat {\n            rtmp_stat all;\n            rtmp_stat_stylesheet /stat.xsl;\n        }\n        location /xstat {\n            rtmp_stat all;\n        }\n        location /sys_stat {\n            sys_stat;\n        }\n        location /hls2 {\n            hls2_live 1935 app=live;\n        }\n        location /hls {\n              # Serve HLS fragments\n            types {\n                application/vnd.apple.mpegurl m3u8;\n                video/mp2t ts;\n            }\n            root /tmp;\n            add_header Cache-Control no-cache;\n        }\n        location /dash {\n            # Serve DASH fragments\n            root /tmp;\n            add_header Cache-Control no-cache;\n        }\n    }\n}\n\n```\n\n## 开启流量监控页面\n\n```\ncd nginx-rtmp-module\ncp stat.xsl /usr/local/nginx/html/stat.xsl\n```\n\n## 启动nginx\n\n```\ncd /usr/local/nginx\n./sbin/nginx\n```\n\n### 推流地址\n\nrtmp://your-server-ip/live/stream-name\n\n### 播放地址\n\n- rtmp播放地址： rtmp://your-server-ip/live/stream-name\n- http-flv播放地址：http://your-server-ip/flv/stream-name\n- http-ts播放地址：http://your-server-ip/ts/stream-name\n- hls播放地址：http://your-server-ip/hls/stream-name.m3u8\n- “hls+”播放地址：http://your-server-ip/hls2/stream-name.m3u8\n\n\n### 后台监控\n\n在浏览器中打开：http://your-server-ip/rtmp_stat\n可以通过后台查到当前实时情况\n![image](https://img.fengjr.com/image/2019/11/20/fe2615b6ad55d47242265900865486e6.png)\n\n\n# 4、推流工具介绍\n\n## FFmpeg\n\nFFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序\n\n### 基本命令\n\n```\nffmpeg -re -i your-input-file -vcodec libx264 -acodec aac -f flv rtmp://your-server-ip/live/stream-name\n```\n\n## OBS\n\nOBS是一个用于录制和进行网络直播的自由开源软件套件。OBS使用C和C++语音编写，提供实时源和设备捕获、场景组成、编码、录制和广播。数据传输主要通过实时消息协议（RTMP）完成，可以发送到任何支持RTMP的目的地，包括YouTube、Twitch.tv、Instagram和Facebook等流媒体网站。\n\n页面概览\n![image](https://img.fengjr.com/image/2019/11/20/08505f893cd3fa25f8198e3637e0012a.png)\n\n配置说明\n\n![image](https://img.fengjr.com/image/2019/11/20/267c91f529621908bbe025a4bebd627b.png)\n\n# 5、web端拉流介绍\n\n因为flash在移动端不支持，所以播放涉及到很多兼容性，而且PC浏览器目前也逐渐在废弃掉flash，各浏览器兼容性差异也很大，原声的video标签样式在各个平台也不统一，所以很多开源优秀的播放器插件被广泛的应用，诸如video.js、flv.js等等。\n\n移动端目前建议使用hls进行，flv、flash普遍不支持，以react为例，移动端合PC端都支持\n\n代码如下\n\n## HLS \n\n```JSX\nimport React, { useEffect, useRef } from 'react';\nimport videojs from 'video.js';\nimport 'video.js/dist/video-js.css'\n\nexport default function Live () {\n  const videoOption = {\n    autoplay: true,\n    controls: true,\n    sources: [{\n      src: 'http://10.255.72.234/hls/0.m3u8',\n      type: 'application/x-mpegURL'\n    }]\n  }\n  return (\n    <div>\n      <VideoPlaer  {...videoOption} />\n    </div>\n  )\n}\n\nfunction VideoPlaer (props) {\n  const videoRef = useRef(null);\n  const isSupportHls = videojs.Hls.supportsNativeHls \n  useEffect(() => {\n    if (!isSupportHls) {\n      const player = videojs(videoRef.current, props, function onPlayerReady() {\n        console.log('onPlayerReady', this)\n      });\n      return () => {\n        player.dispose()\n      }\n    }\n  })\n\n  return (\n    <div>\n      {!isSupportHls && <video-js ref={videoRef} className=\"video-js\"></video-js> }\n      {isSupportHls && \n        <video className=\"vjs-tech\" width=\"100%\" height=\"100%\"\n        controls=\"controls\" autoplay=\"autoplay\"\n        x-webkit-airplay=\"true\" x5-video-player-fullscreen=\"true\"\n        preload=\"auto\" playsinline=\"true\" webkit-playsinline\n        x5-video-player-typ=\"h5\">\n        <source type=\"application/x-mpegURL\" src=\"http://10.255.72.234/hls/.m3u8\" />\n      </video>}\n    </div>\n  )\n}\n```\n\n## RTMP\n\nRTMP只支持PC端播放，代码如下\n\n```\nimport React, { useEffect, useRef } from 'react';\nimport videojs from 'video.js';\nimport 'video.js/dist/video-js.css' //video样式文件\nimport 'videojs-flash' //必须\n\nexport default function Live () {\n  const videoOption = {\n    autoplay: true,\n    controls: true,\n    sources: [{\n      src: 'rtmp://10.255.72.234/live/0',\n      type: 'rtmp/flv'\n    }]\n  }\n  return (\n    <div>\n      <VideoPlaer  {...videoOption} />\n    </div>\n  )\n}\n\nfunction VideoPlaer (props) {\n  const videoRef = useRef(null);\n  useEffect(() => {\n    const player = videojs(videoRef.current, props, function onPlayerReady() {\n      console.log('onPlayerReady', this)\n    })\n    return () => {\n      player.dispose()\n    }\n  })\n\n  return (\n    <div>\n      <video-js ref={videoRef} className=\"video-js\" />\n    </div>\n  )\n}\n```\n\n## HTTP-FLV\n\nHTTP-FLV格式的播放需要用到flv.js，这个框架是bilibili的开源框架，是可以通过纯js播放flv直播文件，而不需要通过flash。\n\n\n```\nimport React, { useEffect, useRef } from 'react';\nimport flvjs from  'flv.js'\n\nexport default function Live () {\n  return (\n    <div>\n      <VideoPlaer />\n    </div>\n  )\n}\n\nfunction VideoPlaer () {\n  const flvRef = useRef(null);\n  useEffect(() => {\n    const flvPlayer = flvjs.createPlayer({\n      type: 'flv',\n      isLive: true,\n      hasAudio: true,\n      hasVideo: true,\n      url: 'http://10.255.72.234/flv/0'\n    });\n    flvPlayer.attachMediaElement(flvRef.current);\n    flvPlayer.load();\n    flvPlayer.play();\n  }, [])\n  return (\n    <div>\n       <video controls autoplay ref={flvRef} />\n    </div>\n  )\n}\n\n```\n","source":"_posts/2019-11-21-nginx-rtmp-module-course.md","raw":"---\ntitle: 基于Nginx-rtmp-module直播实战\ncomments: true\ndate: 2019-11-21 14:00:11\ntags:\ncategories: WEB前端\nauthor: jun.zhou\n---\n\n# 基于Nginx-rtmp-module直播实战\n\n![Nginx-rtmp-module](https://img.fengjr.com/image/2019/11/20/336537d7e80764f5a6a297f9a0546822.png)\n\n随着流量资费的降低和网路带宽的增加，直播已经深入到我们的方方面面，从最开始的游戏主播，到后来的生活主播、没事主播，从PC到移动端，出现了很多很多知名平台和主播。技术媒体的进步，让人们可以进一步与明星和主播进行沟通和互动。下面我给大家介绍一种基于Nginx 的流媒体服务器，它的特点是安装简单，并且可以基于Nginx进行分布式部署，能够实现高并发、易扩展、占用内存小的特点。\n\n# 1、协议介绍\n\n我们大家都知道WEB网站内容的获取用的是HTTP协议，它是基于TCP层上的应用层协议，那么直播领域也用到一些常用的协议，如RTMP、HTTP-FLV、HLS，还有一些其它的协议。\n\n## RMTP协议\nRTMP（Real Time Messaging Protocol）是基于TCP协议的应用层协议，它主要是给Adobe公司为flash播放器和服务器进行音视频传输而开发的协议，默认使用1935端口，它是一种流式协议，流式协议就是将一整帧完成数据切割成大小基本相等的块（chunk）进行传输，支持推流和拉流操作，目前adobe已经停止了该协议进行升级，所以RTMP不支持一些新的音视频编码（例如H265、VP8、VP9等），国内CDN厂商会对RTMP进行扩展，使其支持H265协议\n\n## HTTP-FLV协议\n\n这是一种更简单的协议，它的实现是基于HTTP下载的，如果http头中没有content-length字段，那么http客户端就会一直接受服务端传过来的数据，知道服务器主动将TCP链接断开。所以，试想一下，如果服务器下发给客户端一个flv头，然后返回直播内容，那么客户端将一直接受到该直播内容，知道直播结束，服务端断开连接。\n\n## HLS协议\n\nHLS（HTTP Live Streaming）它也是一种基于HTTP下载的媒体协议，它是由Apple公司开发，应用在apple产品上的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。\n\n## 其它协议\n\n其它的直播协议还有DASH、HTTP-TS、HTTP-FMP4等\n\n## 总结\n\n\n|协议 |\t场景|\t延时|\n|---|---|---|\n|rtmp |\tflash、ffplay、vlc等终端播放器 | 2s+（（如果取消缓存也可以做到1s左右延时））|\n|http-flv |\tflash、ffplay、vlc等终端播放器，当然也有h5播放方案（利用mes方案，如flv.js，以后会介绍具体实现方式）|\t2s+（如果取消缓存也可以做到1s左右延时）|\n|hls  |\t几乎支持所有终端播放器（包括html5）|\t5s+|\n|http-ts  |\t与http-flv非常类似，只不过是利用http协议分发ts媒体流 | 同http-flv|\n\n# 2、Nginx-rtmp-module安装\n\n简单的直播系统的架构图也很简单，基本长这样\n\n![image](https://img.fengjr.com/image/2019/11/20/c795ffb45b720b47e0031d1994761f6b.png)\n\n\nNginx-rtmp-module的安装也比较简单，我目前用的是基于Nginx-rtmp-module的做的扩展库，这个扩展库支持以下功能\n\n## 服务器功能\n\n1. 接收RTMP流\n2. 支持rtmp、http-flv、http-ts、hls、hls+（内存切片） 直播服务\n3. 支持实时录制功能\n4. 支持流状态监控\n\n## 搭建环境\n\n### 环境\n\n以Centos、MacOS、Linux 为例\n\n### 安装依赖\n\n```\nyum install -y gcc gcc-c++ openssl openssl-devel pcre-devel\n```\n\n### 安装资源包\n\n```\ngit clone https://github.com/im-pingo/nginx-client-module.git\ngit clone https://github.com/im-pingo/nginx-multiport-module.git\ngit clone https://github.com/im-pingo/nginx-toolkit-module.git\ngit clone https://github.com/im-pingo/nginx-rtmp-module.git\n\n// 如果已经安装过nginx的可以，可以找到nginx的安装目录，执行以下操作\ngit clone https://github.com/nginx/nginx.git\ncd nginx\n./auto/configure --add-module=../nginx-client-module   \\\n    --add-module=../nginx-multiport-module             \\\n    --add-module=../nginx-toolkit-module               \\\n    --add-module=../nginx-rtmp-module\n\nmake && sudo make install\n```\n\n# 3、Nginx-rtmp-module配置介绍\n\n\n## 配置文件介绍\n```\nuser  root;\ndaemon on;\nmaster_process on;\nworker_processes  1;\n#worker_rlimit 4g;\n#working_directory /usr/local/openresty/nginx/logs;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\nerror_log  logs/error.log  info;\n\nworker_rlimit_nofile 102400;\nworker_rlimit_core   2G;\nworking_directory    /tmp;\n\n#pid        logs/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\nstream_zone buckets=1024 streams=4096;\n\nrtmp {\n    server {\n        listen 1935;\n        application live {\n            send_all off;\n            zero_start off;\n            live on;\n            hls on;\n            hls_path /tmp/hls;\n  \n            hls2memory on;\n            mpegts_cache_time 20s;\n            hls2_fragment 1300ms;\n            hls2_max_fragment 1800ms;\n            hls2_playlist_length 3900ms;\n            wait_key on;\n            wait_video on;\n            cache_time 2s;\n            low_latency on;\n            fix_timestamp 2000ms;\n            # h265 codecid, default 12\n            hevc_codecid  12;\n        }\n    }\n}\n\nhttp {\n    server {\n        listen     80;\n\t    location / {\n           chunked_transfer_encoding on;\n            root html/;\n        }\n        location /flv {\n            flv_live 1935 app=live;\n        }\n        location /ts {\n            ts_live 1935 app=live;\n        }\n        location /rtmp_stat {\n            rtmp_stat all;\n            rtmp_stat_stylesheet /stat.xsl;\n        }\n        location /xstat {\n            rtmp_stat all;\n        }\n        location /sys_stat {\n            sys_stat;\n        }\n        location /hls2 {\n            hls2_live 1935 app=live;\n        }\n        location /hls {\n              # Serve HLS fragments\n            types {\n                application/vnd.apple.mpegurl m3u8;\n                video/mp2t ts;\n            }\n            root /tmp;\n            add_header Cache-Control no-cache;\n        }\n        location /dash {\n            # Serve DASH fragments\n            root /tmp;\n            add_header Cache-Control no-cache;\n        }\n    }\n}\n\n```\n\n## 开启流量监控页面\n\n```\ncd nginx-rtmp-module\ncp stat.xsl /usr/local/nginx/html/stat.xsl\n```\n\n## 启动nginx\n\n```\ncd /usr/local/nginx\n./sbin/nginx\n```\n\n### 推流地址\n\nrtmp://your-server-ip/live/stream-name\n\n### 播放地址\n\n- rtmp播放地址： rtmp://your-server-ip/live/stream-name\n- http-flv播放地址：http://your-server-ip/flv/stream-name\n- http-ts播放地址：http://your-server-ip/ts/stream-name\n- hls播放地址：http://your-server-ip/hls/stream-name.m3u8\n- “hls+”播放地址：http://your-server-ip/hls2/stream-name.m3u8\n\n\n### 后台监控\n\n在浏览器中打开：http://your-server-ip/rtmp_stat\n可以通过后台查到当前实时情况\n![image](https://img.fengjr.com/image/2019/11/20/fe2615b6ad55d47242265900865486e6.png)\n\n\n# 4、推流工具介绍\n\n## FFmpeg\n\nFFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序\n\n### 基本命令\n\n```\nffmpeg -re -i your-input-file -vcodec libx264 -acodec aac -f flv rtmp://your-server-ip/live/stream-name\n```\n\n## OBS\n\nOBS是一个用于录制和进行网络直播的自由开源软件套件。OBS使用C和C++语音编写，提供实时源和设备捕获、场景组成、编码、录制和广播。数据传输主要通过实时消息协议（RTMP）完成，可以发送到任何支持RTMP的目的地，包括YouTube、Twitch.tv、Instagram和Facebook等流媒体网站。\n\n页面概览\n![image](https://img.fengjr.com/image/2019/11/20/08505f893cd3fa25f8198e3637e0012a.png)\n\n配置说明\n\n![image](https://img.fengjr.com/image/2019/11/20/267c91f529621908bbe025a4bebd627b.png)\n\n# 5、web端拉流介绍\n\n因为flash在移动端不支持，所以播放涉及到很多兼容性，而且PC浏览器目前也逐渐在废弃掉flash，各浏览器兼容性差异也很大，原声的video标签样式在各个平台也不统一，所以很多开源优秀的播放器插件被广泛的应用，诸如video.js、flv.js等等。\n\n移动端目前建议使用hls进行，flv、flash普遍不支持，以react为例，移动端合PC端都支持\n\n代码如下\n\n## HLS \n\n```JSX\nimport React, { useEffect, useRef } from 'react';\nimport videojs from 'video.js';\nimport 'video.js/dist/video-js.css'\n\nexport default function Live () {\n  const videoOption = {\n    autoplay: true,\n    controls: true,\n    sources: [{\n      src: 'http://10.255.72.234/hls/0.m3u8',\n      type: 'application/x-mpegURL'\n    }]\n  }\n  return (\n    <div>\n      <VideoPlaer  {...videoOption} />\n    </div>\n  )\n}\n\nfunction VideoPlaer (props) {\n  const videoRef = useRef(null);\n  const isSupportHls = videojs.Hls.supportsNativeHls \n  useEffect(() => {\n    if (!isSupportHls) {\n      const player = videojs(videoRef.current, props, function onPlayerReady() {\n        console.log('onPlayerReady', this)\n      });\n      return () => {\n        player.dispose()\n      }\n    }\n  })\n\n  return (\n    <div>\n      {!isSupportHls && <video-js ref={videoRef} className=\"video-js\"></video-js> }\n      {isSupportHls && \n        <video className=\"vjs-tech\" width=\"100%\" height=\"100%\"\n        controls=\"controls\" autoplay=\"autoplay\"\n        x-webkit-airplay=\"true\" x5-video-player-fullscreen=\"true\"\n        preload=\"auto\" playsinline=\"true\" webkit-playsinline\n        x5-video-player-typ=\"h5\">\n        <source type=\"application/x-mpegURL\" src=\"http://10.255.72.234/hls/.m3u8\" />\n      </video>}\n    </div>\n  )\n}\n```\n\n## RTMP\n\nRTMP只支持PC端播放，代码如下\n\n```\nimport React, { useEffect, useRef } from 'react';\nimport videojs from 'video.js';\nimport 'video.js/dist/video-js.css' //video样式文件\nimport 'videojs-flash' //必须\n\nexport default function Live () {\n  const videoOption = {\n    autoplay: true,\n    controls: true,\n    sources: [{\n      src: 'rtmp://10.255.72.234/live/0',\n      type: 'rtmp/flv'\n    }]\n  }\n  return (\n    <div>\n      <VideoPlaer  {...videoOption} />\n    </div>\n  )\n}\n\nfunction VideoPlaer (props) {\n  const videoRef = useRef(null);\n  useEffect(() => {\n    const player = videojs(videoRef.current, props, function onPlayerReady() {\n      console.log('onPlayerReady', this)\n    })\n    return () => {\n      player.dispose()\n    }\n  })\n\n  return (\n    <div>\n      <video-js ref={videoRef} className=\"video-js\" />\n    </div>\n  )\n}\n```\n\n## HTTP-FLV\n\nHTTP-FLV格式的播放需要用到flv.js，这个框架是bilibili的开源框架，是可以通过纯js播放flv直播文件，而不需要通过flash。\n\n\n```\nimport React, { useEffect, useRef } from 'react';\nimport flvjs from  'flv.js'\n\nexport default function Live () {\n  return (\n    <div>\n      <VideoPlaer />\n    </div>\n  )\n}\n\nfunction VideoPlaer () {\n  const flvRef = useRef(null);\n  useEffect(() => {\n    const flvPlayer = flvjs.createPlayer({\n      type: 'flv',\n      isLive: true,\n      hasAudio: true,\n      hasVideo: true,\n      url: 'http://10.255.72.234/flv/0'\n    });\n    flvPlayer.attachMediaElement(flvRef.current);\n    flvPlayer.load();\n    flvPlayer.play();\n  }, [])\n  return (\n    <div>\n       <video controls autoplay ref={flvRef} />\n    </div>\n  )\n}\n\n```\n","slug":"nginx-rtmp-module-course","published":1,"updated":"2020-06-10T06:01:40.705Z","_id":"ck562y5rm0000khq6vxm5a885","layout":"post","photos":[],"link":"","content":"<h1 id=\"基于Nginx-rtmp-module直播实战\"><a href=\"#基于Nginx-rtmp-module直播实战\" class=\"headerlink\" title=\"基于Nginx-rtmp-module直播实战\"></a>基于Nginx-rtmp-module直播实战</h1><p><img src=\"https://img.fengjr.com/image/2019/11/20/336537d7e80764f5a6a297f9a0546822.png\" alt=\"Nginx-rtmp-module\"></p>\n<p>随着流量资费的降低和网路带宽的增加，直播已经深入到我们的方方面面，从最开始的游戏主播，到后来的生活主播、没事主播，从PC到移动端，出现了很多很多知名平台和主播。技术媒体的进步，让人们可以进一步与明星和主播进行沟通和互动。下面我给大家介绍一种基于Nginx 的流媒体服务器，它的特点是安装简单，并且可以基于Nginx进行分布式部署，能够实现高并发、易扩展、占用内存小的特点。</p>\n<h1 id=\"1、协议介绍\"><a href=\"#1、协议介绍\" class=\"headerlink\" title=\"1、协议介绍\"></a>1、协议介绍</h1><p>我们大家都知道WEB网站内容的获取用的是HTTP协议，它是基于TCP层上的应用层协议，那么直播领域也用到一些常用的协议，如RTMP、HTTP-FLV、HLS，还有一些其它的协议。</p>\n<h2 id=\"RMTP协议\"><a href=\"#RMTP协议\" class=\"headerlink\" title=\"RMTP协议\"></a>RMTP协议</h2><p>RTMP（Real Time Messaging Protocol）是基于TCP协议的应用层协议，它主要是给Adobe公司为flash播放器和服务器进行音视频传输而开发的协议，默认使用1935端口，它是一种流式协议，流式协议就是将一整帧完成数据切割成大小基本相等的块（chunk）进行传输，支持推流和拉流操作，目前adobe已经停止了该协议进行升级，所以RTMP不支持一些新的音视频编码（例如H265、VP8、VP9等），国内CDN厂商会对RTMP进行扩展，使其支持H265协议</p>\n<h2 id=\"HTTP-FLV协议\"><a href=\"#HTTP-FLV协议\" class=\"headerlink\" title=\"HTTP-FLV协议\"></a>HTTP-FLV协议</h2><p>这是一种更简单的协议，它的实现是基于HTTP下载的，如果http头中没有content-length字段，那么http客户端就会一直接受服务端传过来的数据，知道服务器主动将TCP链接断开。所以，试想一下，如果服务器下发给客户端一个flv头，然后返回直播内容，那么客户端将一直接受到该直播内容，知道直播结束，服务端断开连接。</p>\n<h2 id=\"HLS协议\"><a href=\"#HLS协议\" class=\"headerlink\" title=\"HLS协议\"></a>HLS协议</h2><p>HLS（HTTP Live Streaming）它也是一种基于HTTP下载的媒体协议，它是由Apple公司开发，应用在apple产品上的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。</p>\n<h2 id=\"其它协议\"><a href=\"#其它协议\" class=\"headerlink\" title=\"其它协议\"></a>其它协议</h2><p>其它的直播协议还有DASH、HTTP-TS、HTTP-FMP4等</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>协议</th>\n<th>场景</th>\n<th>延时</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rtmp</td>\n<td>flash、ffplay、vlc等终端播放器</td>\n<td>2s+（（如果取消缓存也可以做到1s左右延时））</td>\n</tr>\n<tr>\n<td>http-flv</td>\n<td>flash、ffplay、vlc等终端播放器，当然也有h5播放方案（利用mes方案，如flv.js，以后会介绍具体实现方式）</td>\n<td>2s+（如果取消缓存也可以做到1s左右延时）</td>\n</tr>\n<tr>\n<td>hls</td>\n<td>几乎支持所有终端播放器（包括html5）</td>\n<td>5s+</td>\n</tr>\n<tr>\n<td>http-ts</td>\n<td>与http-flv非常类似，只不过是利用http协议分发ts媒体流</td>\n<td>同http-flv</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"2、Nginx-rtmp-module安装\"><a href=\"#2、Nginx-rtmp-module安装\" class=\"headerlink\" title=\"2、Nginx-rtmp-module安装\"></a>2、Nginx-rtmp-module安装</h1><p>简单的直播系统的架构图也很简单，基本长这样</p>\n<p><img src=\"https://img.fengjr.com/image/2019/11/20/c795ffb45b720b47e0031d1994761f6b.png\" alt=\"image\"></p>\n<p>Nginx-rtmp-module的安装也比较简单，我目前用的是基于Nginx-rtmp-module的做的扩展库，这个扩展库支持以下功能</p>\n<h2 id=\"服务器功能\"><a href=\"#服务器功能\" class=\"headerlink\" title=\"服务器功能\"></a>服务器功能</h2><ol>\n<li>接收RTMP流</li>\n<li>支持rtmp、http-flv、http-ts、hls、hls+（内存切片） 直播服务</li>\n<li>支持实时录制功能</li>\n<li>支持流状态监控</li>\n</ol>\n<h2 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h2><h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><p>以Centos、MacOS、Linux 为例</p>\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y gcc gcc-c++ openssl openssl-devel pcre-devel</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装资源包\"><a href=\"#安装资源包\" class=\"headerlink\" title=\"安装资源包\"></a>安装资源包</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/im-pingo/nginx-client-module.git</span><br><span class=\"line\">git clone https://github.com/im-pingo/nginx-multiport-module.git</span><br><span class=\"line\">git clone https://github.com/im-pingo/nginx-toolkit-module.git</span><br><span class=\"line\">git clone https://github.com/im-pingo/nginx-rtmp-module.git</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果已经安装过nginx的可以，可以找到nginx的安装目录，执行以下操作</span><br><span class=\"line\">git clone https://github.com/nginx/nginx.git</span><br><span class=\"line\">cd nginx</span><br><span class=\"line\">./auto/configure --add-module=../nginx-client-module   \\</span><br><span class=\"line\">    --add-module=../nginx-multiport-module             \\</span><br><span class=\"line\">    --add-module=../nginx-toolkit-module               \\</span><br><span class=\"line\">    --add-module=../nginx-rtmp-module</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>\n<h1 id=\"3、Nginx-rtmp-module配置介绍\"><a href=\"#3、Nginx-rtmp-module配置介绍\" class=\"headerlink\" title=\"3、Nginx-rtmp-module配置介绍\"></a>3、Nginx-rtmp-module配置介绍</h1><h2 id=\"配置文件介绍\"><a href=\"#配置文件介绍\" class=\"headerlink\" title=\"配置文件介绍\"></a>配置文件介绍</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user  root;</span><br><span class=\"line\">daemon on;</span><br><span class=\"line\">master_process on;</span><br><span class=\"line\">worker_processes  1;</span><br><span class=\"line\">#worker_rlimit 4g;</span><br><span class=\"line\">#working_directory /usr/local/openresty/nginx/logs;</span><br><span class=\"line\"></span><br><span class=\"line\">#error_log  logs/error.log;</span><br><span class=\"line\">#error_log  logs/error.log  notice;</span><br><span class=\"line\">error_log  logs/error.log  info;</span><br><span class=\"line\"></span><br><span class=\"line\">worker_rlimit_nofile 102400;</span><br><span class=\"line\">worker_rlimit_core   2G;</span><br><span class=\"line\">working_directory    /tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">#pid        logs/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stream_zone buckets=1024 streams=4096;</span><br><span class=\"line\"></span><br><span class=\"line\">rtmp &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 1935;</span><br><span class=\"line\">        application live &#123;</span><br><span class=\"line\">            send_all off;</span><br><span class=\"line\">            zero_start off;</span><br><span class=\"line\">            live on;</span><br><span class=\"line\">            hls on;</span><br><span class=\"line\">            hls_path /tmp/hls;</span><br><span class=\"line\">  </span><br><span class=\"line\">            hls2memory on;</span><br><span class=\"line\">            mpegts_cache_time 20s;</span><br><span class=\"line\">            hls2_fragment 1300ms;</span><br><span class=\"line\">            hls2_max_fragment 1800ms;</span><br><span class=\"line\">            hls2_playlist_length 3900ms;</span><br><span class=\"line\">            wait_key on;</span><br><span class=\"line\">            wait_video on;</span><br><span class=\"line\">            cache_time 2s;</span><br><span class=\"line\">            low_latency on;</span><br><span class=\"line\">            fix_timestamp 2000ms;</span><br><span class=\"line\">            # h265 codecid, default 12</span><br><span class=\"line\">            hevc_codecid  12;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen     80;</span><br><span class=\"line\">\t    location / &#123;</span><br><span class=\"line\">           chunked_transfer_encoding on;</span><br><span class=\"line\">            root html/;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /flv &#123;</span><br><span class=\"line\">            flv_live 1935 app=live;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /ts &#123;</span><br><span class=\"line\">            ts_live 1935 app=live;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /rtmp_stat &#123;</span><br><span class=\"line\">            rtmp_stat all;</span><br><span class=\"line\">            rtmp_stat_stylesheet /stat.xsl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /xstat &#123;</span><br><span class=\"line\">            rtmp_stat all;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /sys_stat &#123;</span><br><span class=\"line\">            sys_stat;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /hls2 &#123;</span><br><span class=\"line\">            hls2_live 1935 app=live;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /hls &#123;</span><br><span class=\"line\">              # Serve HLS fragments</span><br><span class=\"line\">            types &#123;</span><br><span class=\"line\">                application/vnd.apple.mpegurl m3u8;</span><br><span class=\"line\">                video/mp2t ts;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root /tmp;</span><br><span class=\"line\">            add_header Cache-Control no-cache;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /dash &#123;</span><br><span class=\"line\">            # Serve DASH fragments</span><br><span class=\"line\">            root /tmp;</span><br><span class=\"line\">            add_header Cache-Control no-cache;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开启流量监控页面\"><a href=\"#开启流量监控页面\" class=\"headerlink\" title=\"开启流量监控页面\"></a>开启流量监控页面</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd nginx-rtmp-module</span><br><span class=\"line\">cp stat.xsl /usr/local/nginx/html/stat.xsl</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动nginx\"><a href=\"#启动nginx\" class=\"headerlink\" title=\"启动nginx\"></a>启动nginx</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/nginx</span><br><span class=\"line\">./sbin/nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"推流地址\"><a href=\"#推流地址\" class=\"headerlink\" title=\"推流地址\"></a>推流地址</h3><p>rtmp://your-server-ip/live/stream-name</p>\n<h3 id=\"播放地址\"><a href=\"#播放地址\" class=\"headerlink\" title=\"播放地址\"></a>播放地址</h3><ul>\n<li>rtmp播放地址： rtmp://your-server-ip/live/stream-name</li>\n<li>http-flv播放地址：<a href=\"http://your-server-ip/flv/stream-name\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/flv/stream-name</a></li>\n<li>http-ts播放地址：<a href=\"http://your-server-ip/ts/stream-name\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/ts/stream-name</a></li>\n<li>hls播放地址：<a href=\"http://your-server-ip/hls/stream-name.m3u8\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/hls/stream-name.m3u8</a></li>\n<li>“hls+”播放地址：<a href=\"http://your-server-ip/hls2/stream-name.m3u8\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/hls2/stream-name.m3u8</a></li>\n</ul>\n<h3 id=\"后台监控\"><a href=\"#后台监控\" class=\"headerlink\" title=\"后台监控\"></a>后台监控</h3><p>在浏览器中打开：<a href=\"http://your-server-ip/rtmp_stat\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/rtmp_stat</a><br>可以通过后台查到当前实时情况<br><img src=\"https://img.fengjr.com/image/2019/11/20/fe2615b6ad55d47242265900865486e6.png\" alt=\"image\"></p>\n<h1 id=\"4、推流工具介绍\"><a href=\"#4、推流工具介绍\" class=\"headerlink\" title=\"4、推流工具介绍\"></a>4、推流工具介绍</h1><h2 id=\"FFmpeg\"><a href=\"#FFmpeg\" class=\"headerlink\" title=\"FFmpeg\"></a>FFmpeg</h2><p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序</p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg -re -i your-input-file -vcodec libx264 -acodec aac -f flv rtmp://your-server-ip/live/stream-name</span><br></pre></td></tr></table></figure>\n<h2 id=\"OBS\"><a href=\"#OBS\" class=\"headerlink\" title=\"OBS\"></a>OBS</h2><p>OBS是一个用于录制和进行网络直播的自由开源软件套件。OBS使用C和C++语音编写，提供实时源和设备捕获、场景组成、编码、录制和广播。数据传输主要通过实时消息协议（RTMP）完成，可以发送到任何支持RTMP的目的地，包括YouTube、Twitch.tv、Instagram和Facebook等流媒体网站。</p>\n<p>页面概览<br><img src=\"https://img.fengjr.com/image/2019/11/20/08505f893cd3fa25f8198e3637e0012a.png\" alt=\"image\"></p>\n<p>配置说明</p>\n<p><img src=\"https://img.fengjr.com/image/2019/11/20/267c91f529621908bbe025a4bebd627b.png\" alt=\"image\"></p>\n<h1 id=\"5、web端拉流介绍\"><a href=\"#5、web端拉流介绍\" class=\"headerlink\" title=\"5、web端拉流介绍\"></a>5、web端拉流介绍</h1><p>因为flash在移动端不支持，所以播放涉及到很多兼容性，而且PC浏览器目前也逐渐在废弃掉flash，各浏览器兼容性差异也很大，原声的video标签样式在各个平台也不统一，所以很多开源优秀的播放器插件被广泛的应用，诸如video.js、flv.js等等。</p>\n<p>移动端目前建议使用hls进行，flv、flash普遍不支持，以react为例，移动端合PC端都支持</p>\n<p>代码如下</p>\n<h2 id=\"HLS\"><a href=\"#HLS\" class=\"headerlink\" title=\"HLS\"></a>HLS</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useEffect, useRef &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> videojs <span class=\"keyword\">from</span> <span class=\"string\">'video.js'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'video.js/dist/video-js.css'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Live</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> videoOption = &#123;</span><br><span class=\"line\">    autoplay: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    controls: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    sources: [&#123;</span><br><span class=\"line\">      src: <span class=\"string\">'http://10.255.72.234/hls/0.m3u8'</span>,</span><br><span class=\"line\">      type: <span class=\"string\">'application/x-mpegURL'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;VideoPlaer  &#123;...videoOption&#125; /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function VideoPlaer (props) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  const videoRef = useRef(null);</span></span><br><span class=\"line\"><span class=\"regexp\">  const isSupportHls = videojs.Hls.supportsNativeHls </span></span><br><span class=\"line\"><span class=\"regexp\">  useEffect(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    if (!isSupportHls) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      const player = videojs(videoRef.current, props, function onPlayerReady() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        console.log('onPlayerReady', this)</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">      return () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        player.dispose()</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &#123;!isSupportHls &amp;&amp; &lt;video-js ref=&#123;videoRef&#125; className=\"video-js\"&gt;&lt;/</span>video-js&gt; &#125;</span><br><span class=\"line\">      &#123;isSupportHls &amp;&amp; </span><br><span class=\"line\">        &lt;video className=<span class=\"string\">\"vjs-tech\"</span> width=<span class=\"string\">\"100%\"</span> height=<span class=\"string\">\"100%\"</span></span><br><span class=\"line\">        controls=<span class=\"string\">\"controls\"</span> autoplay=<span class=\"string\">\"autoplay\"</span></span><br><span class=\"line\">        x-webkit-airplay=<span class=\"string\">\"true\"</span> x5-video-player-fullscreen=<span class=\"string\">\"true\"</span></span><br><span class=\"line\">        preload=<span class=\"string\">\"auto\"</span> playsinline=<span class=\"string\">\"true\"</span> webkit-playsinline</span><br><span class=\"line\">        x5-video-player-typ=<span class=\"string\">\"h5\"</span>&gt;</span><br><span class=\"line\">        &lt;source type=<span class=\"string\">\"application/x-mpegURL\"</span> src=<span class=\"string\">\"http://10.255.72.234/hls/.m3u8\"</span> /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/video&gt;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RTMP\"><a href=\"#RTMP\" class=\"headerlink\" title=\"RTMP\"></a>RTMP</h2><p>RTMP只支持PC端播放，代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; useEffect, useRef &#125; from &apos;react&apos;;</span><br><span class=\"line\">import videojs from &apos;video.js&apos;;</span><br><span class=\"line\">import &apos;video.js/dist/video-js.css&apos; //video样式文件</span><br><span class=\"line\">import &apos;videojs-flash&apos; //必须</span><br><span class=\"line\"></span><br><span class=\"line\">export default function Live () &#123;</span><br><span class=\"line\">  const videoOption = &#123;</span><br><span class=\"line\">    autoplay: true,</span><br><span class=\"line\">    controls: true,</span><br><span class=\"line\">    sources: [&#123;</span><br><span class=\"line\">      src: &apos;rtmp://10.255.72.234/live/0&apos;,</span><br><span class=\"line\">      type: &apos;rtmp/flv&apos;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;VideoPlaer  &#123;...videoOption&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function VideoPlaer (props) &#123;</span><br><span class=\"line\">  const videoRef = useRef(null);</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    const player = videojs(videoRef.current, props, function onPlayerReady() &#123;</span><br><span class=\"line\">      console.log(&apos;onPlayerReady&apos;, this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      player.dispose()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;video-js ref=&#123;videoRef&#125; className=&quot;video-js&quot; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTTP-FLV\"><a href=\"#HTTP-FLV\" class=\"headerlink\" title=\"HTTP-FLV\"></a>HTTP-FLV</h2><p>HTTP-FLV格式的播放需要用到flv.js，这个框架是bilibili的开源框架，是可以通过纯js播放flv直播文件，而不需要通过flash。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; useEffect, useRef &#125; from &apos;react&apos;;</span><br><span class=\"line\">import flvjs from  &apos;flv.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default function Live () &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;VideoPlaer /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function VideoPlaer () &#123;</span><br><span class=\"line\">  const flvRef = useRef(null);</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    const flvPlayer = flvjs.createPlayer(&#123;</span><br><span class=\"line\">      type: &apos;flv&apos;,</span><br><span class=\"line\">      isLive: true,</span><br><span class=\"line\">      hasAudio: true,</span><br><span class=\"line\">      hasVideo: true,</span><br><span class=\"line\">      url: &apos;http://10.255.72.234/flv/0&apos;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    flvPlayer.attachMediaElement(flvRef.current);</span><br><span class=\"line\">    flvPlayer.load();</span><br><span class=\"line\">    flvPlayer.play();</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">       &lt;video controls autoplay ref=&#123;flvRef&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基于Nginx-rtmp-module直播实战\"><a href=\"#基于Nginx-rtmp-module直播实战\" class=\"headerlink\" title=\"基于Nginx-rtmp-module直播实战\"></a>基于Nginx-rtmp-module直播实战</h1><p><img src=\"https://img.fengjr.com/image/2019/11/20/336537d7e80764f5a6a297f9a0546822.png\" alt=\"Nginx-rtmp-module\"></p>\n<p>随着流量资费的降低和网路带宽的增加，直播已经深入到我们的方方面面，从最开始的游戏主播，到后来的生活主播、没事主播，从PC到移动端，出现了很多很多知名平台和主播。技术媒体的进步，让人们可以进一步与明星和主播进行沟通和互动。下面我给大家介绍一种基于Nginx 的流媒体服务器，它的特点是安装简单，并且可以基于Nginx进行分布式部署，能够实现高并发、易扩展、占用内存小的特点。</p>\n<h1 id=\"1、协议介绍\"><a href=\"#1、协议介绍\" class=\"headerlink\" title=\"1、协议介绍\"></a>1、协议介绍</h1><p>我们大家都知道WEB网站内容的获取用的是HTTP协议，它是基于TCP层上的应用层协议，那么直播领域也用到一些常用的协议，如RTMP、HTTP-FLV、HLS，还有一些其它的协议。</p>\n<h2 id=\"RMTP协议\"><a href=\"#RMTP协议\" class=\"headerlink\" title=\"RMTP协议\"></a>RMTP协议</h2><p>RTMP（Real Time Messaging Protocol）是基于TCP协议的应用层协议，它主要是给Adobe公司为flash播放器和服务器进行音视频传输而开发的协议，默认使用1935端口，它是一种流式协议，流式协议就是将一整帧完成数据切割成大小基本相等的块（chunk）进行传输，支持推流和拉流操作，目前adobe已经停止了该协议进行升级，所以RTMP不支持一些新的音视频编码（例如H265、VP8、VP9等），国内CDN厂商会对RTMP进行扩展，使其支持H265协议</p>\n<h2 id=\"HTTP-FLV协议\"><a href=\"#HTTP-FLV协议\" class=\"headerlink\" title=\"HTTP-FLV协议\"></a>HTTP-FLV协议</h2><p>这是一种更简单的协议，它的实现是基于HTTP下载的，如果http头中没有content-length字段，那么http客户端就会一直接受服务端传过来的数据，知道服务器主动将TCP链接断开。所以，试想一下，如果服务器下发给客户端一个flv头，然后返回直播内容，那么客户端将一直接受到该直播内容，知道直播结束，服务端断开连接。</p>\n<h2 id=\"HLS协议\"><a href=\"#HLS协议\" class=\"headerlink\" title=\"HLS协议\"></a>HLS协议</h2><p>HLS（HTTP Live Streaming）它也是一种基于HTTP下载的媒体协议，它是由Apple公司开发，应用在apple产品上的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。</p>\n<h2 id=\"其它协议\"><a href=\"#其它协议\" class=\"headerlink\" title=\"其它协议\"></a>其它协议</h2><p>其它的直播协议还有DASH、HTTP-TS、HTTP-FMP4等</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>协议</th>\n<th>场景</th>\n<th>延时</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rtmp</td>\n<td>flash、ffplay、vlc等终端播放器</td>\n<td>2s+（（如果取消缓存也可以做到1s左右延时））</td>\n</tr>\n<tr>\n<td>http-flv</td>\n<td>flash、ffplay、vlc等终端播放器，当然也有h5播放方案（利用mes方案，如flv.js，以后会介绍具体实现方式）</td>\n<td>2s+（如果取消缓存也可以做到1s左右延时）</td>\n</tr>\n<tr>\n<td>hls</td>\n<td>几乎支持所有终端播放器（包括html5）</td>\n<td>5s+</td>\n</tr>\n<tr>\n<td>http-ts</td>\n<td>与http-flv非常类似，只不过是利用http协议分发ts媒体流</td>\n<td>同http-flv</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"2、Nginx-rtmp-module安装\"><a href=\"#2、Nginx-rtmp-module安装\" class=\"headerlink\" title=\"2、Nginx-rtmp-module安装\"></a>2、Nginx-rtmp-module安装</h1><p>简单的直播系统的架构图也很简单，基本长这样</p>\n<p><img src=\"https://img.fengjr.com/image/2019/11/20/c795ffb45b720b47e0031d1994761f6b.png\" alt=\"image\"></p>\n<p>Nginx-rtmp-module的安装也比较简单，我目前用的是基于Nginx-rtmp-module的做的扩展库，这个扩展库支持以下功能</p>\n<h2 id=\"服务器功能\"><a href=\"#服务器功能\" class=\"headerlink\" title=\"服务器功能\"></a>服务器功能</h2><ol>\n<li>接收RTMP流</li>\n<li>支持rtmp、http-flv、http-ts、hls、hls+（内存切片） 直播服务</li>\n<li>支持实时录制功能</li>\n<li>支持流状态监控</li>\n</ol>\n<h2 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h2><h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><p>以Centos、MacOS、Linux 为例</p>\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y gcc gcc-c++ openssl openssl-devel pcre-devel</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装资源包\"><a href=\"#安装资源包\" class=\"headerlink\" title=\"安装资源包\"></a>安装资源包</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/im-pingo/nginx-client-module.git</span><br><span class=\"line\">git clone https://github.com/im-pingo/nginx-multiport-module.git</span><br><span class=\"line\">git clone https://github.com/im-pingo/nginx-toolkit-module.git</span><br><span class=\"line\">git clone https://github.com/im-pingo/nginx-rtmp-module.git</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果已经安装过nginx的可以，可以找到nginx的安装目录，执行以下操作</span><br><span class=\"line\">git clone https://github.com/nginx/nginx.git</span><br><span class=\"line\">cd nginx</span><br><span class=\"line\">./auto/configure --add-module=../nginx-client-module   \\</span><br><span class=\"line\">    --add-module=../nginx-multiport-module             \\</span><br><span class=\"line\">    --add-module=../nginx-toolkit-module               \\</span><br><span class=\"line\">    --add-module=../nginx-rtmp-module</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>\n<h1 id=\"3、Nginx-rtmp-module配置介绍\"><a href=\"#3、Nginx-rtmp-module配置介绍\" class=\"headerlink\" title=\"3、Nginx-rtmp-module配置介绍\"></a>3、Nginx-rtmp-module配置介绍</h1><h2 id=\"配置文件介绍\"><a href=\"#配置文件介绍\" class=\"headerlink\" title=\"配置文件介绍\"></a>配置文件介绍</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user  root;</span><br><span class=\"line\">daemon on;</span><br><span class=\"line\">master_process on;</span><br><span class=\"line\">worker_processes  1;</span><br><span class=\"line\">#worker_rlimit 4g;</span><br><span class=\"line\">#working_directory /usr/local/openresty/nginx/logs;</span><br><span class=\"line\"></span><br><span class=\"line\">#error_log  logs/error.log;</span><br><span class=\"line\">#error_log  logs/error.log  notice;</span><br><span class=\"line\">error_log  logs/error.log  info;</span><br><span class=\"line\"></span><br><span class=\"line\">worker_rlimit_nofile 102400;</span><br><span class=\"line\">worker_rlimit_core   2G;</span><br><span class=\"line\">working_directory    /tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">#pid        logs/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stream_zone buckets=1024 streams=4096;</span><br><span class=\"line\"></span><br><span class=\"line\">rtmp &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 1935;</span><br><span class=\"line\">        application live &#123;</span><br><span class=\"line\">            send_all off;</span><br><span class=\"line\">            zero_start off;</span><br><span class=\"line\">            live on;</span><br><span class=\"line\">            hls on;</span><br><span class=\"line\">            hls_path /tmp/hls;</span><br><span class=\"line\">  </span><br><span class=\"line\">            hls2memory on;</span><br><span class=\"line\">            mpegts_cache_time 20s;</span><br><span class=\"line\">            hls2_fragment 1300ms;</span><br><span class=\"line\">            hls2_max_fragment 1800ms;</span><br><span class=\"line\">            hls2_playlist_length 3900ms;</span><br><span class=\"line\">            wait_key on;</span><br><span class=\"line\">            wait_video on;</span><br><span class=\"line\">            cache_time 2s;</span><br><span class=\"line\">            low_latency on;</span><br><span class=\"line\">            fix_timestamp 2000ms;</span><br><span class=\"line\">            # h265 codecid, default 12</span><br><span class=\"line\">            hevc_codecid  12;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen     80;</span><br><span class=\"line\">\t    location / &#123;</span><br><span class=\"line\">           chunked_transfer_encoding on;</span><br><span class=\"line\">            root html/;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /flv &#123;</span><br><span class=\"line\">            flv_live 1935 app=live;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /ts &#123;</span><br><span class=\"line\">            ts_live 1935 app=live;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /rtmp_stat &#123;</span><br><span class=\"line\">            rtmp_stat all;</span><br><span class=\"line\">            rtmp_stat_stylesheet /stat.xsl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /xstat &#123;</span><br><span class=\"line\">            rtmp_stat all;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /sys_stat &#123;</span><br><span class=\"line\">            sys_stat;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /hls2 &#123;</span><br><span class=\"line\">            hls2_live 1935 app=live;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /hls &#123;</span><br><span class=\"line\">              # Serve HLS fragments</span><br><span class=\"line\">            types &#123;</span><br><span class=\"line\">                application/vnd.apple.mpegurl m3u8;</span><br><span class=\"line\">                video/mp2t ts;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root /tmp;</span><br><span class=\"line\">            add_header Cache-Control no-cache;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /dash &#123;</span><br><span class=\"line\">            # Serve DASH fragments</span><br><span class=\"line\">            root /tmp;</span><br><span class=\"line\">            add_header Cache-Control no-cache;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开启流量监控页面\"><a href=\"#开启流量监控页面\" class=\"headerlink\" title=\"开启流量监控页面\"></a>开启流量监控页面</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd nginx-rtmp-module</span><br><span class=\"line\">cp stat.xsl /usr/local/nginx/html/stat.xsl</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动nginx\"><a href=\"#启动nginx\" class=\"headerlink\" title=\"启动nginx\"></a>启动nginx</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/nginx</span><br><span class=\"line\">./sbin/nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"推流地址\"><a href=\"#推流地址\" class=\"headerlink\" title=\"推流地址\"></a>推流地址</h3><p>rtmp://your-server-ip/live/stream-name</p>\n<h3 id=\"播放地址\"><a href=\"#播放地址\" class=\"headerlink\" title=\"播放地址\"></a>播放地址</h3><ul>\n<li>rtmp播放地址： rtmp://your-server-ip/live/stream-name</li>\n<li>http-flv播放地址：<a href=\"http://your-server-ip/flv/stream-name\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/flv/stream-name</a></li>\n<li>http-ts播放地址：<a href=\"http://your-server-ip/ts/stream-name\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/ts/stream-name</a></li>\n<li>hls播放地址：<a href=\"http://your-server-ip/hls/stream-name.m3u8\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/hls/stream-name.m3u8</a></li>\n<li>“hls+”播放地址：<a href=\"http://your-server-ip/hls2/stream-name.m3u8\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/hls2/stream-name.m3u8</a></li>\n</ul>\n<h3 id=\"后台监控\"><a href=\"#后台监控\" class=\"headerlink\" title=\"后台监控\"></a>后台监控</h3><p>在浏览器中打开：<a href=\"http://your-server-ip/rtmp_stat\" target=\"_blank\" rel=\"noopener\">http://your-server-ip/rtmp_stat</a><br>可以通过后台查到当前实时情况<br><img src=\"https://img.fengjr.com/image/2019/11/20/fe2615b6ad55d47242265900865486e6.png\" alt=\"image\"></p>\n<h1 id=\"4、推流工具介绍\"><a href=\"#4、推流工具介绍\" class=\"headerlink\" title=\"4、推流工具介绍\"></a>4、推流工具介绍</h1><h2 id=\"FFmpeg\"><a href=\"#FFmpeg\" class=\"headerlink\" title=\"FFmpeg\"></a>FFmpeg</h2><p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序</p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg -re -i your-input-file -vcodec libx264 -acodec aac -f flv rtmp://your-server-ip/live/stream-name</span><br></pre></td></tr></table></figure>\n<h2 id=\"OBS\"><a href=\"#OBS\" class=\"headerlink\" title=\"OBS\"></a>OBS</h2><p>OBS是一个用于录制和进行网络直播的自由开源软件套件。OBS使用C和C++语音编写，提供实时源和设备捕获、场景组成、编码、录制和广播。数据传输主要通过实时消息协议（RTMP）完成，可以发送到任何支持RTMP的目的地，包括YouTube、Twitch.tv、Instagram和Facebook等流媒体网站。</p>\n<p>页面概览<br><img src=\"https://img.fengjr.com/image/2019/11/20/08505f893cd3fa25f8198e3637e0012a.png\" alt=\"image\"></p>\n<p>配置说明</p>\n<p><img src=\"https://img.fengjr.com/image/2019/11/20/267c91f529621908bbe025a4bebd627b.png\" alt=\"image\"></p>\n<h1 id=\"5、web端拉流介绍\"><a href=\"#5、web端拉流介绍\" class=\"headerlink\" title=\"5、web端拉流介绍\"></a>5、web端拉流介绍</h1><p>因为flash在移动端不支持，所以播放涉及到很多兼容性，而且PC浏览器目前也逐渐在废弃掉flash，各浏览器兼容性差异也很大，原声的video标签样式在各个平台也不统一，所以很多开源优秀的播放器插件被广泛的应用，诸如video.js、flv.js等等。</p>\n<p>移动端目前建议使用hls进行，flv、flash普遍不支持，以react为例，移动端合PC端都支持</p>\n<p>代码如下</p>\n<h2 id=\"HLS\"><a href=\"#HLS\" class=\"headerlink\" title=\"HLS\"></a>HLS</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useEffect, useRef &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> videojs <span class=\"keyword\">from</span> <span class=\"string\">'video.js'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'video.js/dist/video-js.css'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Live</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> videoOption = &#123;</span><br><span class=\"line\">    autoplay: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    controls: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    sources: [&#123;</span><br><span class=\"line\">      src: <span class=\"string\">'http://10.255.72.234/hls/0.m3u8'</span>,</span><br><span class=\"line\">      type: <span class=\"string\">'application/x-mpegURL'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;VideoPlaer  &#123;...videoOption&#125; /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function VideoPlaer (props) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  const videoRef = useRef(null);</span></span><br><span class=\"line\"><span class=\"regexp\">  const isSupportHls = videojs.Hls.supportsNativeHls </span></span><br><span class=\"line\"><span class=\"regexp\">  useEffect(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    if (!isSupportHls) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      const player = videojs(videoRef.current, props, function onPlayerReady() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        console.log('onPlayerReady', this)</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">      return () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        player.dispose()</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &#123;!isSupportHls &amp;&amp; &lt;video-js ref=&#123;videoRef&#125; className=\"video-js\"&gt;&lt;/</span>video-js&gt; &#125;</span><br><span class=\"line\">      &#123;isSupportHls &amp;&amp; </span><br><span class=\"line\">        &lt;video className=<span class=\"string\">\"vjs-tech\"</span> width=<span class=\"string\">\"100%\"</span> height=<span class=\"string\">\"100%\"</span></span><br><span class=\"line\">        controls=<span class=\"string\">\"controls\"</span> autoplay=<span class=\"string\">\"autoplay\"</span></span><br><span class=\"line\">        x-webkit-airplay=<span class=\"string\">\"true\"</span> x5-video-player-fullscreen=<span class=\"string\">\"true\"</span></span><br><span class=\"line\">        preload=<span class=\"string\">\"auto\"</span> playsinline=<span class=\"string\">\"true\"</span> webkit-playsinline</span><br><span class=\"line\">        x5-video-player-typ=<span class=\"string\">\"h5\"</span>&gt;</span><br><span class=\"line\">        &lt;source type=<span class=\"string\">\"application/x-mpegURL\"</span> src=<span class=\"string\">\"http://10.255.72.234/hls/.m3u8\"</span> /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/video&gt;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RTMP\"><a href=\"#RTMP\" class=\"headerlink\" title=\"RTMP\"></a>RTMP</h2><p>RTMP只支持PC端播放，代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; useEffect, useRef &#125; from &apos;react&apos;;</span><br><span class=\"line\">import videojs from &apos;video.js&apos;;</span><br><span class=\"line\">import &apos;video.js/dist/video-js.css&apos; //video样式文件</span><br><span class=\"line\">import &apos;videojs-flash&apos; //必须</span><br><span class=\"line\"></span><br><span class=\"line\">export default function Live () &#123;</span><br><span class=\"line\">  const videoOption = &#123;</span><br><span class=\"line\">    autoplay: true,</span><br><span class=\"line\">    controls: true,</span><br><span class=\"line\">    sources: [&#123;</span><br><span class=\"line\">      src: &apos;rtmp://10.255.72.234/live/0&apos;,</span><br><span class=\"line\">      type: &apos;rtmp/flv&apos;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;VideoPlaer  &#123;...videoOption&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function VideoPlaer (props) &#123;</span><br><span class=\"line\">  const videoRef = useRef(null);</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    const player = videojs(videoRef.current, props, function onPlayerReady() &#123;</span><br><span class=\"line\">      console.log(&apos;onPlayerReady&apos;, this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      player.dispose()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;video-js ref=&#123;videoRef&#125; className=&quot;video-js&quot; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTTP-FLV\"><a href=\"#HTTP-FLV\" class=\"headerlink\" title=\"HTTP-FLV\"></a>HTTP-FLV</h2><p>HTTP-FLV格式的播放需要用到flv.js，这个框架是bilibili的开源框架，是可以通过纯js播放flv直播文件，而不需要通过flash。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; useEffect, useRef &#125; from &apos;react&apos;;</span><br><span class=\"line\">import flvjs from  &apos;flv.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default function Live () &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;VideoPlaer /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function VideoPlaer () &#123;</span><br><span class=\"line\">  const flvRef = useRef(null);</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    const flvPlayer = flvjs.createPlayer(&#123;</span><br><span class=\"line\">      type: &apos;flv&apos;,</span><br><span class=\"line\">      isLive: true,</span><br><span class=\"line\">      hasAudio: true,</span><br><span class=\"line\">      hasVideo: true,</span><br><span class=\"line\">      url: &apos;http://10.255.72.234/flv/0&apos;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    flvPlayer.attachMediaElement(flvRef.current);</span><br><span class=\"line\">    flvPlayer.load();</span><br><span class=\"line\">    flvPlayer.play();</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">       &lt;video controls autoplay ref=&#123;flvRef&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Redux原理","comments":0,"date":"2019-11-26T02:58:28.000Z","updated":"2020-06-10T06:01:39.562Z","author":"jun.zhou","_content":"\n# 1 什么时候使用redux\n首先，并不是所有的 React 应用程序都需要使用 Redux。事实上，大多数非常简单的 React 应用程序根本不能从 Redux 中受益。\n#### 第1天\n使用 React 本地组件状态\nReact 使用单向数据流，这意味着父组件把自身的状态作为属性传递给子组件。\n<iframe width=600 height=300 src=\"https://img.fengjr.com/image/2019/11/26/ed405e9a73d1d95196668d52024a201c.gif\"/>\n#### 第5天\n随着添加更多的功能，非父子组件之间需要共享一些状态。\n我们通过提升状态来解决这个问题。\n这意味着我们将状态（和改变这个状态的函数）提升到最接近的祖先（Container Component）。我们将这些函数绑定到容器组件，并将它们作为属性向下传递。这意味着子组件可以触发其父组件中的状态更改，这将更新树中的所有其他组件。\n<iframe width=600 height=325 src=\"https://img.fengjr.com/image/2019/11/26/7adb4aa588ca14985673b3bace108e05.gif\"/>\n#### 第20天\n随着添加了更多的功能和组件，我们的应用程序状态流程开始看起来像这样...\n<iframe width=600 height=480 src=\"https://img.fengjr.com/image/2019/11/26/68d9f5328d8a4c30c1feb0494fdba7c1.gif\"/>\n#### Redux\n当我们使用 Redux 后，状态变成了这样：\n<iframe width=700 height=480 src=\"https://img.fengjr.com/image/2019/11/26/a5c3b436a4f28db524201e13c483ce60.gif\"/>\n##### 如果您的应用符合以下某些条件，那么我认为应该立即使用 Redux。\n+ UI 可以根据应用程序状态显着变化\n+ 并不总是以一种线性的，单向的方式流动\n+ 许多不相关的组件以相同的方式更新状态\n+ 状态树并不简单\n+ 状态以许多不同的方式更新\n+ 您需要能够撤消以前的用户操作\n\n# 2 没有redux的时候\n如果没有redux，我们再处理跨组件传递数据的时候怎么处理呢？以上面的例子为例，我们用react实现一下\n首先准备几个基础组件\n\n```javascript\n//节点1\nimport Son11 from './son1_1'\nimport Son12 from './son1_2'\nclass Son extends React.Component {\n    render() {\n        return (\n            <div className=\"tac w50\">\n                Son1\n                <div className=\"flexC\">\n                    <Son11/>\n                    <Son12/>\n                </div>\n            </div>\n        );\n    }}\nexport default Son;\n```\n\n```javascript\n//节点1-1 负责展示\nclass Son extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            value: '',\n        }\n    }\n    render() {\n        let {value}=this.state;\n        return (\n            <div className=\"w50\">\n                Son1_1 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }}\nexport default Son;\n```\n```javascript\n//节点1-2 无\nimport Son121 from './son1_2_1'\nimport Son122 from './son1_2_2'\nclass Son extends React.Component {\n    render() {\n        return (\n            <div className=\"tac w50\">\n                Son1_2\n                <div className=\"flexC\">\n                    <Son121/>\n                    <Son122/>\n                </div>\n            </div>\n        );\n    }}\nexport default Son;\n```\n\n```javascript\n////节点1-2-1 负责展示\nclass Son extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            value: '',\n        }\n    }\n    render() {\n        let {value}=this.state;\n        return (\n            <div className=\"w50\">\n                Son1_2_1 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }}\nexport default Son;\n```\n\n```javascript\n//节点1-2-2  负责展示和触发事件\nclass Son extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            value: '',\n        }\n    }\n    render() {\n        let {value}=this.state;\n        return (\n            <div className=\"w50 active\" onClick={()=>this.onClick()}>\n                Son1_2_2 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }}\nexport default Son;\n```\n\n```javascript\n//节点2  无\nimport Son21 from './son2_1'\nclass Son extends React.Component {\n    render() {\n        return  <div className=\"tac w50\">\n                Son2\n                <div className=\"flexC fe\">\n                    <Son21 />\n                </div>\n            </div>\n    }}\nexport default Son;\n```\n\n```javascript\n//节点2-1  负责触发事件\nclass Son extends React.Component {\n    render() {\n        return (\n            <div className=\"w50 active\" onClick={this.onClick}>\n                Son2_1\n            </div>\n        );\n    }}\nexport default Son;\n```\n以上是基础组件，节点1-2-2和节点2-1来模拟点击事件，节点1-1、节点1-2-1、节点1-2-2来展示效果。\n下面以发布/订阅模式 pub-sub(Publish/Subscribe) 来实现，发布/订阅模式(Pub/Sub)是一种消息模式，它有两个参与者 :  发布者和订阅者，两者之间是多对多的关系。通过消息处理器来关联。发布者向某个信道（通常是个字符串）发布一条消息，订阅者绑定这个信道，当有消息发布至信道时就会接收到一个通知。最重要的一点是， 发布者和订阅者是完全解耦的，彼此并不知晓对方的存在，两者仅仅共享一个信道名称。\n发布/订阅模式，通常用于消息队列中。一般有两种形式来实现消息队列，一是使用生产者和消费者来实现，二是使用发布/订阅模式来实现。\n```javascript\nimport React from 'react';\nimport Son1 from './subComp2/son1'\nimport Son2 from './subComp2/son2'\nclass App extends React.Component {\n    constructor() {\n        super();\n        window.reduxData = {\n            events: {},\n            sub: function (name, event) {//订阅\n                this.events[name] = this.events[name] || [];\n                this.events[name].push(event);\n            },\n            pub: function (name, data) {//发布\n                (this.events[name] || []).forEach(event=> {\n                    event(data);\n                })\n            }\n        }\n    }\n    render() {\n        return  <div className=\"app tac\">\n                App2\n                <div className=\"flexC\">\n                    <Son1/>\n                    <Son2/>\n                </div>\n            </div>\n    }}\nexport default App;\n\n```\n上面代码实现了一个消息处理器，然后我们来看如何使用。首先要订阅消息，我们修改节点1-1点代码\n```javascript\n//节点1-1\nclass Son extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            value: '',\n        }\n    }\n    componentDidMount() {\n        window.reduxData.sub('event_son1_1', (data)=> {//订阅消息\n            this.setState({\n                value: data,\n            })\n        });\n    }\n    render() {\n        let {value}=this.state;\n        return (\n            <div className=\"w50\">\n                Son1_1 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }\n}\nexport default Son;\n```\n节点1-2-1、节点1-2-2的代码也类似。\n然后是发布消息，修改节点2-1点代码如下：\n```javascript\n//节点2-1\nclass Son extends React.Component {\n    onClick = ()=> {\n        window.reduxData.pub('event_son1_1', '2');//发布消息\n        window.reduxData.pub('event_son1_2_1', '2');\n        window.reduxData.pub('event_son1_2_2', '2');\n    }\n    render() {\n        return <div className=\"w50 active\" onClick={this.onClick}>\n                Son2_1\n            </div>\n    }}\nexport default Son;\n```\n节点1-2-2也按此修改。\n除了发布/订阅模式，还有另外两种模式：观察者模式和事件监听模式\n观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常用在实时事件处理系统。参与者是被观察者（含消息管理器）、观察者。\n发布/订阅模式与观察者模式的区别：从定义上看，发布订阅模式里双方是完全解耦的，而在观察者模式里，目标对象管理这观察者，双方是耦合的，这是最主要的区别，而在发布订阅模式中多了一个中间层信道。\n事件监听模式重要的三个概念：事件+事件监听器+事件源，从观察者模式发展而来，比观察者模式略微复杂，就是将消息处理器进行分离解耦，从而更加灵活\n事件监听模式与观察者模式勉强的对应关系可以看成是，被观察者相当于事件源，观察者相当于监听器，事件源会产生事件，监听器监听事件。\n**观察者模式和发布订阅模型的区别就在于消息是否发送给中间件，观察者和被观察着是否完全解耦；而观察者模式和事件驱动的区别则在于事件驱动则更加灵活，但同时增加了程序的复杂性。其实这三者本质上没有什么区别，只是适用场景不同。**\n\n# 3 redux\n很明显以上的方法虽然能处理问题，但是很明显存在一些缺陷：例如信道名称多的话就容易混乱；发布者与订阅者互相不知道对方，分不清数据流向；window上的全局变量不安全。\n其实我们想要这样一个函数，他满足：\n* 存放一个数据对象\n* 外界能访问到这个数据\n* 外界也能修改这个数据\n* 当数据有变化的时候，通知订阅者\n\n```javascript\nfunction createStore(reducer, initialState) {\n // currentState就是那个数据\n let currentState = initialState;\n let listener = () => {};\n\n function getState() {\n    return currentState;\n }\n\n function dispatch(action) {\n    currentState = reducer(currentState, action); // 更新数据\n    listener(); // 执行订阅函数\n    return action;\n }\n\n function subscribe(newListener) {\n     listener = newListener;\n     // 取消订阅函数\n     return function unsubscribe() {\n       listener = () => {};\n     };\n }\n\n return {\n     getState,\n     dispatch,\n     subscribe\n };\n}\n```\n这样就实现了一个store，提供一个数据存储中心，可以供外部访问、修改等，这就是Redux的主要思想。 实际上，Redux确实和React没有什么关系，Redux可以结合其他库正常使用。只不过Redux这种数据管理方式，跟React的数据驱动视图理念很合拍，它俩结合在一起，开发非常便利。\n不过创建的store存在放在window上还是不舒服。\n\n# 4 react-redux\n在react-redux，把store直接集成到React应用的顶层props里面，只要各个子组件能访问到顶层props就行了，比如这样：\n```javascript\n<Provider store={store}>\n  <App />\n</Provider>\n```\nReact恰好提供了这么一个钩子，Context。各个子组件就能够轻易地访问到store了，接下来就是子组件把store中用到的数据取出来、修改、以及订阅更新UI等，每个子组件都需要这样做一遍就好。\n当然，肯定有更便利的方法：高阶组件。通过高阶组件把store.getState()、store.dispatch、store.subscribe封装起来，子组件对store是无感知的，子组件正常使用props获取数据以及正常使用callback触发回调，相当于没有store存在一样。\n### Context的用法\n这里我们顺带说一下Context，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。\n如果要Context发挥作用，需要用到两种组件，一个是Context生产者(Provider)，通常是一个父节点，另外是一个Context的消费者(Consumer)，通常是一个或者多个子节点。所以Context的使用基于生产者消费者模式。\n对于父组件，也就是Context生产者，需要通过一个静态属性childContextTypes声明提供给子组件的Context对象的属性，并实现一个实例getChildContext方法，返回一个代表Context的纯对象 (plain object) 。\n```javascript\nclass ParentComponent extends React.Component {\n    static childContextTypes = { // 声明Context对象属性\n        color: PropTypes.string,\n    }\n    getChildContext () {// 返回Context对象，方法名是约定好的\n        return {\n            color: 'red',\n        }\n    }\n    render () {\n        return <MiddleComponent />\n    }\n}\nclass MiddleComponent extends React.Component {\n    render () {\n        return <ChildComponent />\n    }\n}\n```\n而对于Context的消费者，通过如下方式访问父组件提供的Context。\n```javascript\nclass ChildComponent extends React.Component {\n    // 声明需要使用的Context属性\n    static contextTypes = {\n        color: PropTypes.string\n    }\n    render () {\n        const {color} = this.context\n        return <div>{color}</div>\n    }\n}\n```\n子组件需要通过一个静态属性contextTypes声明后，才能访问父组件Context对象的属性，否则，即使属性名没写错，拿到的对象也是undefined。\n\n### React-Redux的用法\nReact-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）\n#### UI组件\n* 只负责UI的呈现，不带有任何业务逻辑\n* 没有状态（即不使用this.state这个变量）\n* 所有数据都由参数（this.props）提供\n* 不使用任何Redux的 API\n#### 容器组件\n* 负责管理数据和业务逻辑，不负责 UI 的呈现\n* 带有内部状态\n* 使用 Redux 的 API\nReact-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。那么react-redux是如何生成容器组件呢，答案是通过connect()函数，例如：\n\n```javascript\nimport { connect } from 'react-redux'\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n```\nconnect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。\n上面的点击的例子，我们用react-redux来实现，首先要增加reducers和actions\n```javascript\n//file actions\nexport const CLICK_SON2_1 = 'CLICK_SON2_1';\nexport const CLICK_SON1_2_2 = 'CLICK_SON1_2_2';\n//action函数包含属性名和属性值\nexport function clickSon2_1(text) {\n    return {\n        type: CLICK_SON2_1,\n        text,\n    }\n}\n\nexport function clickSon1_2_2(text) {\n    return {\n        type: CLICK_SON1_2_2,\n        text,\n    }\n}\n```\n\n```javascript\n//file reducers\nimport { CLICK_SON2_1, CLICK_SON1_2_2} from './actions'\nfunction reducers(state = {}, action) {//修改状态\n    switch (action.type) {\n        case CLICK_SON2_1:\n            return Object.assign({}, state, {\n                clickValue: action.text\n            });\n        case CLICK_SON1_2_2:\n            return Object.assign({}, state, {\n                clickValue: action.text\n            });\n    }\n    return state;\n}\nexport default reducers;\n```\n下面修改节点1-1展示的代码\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux'\nclass Son extends React.Component {\n    render() {\n        let {value}=this.props;\n        return (\n            <div className=\"w50\">\n                Son1_1 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }\n}\nexport default connect(state=> {\n    return {\n        value: state.clickValue\n    }\n}, dispatch=> {\n    return {}\n})(Son);\n```\n然后修改2-1点击事件的代码\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux'\nimport {clickSon2_1} from '../subComp3/redux/actions'\n\nclass Son extends React.Component {\n    onClick = ()=> {\n        this.props.click();\n    }\n    render() {\n        return (\n            <div className=\"w50 active\" onClick={this.onClick}>\n                Son2_1\n            </div>\n        );\n    }\n}\n\nexport default connect(state=> {\n    return {}\n}, dispatch=> {\n    return {\n        click: ()=> {\n            dispatch(clickSon2_1('2'))\n        }\n    }\n})(Son);\n\n```\n最修改app代码\n```javascript\nimport React from 'react';\nimport {Provider} from 'react-redux'\nimport {createStore} from 'redux'\nimport Son1 from './subComp3/son1'\nimport Son2 from './subComp3/son2'\n\n//初始化store\nimport reducers from './subComp3/redux/reducers'\nlet store = createStore(reducers)\n\n//redux方式实现状态管理\nclass App extends React.Component {\n    render() {\n        return (\n            <Provider store={store}>\n                <div className=\"app tac\">\n                    App3\n                    <div className=\"flexC\">\n                        <Son1/>\n                        <Son2/>\n                    </div>\n                </div>\n            </Provider>\n        );\n    }\n}\nexport default App;\n```\n# 4 react-redux原理\n从上面的应用中我们也可以看出，react-redux的核心函数是：createStore函数和connect函数，下面我们看一下这两个函数的实现\n```javascript\n//createStore函数\n\nconst INIT = '@@redux/INIT_' + Math.random().toString(36).substring(7)\nexport default function createStore(reducer, initialState/*初始值*/, enhancer/*加强函数*/) {\n    //如果第二个参数传入的是函数则认为是加强函数\n    if (typeof initialState === 'function') {\n        enhancer = initialState;\n        initialState = undefined;\n    }\n    //执行加强函数\n    if (typeof enhancer === 'function') {\n        return enhancer(createStore)(reducer, initialState)\n    }\n\n    let state = initialState;\n    const listeners = [];\n    const store = {\n        getState(){\n            return state\n        },\n        dispatch(action){\n            if (!action || !action.type)return;\n            state = reducer(state, action);\n            listeners.forEach(listener=>listener())\n        },\n        subscribe(listener){\n            if (!typeof listener === 'function')return;\n            listeners.push(listener);\n            return ()=> {//删除订阅函数\n                let index = listeners.indexOf(listener);\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    //自动执行初始化\n    store.dispatch({type: INIT})\n    return store;\n}\n```\n\n```javascript\nimport React from 'react'\nimport PropTypes from 'prop-types'\nconst connect = (mapStateToProps = state=>state, mapDispatchToProps = dispatch=>({}))=>(WrappedComponent)=> {\n    class Connect extends React.Component {\n        constructor() {\n            super()\n            this.state = {};\n        }\n\n        componentWillMount() {\n            this.unSubscribe = this.context.store.subscribe(()=> {\n                this.setState(mapStateToProps(this.context.store.getState()))\n            });\n        }\n\n        componentWillUnmount() {\n            this.unSubscribe();\n        }\n\n        render() {\n            return <WrappedComponent {...this.state}\n                {...mapDispatchToProps(this.context.store.dispatch)}\n            />\n        }\n    }\n    Connect.contextTypes = {\n        store: PropTypes.object\n    }\n    return Connect;\n}\n\n\nexport default connect\n```\n上面我们说过，store是通过顶层组件Provider传递进来的，配合context，来进行跨组件传递数据。代码如下：\n```javascript\nimport React from 'react';\nimport PropTypes from 'prop-types'\n\nclass Provider extends React.Component {\n    getChildContext() {\n        return {\n            store: this.props.store\n        };\n    }\n    constructor() {\n        super()\n        this.state = {};\n    }\n    render() {\n        return this.props.children;\n    }\n}\n\nProvider.childContextTypes = {\n    store: PropTypes.object\n}\nexport default Provider;\n\n```\n另外react-redux为了让我们更好的拆分合并reducers，提供了一个combineReducers方法，代码如下：\n```javascript\nexport default function combineReducers(reducers) {\n    const availableKeys = []      //存储函数名\n    const availableReducers = {}  //存储函数\n    //遍历获取全部reducer函数\n    Object.keys(reducers).forEach(key => {\n        if (typeof reducers[key] === 'function') {\n            availableKeys.push(key)\n            availableReducers[key] = reducers[key]\n        }\n    })\n    //返回一个reducer函数\n    return (state = {}, action) => {\n        const nextState = {}\n        let hasChanged = false\n        //逐个调用reducer函数来修改state，同时判断state是否发生改变\n        availableKeys.forEach(key => {\n            nextState[key] = availableReducers[key](state[key], action)\n            if (!hasChanged) {\n                hasChanged = state[key] !== nextState[key]\n            }\n        })\n        return hasChanged ? nextState : state\n    }\n}\n```\n以上呢就是react-redux的基本原理，是不是很简单，确实如此。\n但是，redux更强大是中间件功能。先来看一个例子：\n```javascript\n// file myMiddlewares\nfunction middleware1(getStore, dispatch) {\n    return function (next) {\n        return function (action) {\n            console.log(1)\n            next(action)\n            console.log(2)\n        }\n    }\n}\nconst standMiddleware = (getStore, dispatch)=>next=>action=> {\n    console.log('i am stand')\n    next(action);\n    console.log('i am stand 2')\n}\nexport default [middleware1, standMiddleware]\n```\n\n```javascript\nimport createStore from './createStore'\nimport reducers from './reducers'\nimport applyMiddleware from './applyMiddleware'\nimport myMiddlewares from './myMiddlewares'\nconst store = createStore(\n    reducers,\n    applyMiddleware(...myMiddlewares)\n);\n```\nmiddleware 的函数签名是 ({ getState, dispatch }) => next => action\nMiddleware 只是包装了 store 的 dispatch 方法。技术上讲，任何 middleware 能做的事情，都可能通过手动包装 dispatch 调用来实现，但是放在同一个地方统一管理会使整个项目的扩展变的容易得多。\n这次我们在创建store时传入了一个加强函数，其中我们还用到了 applyMiddleware 方法，有什么作用呢？applyMiddleware 主要是对redux进行增强。\n```javascript\nimport compose from './compose'\nexport default function applyMiddleware(...middlewares) {\n    return createStore=>(...args)=> {//三个参数 reducer, preloadedState, enhancer\n        const store = createStore(...args);\n        let dispatch = ()=> {\n        }\n        const middlewareAPI = {\n            getState: store.getState,\n            dispatch: (...args)=>dispatch(...args)\n        }\n\n        const chains = middlewares.map(middleware=>middleware(middlewareAPI))\n        dispatch = compose(...chains)(store.dispatch);\n\n        return {\n            ...store,\n            dispatch\n        }\n\n    }\n}\n```\n这里applyMiddleware返回的函数可以用来加强createStore函数的，因此我们又多了一种创建store的方法，新函数内部对中间件进行了洋葱圈式的调用，生成了新的dispatch。\n```javascript\n//方法1\nconst store = createStore(reducer, null, applyMiddleware(...))\n//方法2\nconst store = createStore(reducer, applyMiddleware(...))\n//方法3\nconst midCreateStore= applyMiddleware(...)(createStore);\nconst store = midCreateStore(reducer)\n```\napplyMiddleware本质是什么吗？它肯定是比 middleware 还强大的扩展机制。实际上，applyMiddleware 只是被称为 Redux 最强大的扩展机制的 store enhancers 中的一个范例而已。我们不太可能需要实现自己的 store enhancer。另一个 store enhancer 示例是 redux-devtools。Middleware 并没有 store enhancer 强大，但开发起来却是更容易的。\nMiddleware 听起来比实际难一些。真正理解 middleware 的唯一办法是了解现有的 middleware 是如何工作的，并尝试自己实现。需要的功能可能错综复杂，但是你会发现大部分 middleware 实际上很小，只有 10 行左右，是通过对它们的组合使用来达到最终的目的。\n这里需要注意的一个地方是用到了一个compose函数，代码如下：\n```javascript\nexport default function compose(...funcs) {\n    if (funcs.length == 0) {\n        return arg=>arg;\n    }\n    if (funcs.length === 1) {\n        return funcs[0]\n    }\n    return funcs.reduce((a, b)=> {//a是reduce函数的累加器\n        return (...args)=> {\n            return a(b(...args))\n        }\n    })\n}\n```\n函数式编程中有一种模式是通过组合多个函数的功能来实现一个组合函数。一般支持函数式编程的工具库都实现了这种模式，这种模式一般被称作 compose 与 pipe。看下面一个例子。\n```javascript\n const inc=(num)=>++num;\n const f1=compose(Math.abs,inc,Math.pow);\n const f2=pipe(Math.pow,Math.abs,inc);\n console.log(f1(-2,3));//7\n console.log(f2(-2,3));//9\n```\n从上面的例子可以看出，假设f、g、h分别表示三个函数，则compose(f,g,h)返回的函数完成类似(...args) => f(g(h(...args)))的功能。即从右到左组合多个函数，前面函数的返回值作为下一个函数的参数;\n**注意，只有最后一个函数可以接收多个参数，前面的函数都只接收一个参数**\npipe(f,g,h)返回的函数完成类似(...args) => h(g(f(...args)))的功能，即从左到右组合多个函数，前面函数的返回值作为下一个函数的参数；\n**注意，只有第一个函数可以接收多个参数，后面的函数都只接收一个参数**\ncompose函数再实现的时候用到了Array.reduce函数，不清楚的可以自己了解一下\ncompose模块的代码十分简练，但是实现的作用却是十分强大。redux为何称为redux？有人说就是reduce和flux的结合体，而reduce正是compose模块的核心。\n\n# 5 我们项目中的reducers\n先来看一下一般情况下的reducers，这个是刚才我们实现的。\n```javascript\nimport {\n    CLICK_SON2_1,\n    CLICK_SON1_2_2\n} from './actions'\nfunction reducers(state = {}, action) {\n    switch (action.type) {\n        case CLICK_SON2_1:\n            return Object.assign({}, state, {\n                clickValue: action.text\n            });\n        case CLICK_SON1_2_2:\n            return Object.assign({}, state, {\n                clickValue: action.text\n            });\n    }\n    return state;\n}\nexport default reducers;\n```\n两个点击，需要两个数据状态，就包含两个case语句，虽然redux给我们提供了combineReducers来进行拆分合并，但是这些变量管理起来还是很麻烦。我们来看一下我们的项目里是怎么实现的。\n```javascript\nimport combineReducers from './combineReducers'\nimport {Map} from 'immutable'  //不可改变的数据结构\nfunction mapReducer(state = new Map(), action = {}) {\n    switch (action.type) {\n        case 'SET_MAP':\n            return state.setIn(action.keyPath, action.value)\n    }\n    return state;\n}\nexport default combineReducers({\n    map: mapReducer,\n});\n```\n\n```javascript\nimport {dispatch,getState} from './store'\n\nexport function setMap(keyPath, value) {\n    keyPath = getKeyPath(keyPath)\n    dispatch({type: 'SET_MAP', keyPath, value});\n}\n\nexport function getMap(keyPath) {\n    keyPath = getKeyPath(keyPath)\n    return getState().map.getIn(keyPath);\n}\n\nfunction getKeyPath(keyPath) {\n    if (!Array.isArray(keyPath)) {\n        keyPath = [keyPath]\n    }\n    return keyPath;\n}\n```\n用法\n```javascript\nsetMap('value', '2');//设置\ngetMap('value')       //获取\n//或者\nsetMap(['page1','value'], {a:'2'});//设置\ngetMap(['page1','value'])       //获取\n```\n这里面主要用到了一个immutable对象，什么是immutable呢？\nImmutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。\n不可变数据让纯函数更强大，也让程序开发愈发简单明了，同时使类似于惰性求值的函数式编程成为可能。\n为了在javascript上实现这些强大的概念，我们给javascript引擎带来了熟悉的面向对象的API以及Array、Map和Set上一的些镜像方法，让它能简单和高效地与普通javascript对象互相转换。\n这里我们主要用到的api就是Map\n<iframe width=613 height=575 src=\"https://img.fengjr.com/image/2019/12/03/38ffaa6822fa66c12ac56c25ccc7b1de.gif\"/>\n* Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象\n* Immutable 实现的原理是 Persistent Data Structure （持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变\n* 同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗， Immutable 使用了 Structural Sharing···· （结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。\nredux中的store是有不可变性的，不可变性保证了纯函数无副作用，能够直观的逻辑推导。因此Redux本身的原则也保证了状态对象的不可变性。\n#### redux有三原则：\n* 单一数据源\n* State 是只读的\n* 使用纯函数来执行修改\n因此每次更新获取的都是一个新的state对象。immutable本身也是一个不可变对象，每次更新也是生成一个新的对象，跟redux结合非常合适。\n**实际上，Redux 并不在意你如何存储 state，state 可以是普通对象，不可变对象，或者其它类型。你可以使用任何数据存储的库，只要它支持数据的不可变动性。**\n\n\n\n\n\n\n\n","source":"_posts/2019-11-26-redux原理.md","raw":"---\ntitle: Redux原理\ncomments: false\ndate: 2019-11-26 10:58:28\ntags:\n- js\nupdated:\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n# 1 什么时候使用redux\n首先，并不是所有的 React 应用程序都需要使用 Redux。事实上，大多数非常简单的 React 应用程序根本不能从 Redux 中受益。\n#### 第1天\n使用 React 本地组件状态\nReact 使用单向数据流，这意味着父组件把自身的状态作为属性传递给子组件。\n<iframe width=600 height=300 src=\"https://img.fengjr.com/image/2019/11/26/ed405e9a73d1d95196668d52024a201c.gif\"/>\n#### 第5天\n随着添加更多的功能，非父子组件之间需要共享一些状态。\n我们通过提升状态来解决这个问题。\n这意味着我们将状态（和改变这个状态的函数）提升到最接近的祖先（Container Component）。我们将这些函数绑定到容器组件，并将它们作为属性向下传递。这意味着子组件可以触发其父组件中的状态更改，这将更新树中的所有其他组件。\n<iframe width=600 height=325 src=\"https://img.fengjr.com/image/2019/11/26/7adb4aa588ca14985673b3bace108e05.gif\"/>\n#### 第20天\n随着添加了更多的功能和组件，我们的应用程序状态流程开始看起来像这样...\n<iframe width=600 height=480 src=\"https://img.fengjr.com/image/2019/11/26/68d9f5328d8a4c30c1feb0494fdba7c1.gif\"/>\n#### Redux\n当我们使用 Redux 后，状态变成了这样：\n<iframe width=700 height=480 src=\"https://img.fengjr.com/image/2019/11/26/a5c3b436a4f28db524201e13c483ce60.gif\"/>\n##### 如果您的应用符合以下某些条件，那么我认为应该立即使用 Redux。\n+ UI 可以根据应用程序状态显着变化\n+ 并不总是以一种线性的，单向的方式流动\n+ 许多不相关的组件以相同的方式更新状态\n+ 状态树并不简单\n+ 状态以许多不同的方式更新\n+ 您需要能够撤消以前的用户操作\n\n# 2 没有redux的时候\n如果没有redux，我们再处理跨组件传递数据的时候怎么处理呢？以上面的例子为例，我们用react实现一下\n首先准备几个基础组件\n\n```javascript\n//节点1\nimport Son11 from './son1_1'\nimport Son12 from './son1_2'\nclass Son extends React.Component {\n    render() {\n        return (\n            <div className=\"tac w50\">\n                Son1\n                <div className=\"flexC\">\n                    <Son11/>\n                    <Son12/>\n                </div>\n            </div>\n        );\n    }}\nexport default Son;\n```\n\n```javascript\n//节点1-1 负责展示\nclass Son extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            value: '',\n        }\n    }\n    render() {\n        let {value}=this.state;\n        return (\n            <div className=\"w50\">\n                Son1_1 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }}\nexport default Son;\n```\n```javascript\n//节点1-2 无\nimport Son121 from './son1_2_1'\nimport Son122 from './son1_2_2'\nclass Son extends React.Component {\n    render() {\n        return (\n            <div className=\"tac w50\">\n                Son1_2\n                <div className=\"flexC\">\n                    <Son121/>\n                    <Son122/>\n                </div>\n            </div>\n        );\n    }}\nexport default Son;\n```\n\n```javascript\n////节点1-2-1 负责展示\nclass Son extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            value: '',\n        }\n    }\n    render() {\n        let {value}=this.state;\n        return (\n            <div className=\"w50\">\n                Son1_2_1 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }}\nexport default Son;\n```\n\n```javascript\n//节点1-2-2  负责展示和触发事件\nclass Son extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            value: '',\n        }\n    }\n    render() {\n        let {value}=this.state;\n        return (\n            <div className=\"w50 active\" onClick={()=>this.onClick()}>\n                Son1_2_2 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }}\nexport default Son;\n```\n\n```javascript\n//节点2  无\nimport Son21 from './son2_1'\nclass Son extends React.Component {\n    render() {\n        return  <div className=\"tac w50\">\n                Son2\n                <div className=\"flexC fe\">\n                    <Son21 />\n                </div>\n            </div>\n    }}\nexport default Son;\n```\n\n```javascript\n//节点2-1  负责触发事件\nclass Son extends React.Component {\n    render() {\n        return (\n            <div className=\"w50 active\" onClick={this.onClick}>\n                Son2_1\n            </div>\n        );\n    }}\nexport default Son;\n```\n以上是基础组件，节点1-2-2和节点2-1来模拟点击事件，节点1-1、节点1-2-1、节点1-2-2来展示效果。\n下面以发布/订阅模式 pub-sub(Publish/Subscribe) 来实现，发布/订阅模式(Pub/Sub)是一种消息模式，它有两个参与者 :  发布者和订阅者，两者之间是多对多的关系。通过消息处理器来关联。发布者向某个信道（通常是个字符串）发布一条消息，订阅者绑定这个信道，当有消息发布至信道时就会接收到一个通知。最重要的一点是， 发布者和订阅者是完全解耦的，彼此并不知晓对方的存在，两者仅仅共享一个信道名称。\n发布/订阅模式，通常用于消息队列中。一般有两种形式来实现消息队列，一是使用生产者和消费者来实现，二是使用发布/订阅模式来实现。\n```javascript\nimport React from 'react';\nimport Son1 from './subComp2/son1'\nimport Son2 from './subComp2/son2'\nclass App extends React.Component {\n    constructor() {\n        super();\n        window.reduxData = {\n            events: {},\n            sub: function (name, event) {//订阅\n                this.events[name] = this.events[name] || [];\n                this.events[name].push(event);\n            },\n            pub: function (name, data) {//发布\n                (this.events[name] || []).forEach(event=> {\n                    event(data);\n                })\n            }\n        }\n    }\n    render() {\n        return  <div className=\"app tac\">\n                App2\n                <div className=\"flexC\">\n                    <Son1/>\n                    <Son2/>\n                </div>\n            </div>\n    }}\nexport default App;\n\n```\n上面代码实现了一个消息处理器，然后我们来看如何使用。首先要订阅消息，我们修改节点1-1点代码\n```javascript\n//节点1-1\nclass Son extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            value: '',\n        }\n    }\n    componentDidMount() {\n        window.reduxData.sub('event_son1_1', (data)=> {//订阅消息\n            this.setState({\n                value: data,\n            })\n        });\n    }\n    render() {\n        let {value}=this.state;\n        return (\n            <div className=\"w50\">\n                Son1_1 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }\n}\nexport default Son;\n```\n节点1-2-1、节点1-2-2的代码也类似。\n然后是发布消息，修改节点2-1点代码如下：\n```javascript\n//节点2-1\nclass Son extends React.Component {\n    onClick = ()=> {\n        window.reduxData.pub('event_son1_1', '2');//发布消息\n        window.reduxData.pub('event_son1_2_1', '2');\n        window.reduxData.pub('event_son1_2_2', '2');\n    }\n    render() {\n        return <div className=\"w50 active\" onClick={this.onClick}>\n                Son2_1\n            </div>\n    }}\nexport default Son;\n```\n节点1-2-2也按此修改。\n除了发布/订阅模式，还有另外两种模式：观察者模式和事件监听模式\n观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常用在实时事件处理系统。参与者是被观察者（含消息管理器）、观察者。\n发布/订阅模式与观察者模式的区别：从定义上看，发布订阅模式里双方是完全解耦的，而在观察者模式里，目标对象管理这观察者，双方是耦合的，这是最主要的区别，而在发布订阅模式中多了一个中间层信道。\n事件监听模式重要的三个概念：事件+事件监听器+事件源，从观察者模式发展而来，比观察者模式略微复杂，就是将消息处理器进行分离解耦，从而更加灵活\n事件监听模式与观察者模式勉强的对应关系可以看成是，被观察者相当于事件源，观察者相当于监听器，事件源会产生事件，监听器监听事件。\n**观察者模式和发布订阅模型的区别就在于消息是否发送给中间件，观察者和被观察着是否完全解耦；而观察者模式和事件驱动的区别则在于事件驱动则更加灵活，但同时增加了程序的复杂性。其实这三者本质上没有什么区别，只是适用场景不同。**\n\n# 3 redux\n很明显以上的方法虽然能处理问题，但是很明显存在一些缺陷：例如信道名称多的话就容易混乱；发布者与订阅者互相不知道对方，分不清数据流向；window上的全局变量不安全。\n其实我们想要这样一个函数，他满足：\n* 存放一个数据对象\n* 外界能访问到这个数据\n* 外界也能修改这个数据\n* 当数据有变化的时候，通知订阅者\n\n```javascript\nfunction createStore(reducer, initialState) {\n // currentState就是那个数据\n let currentState = initialState;\n let listener = () => {};\n\n function getState() {\n    return currentState;\n }\n\n function dispatch(action) {\n    currentState = reducer(currentState, action); // 更新数据\n    listener(); // 执行订阅函数\n    return action;\n }\n\n function subscribe(newListener) {\n     listener = newListener;\n     // 取消订阅函数\n     return function unsubscribe() {\n       listener = () => {};\n     };\n }\n\n return {\n     getState,\n     dispatch,\n     subscribe\n };\n}\n```\n这样就实现了一个store，提供一个数据存储中心，可以供外部访问、修改等，这就是Redux的主要思想。 实际上，Redux确实和React没有什么关系，Redux可以结合其他库正常使用。只不过Redux这种数据管理方式，跟React的数据驱动视图理念很合拍，它俩结合在一起，开发非常便利。\n不过创建的store存在放在window上还是不舒服。\n\n# 4 react-redux\n在react-redux，把store直接集成到React应用的顶层props里面，只要各个子组件能访问到顶层props就行了，比如这样：\n```javascript\n<Provider store={store}>\n  <App />\n</Provider>\n```\nReact恰好提供了这么一个钩子，Context。各个子组件就能够轻易地访问到store了，接下来就是子组件把store中用到的数据取出来、修改、以及订阅更新UI等，每个子组件都需要这样做一遍就好。\n当然，肯定有更便利的方法：高阶组件。通过高阶组件把store.getState()、store.dispatch、store.subscribe封装起来，子组件对store是无感知的，子组件正常使用props获取数据以及正常使用callback触发回调，相当于没有store存在一样。\n### Context的用法\n这里我们顺带说一下Context，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。\n如果要Context发挥作用，需要用到两种组件，一个是Context生产者(Provider)，通常是一个父节点，另外是一个Context的消费者(Consumer)，通常是一个或者多个子节点。所以Context的使用基于生产者消费者模式。\n对于父组件，也就是Context生产者，需要通过一个静态属性childContextTypes声明提供给子组件的Context对象的属性，并实现一个实例getChildContext方法，返回一个代表Context的纯对象 (plain object) 。\n```javascript\nclass ParentComponent extends React.Component {\n    static childContextTypes = { // 声明Context对象属性\n        color: PropTypes.string,\n    }\n    getChildContext () {// 返回Context对象，方法名是约定好的\n        return {\n            color: 'red',\n        }\n    }\n    render () {\n        return <MiddleComponent />\n    }\n}\nclass MiddleComponent extends React.Component {\n    render () {\n        return <ChildComponent />\n    }\n}\n```\n而对于Context的消费者，通过如下方式访问父组件提供的Context。\n```javascript\nclass ChildComponent extends React.Component {\n    // 声明需要使用的Context属性\n    static contextTypes = {\n        color: PropTypes.string\n    }\n    render () {\n        const {color} = this.context\n        return <div>{color}</div>\n    }\n}\n```\n子组件需要通过一个静态属性contextTypes声明后，才能访问父组件Context对象的属性，否则，即使属性名没写错，拿到的对象也是undefined。\n\n### React-Redux的用法\nReact-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）\n#### UI组件\n* 只负责UI的呈现，不带有任何业务逻辑\n* 没有状态（即不使用this.state这个变量）\n* 所有数据都由参数（this.props）提供\n* 不使用任何Redux的 API\n#### 容器组件\n* 负责管理数据和业务逻辑，不负责 UI 的呈现\n* 带有内部状态\n* 使用 Redux 的 API\nReact-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。那么react-redux是如何生成容器组件呢，答案是通过connect()函数，例如：\n\n```javascript\nimport { connect } from 'react-redux'\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n```\nconnect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。\n上面的点击的例子，我们用react-redux来实现，首先要增加reducers和actions\n```javascript\n//file actions\nexport const CLICK_SON2_1 = 'CLICK_SON2_1';\nexport const CLICK_SON1_2_2 = 'CLICK_SON1_2_2';\n//action函数包含属性名和属性值\nexport function clickSon2_1(text) {\n    return {\n        type: CLICK_SON2_1,\n        text,\n    }\n}\n\nexport function clickSon1_2_2(text) {\n    return {\n        type: CLICK_SON1_2_2,\n        text,\n    }\n}\n```\n\n```javascript\n//file reducers\nimport { CLICK_SON2_1, CLICK_SON1_2_2} from './actions'\nfunction reducers(state = {}, action) {//修改状态\n    switch (action.type) {\n        case CLICK_SON2_1:\n            return Object.assign({}, state, {\n                clickValue: action.text\n            });\n        case CLICK_SON1_2_2:\n            return Object.assign({}, state, {\n                clickValue: action.text\n            });\n    }\n    return state;\n}\nexport default reducers;\n```\n下面修改节点1-1展示的代码\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux'\nclass Son extends React.Component {\n    render() {\n        let {value}=this.props;\n        return (\n            <div className=\"w50\">\n                Son1_1 {value && <span className=\"selected\">{value}</span>}\n            </div>\n        );\n    }\n}\nexport default connect(state=> {\n    return {\n        value: state.clickValue\n    }\n}, dispatch=> {\n    return {}\n})(Son);\n```\n然后修改2-1点击事件的代码\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux'\nimport {clickSon2_1} from '../subComp3/redux/actions'\n\nclass Son extends React.Component {\n    onClick = ()=> {\n        this.props.click();\n    }\n    render() {\n        return (\n            <div className=\"w50 active\" onClick={this.onClick}>\n                Son2_1\n            </div>\n        );\n    }\n}\n\nexport default connect(state=> {\n    return {}\n}, dispatch=> {\n    return {\n        click: ()=> {\n            dispatch(clickSon2_1('2'))\n        }\n    }\n})(Son);\n\n```\n最修改app代码\n```javascript\nimport React from 'react';\nimport {Provider} from 'react-redux'\nimport {createStore} from 'redux'\nimport Son1 from './subComp3/son1'\nimport Son2 from './subComp3/son2'\n\n//初始化store\nimport reducers from './subComp3/redux/reducers'\nlet store = createStore(reducers)\n\n//redux方式实现状态管理\nclass App extends React.Component {\n    render() {\n        return (\n            <Provider store={store}>\n                <div className=\"app tac\">\n                    App3\n                    <div className=\"flexC\">\n                        <Son1/>\n                        <Son2/>\n                    </div>\n                </div>\n            </Provider>\n        );\n    }\n}\nexport default App;\n```\n# 4 react-redux原理\n从上面的应用中我们也可以看出，react-redux的核心函数是：createStore函数和connect函数，下面我们看一下这两个函数的实现\n```javascript\n//createStore函数\n\nconst INIT = '@@redux/INIT_' + Math.random().toString(36).substring(7)\nexport default function createStore(reducer, initialState/*初始值*/, enhancer/*加强函数*/) {\n    //如果第二个参数传入的是函数则认为是加强函数\n    if (typeof initialState === 'function') {\n        enhancer = initialState;\n        initialState = undefined;\n    }\n    //执行加强函数\n    if (typeof enhancer === 'function') {\n        return enhancer(createStore)(reducer, initialState)\n    }\n\n    let state = initialState;\n    const listeners = [];\n    const store = {\n        getState(){\n            return state\n        },\n        dispatch(action){\n            if (!action || !action.type)return;\n            state = reducer(state, action);\n            listeners.forEach(listener=>listener())\n        },\n        subscribe(listener){\n            if (!typeof listener === 'function')return;\n            listeners.push(listener);\n            return ()=> {//删除订阅函数\n                let index = listeners.indexOf(listener);\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    //自动执行初始化\n    store.dispatch({type: INIT})\n    return store;\n}\n```\n\n```javascript\nimport React from 'react'\nimport PropTypes from 'prop-types'\nconst connect = (mapStateToProps = state=>state, mapDispatchToProps = dispatch=>({}))=>(WrappedComponent)=> {\n    class Connect extends React.Component {\n        constructor() {\n            super()\n            this.state = {};\n        }\n\n        componentWillMount() {\n            this.unSubscribe = this.context.store.subscribe(()=> {\n                this.setState(mapStateToProps(this.context.store.getState()))\n            });\n        }\n\n        componentWillUnmount() {\n            this.unSubscribe();\n        }\n\n        render() {\n            return <WrappedComponent {...this.state}\n                {...mapDispatchToProps(this.context.store.dispatch)}\n            />\n        }\n    }\n    Connect.contextTypes = {\n        store: PropTypes.object\n    }\n    return Connect;\n}\n\n\nexport default connect\n```\n上面我们说过，store是通过顶层组件Provider传递进来的，配合context，来进行跨组件传递数据。代码如下：\n```javascript\nimport React from 'react';\nimport PropTypes from 'prop-types'\n\nclass Provider extends React.Component {\n    getChildContext() {\n        return {\n            store: this.props.store\n        };\n    }\n    constructor() {\n        super()\n        this.state = {};\n    }\n    render() {\n        return this.props.children;\n    }\n}\n\nProvider.childContextTypes = {\n    store: PropTypes.object\n}\nexport default Provider;\n\n```\n另外react-redux为了让我们更好的拆分合并reducers，提供了一个combineReducers方法，代码如下：\n```javascript\nexport default function combineReducers(reducers) {\n    const availableKeys = []      //存储函数名\n    const availableReducers = {}  //存储函数\n    //遍历获取全部reducer函数\n    Object.keys(reducers).forEach(key => {\n        if (typeof reducers[key] === 'function') {\n            availableKeys.push(key)\n            availableReducers[key] = reducers[key]\n        }\n    })\n    //返回一个reducer函数\n    return (state = {}, action) => {\n        const nextState = {}\n        let hasChanged = false\n        //逐个调用reducer函数来修改state，同时判断state是否发生改变\n        availableKeys.forEach(key => {\n            nextState[key] = availableReducers[key](state[key], action)\n            if (!hasChanged) {\n                hasChanged = state[key] !== nextState[key]\n            }\n        })\n        return hasChanged ? nextState : state\n    }\n}\n```\n以上呢就是react-redux的基本原理，是不是很简单，确实如此。\n但是，redux更强大是中间件功能。先来看一个例子：\n```javascript\n// file myMiddlewares\nfunction middleware1(getStore, dispatch) {\n    return function (next) {\n        return function (action) {\n            console.log(1)\n            next(action)\n            console.log(2)\n        }\n    }\n}\nconst standMiddleware = (getStore, dispatch)=>next=>action=> {\n    console.log('i am stand')\n    next(action);\n    console.log('i am stand 2')\n}\nexport default [middleware1, standMiddleware]\n```\n\n```javascript\nimport createStore from './createStore'\nimport reducers from './reducers'\nimport applyMiddleware from './applyMiddleware'\nimport myMiddlewares from './myMiddlewares'\nconst store = createStore(\n    reducers,\n    applyMiddleware(...myMiddlewares)\n);\n```\nmiddleware 的函数签名是 ({ getState, dispatch }) => next => action\nMiddleware 只是包装了 store 的 dispatch 方法。技术上讲，任何 middleware 能做的事情，都可能通过手动包装 dispatch 调用来实现，但是放在同一个地方统一管理会使整个项目的扩展变的容易得多。\n这次我们在创建store时传入了一个加强函数，其中我们还用到了 applyMiddleware 方法，有什么作用呢？applyMiddleware 主要是对redux进行增强。\n```javascript\nimport compose from './compose'\nexport default function applyMiddleware(...middlewares) {\n    return createStore=>(...args)=> {//三个参数 reducer, preloadedState, enhancer\n        const store = createStore(...args);\n        let dispatch = ()=> {\n        }\n        const middlewareAPI = {\n            getState: store.getState,\n            dispatch: (...args)=>dispatch(...args)\n        }\n\n        const chains = middlewares.map(middleware=>middleware(middlewareAPI))\n        dispatch = compose(...chains)(store.dispatch);\n\n        return {\n            ...store,\n            dispatch\n        }\n\n    }\n}\n```\n这里applyMiddleware返回的函数可以用来加强createStore函数的，因此我们又多了一种创建store的方法，新函数内部对中间件进行了洋葱圈式的调用，生成了新的dispatch。\n```javascript\n//方法1\nconst store = createStore(reducer, null, applyMiddleware(...))\n//方法2\nconst store = createStore(reducer, applyMiddleware(...))\n//方法3\nconst midCreateStore= applyMiddleware(...)(createStore);\nconst store = midCreateStore(reducer)\n```\napplyMiddleware本质是什么吗？它肯定是比 middleware 还强大的扩展机制。实际上，applyMiddleware 只是被称为 Redux 最强大的扩展机制的 store enhancers 中的一个范例而已。我们不太可能需要实现自己的 store enhancer。另一个 store enhancer 示例是 redux-devtools。Middleware 并没有 store enhancer 强大，但开发起来却是更容易的。\nMiddleware 听起来比实际难一些。真正理解 middleware 的唯一办法是了解现有的 middleware 是如何工作的，并尝试自己实现。需要的功能可能错综复杂，但是你会发现大部分 middleware 实际上很小，只有 10 行左右，是通过对它们的组合使用来达到最终的目的。\n这里需要注意的一个地方是用到了一个compose函数，代码如下：\n```javascript\nexport default function compose(...funcs) {\n    if (funcs.length == 0) {\n        return arg=>arg;\n    }\n    if (funcs.length === 1) {\n        return funcs[0]\n    }\n    return funcs.reduce((a, b)=> {//a是reduce函数的累加器\n        return (...args)=> {\n            return a(b(...args))\n        }\n    })\n}\n```\n函数式编程中有一种模式是通过组合多个函数的功能来实现一个组合函数。一般支持函数式编程的工具库都实现了这种模式，这种模式一般被称作 compose 与 pipe。看下面一个例子。\n```javascript\n const inc=(num)=>++num;\n const f1=compose(Math.abs,inc,Math.pow);\n const f2=pipe(Math.pow,Math.abs,inc);\n console.log(f1(-2,3));//7\n console.log(f2(-2,3));//9\n```\n从上面的例子可以看出，假设f、g、h分别表示三个函数，则compose(f,g,h)返回的函数完成类似(...args) => f(g(h(...args)))的功能。即从右到左组合多个函数，前面函数的返回值作为下一个函数的参数;\n**注意，只有最后一个函数可以接收多个参数，前面的函数都只接收一个参数**\npipe(f,g,h)返回的函数完成类似(...args) => h(g(f(...args)))的功能，即从左到右组合多个函数，前面函数的返回值作为下一个函数的参数；\n**注意，只有第一个函数可以接收多个参数，后面的函数都只接收一个参数**\ncompose函数再实现的时候用到了Array.reduce函数，不清楚的可以自己了解一下\ncompose模块的代码十分简练，但是实现的作用却是十分强大。redux为何称为redux？有人说就是reduce和flux的结合体，而reduce正是compose模块的核心。\n\n# 5 我们项目中的reducers\n先来看一下一般情况下的reducers，这个是刚才我们实现的。\n```javascript\nimport {\n    CLICK_SON2_1,\n    CLICK_SON1_2_2\n} from './actions'\nfunction reducers(state = {}, action) {\n    switch (action.type) {\n        case CLICK_SON2_1:\n            return Object.assign({}, state, {\n                clickValue: action.text\n            });\n        case CLICK_SON1_2_2:\n            return Object.assign({}, state, {\n                clickValue: action.text\n            });\n    }\n    return state;\n}\nexport default reducers;\n```\n两个点击，需要两个数据状态，就包含两个case语句，虽然redux给我们提供了combineReducers来进行拆分合并，但是这些变量管理起来还是很麻烦。我们来看一下我们的项目里是怎么实现的。\n```javascript\nimport combineReducers from './combineReducers'\nimport {Map} from 'immutable'  //不可改变的数据结构\nfunction mapReducer(state = new Map(), action = {}) {\n    switch (action.type) {\n        case 'SET_MAP':\n            return state.setIn(action.keyPath, action.value)\n    }\n    return state;\n}\nexport default combineReducers({\n    map: mapReducer,\n});\n```\n\n```javascript\nimport {dispatch,getState} from './store'\n\nexport function setMap(keyPath, value) {\n    keyPath = getKeyPath(keyPath)\n    dispatch({type: 'SET_MAP', keyPath, value});\n}\n\nexport function getMap(keyPath) {\n    keyPath = getKeyPath(keyPath)\n    return getState().map.getIn(keyPath);\n}\n\nfunction getKeyPath(keyPath) {\n    if (!Array.isArray(keyPath)) {\n        keyPath = [keyPath]\n    }\n    return keyPath;\n}\n```\n用法\n```javascript\nsetMap('value', '2');//设置\ngetMap('value')       //获取\n//或者\nsetMap(['page1','value'], {a:'2'});//设置\ngetMap(['page1','value'])       //获取\n```\n这里面主要用到了一个immutable对象，什么是immutable呢？\nImmutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。\n不可变数据让纯函数更强大，也让程序开发愈发简单明了，同时使类似于惰性求值的函数式编程成为可能。\n为了在javascript上实现这些强大的概念，我们给javascript引擎带来了熟悉的面向对象的API以及Array、Map和Set上一的些镜像方法，让它能简单和高效地与普通javascript对象互相转换。\n这里我们主要用到的api就是Map\n<iframe width=613 height=575 src=\"https://img.fengjr.com/image/2019/12/03/38ffaa6822fa66c12ac56c25ccc7b1de.gif\"/>\n* Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象\n* Immutable 实现的原理是 Persistent Data Structure （持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变\n* 同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗， Immutable 使用了 Structural Sharing···· （结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。\nredux中的store是有不可变性的，不可变性保证了纯函数无副作用，能够直观的逻辑推导。因此Redux本身的原则也保证了状态对象的不可变性。\n#### redux有三原则：\n* 单一数据源\n* State 是只读的\n* 使用纯函数来执行修改\n因此每次更新获取的都是一个新的state对象。immutable本身也是一个不可变对象，每次更新也是生成一个新的对象，跟redux结合非常合适。\n**实际上，Redux 并不在意你如何存储 state，state 可以是普通对象，不可变对象，或者其它类型。你可以使用任何数据存储的库，只要它支持数据的不可变动性。**\n\n\n\n\n\n\n\n","slug":"redux原理","published":1,"_id":"ck562y5rs0001khq67re0qiol","layout":"post","photos":[],"link":"","content":"<h1 id=\"1-什么时候使用redux\"><a href=\"#1-什么时候使用redux\" class=\"headerlink\" title=\"1 什么时候使用redux\"></a>1 什么时候使用redux</h1><p>首先，并不是所有的 React 应用程序都需要使用 Redux。事实上，大多数非常简单的 React 应用程序根本不能从 Redux 中受益。</p>\n<h4 id=\"第1天\"><a href=\"#第1天\" class=\"headerlink\" title=\"第1天\"></a>第1天</h4><p>使用 React 本地组件状态<br>React 使用单向数据流，这意味着父组件把自身的状态作为属性传递给子组件。</p>\n<p><iframe width=\"600\" height=\"300\" src=\"https://img.fengjr.com/image/2019/11/26/ed405e9a73d1d95196668d52024a201c.gif\"></iframe></p>\n<h4 id=\"第5天\"><a href=\"#第5天\" class=\"headerlink\" title=\"第5天\"></a>第5天</h4><p>随着添加更多的功能，非父子组件之间需要共享一些状态。<br>我们通过提升状态来解决这个问题。<br>这意味着我们将状态（和改变这个状态的函数）提升到最接近的祖先（Container Component）。我们将这些函数绑定到容器组件，并将它们作为属性向下传递。这意味着子组件可以触发其父组件中的状态更改，这将更新树中的所有其他组件。</p>\n<p><iframe width=\"600\" height=\"325\" src=\"https://img.fengjr.com/image/2019/11/26/7adb4aa588ca14985673b3bace108e05.gif\"></iframe></p>\n<h4 id=\"第20天\"><a href=\"#第20天\" class=\"headerlink\" title=\"第20天\"></a>第20天</h4><p>随着添加了更多的功能和组件，我们的应用程序状态流程开始看起来像这样…</p>\n<p><iframe width=\"600\" height=\"480\" src=\"https://img.fengjr.com/image/2019/11/26/68d9f5328d8a4c30c1feb0494fdba7c1.gif\"></iframe></p>\n<h4 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h4><p>当我们使用 Redux 后，状态变成了这样：</p>\n<p><iframe width=\"700\" height=\"480\" src=\"https://img.fengjr.com/image/2019/11/26/a5c3b436a4f28db524201e13c483ce60.gif\"></iframe></p>\n<h5 id=\"如果您的应用符合以下某些条件，那么我认为应该立即使用-Redux。\"><a href=\"#如果您的应用符合以下某些条件，那么我认为应该立即使用-Redux。\" class=\"headerlink\" title=\"如果您的应用符合以下某些条件，那么我认为应该立即使用 Redux。\"></a>如果您的应用符合以下某些条件，那么我认为应该立即使用 Redux。</h5><ul>\n<li>UI 可以根据应用程序状态显着变化</li>\n<li>并不总是以一种线性的，单向的方式流动</li>\n<li>许多不相关的组件以相同的方式更新状态</li>\n<li>状态树并不简单</li>\n<li>状态以许多不同的方式更新</li>\n<li>您需要能够撤消以前的用户操作</li>\n</ul>\n<h1 id=\"2-没有redux的时候\"><a href=\"#2-没有redux的时候\" class=\"headerlink\" title=\"2 没有redux的时候\"></a>2 没有redux的时候</h1><p>如果没有redux，我们再处理跨组件传递数据的时候怎么处理呢？以上面的例子为例，我们用react实现一下<br>首先准备几个基础组件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son11 <span class=\"keyword\">from</span> <span class=\"string\">'./son1_1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son12 <span class=\"keyword\">from</span> <span class=\"string\">'./son1_2'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"tac w50\"</span>&gt;</span><br><span class=\"line\">                Son1</span><br><span class=\"line\">                &lt;div className=<span class=\"string\">\"flexC\"</span>&gt;</span><br><span class=\"line\">                    &lt;Son11/&gt;</span><br><span class=\"line\">                    &lt;Son12/&gt;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Son;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1-1 负责展示</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            value: <span class=\"string\">''</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50\"</span>&gt;</span><br><span class=\"line\">                Son1_1 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1-2 无</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son121 <span class=\"keyword\">from</span> <span class=\"string\">'./son1_2_1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son122 <span class=\"keyword\">from</span> <span class=\"string\">'./son1_2_2'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"tac w50\"</span>&gt;</span><br><span class=\"line\">                Son1_2</span><br><span class=\"line\">                &lt;div className=<span class=\"string\">\"flexC\"</span>&gt;</span><br><span class=\"line\">                    &lt;Son121/&gt;</span><br><span class=\"line\">                    &lt;Son122/&gt;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Son;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">////节点1-2-1 负责展示</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            value: <span class=\"string\">''</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50\"</span>&gt;</span><br><span class=\"line\">                Son1_2_1 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1-2-2  负责展示和触发事件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            value: <span class=\"string\">''</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50 active\"</span> onClick=&#123;()=&gt;<span class=\"keyword\">this</span>.onClick()&#125;&gt;</span><br><span class=\"line\">                Son1_2_2 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点2  无</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son21 <span class=\"keyword\">from</span> <span class=\"string\">'./son2_1'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"tac w50\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                Son2</span></span><br><span class=\"line\">                &lt;div className=\"flexC fe\"&gt;</span><br><span class=\"line\">                    &lt;Son21 /&gt;</span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Son;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点2-1  负责触发事件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50 active\"</span> onClick=&#123;<span class=\"keyword\">this</span>.onClick&#125;&gt;</span><br><span class=\"line\">                Son2_1</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure>\n<p>以上是基础组件，节点1-2-2和节点2-1来模拟点击事件，节点1-1、节点1-2-1、节点1-2-2来展示效果。<br>下面以发布/订阅模式 pub-sub(Publish/Subscribe) 来实现，发布/订阅模式(Pub/Sub)是一种消息模式，它有两个参与者 :  发布者和订阅者，两者之间是多对多的关系。通过消息处理器来关联。发布者向某个信道（通常是个字符串）发布一条消息，订阅者绑定这个信道，当有消息发布至信道时就会接收到一个通知。最重要的一点是， 发布者和订阅者是完全解耦的，彼此并不知晓对方的存在，两者仅仅共享一个信道名称。<br>发布/订阅模式，通常用于消息队列中。一般有两种形式来实现消息队列，一是使用生产者和消费者来实现，二是使用发布/订阅模式来实现。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Son1 <span class=\"keyword\">from</span> <span class=\"string\">'./subComp2/son1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son2 <span class=\"keyword\">from</span> <span class=\"string\">'./subComp2/son2'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData = &#123;</span><br><span class=\"line\">            events: &#123;&#125;,</span><br><span class=\"line\">            sub: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, event</span>) </span>&#123;<span class=\"comment\">//订阅</span></span><br><span class=\"line\">                <span class=\"keyword\">this</span>.events[name] = <span class=\"keyword\">this</span>.events[name] || [];</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.events[name].push(event);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            pub: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, data</span>) </span>&#123;<span class=\"comment\">//发布</span></span><br><span class=\"line\">                (<span class=\"keyword\">this</span>.events[name] || []).forEach(<span class=\"function\"><span class=\"params\">event</span>=&gt;</span> &#123;</span><br><span class=\"line\">                    event(data);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"app tac\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                App2</span></span><br><span class=\"line\">                &lt;div className=\"flexC\"&gt;</span><br><span class=\"line\">                    &lt;Son1/&gt;</span><br><span class=\"line\">                    &lt;Son2/&gt;</span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码实现了一个消息处理器，然后我们来看如何使用。首先要订阅消息，我们修改节点1-1点代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1-1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            value: <span class=\"string\">''</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData.sub(<span class=\"string\">'event_son1_1'</span>, (data)=&gt; &#123;<span class=\"comment\">//订阅消息</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                value: data,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50\"</span>&gt;</span><br><span class=\"line\">                Son1_1 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure></p>\n<p>节点1-2-1、节点1-2-2的代码也类似。<br>然后是发布消息，修改节点2-1点代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点2-1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    onClick = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData.pub(<span class=\"string\">'event_son1_1'</span>, <span class=\"string\">'2'</span>);<span class=\"comment\">//发布消息</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData.pub(<span class=\"string\">'event_son1_2_1'</span>, <span class=\"string\">'2'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData.pub(<span class=\"string\">'event_son1_2_2'</span>, <span class=\"string\">'2'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"w50 active\"</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.onClick&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                Son2_1</span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Son;</span><br></pre></td></tr></table></figure></p>\n<p>节点1-2-2也按此修改。<br>除了发布/订阅模式，还有另外两种模式：观察者模式和事件监听模式<br>观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常用在实时事件处理系统。参与者是被观察者（含消息管理器）、观察者。<br>发布/订阅模式与观察者模式的区别：从定义上看，发布订阅模式里双方是完全解耦的，而在观察者模式里，目标对象管理这观察者，双方是耦合的，这是最主要的区别，而在发布订阅模式中多了一个中间层信道。<br>事件监听模式重要的三个概念：事件+事件监听器+事件源，从观察者模式发展而来，比观察者模式略微复杂，就是将消息处理器进行分离解耦，从而更加灵活<br>事件监听模式与观察者模式勉强的对应关系可以看成是，被观察者相当于事件源，观察者相当于监听器，事件源会产生事件，监听器监听事件。<br><strong>观察者模式和发布订阅模型的区别就在于消息是否发送给中间件，观察者和被观察着是否完全解耦；而观察者模式和事件驱动的区别则在于事件驱动则更加灵活，但同时增加了程序的复杂性。其实这三者本质上没有什么区别，只是适用场景不同。</strong></p>\n<h1 id=\"3-redux\"><a href=\"#3-redux\" class=\"headerlink\" title=\"3 redux\"></a>3 redux</h1><p>很明显以上的方法虽然能处理问题，但是很明显存在一些缺陷：例如信道名称多的话就容易混乱；发布者与订阅者互相不知道对方，分不清数据流向；window上的全局变量不安全。<br>其实我们想要这样一个函数，他满足：</p>\n<ul>\n<li>存放一个数据对象</li>\n<li>外界能访问到这个数据</li>\n<li>外界也能修改这个数据</li>\n<li>当数据有变化的时候，通知订阅者</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, initialState</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// currentState就是那个数据</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> currentState = initialState;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> listener = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">    currentState = reducer(currentState, action); <span class=\"comment\">// 更新数据</span></span><br><span class=\"line\">    listener(); <span class=\"comment\">// 执行订阅函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> action;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">newListener</span>) </span>&#123;</span><br><span class=\"line\">     listener = newListener;</span><br><span class=\"line\">     <span class=\"comment\">// 取消订阅函数</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       listener = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">     getState,</span><br><span class=\"line\">     dispatch,</span><br><span class=\"line\">     subscribe</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就实现了一个store，提供一个数据存储中心，可以供外部访问、修改等，这就是Redux的主要思想。 实际上，Redux确实和React没有什么关系，Redux可以结合其他库正常使用。只不过Redux这种数据管理方式，跟React的数据驱动视图理念很合拍，它俩结合在一起，开发非常便利。<br>不过创建的store存在放在window上还是不舒服。</p>\n<h1 id=\"4-react-redux\"><a href=\"#4-react-redux\" class=\"headerlink\" title=\"4 react-redux\"></a>4 react-redux</h1><p>在react-redux，把store直接集成到React应用的顶层props里面，只要各个子组件能访问到顶层props就行了，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">  &lt;App /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Provider&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>React恰好提供了这么一个钩子，Context。各个子组件就能够轻易地访问到store了，接下来就是子组件把store中用到的数据取出来、修改、以及订阅更新UI等，每个子组件都需要这样做一遍就好。<br>当然，肯定有更便利的方法：高阶组件。通过高阶组件把store.getState()、store.dispatch、store.subscribe封装起来，子组件对store是无感知的，子组件正常使用props获取数据以及正常使用callback触发回调，相当于没有store存在一样。</p>\n<h3 id=\"Context的用法\"><a href=\"#Context的用法\" class=\"headerlink\" title=\"Context的用法\"></a>Context的用法</h3><p>这里我们顺带说一下Context，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。<br>如果要Context发挥作用，需要用到两种组件，一个是Context生产者(Provider)，通常是一个父节点，另外是一个Context的消费者(Consumer)，通常是一个或者多个子节点。所以Context的使用基于生产者消费者模式。<br>对于父组件，也就是Context生产者，需要通过一个静态属性childContextTypes声明提供给子组件的Context对象的属性，并实现一个实例getChildContext方法，返回一个代表Context的纯对象 (plain object) 。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> childContextTypes = &#123; <span class=\"comment\">// 声明Context对象属性</span></span><br><span class=\"line\">        color: PropTypes.string,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getChildContext () &#123;<span class=\"comment\">// 返回Context对象，方法名是约定好的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            color: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">MiddleComponent</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">class MiddleComponent extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    render () &#123;</span></span><br><span class=\"line\"><span class=\"xml\">        return <span class=\"tag\">&lt;<span class=\"name\">ChildComponent</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>而对于Context的消费者，通过如下方式访问父组件提供的Context。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明需要使用的Context属性</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">        color: PropTypes.string</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;color&#125; = <span class=\"keyword\">this</span>.context</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;color&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>子组件需要通过一个静态属性contextTypes声明后，才能访问父组件Context对象的属性，否则，即使属性名没写错，拿到的对象也是undefined。</p>\n<h3 id=\"React-Redux的用法\"><a href=\"#React-Redux的用法\" class=\"headerlink\" title=\"React-Redux的用法\"></a>React-Redux的用法</h3><p>React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）</p>\n<h4 id=\"UI组件\"><a href=\"#UI组件\" class=\"headerlink\" title=\"UI组件\"></a>UI组件</h4><ul>\n<li>只负责UI的呈现，不带有任何业务逻辑</li>\n<li>没有状态（即不使用this.state这个变量）</li>\n<li>所有数据都由参数（this.props）提供</li>\n<li>不使用任何Redux的 API<h4 id=\"容器组件\"><a href=\"#容器组件\" class=\"headerlink\" title=\"容器组件\"></a>容器组件</h4></li>\n<li>负责管理数据和业务逻辑，不负责 UI 的呈现</li>\n<li>带有内部状态</li>\n<li>使用 Redux 的 API<br>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。那么react-redux是如何生成容器组件呢，答案是通过connect()函数，例如：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> VisibleTodoList = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(TodoList)</span><br></pre></td></tr></table></figure>\n<p>connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。<br>上面的点击的例子，我们用react-redux来实现，首先要增加reducers和actions<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file actions</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> CLICK_SON2_1 = <span class=\"string\">'CLICK_SON2_1'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> CLICK_SON1_2_2 = <span class=\"string\">'CLICK_SON1_2_2'</span>;</span><br><span class=\"line\"><span class=\"comment\">//action函数包含属性名和属性值</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clickSon2_1</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        type: CLICK_SON2_1,</span><br><span class=\"line\">        text,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clickSon1_2_2</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        type: CLICK_SON1_2_2,</span><br><span class=\"line\">        text,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file reducers</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; CLICK_SON2_1, CLICK_SON1_2_2&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducers</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;<span class=\"comment\">//修改状态</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CLICK_SON2_1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">                clickValue: action.text</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CLICK_SON1_2_2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">                clickValue: action.text</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> reducers;</span><br></pre></td></tr></table></figure>\n<p>下面修改节点1-1展示的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50\"</span>&gt;</span><br><span class=\"line\">                Son1_1 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(state=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        value: state.clickValue</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;, dispatch=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)(Son);</span></span><br></pre></td></tr></table></figure></p>\n<p>然后修改2-1点击事件的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;clickSon2_1&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../subComp3/redux/actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    onClick = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50 active\"</span> onClick=&#123;<span class=\"keyword\">this</span>.onClick&#125;&gt;</span><br><span class=\"line\">                Son2_1</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(state=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;, dispatch=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        click: ()=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            dispatch(clickSon2_1('2'))</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)(Son);</span></span><br></pre></td></tr></table></figure></p>\n<p>最修改app代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Provider&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son1 <span class=\"keyword\">from</span> <span class=\"string\">'./subComp3/son1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son2 <span class=\"keyword\">from</span> <span class=\"string\">'./subComp3/son2'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化store</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducers <span class=\"keyword\">from</span> <span class=\"string\">'./subComp3/redux/reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducers)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//redux方式实现状态管理</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">                &lt;div className=<span class=\"string\">\"app tac\"</span>&gt;</span><br><span class=\"line\">                    App3</span><br><span class=\"line\">                    &lt;div className=<span class=\"string\">\"flexC\"</span>&gt;</span><br><span class=\"line\">                        &lt;Son1/&gt;</span><br><span class=\"line\">                        &lt;Son2/&gt;</span><br><span class=\"line\">                    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;/</span>div&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-react-redux原理\"><a href=\"#4-react-redux原理\" class=\"headerlink\" title=\"4 react-redux原理\"></a>4 react-redux原理</h1><p>从上面的应用中我们也可以看出，react-redux的核心函数是：createStore函数和connect函数，下面我们看一下这两个函数的实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//createStore函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> INIT = <span class=\"string\">'@@redux/INIT_'</span> + <span class=\"built_in\">Math</span>.random().toString(<span class=\"number\">36</span>).substring(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, initialState<span class=\"regexp\">/*初始值*/</span>, enhancer<span class=\"regexp\">/*加强函数*/</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果第二个参数传入的是函数则认为是加强函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> initialState === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        enhancer = initialState;</span><br><span class=\"line\">        initialState = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//执行加强函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer(createStore)(reducer, initialState)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> state = initialState;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> listeners = [];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = &#123;</span><br><span class=\"line\">        getState()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        dispatch(action)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!action || !action.type)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">            state = reducer(state, action);</span><br><span class=\"line\">            listeners.forEach(<span class=\"function\"><span class=\"params\">listener</span>=&gt;</span>listener())</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        subscribe(listener)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"keyword\">typeof</span> listener === <span class=\"string\">'function'</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">            listeners.push(listener);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;<span class=\"comment\">//删除订阅函数</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> index = listeners.indexOf(listener);</span><br><span class=\"line\">                listeners.splice(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//自动执行初始化</span></span><br><span class=\"line\">    store.dispatch(&#123;<span class=\"attr\">type</span>: INIT&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> store;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state=&gt;state, mapDispatchToProps = dispatch=&gt;(&#123;&#125;</span>))=&gt;</span><span class=\"function\">(<span class=\"params\">WrappedComponent</span>)=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>()</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.state = &#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentWillMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.unSubscribe = <span class=\"keyword\">this</span>.context.store.subscribe(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.setState(mapStateToProps(<span class=\"keyword\">this</span>.context.store.getState()))</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentWillUnmount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.unSubscribe();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.state</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"xml\">                &#123;...mapDispatchToProps(this.context.store.dispatch)&#125;</span></span><br><span class=\"line\"><span class=\"xml\">            /&gt;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    Connect.contextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"xml\">        store: PropTypes.object</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    return Connect;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">export default connect</span></span><br></pre></td></tr></table></figure>\n<p>上面我们说过，store是通过顶层组件Provider传递进来的，配合context，来进行跨组件传递数据。代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getChildContext() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            store: <span class=\"keyword\">this</span>.props.store</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>()</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Provider.childContextTypes = &#123;</span><br><span class=\"line\">    store: PropTypes.object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Provider;</span><br></pre></td></tr></table></figure></p>\n<p>另外react-redux为了让我们更好的拆分合并reducers，提供了一个combineReducers方法，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> availableKeys = []      <span class=\"comment\">//存储函数名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> availableReducers = &#123;&#125;  <span class=\"comment\">//存储函数</span></span><br><span class=\"line\">    <span class=\"comment\">//遍历获取全部reducer函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(reducers).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">            availableKeys.push(key)</span><br><span class=\"line\">            availableReducers[key] = reducers[key]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">//返回一个reducer函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nextState = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"comment\">//逐个调用reducer函数来修改state，同时判断state是否发生改变</span></span><br><span class=\"line\">        availableKeys.forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">            nextState[key] = availableReducers[key](state[key], action)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasChanged) &#123;</span><br><span class=\"line\">                hasChanged = state[key] !== nextState[key]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上呢就是react-redux的基本原理，是不是很简单，确实如此。<br>但是，redux更强大是中间件功能。先来看一个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file myMiddlewares</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware1</span>(<span class=\"params\">getStore, dispatch</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">            next(action)</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> standMiddleware = <span class=\"function\">(<span class=\"params\">getStore, dispatch</span>)=&gt;</span><span class=\"function\"><span class=\"params\">next</span>=&gt;</span><span class=\"function\"><span class=\"params\">action</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i am stand'</span>)</span><br><span class=\"line\">    next(action);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i am stand 2'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> [middleware1, standMiddleware]</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> createStore <span class=\"keyword\">from</span> <span class=\"string\">'./createStore'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducers <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> applyMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'./applyMiddleware'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> myMiddlewares <span class=\"keyword\">from</span> <span class=\"string\">'./myMiddlewares'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(</span><br><span class=\"line\">    reducers,</span><br><span class=\"line\">    applyMiddleware(...myMiddlewares)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>middleware 的函数签名是 ({ getState, dispatch }) =&gt; next =&gt; action<br>Middleware 只是包装了 store 的 dispatch 方法。技术上讲，任何 middleware 能做的事情，都可能通过手动包装 dispatch 调用来实现，但是放在同一个地方统一管理会使整个项目的扩展变的容易得多。<br>这次我们在创建store时传入了一个加强函数，其中我们还用到了 applyMiddleware 方法，有什么作用呢？applyMiddleware 主要是对redux进行增强。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> compose <span class=\"keyword\">from</span> <span class=\"string\">'./compose'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span>=&gt;</span><span class=\"function\">(<span class=\"params\">...args</span>)=&gt;</span> &#123;<span class=\"comment\">//三个参数 reducer, preloadedState, enhancer</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> store = createStore(...args);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> dispatch = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">            getState: store.getState,</span><br><span class=\"line\">            dispatch: <span class=\"function\">(<span class=\"params\">...args</span>)=&gt;</span>dispatch(...args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> chains = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span>=&gt;</span>middleware(middlewareAPI))</span><br><span class=\"line\">        dispatch = compose(...chains)(store.dispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            ...store,</span><br><span class=\"line\">            dispatch</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里applyMiddleware返回的函数可以用来加强createStore函数的，因此我们又多了一种创建store的方法，新函数内部对中间件进行了洋葱圈式的调用，生成了新的dispatch。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer, <span class=\"literal\">null</span>, applyMiddleware(...))</span><br><span class=\"line\"><span class=\"comment\">//方法2</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer, applyMiddleware(...))</span><br><span class=\"line\"><span class=\"comment\">//方法3</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> midCreateStore= applyMiddleware(...)(createStore);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = midCreateStore(reducer)</span><br></pre></td></tr></table></figure></p>\n<p>applyMiddleware本质是什么吗？它肯定是比 middleware 还强大的扩展机制。实际上，applyMiddleware 只是被称为 Redux 最强大的扩展机制的 store enhancers 中的一个范例而已。我们不太可能需要实现自己的 store enhancer。另一个 store enhancer 示例是 redux-devtools。Middleware 并没有 store enhancer 强大，但开发起来却是更容易的。<br>Middleware 听起来比实际难一些。真正理解 middleware 的唯一办法是了解现有的 middleware 是如何工作的，并尝试自己实现。需要的功能可能错综复杂，但是你会发现大部分 middleware 实际上很小，只有 10 行左右，是通过对它们的组合使用来达到最终的目的。<br>这里需要注意的一个地方是用到了一个compose函数，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (funcs.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span>=&gt;</span>arg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>)=&gt;</span> &#123;<span class=\"comment\">//a是reduce函数的累加器</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...args</span>)=&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a(b(...args))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数式编程中有一种模式是通过组合多个函数的功能来实现一个组合函数。一般支持函数式编程的工具库都实现了这种模式，这种模式一般被称作 compose 与 pipe。看下面一个例子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inc=<span class=\"function\">(<span class=\"params\">num</span>)=&gt;</span>++num;</span><br><span class=\"line\"><span class=\"keyword\">const</span> f1=compose(<span class=\"built_in\">Math</span>.abs,inc,<span class=\"built_in\">Math</span>.pow);</span><br><span class=\"line\"><span class=\"keyword\">const</span> f2=pipe(<span class=\"built_in\">Math</span>.pow,<span class=\"built_in\">Math</span>.abs,inc);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1(<span class=\"number\">-2</span>,<span class=\"number\">3</span>));<span class=\"comment\">//7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f2(<span class=\"number\">-2</span>,<span class=\"number\">3</span>));<span class=\"comment\">//9</span></span><br></pre></td></tr></table></figure></p>\n<p>从上面的例子可以看出，假设f、g、h分别表示三个函数，则compose(f,g,h)返回的函数完成类似(…args) =&gt; f(g(h(…args)))的功能。即从右到左组合多个函数，前面函数的返回值作为下一个函数的参数;<br><strong>注意，只有最后一个函数可以接收多个参数，前面的函数都只接收一个参数</strong><br>pipe(f,g,h)返回的函数完成类似(…args) =&gt; h(g(f(…args)))的功能，即从左到右组合多个函数，前面函数的返回值作为下一个函数的参数；<br><strong>注意，只有第一个函数可以接收多个参数，后面的函数都只接收一个参数</strong><br>compose函数再实现的时候用到了Array.reduce函数，不清楚的可以自己了解一下<br>compose模块的代码十分简练，但是实现的作用却是十分强大。redux为何称为redux？有人说就是reduce和flux的结合体，而reduce正是compose模块的核心。</p>\n<h1 id=\"5-我们项目中的reducers\"><a href=\"#5-我们项目中的reducers\" class=\"headerlink\" title=\"5 我们项目中的reducers\"></a>5 我们项目中的reducers</h1><p>先来看一下一般情况下的reducers，这个是刚才我们实现的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">    CLICK_SON2_1,</span><br><span class=\"line\">    CLICK_SON1_2_2</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducers</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CLICK_SON2_1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">                clickValue: action.text</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CLICK_SON1_2_2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">                clickValue: action.text</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> reducers;</span><br></pre></td></tr></table></figure></p>\n<p>两个点击，需要两个数据状态，就包含两个case语句，虽然redux给我们提供了combineReducers来进行拆分合并，但是这些变量管理起来还是很麻烦。我们来看一下我们的项目里是怎么实现的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> combineReducers <span class=\"keyword\">from</span> <span class=\"string\">'./combineReducers'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"built_in\">Map</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>  <span class=\"comment\">//不可改变的数据结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapReducer</span>(<span class=\"params\">state = new Map(</span>), <span class=\"title\">action</span> = </span>&#123;&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'SET_MAP'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state.setIn(action.keyPath, action.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">    map: mapReducer,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;dispatch,getState&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./store'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setMap</span>(<span class=\"params\">keyPath, value</span>) </span>&#123;</span><br><span class=\"line\">    keyPath = getKeyPath(keyPath)</span><br><span class=\"line\">    dispatch(&#123;<span class=\"attr\">type</span>: <span class=\"string\">'SET_MAP'</span>, keyPath, value&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMap</span>(<span class=\"params\">keyPath</span>) </span>&#123;</span><br><span class=\"line\">    keyPath = getKeyPath(keyPath)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getState().map.getIn(keyPath);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKeyPath</span>(<span class=\"params\">keyPath</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(keyPath)) &#123;</span><br><span class=\"line\">        keyPath = [keyPath]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> keyPath;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setMap(<span class=\"string\">'value'</span>, <span class=\"string\">'2'</span>);<span class=\"comment\">//设置</span></span><br><span class=\"line\">getMap(<span class=\"string\">'value'</span>)       <span class=\"comment\">//获取</span></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\">setMap([<span class=\"string\">'page1'</span>,<span class=\"string\">'value'</span>], &#123;<span class=\"attr\">a</span>:<span class=\"string\">'2'</span>&#125;);<span class=\"comment\">//设置</span></span><br><span class=\"line\">getMap([<span class=\"string\">'page1'</span>,<span class=\"string\">'value'</span>])       <span class=\"comment\">//获取</span></span><br></pre></td></tr></table></figure></p>\n<p>这里面主要用到了一个immutable对象，什么是immutable呢？<br>Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。<br>不可变数据让纯函数更强大，也让程序开发愈发简单明了，同时使类似于惰性求值的函数式编程成为可能。<br>为了在javascript上实现这些强大的概念，我们给javascript引擎带来了熟悉的面向对象的API以及Array、Map和Set上一的些镜像方法，让它能简单和高效地与普通javascript对象互相转换。<br>这里我们主要用到的api就是Map</p>\n<p><iframe width=\"613\" height=\"575\" src=\"https://img.fengjr.com/image/2019/12/03/38ffaa6822fa66c12ac56c25ccc7b1de.gif\"></iframe></p>\n<ul>\n<li>Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象</li>\n<li>Immutable 实现的原理是 Persistent Data Structure （持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变</li>\n<li>同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗， Immutable 使用了 Structural Sharing···· （结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。<br>redux中的store是有不可变性的，不可变性保证了纯函数无副作用，能够直观的逻辑推导。因此Redux本身的原则也保证了状态对象的不可变性。<h4 id=\"redux有三原则：\"><a href=\"#redux有三原则：\" class=\"headerlink\" title=\"redux有三原则：\"></a>redux有三原则：</h4></li>\n<li>单一数据源</li>\n<li>State 是只读的</li>\n<li>使用纯函数来执行修改<br>因此每次更新获取的都是一个新的state对象。immutable本身也是一个不可变对象，每次更新也是生成一个新的对象，跟redux结合非常合适。<br><strong>实际上，Redux 并不在意你如何存储 state，state 可以是普通对象，不可变对象，或者其它类型。你可以使用任何数据存储的库，只要它支持数据的不可变动性。</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-什么时候使用redux\"><a href=\"#1-什么时候使用redux\" class=\"headerlink\" title=\"1 什么时候使用redux\"></a>1 什么时候使用redux</h1><p>首先，并不是所有的 React 应用程序都需要使用 Redux。事实上，大多数非常简单的 React 应用程序根本不能从 Redux 中受益。</p>\n<h4 id=\"第1天\"><a href=\"#第1天\" class=\"headerlink\" title=\"第1天\"></a>第1天</h4><p>使用 React 本地组件状态<br>React 使用单向数据流，这意味着父组件把自身的状态作为属性传递给子组件。</p>\n<p><iframe width=\"600\" height=\"300\" src=\"https://img.fengjr.com/image/2019/11/26/ed405e9a73d1d95196668d52024a201c.gif\"></iframe></p>\n<h4 id=\"第5天\"><a href=\"#第5天\" class=\"headerlink\" title=\"第5天\"></a>第5天</h4><p>随着添加更多的功能，非父子组件之间需要共享一些状态。<br>我们通过提升状态来解决这个问题。<br>这意味着我们将状态（和改变这个状态的函数）提升到最接近的祖先（Container Component）。我们将这些函数绑定到容器组件，并将它们作为属性向下传递。这意味着子组件可以触发其父组件中的状态更改，这将更新树中的所有其他组件。</p>\n<p><iframe width=\"600\" height=\"325\" src=\"https://img.fengjr.com/image/2019/11/26/7adb4aa588ca14985673b3bace108e05.gif\"></iframe></p>\n<h4 id=\"第20天\"><a href=\"#第20天\" class=\"headerlink\" title=\"第20天\"></a>第20天</h4><p>随着添加了更多的功能和组件，我们的应用程序状态流程开始看起来像这样…</p>\n<p><iframe width=\"600\" height=\"480\" src=\"https://img.fengjr.com/image/2019/11/26/68d9f5328d8a4c30c1feb0494fdba7c1.gif\"></iframe></p>\n<h4 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h4><p>当我们使用 Redux 后，状态变成了这样：</p>\n<p><iframe width=\"700\" height=\"480\" src=\"https://img.fengjr.com/image/2019/11/26/a5c3b436a4f28db524201e13c483ce60.gif\"></iframe></p>\n<h5 id=\"如果您的应用符合以下某些条件，那么我认为应该立即使用-Redux。\"><a href=\"#如果您的应用符合以下某些条件，那么我认为应该立即使用-Redux。\" class=\"headerlink\" title=\"如果您的应用符合以下某些条件，那么我认为应该立即使用 Redux。\"></a>如果您的应用符合以下某些条件，那么我认为应该立即使用 Redux。</h5><ul>\n<li>UI 可以根据应用程序状态显着变化</li>\n<li>并不总是以一种线性的，单向的方式流动</li>\n<li>许多不相关的组件以相同的方式更新状态</li>\n<li>状态树并不简单</li>\n<li>状态以许多不同的方式更新</li>\n<li>您需要能够撤消以前的用户操作</li>\n</ul>\n<h1 id=\"2-没有redux的时候\"><a href=\"#2-没有redux的时候\" class=\"headerlink\" title=\"2 没有redux的时候\"></a>2 没有redux的时候</h1><p>如果没有redux，我们再处理跨组件传递数据的时候怎么处理呢？以上面的例子为例，我们用react实现一下<br>首先准备几个基础组件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son11 <span class=\"keyword\">from</span> <span class=\"string\">'./son1_1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son12 <span class=\"keyword\">from</span> <span class=\"string\">'./son1_2'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"tac w50\"</span>&gt;</span><br><span class=\"line\">                Son1</span><br><span class=\"line\">                &lt;div className=<span class=\"string\">\"flexC\"</span>&gt;</span><br><span class=\"line\">                    &lt;Son11/&gt;</span><br><span class=\"line\">                    &lt;Son12/&gt;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Son;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1-1 负责展示</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            value: <span class=\"string\">''</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50\"</span>&gt;</span><br><span class=\"line\">                Son1_1 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1-2 无</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son121 <span class=\"keyword\">from</span> <span class=\"string\">'./son1_2_1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son122 <span class=\"keyword\">from</span> <span class=\"string\">'./son1_2_2'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"tac w50\"</span>&gt;</span><br><span class=\"line\">                Son1_2</span><br><span class=\"line\">                &lt;div className=<span class=\"string\">\"flexC\"</span>&gt;</span><br><span class=\"line\">                    &lt;Son121/&gt;</span><br><span class=\"line\">                    &lt;Son122/&gt;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Son;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">////节点1-2-1 负责展示</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            value: <span class=\"string\">''</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50\"</span>&gt;</span><br><span class=\"line\">                Son1_2_1 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1-2-2  负责展示和触发事件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            value: <span class=\"string\">''</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50 active\"</span> onClick=&#123;()=&gt;<span class=\"keyword\">this</span>.onClick()&#125;&gt;</span><br><span class=\"line\">                Son1_2_2 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点2  无</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son21 <span class=\"keyword\">from</span> <span class=\"string\">'./son2_1'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"tac w50\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                Son2</span></span><br><span class=\"line\">                &lt;div className=\"flexC fe\"&gt;</span><br><span class=\"line\">                    &lt;Son21 /&gt;</span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Son;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点2-1  负责触发事件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50 active\"</span> onClick=&#123;<span class=\"keyword\">this</span>.onClick&#125;&gt;</span><br><span class=\"line\">                Son2_1</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure>\n<p>以上是基础组件，节点1-2-2和节点2-1来模拟点击事件，节点1-1、节点1-2-1、节点1-2-2来展示效果。<br>下面以发布/订阅模式 pub-sub(Publish/Subscribe) 来实现，发布/订阅模式(Pub/Sub)是一种消息模式，它有两个参与者 :  发布者和订阅者，两者之间是多对多的关系。通过消息处理器来关联。发布者向某个信道（通常是个字符串）发布一条消息，订阅者绑定这个信道，当有消息发布至信道时就会接收到一个通知。最重要的一点是， 发布者和订阅者是完全解耦的，彼此并不知晓对方的存在，两者仅仅共享一个信道名称。<br>发布/订阅模式，通常用于消息队列中。一般有两种形式来实现消息队列，一是使用生产者和消费者来实现，二是使用发布/订阅模式来实现。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Son1 <span class=\"keyword\">from</span> <span class=\"string\">'./subComp2/son1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son2 <span class=\"keyword\">from</span> <span class=\"string\">'./subComp2/son2'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData = &#123;</span><br><span class=\"line\">            events: &#123;&#125;,</span><br><span class=\"line\">            sub: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, event</span>) </span>&#123;<span class=\"comment\">//订阅</span></span><br><span class=\"line\">                <span class=\"keyword\">this</span>.events[name] = <span class=\"keyword\">this</span>.events[name] || [];</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.events[name].push(event);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            pub: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, data</span>) </span>&#123;<span class=\"comment\">//发布</span></span><br><span class=\"line\">                (<span class=\"keyword\">this</span>.events[name] || []).forEach(<span class=\"function\"><span class=\"params\">event</span>=&gt;</span> &#123;</span><br><span class=\"line\">                    event(data);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"app tac\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                App2</span></span><br><span class=\"line\">                &lt;div className=\"flexC\"&gt;</span><br><span class=\"line\">                    &lt;Son1/&gt;</span><br><span class=\"line\">                    &lt;Son2/&gt;</span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码实现了一个消息处理器，然后我们来看如何使用。首先要订阅消息，我们修改节点1-1点代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点1-1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            value: <span class=\"string\">''</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData.sub(<span class=\"string\">'event_son1_1'</span>, (data)=&gt; &#123;<span class=\"comment\">//订阅消息</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                value: data,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50\"</span>&gt;</span><br><span class=\"line\">                Son1_1 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Son;</span></span><br></pre></td></tr></table></figure></p>\n<p>节点1-2-1、节点1-2-2的代码也类似。<br>然后是发布消息，修改节点2-1点代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//节点2-1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    onClick = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData.pub(<span class=\"string\">'event_son1_1'</span>, <span class=\"string\">'2'</span>);<span class=\"comment\">//发布消息</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData.pub(<span class=\"string\">'event_son1_2_1'</span>, <span class=\"string\">'2'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.reduxData.pub(<span class=\"string\">'event_son1_2_2'</span>, <span class=\"string\">'2'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"w50 active\"</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.onClick&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                Son2_1</span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Son;</span><br></pre></td></tr></table></figure></p>\n<p>节点1-2-2也按此修改。<br>除了发布/订阅模式，还有另外两种模式：观察者模式和事件监听模式<br>观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常用在实时事件处理系统。参与者是被观察者（含消息管理器）、观察者。<br>发布/订阅模式与观察者模式的区别：从定义上看，发布订阅模式里双方是完全解耦的，而在观察者模式里，目标对象管理这观察者，双方是耦合的，这是最主要的区别，而在发布订阅模式中多了一个中间层信道。<br>事件监听模式重要的三个概念：事件+事件监听器+事件源，从观察者模式发展而来，比观察者模式略微复杂，就是将消息处理器进行分离解耦，从而更加灵活<br>事件监听模式与观察者模式勉强的对应关系可以看成是，被观察者相当于事件源，观察者相当于监听器，事件源会产生事件，监听器监听事件。<br><strong>观察者模式和发布订阅模型的区别就在于消息是否发送给中间件，观察者和被观察着是否完全解耦；而观察者模式和事件驱动的区别则在于事件驱动则更加灵活，但同时增加了程序的复杂性。其实这三者本质上没有什么区别，只是适用场景不同。</strong></p>\n<h1 id=\"3-redux\"><a href=\"#3-redux\" class=\"headerlink\" title=\"3 redux\"></a>3 redux</h1><p>很明显以上的方法虽然能处理问题，但是很明显存在一些缺陷：例如信道名称多的话就容易混乱；发布者与订阅者互相不知道对方，分不清数据流向；window上的全局变量不安全。<br>其实我们想要这样一个函数，他满足：</p>\n<ul>\n<li>存放一个数据对象</li>\n<li>外界能访问到这个数据</li>\n<li>外界也能修改这个数据</li>\n<li>当数据有变化的时候，通知订阅者</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, initialState</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// currentState就是那个数据</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> currentState = initialState;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> listener = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">    currentState = reducer(currentState, action); <span class=\"comment\">// 更新数据</span></span><br><span class=\"line\">    listener(); <span class=\"comment\">// 执行订阅函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> action;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">newListener</span>) </span>&#123;</span><br><span class=\"line\">     listener = newListener;</span><br><span class=\"line\">     <span class=\"comment\">// 取消订阅函数</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       listener = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">     getState,</span><br><span class=\"line\">     dispatch,</span><br><span class=\"line\">     subscribe</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就实现了一个store，提供一个数据存储中心，可以供外部访问、修改等，这就是Redux的主要思想。 实际上，Redux确实和React没有什么关系，Redux可以结合其他库正常使用。只不过Redux这种数据管理方式，跟React的数据驱动视图理念很合拍，它俩结合在一起，开发非常便利。<br>不过创建的store存在放在window上还是不舒服。</p>\n<h1 id=\"4-react-redux\"><a href=\"#4-react-redux\" class=\"headerlink\" title=\"4 react-redux\"></a>4 react-redux</h1><p>在react-redux，把store直接集成到React应用的顶层props里面，只要各个子组件能访问到顶层props就行了，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">  &lt;App /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Provider&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>React恰好提供了这么一个钩子，Context。各个子组件就能够轻易地访问到store了，接下来就是子组件把store中用到的数据取出来、修改、以及订阅更新UI等，每个子组件都需要这样做一遍就好。<br>当然，肯定有更便利的方法：高阶组件。通过高阶组件把store.getState()、store.dispatch、store.subscribe封装起来，子组件对store是无感知的，子组件正常使用props获取数据以及正常使用callback触发回调，相当于没有store存在一样。</p>\n<h3 id=\"Context的用法\"><a href=\"#Context的用法\" class=\"headerlink\" title=\"Context的用法\"></a>Context的用法</h3><p>这里我们顺带说一下Context，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。<br>如果要Context发挥作用，需要用到两种组件，一个是Context生产者(Provider)，通常是一个父节点，另外是一个Context的消费者(Consumer)，通常是一个或者多个子节点。所以Context的使用基于生产者消费者模式。<br>对于父组件，也就是Context生产者，需要通过一个静态属性childContextTypes声明提供给子组件的Context对象的属性，并实现一个实例getChildContext方法，返回一个代表Context的纯对象 (plain object) 。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> childContextTypes = &#123; <span class=\"comment\">// 声明Context对象属性</span></span><br><span class=\"line\">        color: PropTypes.string,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getChildContext () &#123;<span class=\"comment\">// 返回Context对象，方法名是约定好的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            color: <span class=\"string\">'red'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">MiddleComponent</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">class MiddleComponent extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    render () &#123;</span></span><br><span class=\"line\"><span class=\"xml\">        return <span class=\"tag\">&lt;<span class=\"name\">ChildComponent</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>而对于Context的消费者，通过如下方式访问父组件提供的Context。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明需要使用的Context属性</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">        color: PropTypes.string</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;color&#125; = <span class=\"keyword\">this</span>.context</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;color&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>子组件需要通过一个静态属性contextTypes声明后，才能访问父组件Context对象的属性，否则，即使属性名没写错，拿到的对象也是undefined。</p>\n<h3 id=\"React-Redux的用法\"><a href=\"#React-Redux的用法\" class=\"headerlink\" title=\"React-Redux的用法\"></a>React-Redux的用法</h3><p>React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）</p>\n<h4 id=\"UI组件\"><a href=\"#UI组件\" class=\"headerlink\" title=\"UI组件\"></a>UI组件</h4><ul>\n<li>只负责UI的呈现，不带有任何业务逻辑</li>\n<li>没有状态（即不使用this.state这个变量）</li>\n<li>所有数据都由参数（this.props）提供</li>\n<li>不使用任何Redux的 API<h4 id=\"容器组件\"><a href=\"#容器组件\" class=\"headerlink\" title=\"容器组件\"></a>容器组件</h4></li>\n<li>负责管理数据和业务逻辑，不负责 UI 的呈现</li>\n<li>带有内部状态</li>\n<li>使用 Redux 的 API<br>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。那么react-redux是如何生成容器组件呢，答案是通过connect()函数，例如：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> VisibleTodoList = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(TodoList)</span><br></pre></td></tr></table></figure>\n<p>connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。<br>上面的点击的例子，我们用react-redux来实现，首先要增加reducers和actions<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file actions</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> CLICK_SON2_1 = <span class=\"string\">'CLICK_SON2_1'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> CLICK_SON1_2_2 = <span class=\"string\">'CLICK_SON1_2_2'</span>;</span><br><span class=\"line\"><span class=\"comment\">//action函数包含属性名和属性值</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clickSon2_1</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        type: CLICK_SON2_1,</span><br><span class=\"line\">        text,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clickSon1_2_2</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        type: CLICK_SON1_2_2,</span><br><span class=\"line\">        text,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file reducers</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; CLICK_SON2_1, CLICK_SON1_2_2&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducers</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;<span class=\"comment\">//修改状态</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CLICK_SON2_1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">                clickValue: action.text</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CLICK_SON1_2_2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">                clickValue: action.text</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> reducers;</span><br></pre></td></tr></table></figure>\n<p>下面修改节点1-1展示的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123;value&#125;=<span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50\"</span>&gt;</span><br><span class=\"line\">                Son1_1 &#123;value &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">className</span>=<span class=\"string\">\"selected\"</span>&gt;</span>&#123;value&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(state=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        value: state.clickValue</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;, dispatch=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)(Son);</span></span><br></pre></td></tr></table></figure></p>\n<p>然后修改2-1点击事件的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;clickSon2_1&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../subComp3/redux/actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    onClick = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div className=<span class=\"string\">\"w50 active\"</span> onClick=&#123;<span class=\"keyword\">this</span>.onClick&#125;&gt;</span><br><span class=\"line\">                Son2_1</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(state=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;, dispatch=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        click: ()=&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            dispatch(clickSon2_1('2'))</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)(Son);</span></span><br></pre></td></tr></table></figure></p>\n<p>最修改app代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Provider&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son1 <span class=\"keyword\">from</span> <span class=\"string\">'./subComp3/son1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Son2 <span class=\"keyword\">from</span> <span class=\"string\">'./subComp3/son2'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化store</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducers <span class=\"keyword\">from</span> <span class=\"string\">'./subComp3/redux/reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducers)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//redux方式实现状态管理</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">                &lt;div className=<span class=\"string\">\"app tac\"</span>&gt;</span><br><span class=\"line\">                    App3</span><br><span class=\"line\">                    &lt;div className=<span class=\"string\">\"flexC\"</span>&gt;</span><br><span class=\"line\">                        &lt;Son1/&gt;</span><br><span class=\"line\">                        &lt;Son2/&gt;</span><br><span class=\"line\">                    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;/</span>div&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-react-redux原理\"><a href=\"#4-react-redux原理\" class=\"headerlink\" title=\"4 react-redux原理\"></a>4 react-redux原理</h1><p>从上面的应用中我们也可以看出，react-redux的核心函数是：createStore函数和connect函数，下面我们看一下这两个函数的实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//createStore函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> INIT = <span class=\"string\">'@@redux/INIT_'</span> + <span class=\"built_in\">Math</span>.random().toString(<span class=\"number\">36</span>).substring(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, initialState<span class=\"regexp\">/*初始值*/</span>, enhancer<span class=\"regexp\">/*加强函数*/</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果第二个参数传入的是函数则认为是加强函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> initialState === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        enhancer = initialState;</span><br><span class=\"line\">        initialState = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//执行加强函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer(createStore)(reducer, initialState)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> state = initialState;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> listeners = [];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = &#123;</span><br><span class=\"line\">        getState()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        dispatch(action)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!action || !action.type)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">            state = reducer(state, action);</span><br><span class=\"line\">            listeners.forEach(<span class=\"function\"><span class=\"params\">listener</span>=&gt;</span>listener())</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        subscribe(listener)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"keyword\">typeof</span> listener === <span class=\"string\">'function'</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">            listeners.push(listener);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;<span class=\"comment\">//删除订阅函数</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> index = listeners.indexOf(listener);</span><br><span class=\"line\">                listeners.splice(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//自动执行初始化</span></span><br><span class=\"line\">    store.dispatch(&#123;<span class=\"attr\">type</span>: INIT&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> store;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state=&gt;state, mapDispatchToProps = dispatch=&gt;(&#123;&#125;</span>))=&gt;</span><span class=\"function\">(<span class=\"params\">WrappedComponent</span>)=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>()</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.state = &#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentWillMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.unSubscribe = <span class=\"keyword\">this</span>.context.store.subscribe(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.setState(mapStateToProps(<span class=\"keyword\">this</span>.context.store.getState()))</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentWillUnmount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.unSubscribe();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.state</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"xml\">                &#123;...mapDispatchToProps(this.context.store.dispatch)&#125;</span></span><br><span class=\"line\"><span class=\"xml\">            /&gt;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    Connect.contextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"xml\">        store: PropTypes.object</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    return Connect;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">export default connect</span></span><br></pre></td></tr></table></figure>\n<p>上面我们说过，store是通过顶层组件Provider传递进来的，配合context，来进行跨组件传递数据。代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getChildContext() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            store: <span class=\"keyword\">this</span>.props.store</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>()</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Provider.childContextTypes = &#123;</span><br><span class=\"line\">    store: PropTypes.object</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Provider;</span><br></pre></td></tr></table></figure></p>\n<p>另外react-redux为了让我们更好的拆分合并reducers，提供了一个combineReducers方法，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> availableKeys = []      <span class=\"comment\">//存储函数名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> availableReducers = &#123;&#125;  <span class=\"comment\">//存储函数</span></span><br><span class=\"line\">    <span class=\"comment\">//遍历获取全部reducer函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(reducers).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">            availableKeys.push(key)</span><br><span class=\"line\">            availableReducers[key] = reducers[key]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">//返回一个reducer函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nextState = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"comment\">//逐个调用reducer函数来修改state，同时判断state是否发生改变</span></span><br><span class=\"line\">        availableKeys.forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">            nextState[key] = availableReducers[key](state[key], action)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasChanged) &#123;</span><br><span class=\"line\">                hasChanged = state[key] !== nextState[key]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上呢就是react-redux的基本原理，是不是很简单，确实如此。<br>但是，redux更强大是中间件功能。先来看一个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file myMiddlewares</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleware1</span>(<span class=\"params\">getStore, dispatch</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">            next(action)</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> standMiddleware = <span class=\"function\">(<span class=\"params\">getStore, dispatch</span>)=&gt;</span><span class=\"function\"><span class=\"params\">next</span>=&gt;</span><span class=\"function\"><span class=\"params\">action</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i am stand'</span>)</span><br><span class=\"line\">    next(action);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i am stand 2'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> [middleware1, standMiddleware]</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> createStore <span class=\"keyword\">from</span> <span class=\"string\">'./createStore'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducers <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> applyMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'./applyMiddleware'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> myMiddlewares <span class=\"keyword\">from</span> <span class=\"string\">'./myMiddlewares'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(</span><br><span class=\"line\">    reducers,</span><br><span class=\"line\">    applyMiddleware(...myMiddlewares)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>middleware 的函数签名是 ({ getState, dispatch }) =&gt; next =&gt; action<br>Middleware 只是包装了 store 的 dispatch 方法。技术上讲，任何 middleware 能做的事情，都可能通过手动包装 dispatch 调用来实现，但是放在同一个地方统一管理会使整个项目的扩展变的容易得多。<br>这次我们在创建store时传入了一个加强函数，其中我们还用到了 applyMiddleware 方法，有什么作用呢？applyMiddleware 主要是对redux进行增强。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> compose <span class=\"keyword\">from</span> <span class=\"string\">'./compose'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span>=&gt;</span><span class=\"function\">(<span class=\"params\">...args</span>)=&gt;</span> &#123;<span class=\"comment\">//三个参数 reducer, preloadedState, enhancer</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> store = createStore(...args);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> dispatch = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">            getState: store.getState,</span><br><span class=\"line\">            dispatch: <span class=\"function\">(<span class=\"params\">...args</span>)=&gt;</span>dispatch(...args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> chains = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span>=&gt;</span>middleware(middlewareAPI))</span><br><span class=\"line\">        dispatch = compose(...chains)(store.dispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            ...store,</span><br><span class=\"line\">            dispatch</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里applyMiddleware返回的函数可以用来加强createStore函数的，因此我们又多了一种创建store的方法，新函数内部对中间件进行了洋葱圈式的调用，生成了新的dispatch。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer, <span class=\"literal\">null</span>, applyMiddleware(...))</span><br><span class=\"line\"><span class=\"comment\">//方法2</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer, applyMiddleware(...))</span><br><span class=\"line\"><span class=\"comment\">//方法3</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> midCreateStore= applyMiddleware(...)(createStore);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = midCreateStore(reducer)</span><br></pre></td></tr></table></figure></p>\n<p>applyMiddleware本质是什么吗？它肯定是比 middleware 还强大的扩展机制。实际上，applyMiddleware 只是被称为 Redux 最强大的扩展机制的 store enhancers 中的一个范例而已。我们不太可能需要实现自己的 store enhancer。另一个 store enhancer 示例是 redux-devtools。Middleware 并没有 store enhancer 强大，但开发起来却是更容易的。<br>Middleware 听起来比实际难一些。真正理解 middleware 的唯一办法是了解现有的 middleware 是如何工作的，并尝试自己实现。需要的功能可能错综复杂，但是你会发现大部分 middleware 实际上很小，只有 10 行左右，是通过对它们的组合使用来达到最终的目的。<br>这里需要注意的一个地方是用到了一个compose函数，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (funcs.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span>=&gt;</span>arg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>)=&gt;</span> &#123;<span class=\"comment\">//a是reduce函数的累加器</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...args</span>)=&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a(b(...args))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数式编程中有一种模式是通过组合多个函数的功能来实现一个组合函数。一般支持函数式编程的工具库都实现了这种模式，这种模式一般被称作 compose 与 pipe。看下面一个例子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inc=<span class=\"function\">(<span class=\"params\">num</span>)=&gt;</span>++num;</span><br><span class=\"line\"><span class=\"keyword\">const</span> f1=compose(<span class=\"built_in\">Math</span>.abs,inc,<span class=\"built_in\">Math</span>.pow);</span><br><span class=\"line\"><span class=\"keyword\">const</span> f2=pipe(<span class=\"built_in\">Math</span>.pow,<span class=\"built_in\">Math</span>.abs,inc);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1(<span class=\"number\">-2</span>,<span class=\"number\">3</span>));<span class=\"comment\">//7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f2(<span class=\"number\">-2</span>,<span class=\"number\">3</span>));<span class=\"comment\">//9</span></span><br></pre></td></tr></table></figure></p>\n<p>从上面的例子可以看出，假设f、g、h分别表示三个函数，则compose(f,g,h)返回的函数完成类似(…args) =&gt; f(g(h(…args)))的功能。即从右到左组合多个函数，前面函数的返回值作为下一个函数的参数;<br><strong>注意，只有最后一个函数可以接收多个参数，前面的函数都只接收一个参数</strong><br>pipe(f,g,h)返回的函数完成类似(…args) =&gt; h(g(f(…args)))的功能，即从左到右组合多个函数，前面函数的返回值作为下一个函数的参数；<br><strong>注意，只有第一个函数可以接收多个参数，后面的函数都只接收一个参数</strong><br>compose函数再实现的时候用到了Array.reduce函数，不清楚的可以自己了解一下<br>compose模块的代码十分简练，但是实现的作用却是十分强大。redux为何称为redux？有人说就是reduce和flux的结合体，而reduce正是compose模块的核心。</p>\n<h1 id=\"5-我们项目中的reducers\"><a href=\"#5-我们项目中的reducers\" class=\"headerlink\" title=\"5 我们项目中的reducers\"></a>5 我们项目中的reducers</h1><p>先来看一下一般情况下的reducers，这个是刚才我们实现的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">    CLICK_SON2_1,</span><br><span class=\"line\">    CLICK_SON1_2_2</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducers</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CLICK_SON2_1:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">                clickValue: action.text</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CLICK_SON1_2_2:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">                clickValue: action.text</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> reducers;</span><br></pre></td></tr></table></figure></p>\n<p>两个点击，需要两个数据状态，就包含两个case语句，虽然redux给我们提供了combineReducers来进行拆分合并，但是这些变量管理起来还是很麻烦。我们来看一下我们的项目里是怎么实现的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> combineReducers <span class=\"keyword\">from</span> <span class=\"string\">'./combineReducers'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"built_in\">Map</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>  <span class=\"comment\">//不可改变的数据结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapReducer</span>(<span class=\"params\">state = new Map(</span>), <span class=\"title\">action</span> = </span>&#123;&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'SET_MAP'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state.setIn(action.keyPath, action.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">    map: mapReducer,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;dispatch,getState&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./store'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setMap</span>(<span class=\"params\">keyPath, value</span>) </span>&#123;</span><br><span class=\"line\">    keyPath = getKeyPath(keyPath)</span><br><span class=\"line\">    dispatch(&#123;<span class=\"attr\">type</span>: <span class=\"string\">'SET_MAP'</span>, keyPath, value&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMap</span>(<span class=\"params\">keyPath</span>) </span>&#123;</span><br><span class=\"line\">    keyPath = getKeyPath(keyPath)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getState().map.getIn(keyPath);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKeyPath</span>(<span class=\"params\">keyPath</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(keyPath)) &#123;</span><br><span class=\"line\">        keyPath = [keyPath]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> keyPath;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setMap(<span class=\"string\">'value'</span>, <span class=\"string\">'2'</span>);<span class=\"comment\">//设置</span></span><br><span class=\"line\">getMap(<span class=\"string\">'value'</span>)       <span class=\"comment\">//获取</span></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\">setMap([<span class=\"string\">'page1'</span>,<span class=\"string\">'value'</span>], &#123;<span class=\"attr\">a</span>:<span class=\"string\">'2'</span>&#125;);<span class=\"comment\">//设置</span></span><br><span class=\"line\">getMap([<span class=\"string\">'page1'</span>,<span class=\"string\">'value'</span>])       <span class=\"comment\">//获取</span></span><br></pre></td></tr></table></figure></p>\n<p>这里面主要用到了一个immutable对象，什么是immutable呢？<br>Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。<br>不可变数据让纯函数更强大，也让程序开发愈发简单明了，同时使类似于惰性求值的函数式编程成为可能。<br>为了在javascript上实现这些强大的概念，我们给javascript引擎带来了熟悉的面向对象的API以及Array、Map和Set上一的些镜像方法，让它能简单和高效地与普通javascript对象互相转换。<br>这里我们主要用到的api就是Map</p>\n<p><iframe width=\"613\" height=\"575\" src=\"https://img.fengjr.com/image/2019/12/03/38ffaa6822fa66c12ac56c25ccc7b1de.gif\"></iframe></p>\n<ul>\n<li>Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象</li>\n<li>Immutable 实现的原理是 Persistent Data Structure （持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变</li>\n<li>同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗， Immutable 使用了 Structural Sharing···· （结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。<br>redux中的store是有不可变性的，不可变性保证了纯函数无副作用，能够直观的逻辑推导。因此Redux本身的原则也保证了状态对象的不可变性。<h4 id=\"redux有三原则：\"><a href=\"#redux有三原则：\" class=\"headerlink\" title=\"redux有三原则：\"></a>redux有三原则：</h4></li>\n<li>单一数据源</li>\n<li>State 是只读的</li>\n<li>使用纯函数来执行修改<br>因此每次更新获取的都是一个新的state对象。immutable本身也是一个不可变对象，每次更新也是生成一个新的对象，跟redux结合非常合适。<br><strong>实际上，Redux 并不在意你如何存储 state，state 可以是普通对象，不可变对象，或者其它类型。你可以使用任何数据存储的库，只要它支持数据的不可变动性。</strong></li>\n</ul>\n"},{"title":"websocket介绍及应用","comments":1,"date":"2019-11-27T07:16:10.000Z","author":"jun.zhou","_content":"\n# 一、websocket介绍\n\n![](https://img.fengjr.com/image/2019/11/27/379278605a69626b3915c6829b1a2cb5.png)\n\n#### WebSocket协议出现的背景\n我们在上网过程中经常用到的是HTTP和HTTPS协议，HTTP协议和HTTPS协议通信过程通常是客户端通过浏览器发出一个请求，服务器接受请求后进行处理并返回结果给客户端，客户端处理结果。\n\n这种机制对于信息变化不是特别频繁的应用可以良好支撑，但对于实时要求高、海量并发的应用来说显得捉襟见肘，尤其在移动互联网蓬勃发展的趋势下，高并发与用户实时响应是Web应用经常面临的问题，比如金融证券的实时信息、社交网络的实时消息推送等。\n\nWebSocket出现前我们实现推送技术，用的都是轮询，在特定的时间间隔，浏览器自动发出请求，将服务器的消息主动的拉回来，这种情况下，我们需要不断的向服务器发送请求，并且HTTP 请求 的header非常长，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽和服务器资源，并且服务器不能主动向客户端推送数据。在这种情况下需要一种高效节能的双向通信机制来保证数据的实时传输，于是基于HTML5规范的WebSocket应运而生。\n\n\n#### 什么是websocket\nwebsocket是HTML5的一种新的通信协议，它实现了浏览器与服务器的双向通讯。在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。\n\n在客户端使用websocket需要创建WebSocket对象，通过提供的open、send、message、close等方法实现创建、发送、监听信息、关闭连接。现在chrome、firefox等浏览器都已经支持了websocket，而IE却没有。\n\n#### WebSocket与TCP，HTTP的关系\nWebSocket与http协议一样都是基于TCP的，所以他们都是可靠的协议，调用的WebSocket的send函数在实现中最终都是通过TCP的系统接口进行传输的。WebSocket和Http协议一样都属于应用层的协议，WebSocket在建立握手连接时，数据是通过http协议传输的，但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。\n\n#### WebSocket与HTTP轮询\n- ajax轮询 \najax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。场景再现：\n客户端：啦啦啦，有没有新信息(Request)\n服务端：没有（Response）\n客户端：啦啦啦，有没有新信息(Request)\n服务端：没有。。（Response）\n客户端：啦啦啦，有没有新信息(Request)\n服务端：你好烦啊，没有啊。。（Response）\n客户端：啦啦啦，有没有新消息（Request）\n服务端：好啦好啦，有啦给你。（Response）\n客户端：啦啦啦，有没有新消息（Request）\n服务端：。。。。。没。。。。没。。。没有（Response） ---- loop\n\n![](https://img.fengjr.com/image/2019/11/27/2a0bf85b8ef69023aa962f94b2fde30a.png)\n\n- long poll \nlong poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。\n场景再现：\n客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）\n服务端：额。。   等待到有消息的时候。。来 给你（Response）\n客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop\n\n![](https://img.fengjr.com/image/2019/11/27/4c1058fe7a183d623c25ab72f946a868.png)\n\n从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。简单地说就是，服务器是一个很懒的冰箱（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。\n\n说完这个，我们再来说一说上面的缺陷\n从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。\najax轮询 需要服务器有很快的处理速度和资源。（速度）\nlong poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）\n\n- WebSocket\nWebSocket的出现解决了轮询实时交互性和全双工的问题。\n在JavaScript中创建了WebSocket后，会有一个HTTP请求发送到服务器以发起连接。取得服务器响应后，建立的连接使用HTTP升级，从HTTP协议交换为WebSocket协议。即，使用标准的HTTP服务器无法实现WebSocket，只有支持这种协议的专门服务器才能正常工作。\nWebSocket使用了自定义的协议，未加密的连接不再是http://，而是ws://，默认端口为80，加密的连接也不是https://，而是wss://，默认端口为443。\n\n<img src=\"https://img.fengjr.com/image/2019/11/27/34927c1cd3258dab7aa4156463715e6b.png\" width=\"50%\" height=\"50%\">\n\nWebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。\n\nWebSocket与HTTP轮询对比得出的结论：\nWebSocket是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。\n\n\n# 二、WebSocket API\n\n上面讲述了WebSocket比HTTP轮询好，下面介绍一下WebSocket API。\n\n#### 创建WebSocket实例\n要创建WebSocket，先实例一个WebSocket对象并传入要连接的URL：\n```\nvar socket = new WebSocket('http://localhost:8000');\n```\n执行上面语句后，浏览器会马上尝试创建连接，与XHR类似，WebSocket也有一个表示当前状态的readyState属性。不过，这个属性的值与XHR不相同， socket.readyState值如下：\n\n0：正在建立连接， WebSocket.OPENING\n1：已经建立连接， WebSocket.OPEN\n2：正在关闭连接， WebSocket.CLOSING\n3：已经关闭连接， WebSocket.CLOSE\nWebSocket没有readystatechange事件，不过，有其他事件对应着不同的状态，readyState的值永远从0开始。\n示例如下：\n```\nvar socket = new WebSocket('ws://localhost:8000');\n\n  //正在建立连接\n  console.log(\"[readyState]-\" + socket.readyState); //0\n\n  //连接建立成功回调\n  socket.onopen = function() {\n    console.log('Connection established.')\n    console.log(\"[readyState]-\" + socket.readyState); //1\n    //发送消息\n    // socket.send('hello world');\n  };\n\n  //连接失败回调\n  socket.onerror = function() {\n    console.log(\"[readyState]-\" + socket.readyState);//3\n    console.log('Connection error.')\n  };\n\n  //连接关闭回调\n  socket.onclose = function(event) {\n    var code = event.code;\n    var reason = event.reason;\n    var wasClean = event.wasClean;\n    console.log(\"[readyState]-\" + socket.readyState);//3\n    console.log('Connection closed.')\n    console.log(code, reason, wasClean)\n  };\n```\n要关闭WebSocket连接，可以在任何时候调用close方法。\n```\nsocket.close();\n```\n调用了close()之后，readyState的值立即变为2（正在关闭），关闭连接后就会变成3。\n\n#### 发送和接收数据\nWebSocket连接建立之后，可以通过连接发送和接收数据。\n使用send()方法像服务器发送数据，如下：\n```\nvar socket = new WebSocket('ws://localhost:8000');\nsocket.send('hello world');\n```\n当服务器向客户端发来消息时，WebSocket对象会触发message事件。这个message事件与其他传递消息的协议类似，也是把返回的数据保存在event.data属性中。\n```\n socket.onmessage = function(event) {\n  var data = event.data;\n  //处理数据\n};\n```\n\n#### 其他事件\nWebSocket对象还有其他三个事件，在连接生命周期的不同阶段触发。\n\nopen：成功建立连接时触发。\nerror：发生错误时触发，连接断开。\nclose: 连接关闭时触发。\n```\nvar socket = new WebSocket('ws://localhost:8000');\nsocket.onopen = function() {\n  console.log('Connection established.')\n};\nsocket.onerror = function() {\n  console.log('Connection error.')\n};\nsocket.onclose = function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  console.log('Connection closed.')\n};\n```\n这三个事件中，只有close事件的event对象有额外信息，这个事件的事件对象有三个额外的属性：wasClean、code和reason。\n其中wasClean是一个布尔值，表示连接是否已经明确的关闭；\ncode是服务器返回的数值状态码；\nreason是一个字符串，包含服务器发回的信息。\n\n# 三、WebSocket心跳及重连机制\n在使用websocket的过程中，有时候会遇到网络断开的情况，但是在网络断开的时候服务器端并没有触发onclose的事件。这样会有：服务器会继续向客户端发送多余的链接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的链接状态。因此就有了websocket的心跳了。还有心跳，说明还活着，没有心跳说明已经挂掉了。\n\n1. 为什么叫心跳包呢？\n它就像心跳一样每隔固定的时间发一次，来告诉服务器，我还活着。\n\n2. 心跳机制是？\n心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了。需要重连~\n\n那么需要怎么去实现它呢？如下所有代码：\n```\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>WebSocket Demo</title>\n</head>\n<body>\n  <script type=\"text/javascript\">\n    // var ws = new WebSocket(\"wss://echo.websocket.org\");\n    /*\n    ws.onerror = function(e) {\n      console.log('已关闭');\n    };\n    ws.onopen = function(e) {\n      console.log('握手成功');\n      ws.send('123456789');\n    }\n    ws.onclose = function() {\n      console.log('已关闭');\n    }\n    ws.onmessage = function(e) {\n      console.log('收到消息');\n      console.log(e);\n    }\n    */\n    \n    var lockReconnect = false;//避免重复连接\n    var wsUrl = \"wss://echo.websocket.org\";\n    var ws;\n    var tt;\n    function createWebSocket() {\n      try {\n        ws = new WebSocket(wsUrl);\n        init();\n      } catch(e) {\n        console.log('catch');\n        reconnect(wsUrl);\n      }\n    }\n    function init() {\n      ws.onclose = function () {\n        console.log('链接关闭');\n        reconnect(wsUrl);\n      };\n      ws.onerror = function() {\n        console.log('发生异常了');\n        reconnect(wsUrl);\n      };\n      ws.onopen = function () {\n        //心跳检测重置\n        heartCheck.start();\n      };\n      ws.onmessage = function (event) {\n        //拿到任何消息都说明当前连接是正常的\n        console.log('接收到消息');\n        heartCheck.start();\n      }\n    }\n    function reconnect(url) {\n      if(lockReconnect) {\n        return;\n      };\n      lockReconnect = true;\n      //没连接上会一直重连，设置延迟避免请求过多\n      tt && clearTimeout(tt);\n      tt = setTimeout(function () {\n        createWebSocket(url);\n        lockReconnect = false;\n      }, 4000);\n    }\n    //心跳检测\n    var heartCheck = {\n      timeout: 3000,\n      timeoutObj: null,\n      serverTimeoutObj: null,\n      start: function(){\n        console.log('start');\n        var self = this;\n        this.timeoutObj && clearTimeout(this.timeoutObj);\n        this.serverTimeoutObj && clearTimeout(this.serverTimeoutObj);\n        this.timeoutObj = setTimeout(function(){\n          //这里发送一个心跳，后端收到后，返回一个心跳消息，\n          console.log('55555');\n          ws.send(\"123456789\");\n          self.serverTimeoutObj = setTimeout(function() {\n            console.log(111);\n            console.log(ws);\n            ws.close();\n            // createWebSocket();\n          }, self.timeout);\n\n        }, this.timeout)\n      }\n    }\n    createWebSocket(wsUrl);\n  </script>\n</body>\n</html>\n```\n\n具体的思路如下：\n1. 第一步页面初始化，先调用createWebSocket函数，目的是创建一个websocket的方法：new WebSocket(wsUrl);因此封装成函数内如下代码：\n```\nfunction createWebSocket() {\n  try {\n    ws = new WebSocket(wsUrl);\n    init();\n  } catch(e) {\n    console.log('catch');\n    reconnect(wsUrl);\n  }\n}\n```\n2. 第二步调用init方法，该方法内把一些监听事件封装如下：\n```\nfunction init() {\n  ws.onclose = function () {\n    console.log('链接关闭');\n    reconnect(wsUrl);\n  };\n  ws.onerror = function() {\n    console.log('发生异常了');\n    reconnect(wsUrl);\n  };\n  ws.onopen = function () {\n    //心跳检测重置\n    heartCheck.start();\n  };\n  ws.onmessage = function (event) {\n    //拿到任何消息都说明当前连接是正常的\n    console.log('接收到消息');\n    heartCheck.start();\n  }\n}\n```\n3. 如上第二步，当网络断开的时候，会先调用onerror，onclose事件可以监听到，会调用reconnect方法进行重连操作。正常的情况下，是先调用\nonopen方法的，当接收到数据时，会被onmessage事件监听到。\n\n4. 重连操作 reconnect代码如下：\n```\nvar lockReconnect = false;//避免重复连接\nfunction reconnect(url) {\n  if(lockReconnect) {\n    return;\n  };\n  lockReconnect = true;\n  //没连接上会一直重连，设置延迟避免请求过多\n  tt && clearTimeout(tt);\n  tt = setTimeout(function () {\n    createWebSocket(url);\n    lockReconnect = false;\n  }, 4000);\n}\n```\n如上代码，如果网络断开的话，会执行reconnect方法，使用了一个定时器，4秒后会重新创建一个新的websocket链接，重新调用createWebSocket函数，\n重新会执行及发送数据给服务器端。\n\n5. 最后一步就是实现心跳检测的代码：如下：\n```\n//心跳检测\nvar heartCheck = {\n  timeout: 3000,\n  timeoutObj: null,\n  serverTimeoutObj: null,\n  start: function(){\n    console.log('start');\n    var self = this;\n    this.timeoutObj && clearTimeout(this.timeoutObj);\n    this.serverTimeoutObj && clearTimeout(this.serverTimeoutObj);\n    this.timeoutObj = setTimeout(function(){\n      //这里发送一个心跳，后端收到后，返回一个心跳消息，\n      //onmessage拿到返回的心跳就说明连接正常\n      console.log('55555');\n      ws.send(\"123456789\");\n      self.serverTimeoutObj = setTimeout(function() {\n        console.log(111);\n        console.log(ws);\n        ws.close();\n        // createWebSocket();\n      }, self.timeout);\n\n    }, this.timeout)\n  }\n}\n```\n实现心跳检测的思路是：每隔一段固定的时间，向服务器端发送一个ping数据，如果在正常的情况下，服务器会返回一个pong给客户端，如果客户端通过onmessage事件能监听到的话，说明请求正常，这里我们使用了一个定时器，每隔3秒的情况下，如果是网络断开的情况下，在指定的时间内服务器端并没有返回心跳响应消息，因此服务器端断开了，因此这个时候我们使用ws.close关闭连接，在一段时间后(在不同的浏览器下，时间是不一样的，firefox响应更快)，可以通过 onclose事件监听到。因此在onclose事件内，我们可以调用 reconnect事件进行重连操作。\n\n\n\n# 四、WebSocket 实例\n前面已经学习了WebSocket API，包括事件、方法和属性。WebSocket是基于事件驱动，支持全双工通信。下面通过二个简单例子体验一下。\n\n#### 简单在线聊天\n1、通过nodejs在项目里面新建一个server.js，创建服务，指定8181端口\n```\nvar express = require('express');\nvar http = require('http');\nvar WebSocket = require('ws');\nvar app = express();\napp.use(express.static(__dirname));\napp.get('/', function(req, res){\n\tres.send('<h1>Welcome Realtime Server</h1>');\n});\nvar server = http.createServer(app);\nvar wss = new WebSocket.Server({server});\nwss.on('connection', function connection(ws) {\n    console.log('链接成功！');\n    ws.on('message', function incoming(data) {\n        /**\n         * 把消息发送到所有的客户端\n         * wss.clients获取所有链接的客户端\n         */\n        wss.clients.forEach(function each(client) {\n            client.send(data);\n        });\n    });\n});\n\nserver.listen(8181, function listening() {\n    console.log('服务器启动成功！');\n});\n```\n在浏览器里输入http://localhost:8181/测试服务是否启动成功。\n\n2、创建客户端。为了能在多台设备上测试，可以本地在启一个服务来跑客户端代码。\n通node启一个8282端口的本机服务 \napp.js\n```\nvar express = require('express');\nvar http = require('http');\n\nvar app = express();\napp.use(express.static(__dirname));\nvar server = http.createServer(app);\n\napp.get('/', function(req, res){\n\tres.send('<h1>Welcome client</h1>');\n});\n\nserver.listen(8282, function listening() {\n    console.log('ok！');\n});\n```\n3、创建index.html\n```\n<div>\n    <h1>websocket chat</h1>\n    <div>\n        <input id=\"name\" size=\"15\" type=\"text\" placeholder=\"姓名\" value=\"\">\n        <input id=\"message\" size=\"50\" type=\"text\" placeholder=\"内容\" value=\"\">\n        <input id=\"btn_post\" type=\"button\" value=\"post\">\n    </div>\n    <ul id=\"chat\"></ul>\n</div>\n<script src=\"http://cdn.bootcss.com/jquery/1.9.1/jquery.js\"></script>\n```\n可以输入姓名和内容，然后有一个提交按钮来发送数据给服务器。\n\n4、创建websocket链接\n```\nvar ws = new WebSocket(\"ws://localhost:8181\");\n\n```\n要在多台服务测试需要把localhost改成IP\n```\nvar ws = new WebSocket(\"ws://10.254.124.8:8181\");\n```\n5、点击提交按钮或回车向服务器发送信息，使用 ws.send 方法\n```\n$(function(){\n  $(\"#btn_post\").click(post);\n  $(\"#message\").keydown(function(e){\n    if(e.keyCode == 13) post();\n  });\n});\nvar post = function(){\n  var name = $(\"#name\").val();\n  var mes = $(\"#message\").val();\n  ws.send(name+\" : \"+mes);\n  $(\"input#message\").val(\"\");\n};\n```\n6、服务器接收到信息后返回给客户端，使用 ws.onmessage 方法\n```\nws.onmessage = function(e){\n  print(e.data);\n};\nvar print = function(msg){\n  $(\"#chat\").prepend($(\"<li>\").text(msg));\n};\n```\n浏览器里输入 http://10.254.124.8:8282/index.html 可以看到预览效果\n![](https://img.fengjr.com/image/2019/11/27/a36c14d25b7ef14a1787320e29a09266.png)\n\n#### 模拟股票实例\n上面的例子很简单，只是为了演示如何运用nodejs的ws创建一个WebSocket服务器。且可以接受客户端的消息。那么下面这个例子演示股票的实时更新。客服端只需要连接一次，服务器端会不断地发送新数据，客户端收数据后更新UI.页面如下，有五只股票，开始和停止按钮测试连接和关闭。\n\n![](https://img.fengjr.com/image/2019/11/27/83b293b5e353e2d9bdf080e7cf7cbb82.png)\n\n服务端：\n1.模拟五只股票的涨跌。\n```\nvar stocks = {\n    \"AAPL\": 95.0,\n    \"MSFT\": 50.0,\n    \"AMZN\": 300.0,\n    \"GOOG\": 550.0,\n    \"YHOO\": 35.0\n}\nfunction randomInterval(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\nvar stockUpdater;\nvar randomStockUpdater = function() {\n    for (var symbol in stocks) {\n        if(stocks.hasOwnProperty(symbol)) {\n            var randomizedChange = randomInterval(-150, 150);\n            var floatChange = randomizedChange / 100;\n            stocks[symbol] += floatChange;\n        }\n    }\n    var randomMSTime = randomInterval(500, 2500);\n    stockUpdater = setTimeout(function() {\n        randomStockUpdater();\n    }, randomMSTime);\n}\nrandomStockUpdater();\n```\n2.连接建立之后就开始更新数据\n```\nwss.on('connection', function (ws) {\n  var sendStockUpdates = function (ws) {\n      if (ws.readyState == 1) {\n          var stocksObj = {};\n          for (var i = 0; i < clientStocks.length; i++) {\n            var symbol = clientStocks[i];\n              stocksObj[symbol] = stocks[symbol];\n          }\n          if (stocksObj.length !== 0) {\n              ws.send(JSON.stringify(stocksObj));//需要将对象转成字符串。WebSocket只支持文本和二进制数据\n              console.log(\"更新\", JSON.stringify(stocksObj));\n          }\n          \n      }\n  }\n  var clientStockUpdater = setInterval(function () {\n      sendStockUpdates(ws);\n  }, 1000);\n  ws.on('message', function (message) {\n      var stockRequest = JSON.parse(message);//根据请求过来的数据来更新。\n      console.log(\"收到消息\", stockRequest);\n      clientStocks = stockRequest['stocks'];\n      sendStockUpdates(ws);\n  });\n```\n\n客户端：\n建立连接：\n```\n var ws = new WebSocket(\"ws://localhost:8181\");\n```\nonopen直接只有在连接成功后才会触发，在这个时候将客户端需要请求的股票发送给服务端。\n```\nvar isClose = false;\n  var stocks = {\n      \"AAPL\": 0, \"MSFT\": 0, \"AMZN\": 0, \"GOOG\": 0, \"YHOO\": 0\n  };\n  function updataUI() {\n      ws.onopen = function (e) {\n          console.log('Connection to server opened');\n          isClose = false;\n          ws.send(JSON.stringify(stock_request));\n          console.log(\"sened a mesg\");\n      }\n      //更新UI\n      var changeStockEntry = function (symbol, originalValue, newValue) {\n          var valElem = $('#' + symbol + ' span');\n          valElem.html(newValue.toFixed(2));\n          if (newValue < originalValue) {\n              valElem.addClass('label-danger');\n              valElem.removeClass('label-success');\n          } else if (newValue > originalValue) {\n              valElem.addClass('label-success');\n              valElem.removeClass('label-danger');\n          }\n      }\n      // 处理受到的消息\n      ws.onmessage = function (e) {\n          var stocksData = JSON.parse(e.data);\n          console.log(stocksData);\n          for (var symbol in stocksData) {\n              if (stocksData.hasOwnProperty(symbol)) {\n                  changeStockEntry(symbol, stocks[symbol], stocksData[symbol]);\n                  stocks[symbol] = stocksData[symbol];\n              }\n          }\n      };\n  }\n\n  updataUI();\n```\n运行可以看到效果，只需要请求一次，数据就会不断的更新，效果是不是很赞，不用轮询，也不用长连接那么麻烦了。\n\n\n\n\n# 五、socket.io\nsocket.IO是一个websocket库，包括了客户端的js和服务器端的nodejs。官方地址：[http://socket.io](http://socket.io)\n\n#### 客户端使用socket.io\n去github clone socket.io的最新版本，或者直接饮用使用socket.io的CDN服务：\n```\n<script src=\"http://cdn.socket.io/stable/socket.io.js\"></script>\n```\n下面可以创建使用socket.io库来创建客户端js代码了：\n```\nvar socket = io.connect('http://localhost');\nsocket.on('news', function (data) {\n\tconsole.log(data);\n\tsocket.emit('my other event', { my: 'data' });\n});\n```\nsocket.on是监听，收到服务器端发来的news的内容，则运行function，其中data就是请求回来的数据，socket.emit是发送消息给服务器端的方法。\n\n#### 使用socket.io和nodejs搭建websocket服务器端\nsocket.io不仅可以搭建客户端的websocket服务，而且支持nodejs服务器端的websocket。\n\nnodejs安装socket.io\n使用node插件管理包，运行下面的命令就可以安装成功socket.io\n```\nnpm install socket.io\n```\n没有npm的或者windows用户可以使用github下载socket.io并且放入到node_modules文件夹中。\n\n#### nodejs建立socket.io服务\n通过nodejs的http模块就可以方便的搭建websocket服务器环境，例如下面的代码：\n```\n// 引入需要的模块：http和socket.io\nvar http = require('http'), io = require('socket.io');\n//创建server\nvar server = http.createServer(function(req, res){ \n  // Send HTML headers and message\n  res.writeHead(200,{ 'Content-Type': 'text/html' }); \n  res.end('<h1>Hello Socket Lover!</h1>');\n});\n\n//端口8000\nserver.listen(8080);\n//创建socket\nvar socket = io.listen(server);\n//添加连接监听\nsocket.on('connection', function(client){   \n\t//连接成功则执行下面的监听\n\tclient.on('message',function(event){ \n\t\tconsole.log('Received message from client!',event);\n\t});\n\t//断开连接callback\n\tclient.on('disconnect',function(){\n\t\tconsole.log('Server has disconnected');\n\t});\n});\n```\n保存为socket.js然后在命令行执行：node socket.js 即可启动服务器，现在访问localhost:8000就可以了。\n\n目标：Socket.IO旨在让各种浏览器与移动设备上实现实时app功能，模糊化各种传输机制。\n \n\n缺点：socket.io 在高并发的情况下，稳定性与可靠性其实是不高的。特别是其websocket的实现，websocket本身就存在很多局限，对服务端，客户端的要求都比较高，要使其稳定的运行，还是有蛮多的工作要做的。 另外，socket.io 的作者又开发了另一个类似的实现：[engine.io](https://github.com/socketio/engine.io) 应该是就socket.io的一些不足作了改进。\n\n#### socket.io搭建多人聊天室实例\n\n需求分析\n1、兼容不支持WebSocket的低版本浏览器。\n2、允许客户端有相同的用户名。\n3、进入聊天室后可以看到当前在线的用户和在线人数。\n4、用户上线或退出，所有在线的客户端应该实时更新。\n5、用户发送消息，所有客户端实时收取。\n\n有了前面的搭建基础，就不多啰嗦了，直接上代码：\n\nindex.html\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"format-detection\" content=\"telephone=no\"/>\n        <meta name=\"format-detection\" content=\"email=no\"/>\n<meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0\" name=\"viewport\">\n        <title>多人聊天室</title>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\" />\n        <!--[if lt IE 8]><script src=\"./json3.min.js\"></script><![endif]-->\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.dev.js\"></script>\n    </head>\n    <body>\n        <div id=\"loginbox\">\n            <div style=\"width:260px;margin:200px auto;\">\n                请先输入你在聊天室的昵称\n                <br/>\n                <br/>\n                <input type=\"text\" style=\"width:180px;\" placeholder=\"请输入用户名\" id=\"username\" name=\"username\" />\n\t\t\t\t<input type=\"button\" style=\"width:50px;\" value=\"提交\" onclick=\"CHAT.usernameSubmit();\"/>\n            </div>\n        </div>\n        <div id=\"chatbox\" style=\"display:none;\">\n            <div style=\"background:#3d3d3d;height: 28px; width: 100%;font-size:12px;\">\n                <div style=\"line-height: 28px;color:#fff;\">\n                    <span style=\"text-align:left;margin-left:10px;\">Websocket多人聊天室</span>\n                    <span style=\"float:right; margin-right:10px;\"><span id=\"showusername\"></span> | \n\t\t\t\t\t<a href=\"javascript:;\" onclick=\"CHAT.logout()\" style=\"color:#fff;\">退出</a></span>\n                </div>\n            </div>\n            <div id=\"doc\">\n                <div id=\"chat\">\n                    <div id=\"message\" class=\"message\">\n<div id=\"onlinecount\" style=\"background:#EFEFF4; font-size:12px; margin-top:10px; margin-left:10px; color:#666;\">\n</div>\n                    </div>\n                    <div class=\"input-box\">\n                        <div class=\"input\">\n<input type=\"text\" maxlength=\"140\" placeholder=\"请输入聊天内容，按Enter提交\" id=\"content\" name=\"content\">\n                        </div>\n                        <div class=\"action\">\n                            <button type=\"button\" id=\"mjr_send\" onclick=\"CHAT.submit();\">提交</button>\n                        </div>\n                        \n                    </div>\n                </div>\n            </div>\n        </div>\n        <script type=\"text/javascript\" src=\"./client.js\"></script>\n    </body>\n</html>\n```\n\nclient.js 客户端代码，里面有详细注释，很清晰。\n```\n(function () {\n\tvar d = document,\n\tw = window,\n\tp = parseInt,\n\tdd = d.documentElement,\n\tdb = d.body,\n\tdc = d.compatMode == 'CSS1Compat',\n\tdx = dc ? dd: db,\n\tec = encodeURIComponent;\n\t\n\t\n\tw.CHAT = {\n\t\tmsgObj:d.getElementById(\"message\"),\n\t\tscreenheight:w.innerHeight ? w.innerHeight : dx.clientHeight,\n\t\tusername:null,\n\t\tuserid:null,\n\t\tsocket:null,\n\t\t//让浏览器滚动条保持在最低部\n\t\tscrollToBottom:function(){\n\t\t\tw.scrollTo(0, this.msgObj.clientHeight);\n\t\t},\n\t\t//退出，本例只是一个简单的刷新\n\t\tlogout:function(){\n\t\t\t//this.socket.disconnect();\n\t\t\tlocation.reload();\n\t\t},\n\t\t//提交聊天消息内容\n\t\tsubmit:function(){\n\t\t\tvar content = d.getElementById(\"content\").value;\n\t\t\tif(content != ''){\n\t\t\t\tvar obj = {\n\t\t\t\t\tuserid: this.userid,\n\t\t\t\t\tusername: this.username,\n\t\t\t\t\tcontent: content\n\t\t\t\t};\n\t\t\t\tthis.socket.emit('message', obj);\n\t\t\t\td.getElementById(\"content\").value = '';\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tgenUid:function(){\n\t\t\treturn new Date().getTime()+\"\"+Math.floor(Math.random()*899+100);\n\t\t},\n\t\t//更新系统消息，本例中在用户加入、退出的时候调用\n\t\tupdateSysMsg:function(o, action){\n\t\t\t//当前在线用户列表\n\t\t\tvar onlineUsers = o.onlineUsers;\n\t\t\t//当前在线人数\n\t\t\tvar onlineCount = o.onlineCount;\n\t\t\t//新加入用户的信息\n\t\t\tvar user = o.user;\n\t\t\t\t\n\t\t\t//更新在线人数\n\t\t\tvar userhtml = '';\n\t\t\tvar separator = '';\n\t\t\tfor(key in onlineUsers) {\n\t\t        if(onlineUsers.hasOwnProperty(key)){\n\t\t\t\t\tuserhtml += separator+onlineUsers[key];\n\t\t\t\t\tseparator = '、';\n\t\t\t\t}\n\t\t    }\n\t\t\td.getElementById(\"onlinecount\").innerHTML = '当前共有 '+onlineCount+' 人在线，在线列表：'+userhtml;\n\t\t\t\n\t\t\t//添加系统消息\n\t\t\tvar html = '';\n\t\t\thtml += '<div class=\"msg-system\">';\n\t\t\thtml += user.username;\n\t\t\thtml += (action == 'login') ? ' 加入了聊天室' : ' 退出了聊天室';\n\t\t\thtml += '</div>';\n\t\t\tvar section = d.createElement('section');\n\t\t\tsection.className = 'system J-mjrlinkWrap J-cutMsg';\n\t\t\tsection.innerHTML = html;\n\t\t\tthis.msgObj.appendChild(section);\t\n\t\t\tthis.scrollToBottom();\n\t\t},\n\t\t//第一个界面用户提交用户名\n\t\tusernameSubmit:function(){\n\t\t\tvar username = d.getElementById(\"username\").value;\n\t\t\tif(username != \"\"){\n\t\t\t\td.getElementById(\"username\").value = '';\n\t\t\t\td.getElementById(\"loginbox\").style.display = 'none';\n\t\t\t\td.getElementById(\"chatbox\").style.display = 'block';\n\t\t\t\tthis.init(username);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tinit:function(username){\n\t\t\t/*\n\t\t\t客户端根据时间和随机数生成uid,这样使得聊天室用户名称可以重复。\n\t\t\t实际项目中，如果是需要用户登录，那么直接采用用户的uid来做标识就可以\n\t\t\t*/\n\t\t\tthis.userid = this.genUid();\n\t\t\tthis.username = username;\n\t\t\t\n\t\t\td.getElementById(\"showusername\").innerHTML = this.username;\n\t\t\t//this.msgObj.style.minHeight = (this.screenheight - db.clientHeight + this.msgObj.clientHeight) + \"px\";\n\t\t\tthis.scrollToBottom();\n\t\t\t\n\t\t\t//连接websocket后端服务器\n\t\t\tthis.socket = io.connect('ws://10.254.124.8:8383');\n\t\t\t\n\t\t\t//告诉服务器端有用户登录\n\t\t\tthis.socket.emit('login', {userid:this.userid, username:this.username});\n\t\t\t\n\t\t\t//监听新用户登录\n\t\t\tthis.socket.on('login', function(o){\n\t\t\t\tCHAT.updateSysMsg(o, 'login');\t\n\t\t\t});\n\t\t\t\n\t\t\t//监听用户退出\n\t\t\tthis.socket.on('logout', function(o){\n\t\t\t\tCHAT.updateSysMsg(o, 'logout');\n\t\t\t});\n\t\t\t\n\t\t\t//监听消息发送\n\t\t\tthis.socket.on('message', function(obj){\n\t\t\t\tvar isme = (obj.userid == CHAT.userid) ? true : false;\n\t\t\t\tvar contentDiv = '<div>'+obj.content+'</div>';\n\t\t\t\tvar usernameDiv = '<span>'+obj.username+'</span>';\n\t\t\t\t\n\t\t\t\tvar section = d.createElement('section');\n\t\t\t\tif(isme){\n\t\t\t\t\tsection.className = 'user';\n\t\t\t\t\tsection.innerHTML = contentDiv + usernameDiv;\n\t\t\t\t} else {\n\t\t\t\t\tsection.className = 'service';\n\t\t\t\t\tsection.innerHTML = usernameDiv + contentDiv;\n\t\t\t\t}\n\t\t\t\tCHAT.msgObj.appendChild(section);\n\t\t\t\tCHAT.scrollToBottom();\t\n\t\t\t});\n\n\t\t}\n\t};\n\t//通过“回车”提交用户名\n\td.getElementById(\"username\").onkeydown = function(e) {\n\t\te = e || event;\n\t\tif (e.keyCode === 13) {\n\t\t\tCHAT.usernameSubmit();\n\t\t}\n\t};\n\t//通过“回车”提交信息\n\td.getElementById(\"content\").onkeydown = function(e) {\n\t\te = e || event;\n\t\tif (e.keyCode === 13) {\n\t\t\tCHAT.submit();\n\t\t}\n\t};\n})();\n```\n\nserver.js 服务端代码，同样代码里有详细注释。\n```\nvar app = require('express')();\nvar http = require('http').Server(app);\nvar io = require('socket.io')(http);\n\napp.get('/', function(req, res){\n\tres.send('<h1>Welcome Realtime Server</h1>');\n});\n\n//在线用户\nvar onlineUsers = {};\n//当前在线人数\nvar onlineCount = 0;\n\nio.on('connection', function(socket){\n\tconsole.log('a user connected');\n\t\n\t//监听新用户加入\n\tsocket.on('login', function(obj){\n\t\t//将新加入用户的唯一标识当作socket的名称，后面退出的时候会用到\n\t\tsocket.name = obj.userid;\n\t\t\n\t\t//检查在线列表，如果不在里面就加入\n\t\tif(!onlineUsers.hasOwnProperty(obj.userid)) {\n\t\t\tonlineUsers[obj.userid] = obj.username;\n\t\t\t//在线人数+1\n\t\t\tonlineCount++;\n\t\t}\n\t\t\n\t\t//向所有客户端广播用户加入\n\t\tio.emit('login', {onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj});\n\t\tconsole.log(obj.username+'加入了聊天室');\n\t});\n\t\n\t//监听用户退出\n\tsocket.on('disconnect', function(){\n\t\t//将退出的用户从在线列表中删除\n\t\tif(onlineUsers.hasOwnProperty(socket.name)) {\n\t\t\t//退出用户的信息\n\t\t\tvar obj = {userid:socket.name, username:onlineUsers[socket.name]};\n\t\t\t\n\t\t\t//删除\n\t\t\tdelete onlineUsers[socket.name];\n\t\t\t//在线人数-1\n\t\t\tonlineCount--;\n\t\t\t\n\t\t\t//向所有客户端广播用户退出\n\t\t\tio.emit('logout', {onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj});\n\t\t\tconsole.log(obj.username+'退出了聊天室');\n\t\t}\n\t});\n\t\n\t//监听用户发布聊天内容\n\tsocket.on('message', function(obj){\n\t\t//向所有客户端广播发布的消息\n\t\tio.emit('message', obj);\n\t\tconsole.log(obj.username+'说：'+obj.content);\n\t});\n  \n});\n\nhttp.listen(8383, function(){\n\tconsole.log('listening on *:8383');\n});\n```\n\n实现效果：\n<img src=\"https://img.fengjr.com/image/2019/11/28/21a61b1204f4722431232f133b129b00.png\" width=\"50%\" />\n\n#### 总结\nwebsocket学起来并不难，api也不多，但可扩张和延伸的东西很多，想实现一个完整的项目，需要先有一个完整的设计思路才行。比如是一个在线WebIM系统，实现类似微信，qq的功能，客户端可以看到好友在线状态，在线列表，添加好友，删除好友，新建群组等，消息的发送除了支持基本的文字外，还能支持表情、图片和文件。有兴趣的同学可以继续一起深入研究。","source":"_posts/2019-11-27-websocket.md","raw":"---\ntitle: websocket介绍及应用\ncomments: true\ndate: 2019-11-27 15:16:10\ntags:\n- websocket\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n# 一、websocket介绍\n\n![](https://img.fengjr.com/image/2019/11/27/379278605a69626b3915c6829b1a2cb5.png)\n\n#### WebSocket协议出现的背景\n我们在上网过程中经常用到的是HTTP和HTTPS协议，HTTP协议和HTTPS协议通信过程通常是客户端通过浏览器发出一个请求，服务器接受请求后进行处理并返回结果给客户端，客户端处理结果。\n\n这种机制对于信息变化不是特别频繁的应用可以良好支撑，但对于实时要求高、海量并发的应用来说显得捉襟见肘，尤其在移动互联网蓬勃发展的趋势下，高并发与用户实时响应是Web应用经常面临的问题，比如金融证券的实时信息、社交网络的实时消息推送等。\n\nWebSocket出现前我们实现推送技术，用的都是轮询，在特定的时间间隔，浏览器自动发出请求，将服务器的消息主动的拉回来，这种情况下，我们需要不断的向服务器发送请求，并且HTTP 请求 的header非常长，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽和服务器资源，并且服务器不能主动向客户端推送数据。在这种情况下需要一种高效节能的双向通信机制来保证数据的实时传输，于是基于HTML5规范的WebSocket应运而生。\n\n\n#### 什么是websocket\nwebsocket是HTML5的一种新的通信协议，它实现了浏览器与服务器的双向通讯。在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。\n\n在客户端使用websocket需要创建WebSocket对象，通过提供的open、send、message、close等方法实现创建、发送、监听信息、关闭连接。现在chrome、firefox等浏览器都已经支持了websocket，而IE却没有。\n\n#### WebSocket与TCP，HTTP的关系\nWebSocket与http协议一样都是基于TCP的，所以他们都是可靠的协议，调用的WebSocket的send函数在实现中最终都是通过TCP的系统接口进行传输的。WebSocket和Http协议一样都属于应用层的协议，WebSocket在建立握手连接时，数据是通过http协议传输的，但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。\n\n#### WebSocket与HTTP轮询\n- ajax轮询 \najax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。场景再现：\n客户端：啦啦啦，有没有新信息(Request)\n服务端：没有（Response）\n客户端：啦啦啦，有没有新信息(Request)\n服务端：没有。。（Response）\n客户端：啦啦啦，有没有新信息(Request)\n服务端：你好烦啊，没有啊。。（Response）\n客户端：啦啦啦，有没有新消息（Request）\n服务端：好啦好啦，有啦给你。（Response）\n客户端：啦啦啦，有没有新消息（Request）\n服务端：。。。。。没。。。。没。。。没有（Response） ---- loop\n\n![](https://img.fengjr.com/image/2019/11/27/2a0bf85b8ef69023aa962f94b2fde30a.png)\n\n- long poll \nlong poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。\n场景再现：\n客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）\n服务端：额。。   等待到有消息的时候。。来 给你（Response）\n客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop\n\n![](https://img.fengjr.com/image/2019/11/27/4c1058fe7a183d623c25ab72f946a868.png)\n\n从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。简单地说就是，服务器是一个很懒的冰箱（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。\n\n说完这个，我们再来说一说上面的缺陷\n从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。\najax轮询 需要服务器有很快的处理速度和资源。（速度）\nlong poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）\n\n- WebSocket\nWebSocket的出现解决了轮询实时交互性和全双工的问题。\n在JavaScript中创建了WebSocket后，会有一个HTTP请求发送到服务器以发起连接。取得服务器响应后，建立的连接使用HTTP升级，从HTTP协议交换为WebSocket协议。即，使用标准的HTTP服务器无法实现WebSocket，只有支持这种协议的专门服务器才能正常工作。\nWebSocket使用了自定义的协议，未加密的连接不再是http://，而是ws://，默认端口为80，加密的连接也不是https://，而是wss://，默认端口为443。\n\n<img src=\"https://img.fengjr.com/image/2019/11/27/34927c1cd3258dab7aa4156463715e6b.png\" width=\"50%\" height=\"50%\">\n\nWebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。\n\nWebSocket与HTTP轮询对比得出的结论：\nWebSocket是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。\n\n\n# 二、WebSocket API\n\n上面讲述了WebSocket比HTTP轮询好，下面介绍一下WebSocket API。\n\n#### 创建WebSocket实例\n要创建WebSocket，先实例一个WebSocket对象并传入要连接的URL：\n```\nvar socket = new WebSocket('http://localhost:8000');\n```\n执行上面语句后，浏览器会马上尝试创建连接，与XHR类似，WebSocket也有一个表示当前状态的readyState属性。不过，这个属性的值与XHR不相同， socket.readyState值如下：\n\n0：正在建立连接， WebSocket.OPENING\n1：已经建立连接， WebSocket.OPEN\n2：正在关闭连接， WebSocket.CLOSING\n3：已经关闭连接， WebSocket.CLOSE\nWebSocket没有readystatechange事件，不过，有其他事件对应着不同的状态，readyState的值永远从0开始。\n示例如下：\n```\nvar socket = new WebSocket('ws://localhost:8000');\n\n  //正在建立连接\n  console.log(\"[readyState]-\" + socket.readyState); //0\n\n  //连接建立成功回调\n  socket.onopen = function() {\n    console.log('Connection established.')\n    console.log(\"[readyState]-\" + socket.readyState); //1\n    //发送消息\n    // socket.send('hello world');\n  };\n\n  //连接失败回调\n  socket.onerror = function() {\n    console.log(\"[readyState]-\" + socket.readyState);//3\n    console.log('Connection error.')\n  };\n\n  //连接关闭回调\n  socket.onclose = function(event) {\n    var code = event.code;\n    var reason = event.reason;\n    var wasClean = event.wasClean;\n    console.log(\"[readyState]-\" + socket.readyState);//3\n    console.log('Connection closed.')\n    console.log(code, reason, wasClean)\n  };\n```\n要关闭WebSocket连接，可以在任何时候调用close方法。\n```\nsocket.close();\n```\n调用了close()之后，readyState的值立即变为2（正在关闭），关闭连接后就会变成3。\n\n#### 发送和接收数据\nWebSocket连接建立之后，可以通过连接发送和接收数据。\n使用send()方法像服务器发送数据，如下：\n```\nvar socket = new WebSocket('ws://localhost:8000');\nsocket.send('hello world');\n```\n当服务器向客户端发来消息时，WebSocket对象会触发message事件。这个message事件与其他传递消息的协议类似，也是把返回的数据保存在event.data属性中。\n```\n socket.onmessage = function(event) {\n  var data = event.data;\n  //处理数据\n};\n```\n\n#### 其他事件\nWebSocket对象还有其他三个事件，在连接生命周期的不同阶段触发。\n\nopen：成功建立连接时触发。\nerror：发生错误时触发，连接断开。\nclose: 连接关闭时触发。\n```\nvar socket = new WebSocket('ws://localhost:8000');\nsocket.onopen = function() {\n  console.log('Connection established.')\n};\nsocket.onerror = function() {\n  console.log('Connection error.')\n};\nsocket.onclose = function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  console.log('Connection closed.')\n};\n```\n这三个事件中，只有close事件的event对象有额外信息，这个事件的事件对象有三个额外的属性：wasClean、code和reason。\n其中wasClean是一个布尔值，表示连接是否已经明确的关闭；\ncode是服务器返回的数值状态码；\nreason是一个字符串，包含服务器发回的信息。\n\n# 三、WebSocket心跳及重连机制\n在使用websocket的过程中，有时候会遇到网络断开的情况，但是在网络断开的时候服务器端并没有触发onclose的事件。这样会有：服务器会继续向客户端发送多余的链接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的链接状态。因此就有了websocket的心跳了。还有心跳，说明还活着，没有心跳说明已经挂掉了。\n\n1. 为什么叫心跳包呢？\n它就像心跳一样每隔固定的时间发一次，来告诉服务器，我还活着。\n\n2. 心跳机制是？\n心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了。需要重连~\n\n那么需要怎么去实现它呢？如下所有代码：\n```\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>WebSocket Demo</title>\n</head>\n<body>\n  <script type=\"text/javascript\">\n    // var ws = new WebSocket(\"wss://echo.websocket.org\");\n    /*\n    ws.onerror = function(e) {\n      console.log('已关闭');\n    };\n    ws.onopen = function(e) {\n      console.log('握手成功');\n      ws.send('123456789');\n    }\n    ws.onclose = function() {\n      console.log('已关闭');\n    }\n    ws.onmessage = function(e) {\n      console.log('收到消息');\n      console.log(e);\n    }\n    */\n    \n    var lockReconnect = false;//避免重复连接\n    var wsUrl = \"wss://echo.websocket.org\";\n    var ws;\n    var tt;\n    function createWebSocket() {\n      try {\n        ws = new WebSocket(wsUrl);\n        init();\n      } catch(e) {\n        console.log('catch');\n        reconnect(wsUrl);\n      }\n    }\n    function init() {\n      ws.onclose = function () {\n        console.log('链接关闭');\n        reconnect(wsUrl);\n      };\n      ws.onerror = function() {\n        console.log('发生异常了');\n        reconnect(wsUrl);\n      };\n      ws.onopen = function () {\n        //心跳检测重置\n        heartCheck.start();\n      };\n      ws.onmessage = function (event) {\n        //拿到任何消息都说明当前连接是正常的\n        console.log('接收到消息');\n        heartCheck.start();\n      }\n    }\n    function reconnect(url) {\n      if(lockReconnect) {\n        return;\n      };\n      lockReconnect = true;\n      //没连接上会一直重连，设置延迟避免请求过多\n      tt && clearTimeout(tt);\n      tt = setTimeout(function () {\n        createWebSocket(url);\n        lockReconnect = false;\n      }, 4000);\n    }\n    //心跳检测\n    var heartCheck = {\n      timeout: 3000,\n      timeoutObj: null,\n      serverTimeoutObj: null,\n      start: function(){\n        console.log('start');\n        var self = this;\n        this.timeoutObj && clearTimeout(this.timeoutObj);\n        this.serverTimeoutObj && clearTimeout(this.serverTimeoutObj);\n        this.timeoutObj = setTimeout(function(){\n          //这里发送一个心跳，后端收到后，返回一个心跳消息，\n          console.log('55555');\n          ws.send(\"123456789\");\n          self.serverTimeoutObj = setTimeout(function() {\n            console.log(111);\n            console.log(ws);\n            ws.close();\n            // createWebSocket();\n          }, self.timeout);\n\n        }, this.timeout)\n      }\n    }\n    createWebSocket(wsUrl);\n  </script>\n</body>\n</html>\n```\n\n具体的思路如下：\n1. 第一步页面初始化，先调用createWebSocket函数，目的是创建一个websocket的方法：new WebSocket(wsUrl);因此封装成函数内如下代码：\n```\nfunction createWebSocket() {\n  try {\n    ws = new WebSocket(wsUrl);\n    init();\n  } catch(e) {\n    console.log('catch');\n    reconnect(wsUrl);\n  }\n}\n```\n2. 第二步调用init方法，该方法内把一些监听事件封装如下：\n```\nfunction init() {\n  ws.onclose = function () {\n    console.log('链接关闭');\n    reconnect(wsUrl);\n  };\n  ws.onerror = function() {\n    console.log('发生异常了');\n    reconnect(wsUrl);\n  };\n  ws.onopen = function () {\n    //心跳检测重置\n    heartCheck.start();\n  };\n  ws.onmessage = function (event) {\n    //拿到任何消息都说明当前连接是正常的\n    console.log('接收到消息');\n    heartCheck.start();\n  }\n}\n```\n3. 如上第二步，当网络断开的时候，会先调用onerror，onclose事件可以监听到，会调用reconnect方法进行重连操作。正常的情况下，是先调用\nonopen方法的，当接收到数据时，会被onmessage事件监听到。\n\n4. 重连操作 reconnect代码如下：\n```\nvar lockReconnect = false;//避免重复连接\nfunction reconnect(url) {\n  if(lockReconnect) {\n    return;\n  };\n  lockReconnect = true;\n  //没连接上会一直重连，设置延迟避免请求过多\n  tt && clearTimeout(tt);\n  tt = setTimeout(function () {\n    createWebSocket(url);\n    lockReconnect = false;\n  }, 4000);\n}\n```\n如上代码，如果网络断开的话，会执行reconnect方法，使用了一个定时器，4秒后会重新创建一个新的websocket链接，重新调用createWebSocket函数，\n重新会执行及发送数据给服务器端。\n\n5. 最后一步就是实现心跳检测的代码：如下：\n```\n//心跳检测\nvar heartCheck = {\n  timeout: 3000,\n  timeoutObj: null,\n  serverTimeoutObj: null,\n  start: function(){\n    console.log('start');\n    var self = this;\n    this.timeoutObj && clearTimeout(this.timeoutObj);\n    this.serverTimeoutObj && clearTimeout(this.serverTimeoutObj);\n    this.timeoutObj = setTimeout(function(){\n      //这里发送一个心跳，后端收到后，返回一个心跳消息，\n      //onmessage拿到返回的心跳就说明连接正常\n      console.log('55555');\n      ws.send(\"123456789\");\n      self.serverTimeoutObj = setTimeout(function() {\n        console.log(111);\n        console.log(ws);\n        ws.close();\n        // createWebSocket();\n      }, self.timeout);\n\n    }, this.timeout)\n  }\n}\n```\n实现心跳检测的思路是：每隔一段固定的时间，向服务器端发送一个ping数据，如果在正常的情况下，服务器会返回一个pong给客户端，如果客户端通过onmessage事件能监听到的话，说明请求正常，这里我们使用了一个定时器，每隔3秒的情况下，如果是网络断开的情况下，在指定的时间内服务器端并没有返回心跳响应消息，因此服务器端断开了，因此这个时候我们使用ws.close关闭连接，在一段时间后(在不同的浏览器下，时间是不一样的，firefox响应更快)，可以通过 onclose事件监听到。因此在onclose事件内，我们可以调用 reconnect事件进行重连操作。\n\n\n\n# 四、WebSocket 实例\n前面已经学习了WebSocket API，包括事件、方法和属性。WebSocket是基于事件驱动，支持全双工通信。下面通过二个简单例子体验一下。\n\n#### 简单在线聊天\n1、通过nodejs在项目里面新建一个server.js，创建服务，指定8181端口\n```\nvar express = require('express');\nvar http = require('http');\nvar WebSocket = require('ws');\nvar app = express();\napp.use(express.static(__dirname));\napp.get('/', function(req, res){\n\tres.send('<h1>Welcome Realtime Server</h1>');\n});\nvar server = http.createServer(app);\nvar wss = new WebSocket.Server({server});\nwss.on('connection', function connection(ws) {\n    console.log('链接成功！');\n    ws.on('message', function incoming(data) {\n        /**\n         * 把消息发送到所有的客户端\n         * wss.clients获取所有链接的客户端\n         */\n        wss.clients.forEach(function each(client) {\n            client.send(data);\n        });\n    });\n});\n\nserver.listen(8181, function listening() {\n    console.log('服务器启动成功！');\n});\n```\n在浏览器里输入http://localhost:8181/测试服务是否启动成功。\n\n2、创建客户端。为了能在多台设备上测试，可以本地在启一个服务来跑客户端代码。\n通node启一个8282端口的本机服务 \napp.js\n```\nvar express = require('express');\nvar http = require('http');\n\nvar app = express();\napp.use(express.static(__dirname));\nvar server = http.createServer(app);\n\napp.get('/', function(req, res){\n\tres.send('<h1>Welcome client</h1>');\n});\n\nserver.listen(8282, function listening() {\n    console.log('ok！');\n});\n```\n3、创建index.html\n```\n<div>\n    <h1>websocket chat</h1>\n    <div>\n        <input id=\"name\" size=\"15\" type=\"text\" placeholder=\"姓名\" value=\"\">\n        <input id=\"message\" size=\"50\" type=\"text\" placeholder=\"内容\" value=\"\">\n        <input id=\"btn_post\" type=\"button\" value=\"post\">\n    </div>\n    <ul id=\"chat\"></ul>\n</div>\n<script src=\"http://cdn.bootcss.com/jquery/1.9.1/jquery.js\"></script>\n```\n可以输入姓名和内容，然后有一个提交按钮来发送数据给服务器。\n\n4、创建websocket链接\n```\nvar ws = new WebSocket(\"ws://localhost:8181\");\n\n```\n要在多台服务测试需要把localhost改成IP\n```\nvar ws = new WebSocket(\"ws://10.254.124.8:8181\");\n```\n5、点击提交按钮或回车向服务器发送信息，使用 ws.send 方法\n```\n$(function(){\n  $(\"#btn_post\").click(post);\n  $(\"#message\").keydown(function(e){\n    if(e.keyCode == 13) post();\n  });\n});\nvar post = function(){\n  var name = $(\"#name\").val();\n  var mes = $(\"#message\").val();\n  ws.send(name+\" : \"+mes);\n  $(\"input#message\").val(\"\");\n};\n```\n6、服务器接收到信息后返回给客户端，使用 ws.onmessage 方法\n```\nws.onmessage = function(e){\n  print(e.data);\n};\nvar print = function(msg){\n  $(\"#chat\").prepend($(\"<li>\").text(msg));\n};\n```\n浏览器里输入 http://10.254.124.8:8282/index.html 可以看到预览效果\n![](https://img.fengjr.com/image/2019/11/27/a36c14d25b7ef14a1787320e29a09266.png)\n\n#### 模拟股票实例\n上面的例子很简单，只是为了演示如何运用nodejs的ws创建一个WebSocket服务器。且可以接受客户端的消息。那么下面这个例子演示股票的实时更新。客服端只需要连接一次，服务器端会不断地发送新数据，客户端收数据后更新UI.页面如下，有五只股票，开始和停止按钮测试连接和关闭。\n\n![](https://img.fengjr.com/image/2019/11/27/83b293b5e353e2d9bdf080e7cf7cbb82.png)\n\n服务端：\n1.模拟五只股票的涨跌。\n```\nvar stocks = {\n    \"AAPL\": 95.0,\n    \"MSFT\": 50.0,\n    \"AMZN\": 300.0,\n    \"GOOG\": 550.0,\n    \"YHOO\": 35.0\n}\nfunction randomInterval(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\nvar stockUpdater;\nvar randomStockUpdater = function() {\n    for (var symbol in stocks) {\n        if(stocks.hasOwnProperty(symbol)) {\n            var randomizedChange = randomInterval(-150, 150);\n            var floatChange = randomizedChange / 100;\n            stocks[symbol] += floatChange;\n        }\n    }\n    var randomMSTime = randomInterval(500, 2500);\n    stockUpdater = setTimeout(function() {\n        randomStockUpdater();\n    }, randomMSTime);\n}\nrandomStockUpdater();\n```\n2.连接建立之后就开始更新数据\n```\nwss.on('connection', function (ws) {\n  var sendStockUpdates = function (ws) {\n      if (ws.readyState == 1) {\n          var stocksObj = {};\n          for (var i = 0; i < clientStocks.length; i++) {\n            var symbol = clientStocks[i];\n              stocksObj[symbol] = stocks[symbol];\n          }\n          if (stocksObj.length !== 0) {\n              ws.send(JSON.stringify(stocksObj));//需要将对象转成字符串。WebSocket只支持文本和二进制数据\n              console.log(\"更新\", JSON.stringify(stocksObj));\n          }\n          \n      }\n  }\n  var clientStockUpdater = setInterval(function () {\n      sendStockUpdates(ws);\n  }, 1000);\n  ws.on('message', function (message) {\n      var stockRequest = JSON.parse(message);//根据请求过来的数据来更新。\n      console.log(\"收到消息\", stockRequest);\n      clientStocks = stockRequest['stocks'];\n      sendStockUpdates(ws);\n  });\n```\n\n客户端：\n建立连接：\n```\n var ws = new WebSocket(\"ws://localhost:8181\");\n```\nonopen直接只有在连接成功后才会触发，在这个时候将客户端需要请求的股票发送给服务端。\n```\nvar isClose = false;\n  var stocks = {\n      \"AAPL\": 0, \"MSFT\": 0, \"AMZN\": 0, \"GOOG\": 0, \"YHOO\": 0\n  };\n  function updataUI() {\n      ws.onopen = function (e) {\n          console.log('Connection to server opened');\n          isClose = false;\n          ws.send(JSON.stringify(stock_request));\n          console.log(\"sened a mesg\");\n      }\n      //更新UI\n      var changeStockEntry = function (symbol, originalValue, newValue) {\n          var valElem = $('#' + symbol + ' span');\n          valElem.html(newValue.toFixed(2));\n          if (newValue < originalValue) {\n              valElem.addClass('label-danger');\n              valElem.removeClass('label-success');\n          } else if (newValue > originalValue) {\n              valElem.addClass('label-success');\n              valElem.removeClass('label-danger');\n          }\n      }\n      // 处理受到的消息\n      ws.onmessage = function (e) {\n          var stocksData = JSON.parse(e.data);\n          console.log(stocksData);\n          for (var symbol in stocksData) {\n              if (stocksData.hasOwnProperty(symbol)) {\n                  changeStockEntry(symbol, stocks[symbol], stocksData[symbol]);\n                  stocks[symbol] = stocksData[symbol];\n              }\n          }\n      };\n  }\n\n  updataUI();\n```\n运行可以看到效果，只需要请求一次，数据就会不断的更新，效果是不是很赞，不用轮询，也不用长连接那么麻烦了。\n\n\n\n\n# 五、socket.io\nsocket.IO是一个websocket库，包括了客户端的js和服务器端的nodejs。官方地址：[http://socket.io](http://socket.io)\n\n#### 客户端使用socket.io\n去github clone socket.io的最新版本，或者直接饮用使用socket.io的CDN服务：\n```\n<script src=\"http://cdn.socket.io/stable/socket.io.js\"></script>\n```\n下面可以创建使用socket.io库来创建客户端js代码了：\n```\nvar socket = io.connect('http://localhost');\nsocket.on('news', function (data) {\n\tconsole.log(data);\n\tsocket.emit('my other event', { my: 'data' });\n});\n```\nsocket.on是监听，收到服务器端发来的news的内容，则运行function，其中data就是请求回来的数据，socket.emit是发送消息给服务器端的方法。\n\n#### 使用socket.io和nodejs搭建websocket服务器端\nsocket.io不仅可以搭建客户端的websocket服务，而且支持nodejs服务器端的websocket。\n\nnodejs安装socket.io\n使用node插件管理包，运行下面的命令就可以安装成功socket.io\n```\nnpm install socket.io\n```\n没有npm的或者windows用户可以使用github下载socket.io并且放入到node_modules文件夹中。\n\n#### nodejs建立socket.io服务\n通过nodejs的http模块就可以方便的搭建websocket服务器环境，例如下面的代码：\n```\n// 引入需要的模块：http和socket.io\nvar http = require('http'), io = require('socket.io');\n//创建server\nvar server = http.createServer(function(req, res){ \n  // Send HTML headers and message\n  res.writeHead(200,{ 'Content-Type': 'text/html' }); \n  res.end('<h1>Hello Socket Lover!</h1>');\n});\n\n//端口8000\nserver.listen(8080);\n//创建socket\nvar socket = io.listen(server);\n//添加连接监听\nsocket.on('connection', function(client){   \n\t//连接成功则执行下面的监听\n\tclient.on('message',function(event){ \n\t\tconsole.log('Received message from client!',event);\n\t});\n\t//断开连接callback\n\tclient.on('disconnect',function(){\n\t\tconsole.log('Server has disconnected');\n\t});\n});\n```\n保存为socket.js然后在命令行执行：node socket.js 即可启动服务器，现在访问localhost:8000就可以了。\n\n目标：Socket.IO旨在让各种浏览器与移动设备上实现实时app功能，模糊化各种传输机制。\n \n\n缺点：socket.io 在高并发的情况下，稳定性与可靠性其实是不高的。特别是其websocket的实现，websocket本身就存在很多局限，对服务端，客户端的要求都比较高，要使其稳定的运行，还是有蛮多的工作要做的。 另外，socket.io 的作者又开发了另一个类似的实现：[engine.io](https://github.com/socketio/engine.io) 应该是就socket.io的一些不足作了改进。\n\n#### socket.io搭建多人聊天室实例\n\n需求分析\n1、兼容不支持WebSocket的低版本浏览器。\n2、允许客户端有相同的用户名。\n3、进入聊天室后可以看到当前在线的用户和在线人数。\n4、用户上线或退出，所有在线的客户端应该实时更新。\n5、用户发送消息，所有客户端实时收取。\n\n有了前面的搭建基础，就不多啰嗦了，直接上代码：\n\nindex.html\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"format-detection\" content=\"telephone=no\"/>\n        <meta name=\"format-detection\" content=\"email=no\"/>\n<meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0\" name=\"viewport\">\n        <title>多人聊天室</title>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\" />\n        <!--[if lt IE 8]><script src=\"./json3.min.js\"></script><![endif]-->\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.dev.js\"></script>\n    </head>\n    <body>\n        <div id=\"loginbox\">\n            <div style=\"width:260px;margin:200px auto;\">\n                请先输入你在聊天室的昵称\n                <br/>\n                <br/>\n                <input type=\"text\" style=\"width:180px;\" placeholder=\"请输入用户名\" id=\"username\" name=\"username\" />\n\t\t\t\t<input type=\"button\" style=\"width:50px;\" value=\"提交\" onclick=\"CHAT.usernameSubmit();\"/>\n            </div>\n        </div>\n        <div id=\"chatbox\" style=\"display:none;\">\n            <div style=\"background:#3d3d3d;height: 28px; width: 100%;font-size:12px;\">\n                <div style=\"line-height: 28px;color:#fff;\">\n                    <span style=\"text-align:left;margin-left:10px;\">Websocket多人聊天室</span>\n                    <span style=\"float:right; margin-right:10px;\"><span id=\"showusername\"></span> | \n\t\t\t\t\t<a href=\"javascript:;\" onclick=\"CHAT.logout()\" style=\"color:#fff;\">退出</a></span>\n                </div>\n            </div>\n            <div id=\"doc\">\n                <div id=\"chat\">\n                    <div id=\"message\" class=\"message\">\n<div id=\"onlinecount\" style=\"background:#EFEFF4; font-size:12px; margin-top:10px; margin-left:10px; color:#666;\">\n</div>\n                    </div>\n                    <div class=\"input-box\">\n                        <div class=\"input\">\n<input type=\"text\" maxlength=\"140\" placeholder=\"请输入聊天内容，按Enter提交\" id=\"content\" name=\"content\">\n                        </div>\n                        <div class=\"action\">\n                            <button type=\"button\" id=\"mjr_send\" onclick=\"CHAT.submit();\">提交</button>\n                        </div>\n                        \n                    </div>\n                </div>\n            </div>\n        </div>\n        <script type=\"text/javascript\" src=\"./client.js\"></script>\n    </body>\n</html>\n```\n\nclient.js 客户端代码，里面有详细注释，很清晰。\n```\n(function () {\n\tvar d = document,\n\tw = window,\n\tp = parseInt,\n\tdd = d.documentElement,\n\tdb = d.body,\n\tdc = d.compatMode == 'CSS1Compat',\n\tdx = dc ? dd: db,\n\tec = encodeURIComponent;\n\t\n\t\n\tw.CHAT = {\n\t\tmsgObj:d.getElementById(\"message\"),\n\t\tscreenheight:w.innerHeight ? w.innerHeight : dx.clientHeight,\n\t\tusername:null,\n\t\tuserid:null,\n\t\tsocket:null,\n\t\t//让浏览器滚动条保持在最低部\n\t\tscrollToBottom:function(){\n\t\t\tw.scrollTo(0, this.msgObj.clientHeight);\n\t\t},\n\t\t//退出，本例只是一个简单的刷新\n\t\tlogout:function(){\n\t\t\t//this.socket.disconnect();\n\t\t\tlocation.reload();\n\t\t},\n\t\t//提交聊天消息内容\n\t\tsubmit:function(){\n\t\t\tvar content = d.getElementById(\"content\").value;\n\t\t\tif(content != ''){\n\t\t\t\tvar obj = {\n\t\t\t\t\tuserid: this.userid,\n\t\t\t\t\tusername: this.username,\n\t\t\t\t\tcontent: content\n\t\t\t\t};\n\t\t\t\tthis.socket.emit('message', obj);\n\t\t\t\td.getElementById(\"content\").value = '';\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tgenUid:function(){\n\t\t\treturn new Date().getTime()+\"\"+Math.floor(Math.random()*899+100);\n\t\t},\n\t\t//更新系统消息，本例中在用户加入、退出的时候调用\n\t\tupdateSysMsg:function(o, action){\n\t\t\t//当前在线用户列表\n\t\t\tvar onlineUsers = o.onlineUsers;\n\t\t\t//当前在线人数\n\t\t\tvar onlineCount = o.onlineCount;\n\t\t\t//新加入用户的信息\n\t\t\tvar user = o.user;\n\t\t\t\t\n\t\t\t//更新在线人数\n\t\t\tvar userhtml = '';\n\t\t\tvar separator = '';\n\t\t\tfor(key in onlineUsers) {\n\t\t        if(onlineUsers.hasOwnProperty(key)){\n\t\t\t\t\tuserhtml += separator+onlineUsers[key];\n\t\t\t\t\tseparator = '、';\n\t\t\t\t}\n\t\t    }\n\t\t\td.getElementById(\"onlinecount\").innerHTML = '当前共有 '+onlineCount+' 人在线，在线列表：'+userhtml;\n\t\t\t\n\t\t\t//添加系统消息\n\t\t\tvar html = '';\n\t\t\thtml += '<div class=\"msg-system\">';\n\t\t\thtml += user.username;\n\t\t\thtml += (action == 'login') ? ' 加入了聊天室' : ' 退出了聊天室';\n\t\t\thtml += '</div>';\n\t\t\tvar section = d.createElement('section');\n\t\t\tsection.className = 'system J-mjrlinkWrap J-cutMsg';\n\t\t\tsection.innerHTML = html;\n\t\t\tthis.msgObj.appendChild(section);\t\n\t\t\tthis.scrollToBottom();\n\t\t},\n\t\t//第一个界面用户提交用户名\n\t\tusernameSubmit:function(){\n\t\t\tvar username = d.getElementById(\"username\").value;\n\t\t\tif(username != \"\"){\n\t\t\t\td.getElementById(\"username\").value = '';\n\t\t\t\td.getElementById(\"loginbox\").style.display = 'none';\n\t\t\t\td.getElementById(\"chatbox\").style.display = 'block';\n\t\t\t\tthis.init(username);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tinit:function(username){\n\t\t\t/*\n\t\t\t客户端根据时间和随机数生成uid,这样使得聊天室用户名称可以重复。\n\t\t\t实际项目中，如果是需要用户登录，那么直接采用用户的uid来做标识就可以\n\t\t\t*/\n\t\t\tthis.userid = this.genUid();\n\t\t\tthis.username = username;\n\t\t\t\n\t\t\td.getElementById(\"showusername\").innerHTML = this.username;\n\t\t\t//this.msgObj.style.minHeight = (this.screenheight - db.clientHeight + this.msgObj.clientHeight) + \"px\";\n\t\t\tthis.scrollToBottom();\n\t\t\t\n\t\t\t//连接websocket后端服务器\n\t\t\tthis.socket = io.connect('ws://10.254.124.8:8383');\n\t\t\t\n\t\t\t//告诉服务器端有用户登录\n\t\t\tthis.socket.emit('login', {userid:this.userid, username:this.username});\n\t\t\t\n\t\t\t//监听新用户登录\n\t\t\tthis.socket.on('login', function(o){\n\t\t\t\tCHAT.updateSysMsg(o, 'login');\t\n\t\t\t});\n\t\t\t\n\t\t\t//监听用户退出\n\t\t\tthis.socket.on('logout', function(o){\n\t\t\t\tCHAT.updateSysMsg(o, 'logout');\n\t\t\t});\n\t\t\t\n\t\t\t//监听消息发送\n\t\t\tthis.socket.on('message', function(obj){\n\t\t\t\tvar isme = (obj.userid == CHAT.userid) ? true : false;\n\t\t\t\tvar contentDiv = '<div>'+obj.content+'</div>';\n\t\t\t\tvar usernameDiv = '<span>'+obj.username+'</span>';\n\t\t\t\t\n\t\t\t\tvar section = d.createElement('section');\n\t\t\t\tif(isme){\n\t\t\t\t\tsection.className = 'user';\n\t\t\t\t\tsection.innerHTML = contentDiv + usernameDiv;\n\t\t\t\t} else {\n\t\t\t\t\tsection.className = 'service';\n\t\t\t\t\tsection.innerHTML = usernameDiv + contentDiv;\n\t\t\t\t}\n\t\t\t\tCHAT.msgObj.appendChild(section);\n\t\t\t\tCHAT.scrollToBottom();\t\n\t\t\t});\n\n\t\t}\n\t};\n\t//通过“回车”提交用户名\n\td.getElementById(\"username\").onkeydown = function(e) {\n\t\te = e || event;\n\t\tif (e.keyCode === 13) {\n\t\t\tCHAT.usernameSubmit();\n\t\t}\n\t};\n\t//通过“回车”提交信息\n\td.getElementById(\"content\").onkeydown = function(e) {\n\t\te = e || event;\n\t\tif (e.keyCode === 13) {\n\t\t\tCHAT.submit();\n\t\t}\n\t};\n})();\n```\n\nserver.js 服务端代码，同样代码里有详细注释。\n```\nvar app = require('express')();\nvar http = require('http').Server(app);\nvar io = require('socket.io')(http);\n\napp.get('/', function(req, res){\n\tres.send('<h1>Welcome Realtime Server</h1>');\n});\n\n//在线用户\nvar onlineUsers = {};\n//当前在线人数\nvar onlineCount = 0;\n\nio.on('connection', function(socket){\n\tconsole.log('a user connected');\n\t\n\t//监听新用户加入\n\tsocket.on('login', function(obj){\n\t\t//将新加入用户的唯一标识当作socket的名称，后面退出的时候会用到\n\t\tsocket.name = obj.userid;\n\t\t\n\t\t//检查在线列表，如果不在里面就加入\n\t\tif(!onlineUsers.hasOwnProperty(obj.userid)) {\n\t\t\tonlineUsers[obj.userid] = obj.username;\n\t\t\t//在线人数+1\n\t\t\tonlineCount++;\n\t\t}\n\t\t\n\t\t//向所有客户端广播用户加入\n\t\tio.emit('login', {onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj});\n\t\tconsole.log(obj.username+'加入了聊天室');\n\t});\n\t\n\t//监听用户退出\n\tsocket.on('disconnect', function(){\n\t\t//将退出的用户从在线列表中删除\n\t\tif(onlineUsers.hasOwnProperty(socket.name)) {\n\t\t\t//退出用户的信息\n\t\t\tvar obj = {userid:socket.name, username:onlineUsers[socket.name]};\n\t\t\t\n\t\t\t//删除\n\t\t\tdelete onlineUsers[socket.name];\n\t\t\t//在线人数-1\n\t\t\tonlineCount--;\n\t\t\t\n\t\t\t//向所有客户端广播用户退出\n\t\t\tio.emit('logout', {onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj});\n\t\t\tconsole.log(obj.username+'退出了聊天室');\n\t\t}\n\t});\n\t\n\t//监听用户发布聊天内容\n\tsocket.on('message', function(obj){\n\t\t//向所有客户端广播发布的消息\n\t\tio.emit('message', obj);\n\t\tconsole.log(obj.username+'说：'+obj.content);\n\t});\n  \n});\n\nhttp.listen(8383, function(){\n\tconsole.log('listening on *:8383');\n});\n```\n\n实现效果：\n<img src=\"https://img.fengjr.com/image/2019/11/28/21a61b1204f4722431232f133b129b00.png\" width=\"50%\" />\n\n#### 总结\nwebsocket学起来并不难，api也不多，但可扩张和延伸的东西很多，想实现一个完整的项目，需要先有一个完整的设计思路才行。比如是一个在线WebIM系统，实现类似微信，qq的功能，客户端可以看到好友在线状态，在线列表，添加好友，删除好友，新建群组等，消息的发送除了支持基本的文字外，还能支持表情、图片和文件。有兴趣的同学可以继续一起深入研究。","slug":"websocket","published":1,"updated":"2020-06-10T06:01:37.657Z","_id":"ck562y5rw0002khq6orwd3ojh","layout":"post","photos":[],"link":"","content":"<h1 id=\"一、websocket介绍\"><a href=\"#一、websocket介绍\" class=\"headerlink\" title=\"一、websocket介绍\"></a>一、websocket介绍</h1><p><img src=\"https://img.fengjr.com/image/2019/11/27/379278605a69626b3915c6829b1a2cb5.png\" alt></p>\n<h4 id=\"WebSocket协议出现的背景\"><a href=\"#WebSocket协议出现的背景\" class=\"headerlink\" title=\"WebSocket协议出现的背景\"></a>WebSocket协议出现的背景</h4><p>我们在上网过程中经常用到的是HTTP和HTTPS协议，HTTP协议和HTTPS协议通信过程通常是客户端通过浏览器发出一个请求，服务器接受请求后进行处理并返回结果给客户端，客户端处理结果。</p>\n<p>这种机制对于信息变化不是特别频繁的应用可以良好支撑，但对于实时要求高、海量并发的应用来说显得捉襟见肘，尤其在移动互联网蓬勃发展的趋势下，高并发与用户实时响应是Web应用经常面临的问题，比如金融证券的实时信息、社交网络的实时消息推送等。</p>\n<p>WebSocket出现前我们实现推送技术，用的都是轮询，在特定的时间间隔，浏览器自动发出请求，将服务器的消息主动的拉回来，这种情况下，我们需要不断的向服务器发送请求，并且HTTP 请求 的header非常长，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽和服务器资源，并且服务器不能主动向客户端推送数据。在这种情况下需要一种高效节能的双向通信机制来保证数据的实时传输，于是基于HTML5规范的WebSocket应运而生。</p>\n<h4 id=\"什么是websocket\"><a href=\"#什么是websocket\" class=\"headerlink\" title=\"什么是websocket\"></a>什么是websocket</h4><p>websocket是HTML5的一种新的通信协议，它实现了浏览器与服务器的双向通讯。在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>\n<p>在客户端使用websocket需要创建WebSocket对象，通过提供的open、send、message、close等方法实现创建、发送、监听信息、关闭连接。现在chrome、firefox等浏览器都已经支持了websocket，而IE却没有。</p>\n<h4 id=\"WebSocket与TCP，HTTP的关系\"><a href=\"#WebSocket与TCP，HTTP的关系\" class=\"headerlink\" title=\"WebSocket与TCP，HTTP的关系\"></a>WebSocket与TCP，HTTP的关系</h4><p>WebSocket与http协议一样都是基于TCP的，所以他们都是可靠的协议，调用的WebSocket的send函数在实现中最终都是通过TCP的系统接口进行传输的。WebSocket和Http协议一样都属于应用层的协议，WebSocket在建立握手连接时，数据是通过http协议传输的，但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。</p>\n<h4 id=\"WebSocket与HTTP轮询\"><a href=\"#WebSocket与HTTP轮询\" class=\"headerlink\" title=\"WebSocket与HTTP轮询\"></a>WebSocket与HTTP轮询</h4><ul>\n<li>ajax轮询<br>ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。场景再现：<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有。。（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：你好烦啊，没有啊。。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：好啦好啦，有啦给你。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：。。。。。没。。。。没。。。没有（Response） —- loop</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/11/27/2a0bf85b8ef69023aa962f94b2fde30a.png\" alt></p>\n<ul>\n<li>long poll<br>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。<br>场景再现：<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）<br>服务端：额。。   等待到有消息的时候。。来 给你（Response）<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/11/27/4c1058fe7a183d623c25ab72f946a868.png\" alt></p>\n<p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。简单地说就是，服务器是一个很懒的冰箱（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。</p>\n<p>说完这个，我们再来说一说上面的缺陷<br>从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。<br>ajax轮询 需要服务器有很快的处理速度和资源。（速度）<br>long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</p>\n<ul>\n<li>WebSocket<br>WebSocket的出现解决了轮询实时交互性和全双工的问题。<br>在JavaScript中创建了WebSocket后，会有一个HTTP请求发送到服务器以发起连接。取得服务器响应后，建立的连接使用HTTP升级，从HTTP协议交换为WebSocket协议。即，使用标准的HTTP服务器无法实现WebSocket，只有支持这种协议的专门服务器才能正常工作。<br>WebSocket使用了自定义的协议，未加密的连接不再是http://，而是ws://，默认端口为80，加密的连接也不是https://，而是wss://，默认端口为443。</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/11/27/34927c1cd3258dab7aa4156463715e6b.png\" width=\"50%\" height=\"50%\"></p>\n<p>WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p>\n<p>WebSocket与HTTP轮询对比得出的结论：<br>WebSocket是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。</p>\n<h1 id=\"二、WebSocket-API\"><a href=\"#二、WebSocket-API\" class=\"headerlink\" title=\"二、WebSocket API\"></a>二、WebSocket API</h1><p>上面讲述了WebSocket比HTTP轮询好，下面介绍一下WebSocket API。</p>\n<h4 id=\"创建WebSocket实例\"><a href=\"#创建WebSocket实例\" class=\"headerlink\" title=\"创建WebSocket实例\"></a>创建WebSocket实例</h4><p>要创建WebSocket，先实例一个WebSocket对象并传入要连接的URL：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&apos;http://localhost:8000&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>执行上面语句后，浏览器会马上尝试创建连接，与XHR类似，WebSocket也有一个表示当前状态的readyState属性。不过，这个属性的值与XHR不相同， socket.readyState值如下：</p>\n<p>0：正在建立连接， WebSocket.OPENING<br>1：已经建立连接， WebSocket.OPEN<br>2：正在关闭连接， WebSocket.CLOSING<br>3：已经关闭连接， WebSocket.CLOSE<br>WebSocket没有readystatechange事件，不过，有其他事件对应着不同的状态，readyState的值永远从0开始。<br>示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&apos;ws://localhost:8000&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  //正在建立连接</span><br><span class=\"line\">  console.log(&quot;[readyState]-&quot; + socket.readyState); //0</span><br><span class=\"line\"></span><br><span class=\"line\">  //连接建立成功回调</span><br><span class=\"line\">  socket.onopen = function() &#123;</span><br><span class=\"line\">    console.log(&apos;Connection established.&apos;)</span><br><span class=\"line\">    console.log(&quot;[readyState]-&quot; + socket.readyState); //1</span><br><span class=\"line\">    //发送消息</span><br><span class=\"line\">    // socket.send(&apos;hello world&apos;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  //连接失败回调</span><br><span class=\"line\">  socket.onerror = function() &#123;</span><br><span class=\"line\">    console.log(&quot;[readyState]-&quot; + socket.readyState);//3</span><br><span class=\"line\">    console.log(&apos;Connection error.&apos;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  //连接关闭回调</span><br><span class=\"line\">  socket.onclose = function(event) &#123;</span><br><span class=\"line\">    var code = event.code;</span><br><span class=\"line\">    var reason = event.reason;</span><br><span class=\"line\">    var wasClean = event.wasClean;</span><br><span class=\"line\">    console.log(&quot;[readyState]-&quot; + socket.readyState);//3</span><br><span class=\"line\">    console.log(&apos;Connection closed.&apos;)</span><br><span class=\"line\">    console.log(code, reason, wasClean)</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>要关闭WebSocket连接，可以在任何时候调用close方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.close();</span><br></pre></td></tr></table></figure></p>\n<p>调用了close()之后，readyState的值立即变为2（正在关闭），关闭连接后就会变成3。</p>\n<h4 id=\"发送和接收数据\"><a href=\"#发送和接收数据\" class=\"headerlink\" title=\"发送和接收数据\"></a>发送和接收数据</h4><p>WebSocket连接建立之后，可以通过连接发送和接收数据。<br>使用send()方法像服务器发送数据，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&apos;ws://localhost:8000&apos;);</span><br><span class=\"line\">socket.send(&apos;hello world&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>当服务器向客户端发来消息时，WebSocket对象会触发message事件。这个message事件与其他传递消息的协议类似，也是把返回的数据保存在event.data属性中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> socket.onmessage = function(event) &#123;</span><br><span class=\"line\">  var data = event.data;</span><br><span class=\"line\">  //处理数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"其他事件\"><a href=\"#其他事件\" class=\"headerlink\" title=\"其他事件\"></a>其他事件</h4><p>WebSocket对象还有其他三个事件，在连接生命周期的不同阶段触发。</p>\n<p>open：成功建立连接时触发。<br>error：发生错误时触发，连接断开。<br>close: 连接关闭时触发。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&apos;ws://localhost:8000&apos;);</span><br><span class=\"line\">socket.onopen = function() &#123;</span><br><span class=\"line\">  console.log(&apos;Connection established.&apos;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">socket.onerror = function() &#123;</span><br><span class=\"line\">  console.log(&apos;Connection error.&apos;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">socket.onclose = function(event) &#123;</span><br><span class=\"line\">  var code = event.code;</span><br><span class=\"line\">  var reason = event.reason;</span><br><span class=\"line\">  var wasClean = event.wasClean;</span><br><span class=\"line\">  console.log(&apos;Connection closed.&apos;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这三个事件中，只有close事件的event对象有额外信息，这个事件的事件对象有三个额外的属性：wasClean、code和reason。<br>其中wasClean是一个布尔值，表示连接是否已经明确的关闭；<br>code是服务器返回的数值状态码；<br>reason是一个字符串，包含服务器发回的信息。</p>\n<h1 id=\"三、WebSocket心跳及重连机制\"><a href=\"#三、WebSocket心跳及重连机制\" class=\"headerlink\" title=\"三、WebSocket心跳及重连机制\"></a>三、WebSocket心跳及重连机制</h1><p>在使用websocket的过程中，有时候会遇到网络断开的情况，但是在网络断开的时候服务器端并没有触发onclose的事件。这样会有：服务器会继续向客户端发送多余的链接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的链接状态。因此就有了websocket的心跳了。还有心跳，说明还活着，没有心跳说明已经挂掉了。</p>\n<ol>\n<li><p>为什么叫心跳包呢？<br>它就像心跳一样每隔固定的时间发一次，来告诉服务器，我还活着。</p>\n</li>\n<li><p>心跳机制是？<br>心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了。需要重连~</p>\n</li>\n</ol>\n<p>那么需要怎么去实现它呢？如下所有代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;WebSocket Demo&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    // var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    ws.onerror = function(e) &#123;</span><br><span class=\"line\">      console.log(&apos;已关闭&apos;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ws.onopen = function(e) &#123;</span><br><span class=\"line\">      console.log(&apos;握手成功&apos;);</span><br><span class=\"line\">      ws.send(&apos;123456789&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ws.onclose = function() &#123;</span><br><span class=\"line\">      console.log(&apos;已关闭&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ws.onmessage = function(e) &#123;</span><br><span class=\"line\">      console.log(&apos;收到消息&apos;);</span><br><span class=\"line\">      console.log(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    */</span><br><span class=\"line\">    </span><br><span class=\"line\">    var lockReconnect = false;//避免重复连接</span><br><span class=\"line\">    var wsUrl = &quot;wss://echo.websocket.org&quot;;</span><br><span class=\"line\">    var ws;</span><br><span class=\"line\">    var tt;</span><br><span class=\"line\">    function createWebSocket() &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        ws = new WebSocket(wsUrl);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">      &#125; catch(e) &#123;</span><br><span class=\"line\">        console.log(&apos;catch&apos;);</span><br><span class=\"line\">        reconnect(wsUrl);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function init() &#123;</span><br><span class=\"line\">      ws.onclose = function () &#123;</span><br><span class=\"line\">        console.log(&apos;链接关闭&apos;);</span><br><span class=\"line\">        reconnect(wsUrl);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      ws.onerror = function() &#123;</span><br><span class=\"line\">        console.log(&apos;发生异常了&apos;);</span><br><span class=\"line\">        reconnect(wsUrl);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      ws.onopen = function () &#123;</span><br><span class=\"line\">        //心跳检测重置</span><br><span class=\"line\">        heartCheck.start();</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      ws.onmessage = function (event) &#123;</span><br><span class=\"line\">        //拿到任何消息都说明当前连接是正常的</span><br><span class=\"line\">        console.log(&apos;接收到消息&apos;);</span><br><span class=\"line\">        heartCheck.start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function reconnect(url) &#123;</span><br><span class=\"line\">      if(lockReconnect) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      lockReconnect = true;</span><br><span class=\"line\">      //没连接上会一直重连，设置延迟避免请求过多</span><br><span class=\"line\">      tt &amp;&amp; clearTimeout(tt);</span><br><span class=\"line\">      tt = setTimeout(function () &#123;</span><br><span class=\"line\">        createWebSocket(url);</span><br><span class=\"line\">        lockReconnect = false;</span><br><span class=\"line\">      &#125;, 4000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //心跳检测</span><br><span class=\"line\">    var heartCheck = &#123;</span><br><span class=\"line\">      timeout: 3000,</span><br><span class=\"line\">      timeoutObj: null,</span><br><span class=\"line\">      serverTimeoutObj: null,</span><br><span class=\"line\">      start: function()&#123;</span><br><span class=\"line\">        console.log(&apos;start&apos;);</span><br><span class=\"line\">        var self = this;</span><br><span class=\"line\">        this.timeoutObj &amp;&amp; clearTimeout(this.timeoutObj);</span><br><span class=\"line\">        this.serverTimeoutObj &amp;&amp; clearTimeout(this.serverTimeoutObj);</span><br><span class=\"line\">        this.timeoutObj = setTimeout(function()&#123;</span><br><span class=\"line\">          //这里发送一个心跳，后端收到后，返回一个心跳消息，</span><br><span class=\"line\">          console.log(&apos;55555&apos;);</span><br><span class=\"line\">          ws.send(&quot;123456789&quot;);</span><br><span class=\"line\">          self.serverTimeoutObj = setTimeout(function() &#123;</span><br><span class=\"line\">            console.log(111);</span><br><span class=\"line\">            console.log(ws);</span><br><span class=\"line\">            ws.close();</span><br><span class=\"line\">            // createWebSocket();</span><br><span class=\"line\">          &#125;, self.timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;, this.timeout)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    createWebSocket(wsUrl);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>具体的思路如下：</p>\n<ol>\n<li><p>第一步页面初始化，先调用createWebSocket函数，目的是创建一个websocket的方法：new WebSocket(wsUrl);因此封装成函数内如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createWebSocket() &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    ws = new WebSocket(wsUrl);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">  &#125; catch(e) &#123;</span><br><span class=\"line\">    console.log(&apos;catch&apos;);</span><br><span class=\"line\">    reconnect(wsUrl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二步调用init方法，该方法内把一些监听事件封装如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">  ws.onclose = function () &#123;</span><br><span class=\"line\">    console.log(&apos;链接关闭&apos;);</span><br><span class=\"line\">    reconnect(wsUrl);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  ws.onerror = function() &#123;</span><br><span class=\"line\">    console.log(&apos;发生异常了&apos;);</span><br><span class=\"line\">    reconnect(wsUrl);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  ws.onopen = function () &#123;</span><br><span class=\"line\">    //心跳检测重置</span><br><span class=\"line\">    heartCheck.start();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  ws.onmessage = function (event) &#123;</span><br><span class=\"line\">    //拿到任何消息都说明当前连接是正常的</span><br><span class=\"line\">    console.log(&apos;接收到消息&apos;);</span><br><span class=\"line\">    heartCheck.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如上第二步，当网络断开的时候，会先调用onerror，onclose事件可以监听到，会调用reconnect方法进行重连操作。正常的情况下，是先调用<br>onopen方法的，当接收到数据时，会被onmessage事件监听到。</p>\n</li>\n<li><p>重连操作 reconnect代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lockReconnect = false;//避免重复连接</span><br><span class=\"line\">function reconnect(url) &#123;</span><br><span class=\"line\">  if(lockReconnect) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  lockReconnect = true;</span><br><span class=\"line\">  //没连接上会一直重连，设置延迟避免请求过多</span><br><span class=\"line\">  tt &amp;&amp; clearTimeout(tt);</span><br><span class=\"line\">  tt = setTimeout(function () &#123;</span><br><span class=\"line\">    createWebSocket(url);</span><br><span class=\"line\">    lockReconnect = false;</span><br><span class=\"line\">  &#125;, 4000);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如上代码，如果网络断开的话，会执行reconnect方法，使用了一个定时器，4秒后会重新创建一个新的websocket链接，重新调用createWebSocket函数，<br>重新会执行及发送数据给服务器端。</p>\n<ol start=\"5\">\n<li>最后一步就是实现心跳检测的代码：如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//心跳检测</span><br><span class=\"line\">var heartCheck = &#123;</span><br><span class=\"line\">  timeout: 3000,</span><br><span class=\"line\">  timeoutObj: null,</span><br><span class=\"line\">  serverTimeoutObj: null,</span><br><span class=\"line\">  start: function()&#123;</span><br><span class=\"line\">    console.log(&apos;start&apos;);</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    this.timeoutObj &amp;&amp; clearTimeout(this.timeoutObj);</span><br><span class=\"line\">    this.serverTimeoutObj &amp;&amp; clearTimeout(this.serverTimeoutObj);</span><br><span class=\"line\">    this.timeoutObj = setTimeout(function()&#123;</span><br><span class=\"line\">      //这里发送一个心跳，后端收到后，返回一个心跳消息，</span><br><span class=\"line\">      //onmessage拿到返回的心跳就说明连接正常</span><br><span class=\"line\">      console.log(&apos;55555&apos;);</span><br><span class=\"line\">      ws.send(&quot;123456789&quot;);</span><br><span class=\"line\">      self.serverTimeoutObj = setTimeout(function() &#123;</span><br><span class=\"line\">        console.log(111);</span><br><span class=\"line\">        console.log(ws);</span><br><span class=\"line\">        ws.close();</span><br><span class=\"line\">        // createWebSocket();</span><br><span class=\"line\">      &#125;, self.timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;, this.timeout)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>实现心跳检测的思路是：每隔一段固定的时间，向服务器端发送一个ping数据，如果在正常的情况下，服务器会返回一个pong给客户端，如果客户端通过onmessage事件能监听到的话，说明请求正常，这里我们使用了一个定时器，每隔3秒的情况下，如果是网络断开的情况下，在指定的时间内服务器端并没有返回心跳响应消息，因此服务器端断开了，因此这个时候我们使用ws.close关闭连接，在一段时间后(在不同的浏览器下，时间是不一样的，firefox响应更快)，可以通过 onclose事件监听到。因此在onclose事件内，我们可以调用 reconnect事件进行重连操作。</p>\n<h1 id=\"四、WebSocket-实例\"><a href=\"#四、WebSocket-实例\" class=\"headerlink\" title=\"四、WebSocket 实例\"></a>四、WebSocket 实例</h1><p>前面已经学习了WebSocket API，包括事件、方法和属性。WebSocket是基于事件驱动，支持全双工通信。下面通过二个简单例子体验一下。</p>\n<h4 id=\"简单在线聊天\"><a href=\"#简单在线聊天\" class=\"headerlink\" title=\"简单在线聊天\"></a>简单在线聊天</h4><p>1、通过nodejs在项目里面新建一个server.js，创建服务，指定8181端口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var http = require(&apos;http&apos;);</span><br><span class=\"line\">var WebSocket = require(&apos;ws&apos;);</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\">app.use(express.static(__dirname));</span><br><span class=\"line\">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class=\"line\">\tres.send(&apos;&lt;h1&gt;Welcome Realtime Server&lt;/h1&gt;&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">var server = http.createServer(app);</span><br><span class=\"line\">var wss = new WebSocket.Server(&#123;server&#125;);</span><br><span class=\"line\">wss.on(&apos;connection&apos;, function connection(ws) &#123;</span><br><span class=\"line\">    console.log(&apos;链接成功！&apos;);</span><br><span class=\"line\">    ws.on(&apos;message&apos;, function incoming(data) &#123;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 把消息发送到所有的客户端</span><br><span class=\"line\">         * wss.clients获取所有链接的客户端</span><br><span class=\"line\">         */</span><br><span class=\"line\">        wss.clients.forEach(function each(client) &#123;</span><br><span class=\"line\">            client.send(data);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8181, function listening() &#123;</span><br><span class=\"line\">    console.log(&apos;服务器启动成功！&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>在浏览器里输入<a href=\"http://localhost:8181/测试服务是否启动成功。\" target=\"_blank\" rel=\"noopener\">http://localhost:8181/测试服务是否启动成功。</a></p>\n<p>2、创建客户端。为了能在多台设备上测试，可以本地在启一个服务来跑客户端代码。<br>通node启一个8282端口的本机服务<br>app.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var http = require(&apos;http&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var app = express();</span><br><span class=\"line\">app.use(express.static(__dirname));</span><br><span class=\"line\">var server = http.createServer(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class=\"line\">\tres.send(&apos;&lt;h1&gt;Welcome client&lt;/h1&gt;&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8282, function listening() &#123;</span><br><span class=\"line\">    console.log(&apos;ok！&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>3、创建index.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;websocket chat&lt;/h1&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;input id=&quot;name&quot; size=&quot;15&quot; type=&quot;text&quot; placeholder=&quot;姓名&quot; value=&quot;&quot;&gt;</span><br><span class=\"line\">        &lt;input id=&quot;message&quot; size=&quot;50&quot; type=&quot;text&quot; placeholder=&quot;内容&quot; value=&quot;&quot;&gt;</span><br><span class=\"line\">        &lt;input id=&quot;btn_post&quot; type=&quot;button&quot; value=&quot;post&quot;&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;ul id=&quot;chat&quot;&gt;&lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=&quot;http://cdn.bootcss.com/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>可以输入姓名和内容，然后有一个提交按钮来发送数据给服务器。</p>\n<p>4、创建websocket链接<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = new WebSocket(&quot;ws://localhost:8181&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>要在多台服务测试需要把localhost改成IP<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = new WebSocket(&quot;ws://10.254.124.8:8181&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>5、点击提交按钮或回车向服务器发送信息，使用 ws.send 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(function()&#123;</span><br><span class=\"line\">  $(&quot;#btn_post&quot;).click(post);</span><br><span class=\"line\">  $(&quot;#message&quot;).keydown(function(e)&#123;</span><br><span class=\"line\">    if(e.keyCode == 13) post();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">var post = function()&#123;</span><br><span class=\"line\">  var name = $(&quot;#name&quot;).val();</span><br><span class=\"line\">  var mes = $(&quot;#message&quot;).val();</span><br><span class=\"line\">  ws.send(name+&quot; : &quot;+mes);</span><br><span class=\"line\">  $(&quot;input#message&quot;).val(&quot;&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>6、服务器接收到信息后返回给客户端，使用 ws.onmessage 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ws.onmessage = function(e)&#123;</span><br><span class=\"line\">  print(e.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var print = function(msg)&#123;</span><br><span class=\"line\">  $(&quot;#chat&quot;).prepend($(&quot;&lt;li&gt;&quot;).text(msg));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>浏览器里输入 <a href=\"http://10.254.124.8:8282/index.html\" target=\"_blank\" rel=\"noopener\">http://10.254.124.8:8282/index.html</a> 可以看到预览效果<br><img src=\"https://img.fengjr.com/image/2019/11/27/a36c14d25b7ef14a1787320e29a09266.png\" alt></p>\n<h4 id=\"模拟股票实例\"><a href=\"#模拟股票实例\" class=\"headerlink\" title=\"模拟股票实例\"></a>模拟股票实例</h4><p>上面的例子很简单，只是为了演示如何运用nodejs的ws创建一个WebSocket服务器。且可以接受客户端的消息。那么下面这个例子演示股票的实时更新。客服端只需要连接一次，服务器端会不断地发送新数据，客户端收数据后更新UI.页面如下，有五只股票，开始和停止按钮测试连接和关闭。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/11/27/83b293b5e353e2d9bdf080e7cf7cbb82.png\" alt></p>\n<p>服务端：<br>1.模拟五只股票的涨跌。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stocks = &#123;</span><br><span class=\"line\">    &quot;AAPL&quot;: 95.0,</span><br><span class=\"line\">    &quot;MSFT&quot;: 50.0,</span><br><span class=\"line\">    &quot;AMZN&quot;: 300.0,</span><br><span class=\"line\">    &quot;GOOG&quot;: 550.0,</span><br><span class=\"line\">    &quot;YHOO&quot;: 35.0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function randomInterval(min, max) &#123;</span><br><span class=\"line\">    return Math.floor(Math.random() * (max - min + 1) + min);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var stockUpdater;</span><br><span class=\"line\">var randomStockUpdater = function() &#123;</span><br><span class=\"line\">    for (var symbol in stocks) &#123;</span><br><span class=\"line\">        if(stocks.hasOwnProperty(symbol)) &#123;</span><br><span class=\"line\">            var randomizedChange = randomInterval(-150, 150);</span><br><span class=\"line\">            var floatChange = randomizedChange / 100;</span><br><span class=\"line\">            stocks[symbol] += floatChange;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var randomMSTime = randomInterval(500, 2500);</span><br><span class=\"line\">    stockUpdater = setTimeout(function() &#123;</span><br><span class=\"line\">        randomStockUpdater();</span><br><span class=\"line\">    &#125;, randomMSTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">randomStockUpdater();</span><br></pre></td></tr></table></figure></p>\n<p>2.连接建立之后就开始更新数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wss.on(&apos;connection&apos;, function (ws) &#123;</span><br><span class=\"line\">  var sendStockUpdates = function (ws) &#123;</span><br><span class=\"line\">      if (ws.readyState == 1) &#123;</span><br><span class=\"line\">          var stocksObj = &#123;&#125;;</span><br><span class=\"line\">          for (var i = 0; i &lt; clientStocks.length; i++) &#123;</span><br><span class=\"line\">            var symbol = clientStocks[i];</span><br><span class=\"line\">              stocksObj[symbol] = stocks[symbol];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (stocksObj.length !== 0) &#123;</span><br><span class=\"line\">              ws.send(JSON.stringify(stocksObj));//需要将对象转成字符串。WebSocket只支持文本和二进制数据</span><br><span class=\"line\">              console.log(&quot;更新&quot;, JSON.stringify(stocksObj));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var clientStockUpdater = setInterval(function () &#123;</span><br><span class=\"line\">      sendStockUpdates(ws);</span><br><span class=\"line\">  &#125;, 1000);</span><br><span class=\"line\">  ws.on(&apos;message&apos;, function (message) &#123;</span><br><span class=\"line\">      var stockRequest = JSON.parse(message);//根据请求过来的数据来更新。</span><br><span class=\"line\">      console.log(&quot;收到消息&quot;, stockRequest);</span><br><span class=\"line\">      clientStocks = stockRequest[&apos;stocks&apos;];</span><br><span class=\"line\">      sendStockUpdates(ws);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>客户端：<br>建立连接：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = new WebSocket(&quot;ws://localhost:8181&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>onopen直接只有在连接成功后才会触发，在这个时候将客户端需要请求的股票发送给服务端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isClose = false;</span><br><span class=\"line\">  var stocks = &#123;</span><br><span class=\"line\">      &quot;AAPL&quot;: 0, &quot;MSFT&quot;: 0, &quot;AMZN&quot;: 0, &quot;GOOG&quot;: 0, &quot;YHOO&quot;: 0</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  function updataUI() &#123;</span><br><span class=\"line\">      ws.onopen = function (e) &#123;</span><br><span class=\"line\">          console.log(&apos;Connection to server opened&apos;);</span><br><span class=\"line\">          isClose = false;</span><br><span class=\"line\">          ws.send(JSON.stringify(stock_request));</span><br><span class=\"line\">          console.log(&quot;sened a mesg&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      //更新UI</span><br><span class=\"line\">      var changeStockEntry = function (symbol, originalValue, newValue) &#123;</span><br><span class=\"line\">          var valElem = $(&apos;#&apos; + symbol + &apos; span&apos;);</span><br><span class=\"line\">          valElem.html(newValue.toFixed(2));</span><br><span class=\"line\">          if (newValue &lt; originalValue) &#123;</span><br><span class=\"line\">              valElem.addClass(&apos;label-danger&apos;);</span><br><span class=\"line\">              valElem.removeClass(&apos;label-success&apos;);</span><br><span class=\"line\">          &#125; else if (newValue &gt; originalValue) &#123;</span><br><span class=\"line\">              valElem.addClass(&apos;label-success&apos;);</span><br><span class=\"line\">              valElem.removeClass(&apos;label-danger&apos;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 处理受到的消息</span><br><span class=\"line\">      ws.onmessage = function (e) &#123;</span><br><span class=\"line\">          var stocksData = JSON.parse(e.data);</span><br><span class=\"line\">          console.log(stocksData);</span><br><span class=\"line\">          for (var symbol in stocksData) &#123;</span><br><span class=\"line\">              if (stocksData.hasOwnProperty(symbol)) &#123;</span><br><span class=\"line\">                  changeStockEntry(symbol, stocks[symbol], stocksData[symbol]);</span><br><span class=\"line\">                  stocks[symbol] = stocksData[symbol];</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  updataUI();</span><br></pre></td></tr></table></figure></p>\n<p>运行可以看到效果，只需要请求一次，数据就会不断的更新，效果是不是很赞，不用轮询，也不用长连接那么麻烦了。</p>\n<h1 id=\"五、socket-io\"><a href=\"#五、socket-io\" class=\"headerlink\" title=\"五、socket.io\"></a>五、socket.io</h1><p>socket.IO是一个websocket库，包括了客户端的js和服务器端的nodejs。官方地址：<a href=\"http://socket.io\" target=\"_blank\" rel=\"noopener\">http://socket.io</a></p>\n<h4 id=\"客户端使用socket-io\"><a href=\"#客户端使用socket-io\" class=\"headerlink\" title=\"客户端使用socket.io\"></a>客户端使用socket.io</h4><p>去github clone socket.io的最新版本，或者直接饮用使用socket.io的CDN服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://cdn.socket.io/stable/socket.io.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>下面可以创建使用socket.io库来创建客户端js代码了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = io.connect(&apos;http://localhost&apos;);</span><br><span class=\"line\">socket.on(&apos;news&apos;, function (data) &#123;</span><br><span class=\"line\">\tconsole.log(data);</span><br><span class=\"line\">\tsocket.emit(&apos;my other event&apos;, &#123; my: &apos;data&apos; &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>socket.on是监听，收到服务器端发来的news的内容，则运行function，其中data就是请求回来的数据，socket.emit是发送消息给服务器端的方法。</p>\n<h4 id=\"使用socket-io和nodejs搭建websocket服务器端\"><a href=\"#使用socket-io和nodejs搭建websocket服务器端\" class=\"headerlink\" title=\"使用socket.io和nodejs搭建websocket服务器端\"></a>使用socket.io和nodejs搭建websocket服务器端</h4><p>socket.io不仅可以搭建客户端的websocket服务，而且支持nodejs服务器端的websocket。</p>\n<p>nodejs安装socket.io<br>使用node插件管理包，运行下面的命令就可以安装成功socket.io<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install socket.io</span><br></pre></td></tr></table></figure></p>\n<p>没有npm的或者windows用户可以使用github下载socket.io并且放入到node_modules文件夹中。</p>\n<h4 id=\"nodejs建立socket-io服务\"><a href=\"#nodejs建立socket-io服务\" class=\"headerlink\" title=\"nodejs建立socket.io服务\"></a>nodejs建立socket.io服务</h4><p>通过nodejs的http模块就可以方便的搭建websocket服务器环境，例如下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 引入需要的模块：http和socket.io</span><br><span class=\"line\">var http = require(&apos;http&apos;), io = require(&apos;socket.io&apos;);</span><br><span class=\"line\">//创建server</span><br><span class=\"line\">var server = http.createServer(function(req, res)&#123; </span><br><span class=\"line\">  // Send HTML headers and message</span><br><span class=\"line\">  res.writeHead(200,&#123; &apos;Content-Type&apos;: &apos;text/html&apos; &#125;); </span><br><span class=\"line\">  res.end(&apos;&lt;h1&gt;Hello Socket Lover!&lt;/h1&gt;&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//端口8000</span><br><span class=\"line\">server.listen(8080);</span><br><span class=\"line\">//创建socket</span><br><span class=\"line\">var socket = io.listen(server);</span><br><span class=\"line\">//添加连接监听</span><br><span class=\"line\">socket.on(&apos;connection&apos;, function(client)&#123;   </span><br><span class=\"line\">\t//连接成功则执行下面的监听</span><br><span class=\"line\">\tclient.on(&apos;message&apos;,function(event)&#123; </span><br><span class=\"line\">\t\tconsole.log(&apos;Received message from client!&apos;,event);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t//断开连接callback</span><br><span class=\"line\">\tclient.on(&apos;disconnect&apos;,function()&#123;</span><br><span class=\"line\">\t\tconsole.log(&apos;Server has disconnected&apos;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>保存为socket.js然后在命令行执行：node socket.js 即可启动服务器，现在访问localhost:8000就可以了。</p>\n<p>目标：Socket.IO旨在让各种浏览器与移动设备上实现实时app功能，模糊化各种传输机制。</p>\n<p>缺点：socket.io 在高并发的情况下，稳定性与可靠性其实是不高的。特别是其websocket的实现，websocket本身就存在很多局限，对服务端，客户端的要求都比较高，要使其稳定的运行，还是有蛮多的工作要做的。 另外，socket.io 的作者又开发了另一个类似的实现：<a href=\"https://github.com/socketio/engine.io\" target=\"_blank\" rel=\"noopener\">engine.io</a> 应该是就socket.io的一些不足作了改进。</p>\n<h4 id=\"socket-io搭建多人聊天室实例\"><a href=\"#socket-io搭建多人聊天室实例\" class=\"headerlink\" title=\"socket.io搭建多人聊天室实例\"></a>socket.io搭建多人聊天室实例</h4><p>需求分析<br>1、兼容不支持WebSocket的低版本浏览器。<br>2、允许客户端有相同的用户名。<br>3、进入聊天室后可以看到当前在线的用户和在线人数。<br>4、用户上线或退出，所有在线的客户端应该实时更新。<br>5、用户发送消息，所有客户端实时收取。</p>\n<p>有了前面的搭建基础，就不多啰嗦了，直接上代码：</p>\n<p>index.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt;</span><br><span class=\"line\">        &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;/&gt;</span><br><span class=\"line\">&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;多人聊天室&lt;/title&gt;</span><br><span class=\"line\">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot; /&gt;</span><br><span class=\"line\">        &lt;!--[if lt IE 8]&gt;&lt;script src=&quot;./json3.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;</span><br><span class=\"line\">        &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.dev.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;div id=&quot;loginbox&quot;&gt;</span><br><span class=\"line\">            &lt;div style=&quot;width:260px;margin:200px auto;&quot;&gt;</span><br><span class=\"line\">                请先输入你在聊天室的昵称</span><br><span class=\"line\">                &lt;br/&gt;</span><br><span class=\"line\">                &lt;br/&gt;</span><br><span class=\"line\">                &lt;input type=&quot;text&quot; style=&quot;width:180px;&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;input type=&quot;button&quot; style=&quot;width:50px;&quot; value=&quot;提交&quot; onclick=&quot;CHAT.usernameSubmit();&quot;/&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div id=&quot;chatbox&quot; style=&quot;display:none;&quot;&gt;</span><br><span class=\"line\">            &lt;div style=&quot;background:#3d3d3d;height: 28px; width: 100%;font-size:12px;&quot;&gt;</span><br><span class=\"line\">                &lt;div style=&quot;line-height: 28px;color:#fff;&quot;&gt;</span><br><span class=\"line\">                    &lt;span style=&quot;text-align:left;margin-left:10px;&quot;&gt;Websocket多人聊天室&lt;/span&gt;</span><br><span class=\"line\">                    &lt;span style=&quot;float:right; margin-right:10px;&quot;&gt;&lt;span id=&quot;showusername&quot;&gt;&lt;/span&gt; | </span><br><span class=\"line\">\t\t\t\t\t&lt;a href=&quot;javascript:;&quot; onclick=&quot;CHAT.logout()&quot; style=&quot;color:#fff;&quot;&gt;退出&lt;/a&gt;&lt;/span&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">            &lt;div id=&quot;doc&quot;&gt;</span><br><span class=\"line\">                &lt;div id=&quot;chat&quot;&gt;</span><br><span class=\"line\">                    &lt;div id=&quot;message&quot; class=&quot;message&quot;&gt;</span><br><span class=\"line\">&lt;div id=&quot;onlinecount&quot; style=&quot;background:#EFEFF4; font-size:12px; margin-top:10px; margin-left:10px; color:#666;&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                    &lt;div class=&quot;input-box&quot;&gt;</span><br><span class=\"line\">                        &lt;div class=&quot;input&quot;&gt;</span><br><span class=\"line\">&lt;input type=&quot;text&quot; maxlength=&quot;140&quot; placeholder=&quot;请输入聊天内容，按Enter提交&quot; id=&quot;content&quot; name=&quot;content&quot;&gt;</span><br><span class=\"line\">                        &lt;/div&gt;</span><br><span class=\"line\">                        &lt;div class=&quot;action&quot;&gt;</span><br><span class=\"line\">                            &lt;button type=&quot;button&quot; id=&quot;mjr_send&quot; onclick=&quot;CHAT.submit();&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">                        &lt;/div&gt;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;script type=&quot;text/javascript&quot; src=&quot;./client.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>client.js 客户端代码，里面有详细注释，很清晰。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function () &#123;</span><br><span class=\"line\">\tvar d = document,</span><br><span class=\"line\">\tw = window,</span><br><span class=\"line\">\tp = parseInt,</span><br><span class=\"line\">\tdd = d.documentElement,</span><br><span class=\"line\">\tdb = d.body,</span><br><span class=\"line\">\tdc = d.compatMode == &apos;CSS1Compat&apos;,</span><br><span class=\"line\">\tdx = dc ? dd: db,</span><br><span class=\"line\">\tec = encodeURIComponent;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tw.CHAT = &#123;</span><br><span class=\"line\">\t\tmsgObj:d.getElementById(&quot;message&quot;),</span><br><span class=\"line\">\t\tscreenheight:w.innerHeight ? w.innerHeight : dx.clientHeight,</span><br><span class=\"line\">\t\tusername:null,</span><br><span class=\"line\">\t\tuserid:null,</span><br><span class=\"line\">\t\tsocket:null,</span><br><span class=\"line\">\t\t//让浏览器滚动条保持在最低部</span><br><span class=\"line\">\t\tscrollToBottom:function()&#123;</span><br><span class=\"line\">\t\t\tw.scrollTo(0, this.msgObj.clientHeight);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t//退出，本例只是一个简单的刷新</span><br><span class=\"line\">\t\tlogout:function()&#123;</span><br><span class=\"line\">\t\t\t//this.socket.disconnect();</span><br><span class=\"line\">\t\t\tlocation.reload();</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t//提交聊天消息内容</span><br><span class=\"line\">\t\tsubmit:function()&#123;</span><br><span class=\"line\">\t\t\tvar content = d.getElementById(&quot;content&quot;).value;</span><br><span class=\"line\">\t\t\tif(content != &apos;&apos;)&#123;</span><br><span class=\"line\">\t\t\t\tvar obj = &#123;</span><br><span class=\"line\">\t\t\t\t\tuserid: this.userid,</span><br><span class=\"line\">\t\t\t\t\tusername: this.username,</span><br><span class=\"line\">\t\t\t\t\tcontent: content</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t\tthis.socket.emit(&apos;message&apos;, obj);</span><br><span class=\"line\">\t\t\t\td.getElementById(&quot;content&quot;).value = &apos;&apos;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tgenUid:function()&#123;</span><br><span class=\"line\">\t\t\treturn new Date().getTime()+&quot;&quot;+Math.floor(Math.random()*899+100);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t//更新系统消息，本例中在用户加入、退出的时候调用</span><br><span class=\"line\">\t\tupdateSysMsg:function(o, action)&#123;</span><br><span class=\"line\">\t\t\t//当前在线用户列表</span><br><span class=\"line\">\t\t\tvar onlineUsers = o.onlineUsers;</span><br><span class=\"line\">\t\t\t//当前在线人数</span><br><span class=\"line\">\t\t\tvar onlineCount = o.onlineCount;</span><br><span class=\"line\">\t\t\t//新加入用户的信息</span><br><span class=\"line\">\t\t\tvar user = o.user;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t//更新在线人数</span><br><span class=\"line\">\t\t\tvar userhtml = &apos;&apos;;</span><br><span class=\"line\">\t\t\tvar separator = &apos;&apos;;</span><br><span class=\"line\">\t\t\tfor(key in onlineUsers) &#123;</span><br><span class=\"line\">\t\t        if(onlineUsers.hasOwnProperty(key))&#123;</span><br><span class=\"line\">\t\t\t\t\tuserhtml += separator+onlineUsers[key];</span><br><span class=\"line\">\t\t\t\t\tseparator = &apos;、&apos;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t\td.getElementById(&quot;onlinecount&quot;).innerHTML = &apos;当前共有 &apos;+onlineCount+&apos; 人在线，在线列表：&apos;+userhtml;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//添加系统消息</span><br><span class=\"line\">\t\t\tvar html = &apos;&apos;;</span><br><span class=\"line\">\t\t\thtml += &apos;&lt;div class=&quot;msg-system&quot;&gt;&apos;;</span><br><span class=\"line\">\t\t\thtml += user.username;</span><br><span class=\"line\">\t\t\thtml += (action == &apos;login&apos;) ? &apos; 加入了聊天室&apos; : &apos; 退出了聊天室&apos;;</span><br><span class=\"line\">\t\t\thtml += &apos;&lt;/div&gt;&apos;;</span><br><span class=\"line\">\t\t\tvar section = d.createElement(&apos;section&apos;);</span><br><span class=\"line\">\t\t\tsection.className = &apos;system J-mjrlinkWrap J-cutMsg&apos;;</span><br><span class=\"line\">\t\t\tsection.innerHTML = html;</span><br><span class=\"line\">\t\t\tthis.msgObj.appendChild(section);\t</span><br><span class=\"line\">\t\t\tthis.scrollToBottom();</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t//第一个界面用户提交用户名</span><br><span class=\"line\">\t\tusernameSubmit:function()&#123;</span><br><span class=\"line\">\t\t\tvar username = d.getElementById(&quot;username&quot;).value;</span><br><span class=\"line\">\t\t\tif(username != &quot;&quot;)&#123;</span><br><span class=\"line\">\t\t\t\td.getElementById(&quot;username&quot;).value = &apos;&apos;;</span><br><span class=\"line\">\t\t\t\td.getElementById(&quot;loginbox&quot;).style.display = &apos;none&apos;;</span><br><span class=\"line\">\t\t\t\td.getElementById(&quot;chatbox&quot;).style.display = &apos;block&apos;;</span><br><span class=\"line\">\t\t\t\tthis.init(username);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tinit:function(username)&#123;</span><br><span class=\"line\">\t\t\t/*</span><br><span class=\"line\">\t\t\t客户端根据时间和随机数生成uid,这样使得聊天室用户名称可以重复。</span><br><span class=\"line\">\t\t\t实际项目中，如果是需要用户登录，那么直接采用用户的uid来做标识就可以</span><br><span class=\"line\">\t\t\t*/</span><br><span class=\"line\">\t\t\tthis.userid = this.genUid();</span><br><span class=\"line\">\t\t\tthis.username = username;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\td.getElementById(&quot;showusername&quot;).innerHTML = this.username;</span><br><span class=\"line\">\t\t\t//this.msgObj.style.minHeight = (this.screenheight - db.clientHeight + this.msgObj.clientHeight) + &quot;px&quot;;</span><br><span class=\"line\">\t\t\tthis.scrollToBottom();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//连接websocket后端服务器</span><br><span class=\"line\">\t\t\tthis.socket = io.connect(&apos;ws://10.254.124.8:8383&apos;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//告诉服务器端有用户登录</span><br><span class=\"line\">\t\t\tthis.socket.emit(&apos;login&apos;, &#123;userid:this.userid, username:this.username&#125;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//监听新用户登录</span><br><span class=\"line\">\t\t\tthis.socket.on(&apos;login&apos;, function(o)&#123;</span><br><span class=\"line\">\t\t\t\tCHAT.updateSysMsg(o, &apos;login&apos;);\t</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//监听用户退出</span><br><span class=\"line\">\t\t\tthis.socket.on(&apos;logout&apos;, function(o)&#123;</span><br><span class=\"line\">\t\t\t\tCHAT.updateSysMsg(o, &apos;logout&apos;);</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//监听消息发送</span><br><span class=\"line\">\t\t\tthis.socket.on(&apos;message&apos;, function(obj)&#123;</span><br><span class=\"line\">\t\t\t\tvar isme = (obj.userid == CHAT.userid) ? true : false;</span><br><span class=\"line\">\t\t\t\tvar contentDiv = &apos;&lt;div&gt;&apos;+obj.content+&apos;&lt;/div&gt;&apos;;</span><br><span class=\"line\">\t\t\t\tvar usernameDiv = &apos;&lt;span&gt;&apos;+obj.username+&apos;&lt;/span&gt;&apos;;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\tvar section = d.createElement(&apos;section&apos;);</span><br><span class=\"line\">\t\t\t\tif(isme)&#123;</span><br><span class=\"line\">\t\t\t\t\tsection.className = &apos;user&apos;;</span><br><span class=\"line\">\t\t\t\t\tsection.innerHTML = contentDiv + usernameDiv;</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tsection.className = &apos;service&apos;;</span><br><span class=\"line\">\t\t\t\t\tsection.innerHTML = usernameDiv + contentDiv;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tCHAT.msgObj.appendChild(section);</span><br><span class=\"line\">\t\t\t\tCHAT.scrollToBottom();\t</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t//通过“回车”提交用户名</span><br><span class=\"line\">\td.getElementById(&quot;username&quot;).onkeydown = function(e) &#123;</span><br><span class=\"line\">\t\te = e || event;</span><br><span class=\"line\">\t\tif (e.keyCode === 13) &#123;</span><br><span class=\"line\">\t\t\tCHAT.usernameSubmit();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t//通过“回车”提交信息</span><br><span class=\"line\">\td.getElementById(&quot;content&quot;).onkeydown = function(e) &#123;</span><br><span class=\"line\">\t\te = e || event;</span><br><span class=\"line\">\t\tif (e.keyCode === 13) &#123;</span><br><span class=\"line\">\t\t\tCHAT.submit();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>server.js 服务端代码，同样代码里有详细注释。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = require(&apos;express&apos;)();</span><br><span class=\"line\">var http = require(&apos;http&apos;).Server(app);</span><br><span class=\"line\">var io = require(&apos;socket.io&apos;)(http);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class=\"line\">\tres.send(&apos;&lt;h1&gt;Welcome Realtime Server&lt;/h1&gt;&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//在线用户</span><br><span class=\"line\">var onlineUsers = &#123;&#125;;</span><br><span class=\"line\">//当前在线人数</span><br><span class=\"line\">var onlineCount = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(&apos;connection&apos;, function(socket)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;a user connected&apos;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//监听新用户加入</span><br><span class=\"line\">\tsocket.on(&apos;login&apos;, function(obj)&#123;</span><br><span class=\"line\">\t\t//将新加入用户的唯一标识当作socket的名称，后面退出的时候会用到</span><br><span class=\"line\">\t\tsocket.name = obj.userid;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//检查在线列表，如果不在里面就加入</span><br><span class=\"line\">\t\tif(!onlineUsers.hasOwnProperty(obj.userid)) &#123;</span><br><span class=\"line\">\t\t\tonlineUsers[obj.userid] = obj.username;</span><br><span class=\"line\">\t\t\t//在线人数+1</span><br><span class=\"line\">\t\t\tonlineCount++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//向所有客户端广播用户加入</span><br><span class=\"line\">\t\tio.emit(&apos;login&apos;, &#123;onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj&#125;);</span><br><span class=\"line\">\t\tconsole.log(obj.username+&apos;加入了聊天室&apos;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//监听用户退出</span><br><span class=\"line\">\tsocket.on(&apos;disconnect&apos;, function()&#123;</span><br><span class=\"line\">\t\t//将退出的用户从在线列表中删除</span><br><span class=\"line\">\t\tif(onlineUsers.hasOwnProperty(socket.name)) &#123;</span><br><span class=\"line\">\t\t\t//退出用户的信息</span><br><span class=\"line\">\t\t\tvar obj = &#123;userid:socket.name, username:onlineUsers[socket.name]&#125;;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//删除</span><br><span class=\"line\">\t\t\tdelete onlineUsers[socket.name];</span><br><span class=\"line\">\t\t\t//在线人数-1</span><br><span class=\"line\">\t\t\tonlineCount--;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//向所有客户端广播用户退出</span><br><span class=\"line\">\t\t\tio.emit(&apos;logout&apos;, &#123;onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj&#125;);</span><br><span class=\"line\">\t\t\tconsole.log(obj.username+&apos;退出了聊天室&apos;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//监听用户发布聊天内容</span><br><span class=\"line\">\tsocket.on(&apos;message&apos;, function(obj)&#123;</span><br><span class=\"line\">\t\t//向所有客户端广播发布的消息</span><br><span class=\"line\">\t\tio.emit(&apos;message&apos;, obj);</span><br><span class=\"line\">\t\tconsole.log(obj.username+&apos;说：&apos;+obj.content);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.listen(8383, function()&#123;</span><br><span class=\"line\">\tconsole.log(&apos;listening on *:8383&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>实现效果：<br><img src=\"https://img.fengjr.com/image/2019/11/28/21a61b1204f4722431232f133b129b00.png\" width=\"50%\"></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>websocket学起来并不难，api也不多，但可扩张和延伸的东西很多，想实现一个完整的项目，需要先有一个完整的设计思路才行。比如是一个在线WebIM系统，实现类似微信，qq的功能，客户端可以看到好友在线状态，在线列表，添加好友，删除好友，新建群组等，消息的发送除了支持基本的文字外，还能支持表情、图片和文件。有兴趣的同学可以继续一起深入研究。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、websocket介绍\"><a href=\"#一、websocket介绍\" class=\"headerlink\" title=\"一、websocket介绍\"></a>一、websocket介绍</h1><p><img src=\"https://img.fengjr.com/image/2019/11/27/379278605a69626b3915c6829b1a2cb5.png\" alt></p>\n<h4 id=\"WebSocket协议出现的背景\"><a href=\"#WebSocket协议出现的背景\" class=\"headerlink\" title=\"WebSocket协议出现的背景\"></a>WebSocket协议出现的背景</h4><p>我们在上网过程中经常用到的是HTTP和HTTPS协议，HTTP协议和HTTPS协议通信过程通常是客户端通过浏览器发出一个请求，服务器接受请求后进行处理并返回结果给客户端，客户端处理结果。</p>\n<p>这种机制对于信息变化不是特别频繁的应用可以良好支撑，但对于实时要求高、海量并发的应用来说显得捉襟见肘，尤其在移动互联网蓬勃发展的趋势下，高并发与用户实时响应是Web应用经常面临的问题，比如金融证券的实时信息、社交网络的实时消息推送等。</p>\n<p>WebSocket出现前我们实现推送技术，用的都是轮询，在特定的时间间隔，浏览器自动发出请求，将服务器的消息主动的拉回来，这种情况下，我们需要不断的向服务器发送请求，并且HTTP 请求 的header非常长，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽和服务器资源，并且服务器不能主动向客户端推送数据。在这种情况下需要一种高效节能的双向通信机制来保证数据的实时传输，于是基于HTML5规范的WebSocket应运而生。</p>\n<h4 id=\"什么是websocket\"><a href=\"#什么是websocket\" class=\"headerlink\" title=\"什么是websocket\"></a>什么是websocket</h4><p>websocket是HTML5的一种新的通信协议，它实现了浏览器与服务器的双向通讯。在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>\n<p>在客户端使用websocket需要创建WebSocket对象，通过提供的open、send、message、close等方法实现创建、发送、监听信息、关闭连接。现在chrome、firefox等浏览器都已经支持了websocket，而IE却没有。</p>\n<h4 id=\"WebSocket与TCP，HTTP的关系\"><a href=\"#WebSocket与TCP，HTTP的关系\" class=\"headerlink\" title=\"WebSocket与TCP，HTTP的关系\"></a>WebSocket与TCP，HTTP的关系</h4><p>WebSocket与http协议一样都是基于TCP的，所以他们都是可靠的协议，调用的WebSocket的send函数在实现中最终都是通过TCP的系统接口进行传输的。WebSocket和Http协议一样都属于应用层的协议，WebSocket在建立握手连接时，数据是通过http协议传输的，但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。</p>\n<h4 id=\"WebSocket与HTTP轮询\"><a href=\"#WebSocket与HTTP轮询\" class=\"headerlink\" title=\"WebSocket与HTTP轮询\"></a>WebSocket与HTTP轮询</h4><ul>\n<li>ajax轮询<br>ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。场景再现：<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有。。（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：你好烦啊，没有啊。。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：好啦好啦，有啦给你。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：。。。。。没。。。。没。。。没有（Response） —- loop</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/11/27/2a0bf85b8ef69023aa962f94b2fde30a.png\" alt></p>\n<ul>\n<li>long poll<br>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。<br>场景再现：<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）<br>服务端：额。。   等待到有消息的时候。。来 给你（Response）<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/11/27/4c1058fe7a183d623c25ab72f946a868.png\" alt></p>\n<p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。简单地说就是，服务器是一个很懒的冰箱（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。</p>\n<p>说完这个，我们再来说一说上面的缺陷<br>从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。<br>ajax轮询 需要服务器有很快的处理速度和资源。（速度）<br>long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</p>\n<ul>\n<li>WebSocket<br>WebSocket的出现解决了轮询实时交互性和全双工的问题。<br>在JavaScript中创建了WebSocket后，会有一个HTTP请求发送到服务器以发起连接。取得服务器响应后，建立的连接使用HTTP升级，从HTTP协议交换为WebSocket协议。即，使用标准的HTTP服务器无法实现WebSocket，只有支持这种协议的专门服务器才能正常工作。<br>WebSocket使用了自定义的协议，未加密的连接不再是http://，而是ws://，默认端口为80，加密的连接也不是https://，而是wss://，默认端口为443。</li>\n</ul>\n<p><img src=\"https://img.fengjr.com/image/2019/11/27/34927c1cd3258dab7aa4156463715e6b.png\" width=\"50%\" height=\"50%\"></p>\n<p>WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p>\n<p>WebSocket与HTTP轮询对比得出的结论：<br>WebSocket是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。</p>\n<h1 id=\"二、WebSocket-API\"><a href=\"#二、WebSocket-API\" class=\"headerlink\" title=\"二、WebSocket API\"></a>二、WebSocket API</h1><p>上面讲述了WebSocket比HTTP轮询好，下面介绍一下WebSocket API。</p>\n<h4 id=\"创建WebSocket实例\"><a href=\"#创建WebSocket实例\" class=\"headerlink\" title=\"创建WebSocket实例\"></a>创建WebSocket实例</h4><p>要创建WebSocket，先实例一个WebSocket对象并传入要连接的URL：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&apos;http://localhost:8000&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>执行上面语句后，浏览器会马上尝试创建连接，与XHR类似，WebSocket也有一个表示当前状态的readyState属性。不过，这个属性的值与XHR不相同， socket.readyState值如下：</p>\n<p>0：正在建立连接， WebSocket.OPENING<br>1：已经建立连接， WebSocket.OPEN<br>2：正在关闭连接， WebSocket.CLOSING<br>3：已经关闭连接， WebSocket.CLOSE<br>WebSocket没有readystatechange事件，不过，有其他事件对应着不同的状态，readyState的值永远从0开始。<br>示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&apos;ws://localhost:8000&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  //正在建立连接</span><br><span class=\"line\">  console.log(&quot;[readyState]-&quot; + socket.readyState); //0</span><br><span class=\"line\"></span><br><span class=\"line\">  //连接建立成功回调</span><br><span class=\"line\">  socket.onopen = function() &#123;</span><br><span class=\"line\">    console.log(&apos;Connection established.&apos;)</span><br><span class=\"line\">    console.log(&quot;[readyState]-&quot; + socket.readyState); //1</span><br><span class=\"line\">    //发送消息</span><br><span class=\"line\">    // socket.send(&apos;hello world&apos;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  //连接失败回调</span><br><span class=\"line\">  socket.onerror = function() &#123;</span><br><span class=\"line\">    console.log(&quot;[readyState]-&quot; + socket.readyState);//3</span><br><span class=\"line\">    console.log(&apos;Connection error.&apos;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  //连接关闭回调</span><br><span class=\"line\">  socket.onclose = function(event) &#123;</span><br><span class=\"line\">    var code = event.code;</span><br><span class=\"line\">    var reason = event.reason;</span><br><span class=\"line\">    var wasClean = event.wasClean;</span><br><span class=\"line\">    console.log(&quot;[readyState]-&quot; + socket.readyState);//3</span><br><span class=\"line\">    console.log(&apos;Connection closed.&apos;)</span><br><span class=\"line\">    console.log(code, reason, wasClean)</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>要关闭WebSocket连接，可以在任何时候调用close方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.close();</span><br></pre></td></tr></table></figure></p>\n<p>调用了close()之后，readyState的值立即变为2（正在关闭），关闭连接后就会变成3。</p>\n<h4 id=\"发送和接收数据\"><a href=\"#发送和接收数据\" class=\"headerlink\" title=\"发送和接收数据\"></a>发送和接收数据</h4><p>WebSocket连接建立之后，可以通过连接发送和接收数据。<br>使用send()方法像服务器发送数据，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&apos;ws://localhost:8000&apos;);</span><br><span class=\"line\">socket.send(&apos;hello world&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>当服务器向客户端发来消息时，WebSocket对象会触发message事件。这个message事件与其他传递消息的协议类似，也是把返回的数据保存在event.data属性中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> socket.onmessage = function(event) &#123;</span><br><span class=\"line\">  var data = event.data;</span><br><span class=\"line\">  //处理数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"其他事件\"><a href=\"#其他事件\" class=\"headerlink\" title=\"其他事件\"></a>其他事件</h4><p>WebSocket对象还有其他三个事件，在连接生命周期的不同阶段触发。</p>\n<p>open：成功建立连接时触发。<br>error：发生错误时触发，连接断开。<br>close: 连接关闭时触发。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = new WebSocket(&apos;ws://localhost:8000&apos;);</span><br><span class=\"line\">socket.onopen = function() &#123;</span><br><span class=\"line\">  console.log(&apos;Connection established.&apos;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">socket.onerror = function() &#123;</span><br><span class=\"line\">  console.log(&apos;Connection error.&apos;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">socket.onclose = function(event) &#123;</span><br><span class=\"line\">  var code = event.code;</span><br><span class=\"line\">  var reason = event.reason;</span><br><span class=\"line\">  var wasClean = event.wasClean;</span><br><span class=\"line\">  console.log(&apos;Connection closed.&apos;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这三个事件中，只有close事件的event对象有额外信息，这个事件的事件对象有三个额外的属性：wasClean、code和reason。<br>其中wasClean是一个布尔值，表示连接是否已经明确的关闭；<br>code是服务器返回的数值状态码；<br>reason是一个字符串，包含服务器发回的信息。</p>\n<h1 id=\"三、WebSocket心跳及重连机制\"><a href=\"#三、WebSocket心跳及重连机制\" class=\"headerlink\" title=\"三、WebSocket心跳及重连机制\"></a>三、WebSocket心跳及重连机制</h1><p>在使用websocket的过程中，有时候会遇到网络断开的情况，但是在网络断开的时候服务器端并没有触发onclose的事件。这样会有：服务器会继续向客户端发送多余的链接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的链接状态。因此就有了websocket的心跳了。还有心跳，说明还活着，没有心跳说明已经挂掉了。</p>\n<ol>\n<li><p>为什么叫心跳包呢？<br>它就像心跳一样每隔固定的时间发一次，来告诉服务器，我还活着。</p>\n</li>\n<li><p>心跳机制是？<br>心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了。需要重连~</p>\n</li>\n</ol>\n<p>那么需要怎么去实现它呢？如下所有代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;WebSocket Demo&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    // var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    ws.onerror = function(e) &#123;</span><br><span class=\"line\">      console.log(&apos;已关闭&apos;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ws.onopen = function(e) &#123;</span><br><span class=\"line\">      console.log(&apos;握手成功&apos;);</span><br><span class=\"line\">      ws.send(&apos;123456789&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ws.onclose = function() &#123;</span><br><span class=\"line\">      console.log(&apos;已关闭&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ws.onmessage = function(e) &#123;</span><br><span class=\"line\">      console.log(&apos;收到消息&apos;);</span><br><span class=\"line\">      console.log(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    */</span><br><span class=\"line\">    </span><br><span class=\"line\">    var lockReconnect = false;//避免重复连接</span><br><span class=\"line\">    var wsUrl = &quot;wss://echo.websocket.org&quot;;</span><br><span class=\"line\">    var ws;</span><br><span class=\"line\">    var tt;</span><br><span class=\"line\">    function createWebSocket() &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        ws = new WebSocket(wsUrl);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">      &#125; catch(e) &#123;</span><br><span class=\"line\">        console.log(&apos;catch&apos;);</span><br><span class=\"line\">        reconnect(wsUrl);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function init() &#123;</span><br><span class=\"line\">      ws.onclose = function () &#123;</span><br><span class=\"line\">        console.log(&apos;链接关闭&apos;);</span><br><span class=\"line\">        reconnect(wsUrl);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      ws.onerror = function() &#123;</span><br><span class=\"line\">        console.log(&apos;发生异常了&apos;);</span><br><span class=\"line\">        reconnect(wsUrl);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      ws.onopen = function () &#123;</span><br><span class=\"line\">        //心跳检测重置</span><br><span class=\"line\">        heartCheck.start();</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      ws.onmessage = function (event) &#123;</span><br><span class=\"line\">        //拿到任何消息都说明当前连接是正常的</span><br><span class=\"line\">        console.log(&apos;接收到消息&apos;);</span><br><span class=\"line\">        heartCheck.start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function reconnect(url) &#123;</span><br><span class=\"line\">      if(lockReconnect) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      lockReconnect = true;</span><br><span class=\"line\">      //没连接上会一直重连，设置延迟避免请求过多</span><br><span class=\"line\">      tt &amp;&amp; clearTimeout(tt);</span><br><span class=\"line\">      tt = setTimeout(function () &#123;</span><br><span class=\"line\">        createWebSocket(url);</span><br><span class=\"line\">        lockReconnect = false;</span><br><span class=\"line\">      &#125;, 4000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //心跳检测</span><br><span class=\"line\">    var heartCheck = &#123;</span><br><span class=\"line\">      timeout: 3000,</span><br><span class=\"line\">      timeoutObj: null,</span><br><span class=\"line\">      serverTimeoutObj: null,</span><br><span class=\"line\">      start: function()&#123;</span><br><span class=\"line\">        console.log(&apos;start&apos;);</span><br><span class=\"line\">        var self = this;</span><br><span class=\"line\">        this.timeoutObj &amp;&amp; clearTimeout(this.timeoutObj);</span><br><span class=\"line\">        this.serverTimeoutObj &amp;&amp; clearTimeout(this.serverTimeoutObj);</span><br><span class=\"line\">        this.timeoutObj = setTimeout(function()&#123;</span><br><span class=\"line\">          //这里发送一个心跳，后端收到后，返回一个心跳消息，</span><br><span class=\"line\">          console.log(&apos;55555&apos;);</span><br><span class=\"line\">          ws.send(&quot;123456789&quot;);</span><br><span class=\"line\">          self.serverTimeoutObj = setTimeout(function() &#123;</span><br><span class=\"line\">            console.log(111);</span><br><span class=\"line\">            console.log(ws);</span><br><span class=\"line\">            ws.close();</span><br><span class=\"line\">            // createWebSocket();</span><br><span class=\"line\">          &#125;, self.timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;, this.timeout)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    createWebSocket(wsUrl);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>具体的思路如下：</p>\n<ol>\n<li><p>第一步页面初始化，先调用createWebSocket函数，目的是创建一个websocket的方法：new WebSocket(wsUrl);因此封装成函数内如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createWebSocket() &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    ws = new WebSocket(wsUrl);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">  &#125; catch(e) &#123;</span><br><span class=\"line\">    console.log(&apos;catch&apos;);</span><br><span class=\"line\">    reconnect(wsUrl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二步调用init方法，该方法内把一些监听事件封装如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">  ws.onclose = function () &#123;</span><br><span class=\"line\">    console.log(&apos;链接关闭&apos;);</span><br><span class=\"line\">    reconnect(wsUrl);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  ws.onerror = function() &#123;</span><br><span class=\"line\">    console.log(&apos;发生异常了&apos;);</span><br><span class=\"line\">    reconnect(wsUrl);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  ws.onopen = function () &#123;</span><br><span class=\"line\">    //心跳检测重置</span><br><span class=\"line\">    heartCheck.start();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  ws.onmessage = function (event) &#123;</span><br><span class=\"line\">    //拿到任何消息都说明当前连接是正常的</span><br><span class=\"line\">    console.log(&apos;接收到消息&apos;);</span><br><span class=\"line\">    heartCheck.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如上第二步，当网络断开的时候，会先调用onerror，onclose事件可以监听到，会调用reconnect方法进行重连操作。正常的情况下，是先调用<br>onopen方法的，当接收到数据时，会被onmessage事件监听到。</p>\n</li>\n<li><p>重连操作 reconnect代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lockReconnect = false;//避免重复连接</span><br><span class=\"line\">function reconnect(url) &#123;</span><br><span class=\"line\">  if(lockReconnect) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  lockReconnect = true;</span><br><span class=\"line\">  //没连接上会一直重连，设置延迟避免请求过多</span><br><span class=\"line\">  tt &amp;&amp; clearTimeout(tt);</span><br><span class=\"line\">  tt = setTimeout(function () &#123;</span><br><span class=\"line\">    createWebSocket(url);</span><br><span class=\"line\">    lockReconnect = false;</span><br><span class=\"line\">  &#125;, 4000);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如上代码，如果网络断开的话，会执行reconnect方法，使用了一个定时器，4秒后会重新创建一个新的websocket链接，重新调用createWebSocket函数，<br>重新会执行及发送数据给服务器端。</p>\n<ol start=\"5\">\n<li>最后一步就是实现心跳检测的代码：如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//心跳检测</span><br><span class=\"line\">var heartCheck = &#123;</span><br><span class=\"line\">  timeout: 3000,</span><br><span class=\"line\">  timeoutObj: null,</span><br><span class=\"line\">  serverTimeoutObj: null,</span><br><span class=\"line\">  start: function()&#123;</span><br><span class=\"line\">    console.log(&apos;start&apos;);</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    this.timeoutObj &amp;&amp; clearTimeout(this.timeoutObj);</span><br><span class=\"line\">    this.serverTimeoutObj &amp;&amp; clearTimeout(this.serverTimeoutObj);</span><br><span class=\"line\">    this.timeoutObj = setTimeout(function()&#123;</span><br><span class=\"line\">      //这里发送一个心跳，后端收到后，返回一个心跳消息，</span><br><span class=\"line\">      //onmessage拿到返回的心跳就说明连接正常</span><br><span class=\"line\">      console.log(&apos;55555&apos;);</span><br><span class=\"line\">      ws.send(&quot;123456789&quot;);</span><br><span class=\"line\">      self.serverTimeoutObj = setTimeout(function() &#123;</span><br><span class=\"line\">        console.log(111);</span><br><span class=\"line\">        console.log(ws);</span><br><span class=\"line\">        ws.close();</span><br><span class=\"line\">        // createWebSocket();</span><br><span class=\"line\">      &#125;, self.timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;, this.timeout)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>实现心跳检测的思路是：每隔一段固定的时间，向服务器端发送一个ping数据，如果在正常的情况下，服务器会返回一个pong给客户端，如果客户端通过onmessage事件能监听到的话，说明请求正常，这里我们使用了一个定时器，每隔3秒的情况下，如果是网络断开的情况下，在指定的时间内服务器端并没有返回心跳响应消息，因此服务器端断开了，因此这个时候我们使用ws.close关闭连接，在一段时间后(在不同的浏览器下，时间是不一样的，firefox响应更快)，可以通过 onclose事件监听到。因此在onclose事件内，我们可以调用 reconnect事件进行重连操作。</p>\n<h1 id=\"四、WebSocket-实例\"><a href=\"#四、WebSocket-实例\" class=\"headerlink\" title=\"四、WebSocket 实例\"></a>四、WebSocket 实例</h1><p>前面已经学习了WebSocket API，包括事件、方法和属性。WebSocket是基于事件驱动，支持全双工通信。下面通过二个简单例子体验一下。</p>\n<h4 id=\"简单在线聊天\"><a href=\"#简单在线聊天\" class=\"headerlink\" title=\"简单在线聊天\"></a>简单在线聊天</h4><p>1、通过nodejs在项目里面新建一个server.js，创建服务，指定8181端口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var http = require(&apos;http&apos;);</span><br><span class=\"line\">var WebSocket = require(&apos;ws&apos;);</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\">app.use(express.static(__dirname));</span><br><span class=\"line\">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class=\"line\">\tres.send(&apos;&lt;h1&gt;Welcome Realtime Server&lt;/h1&gt;&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">var server = http.createServer(app);</span><br><span class=\"line\">var wss = new WebSocket.Server(&#123;server&#125;);</span><br><span class=\"line\">wss.on(&apos;connection&apos;, function connection(ws) &#123;</span><br><span class=\"line\">    console.log(&apos;链接成功！&apos;);</span><br><span class=\"line\">    ws.on(&apos;message&apos;, function incoming(data) &#123;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 把消息发送到所有的客户端</span><br><span class=\"line\">         * wss.clients获取所有链接的客户端</span><br><span class=\"line\">         */</span><br><span class=\"line\">        wss.clients.forEach(function each(client) &#123;</span><br><span class=\"line\">            client.send(data);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8181, function listening() &#123;</span><br><span class=\"line\">    console.log(&apos;服务器启动成功！&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>在浏览器里输入<a href=\"http://localhost:8181/测试服务是否启动成功。\" target=\"_blank\" rel=\"noopener\">http://localhost:8181/测试服务是否启动成功。</a></p>\n<p>2、创建客户端。为了能在多台设备上测试，可以本地在启一个服务来跑客户端代码。<br>通node启一个8282端口的本机服务<br>app.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var http = require(&apos;http&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var app = express();</span><br><span class=\"line\">app.use(express.static(__dirname));</span><br><span class=\"line\">var server = http.createServer(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class=\"line\">\tres.send(&apos;&lt;h1&gt;Welcome client&lt;/h1&gt;&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8282, function listening() &#123;</span><br><span class=\"line\">    console.log(&apos;ok！&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>3、创建index.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;websocket chat&lt;/h1&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;input id=&quot;name&quot; size=&quot;15&quot; type=&quot;text&quot; placeholder=&quot;姓名&quot; value=&quot;&quot;&gt;</span><br><span class=\"line\">        &lt;input id=&quot;message&quot; size=&quot;50&quot; type=&quot;text&quot; placeholder=&quot;内容&quot; value=&quot;&quot;&gt;</span><br><span class=\"line\">        &lt;input id=&quot;btn_post&quot; type=&quot;button&quot; value=&quot;post&quot;&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;ul id=&quot;chat&quot;&gt;&lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script src=&quot;http://cdn.bootcss.com/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>可以输入姓名和内容，然后有一个提交按钮来发送数据给服务器。</p>\n<p>4、创建websocket链接<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = new WebSocket(&quot;ws://localhost:8181&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>要在多台服务测试需要把localhost改成IP<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = new WebSocket(&quot;ws://10.254.124.8:8181&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>5、点击提交按钮或回车向服务器发送信息，使用 ws.send 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(function()&#123;</span><br><span class=\"line\">  $(&quot;#btn_post&quot;).click(post);</span><br><span class=\"line\">  $(&quot;#message&quot;).keydown(function(e)&#123;</span><br><span class=\"line\">    if(e.keyCode == 13) post();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">var post = function()&#123;</span><br><span class=\"line\">  var name = $(&quot;#name&quot;).val();</span><br><span class=\"line\">  var mes = $(&quot;#message&quot;).val();</span><br><span class=\"line\">  ws.send(name+&quot; : &quot;+mes);</span><br><span class=\"line\">  $(&quot;input#message&quot;).val(&quot;&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>6、服务器接收到信息后返回给客户端，使用 ws.onmessage 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ws.onmessage = function(e)&#123;</span><br><span class=\"line\">  print(e.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var print = function(msg)&#123;</span><br><span class=\"line\">  $(&quot;#chat&quot;).prepend($(&quot;&lt;li&gt;&quot;).text(msg));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>浏览器里输入 <a href=\"http://10.254.124.8:8282/index.html\" target=\"_blank\" rel=\"noopener\">http://10.254.124.8:8282/index.html</a> 可以看到预览效果<br><img src=\"https://img.fengjr.com/image/2019/11/27/a36c14d25b7ef14a1787320e29a09266.png\" alt></p>\n<h4 id=\"模拟股票实例\"><a href=\"#模拟股票实例\" class=\"headerlink\" title=\"模拟股票实例\"></a>模拟股票实例</h4><p>上面的例子很简单，只是为了演示如何运用nodejs的ws创建一个WebSocket服务器。且可以接受客户端的消息。那么下面这个例子演示股票的实时更新。客服端只需要连接一次，服务器端会不断地发送新数据，客户端收数据后更新UI.页面如下，有五只股票，开始和停止按钮测试连接和关闭。</p>\n<p><img src=\"https://img.fengjr.com/image/2019/11/27/83b293b5e353e2d9bdf080e7cf7cbb82.png\" alt></p>\n<p>服务端：<br>1.模拟五只股票的涨跌。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stocks = &#123;</span><br><span class=\"line\">    &quot;AAPL&quot;: 95.0,</span><br><span class=\"line\">    &quot;MSFT&quot;: 50.0,</span><br><span class=\"line\">    &quot;AMZN&quot;: 300.0,</span><br><span class=\"line\">    &quot;GOOG&quot;: 550.0,</span><br><span class=\"line\">    &quot;YHOO&quot;: 35.0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function randomInterval(min, max) &#123;</span><br><span class=\"line\">    return Math.floor(Math.random() * (max - min + 1) + min);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var stockUpdater;</span><br><span class=\"line\">var randomStockUpdater = function() &#123;</span><br><span class=\"line\">    for (var symbol in stocks) &#123;</span><br><span class=\"line\">        if(stocks.hasOwnProperty(symbol)) &#123;</span><br><span class=\"line\">            var randomizedChange = randomInterval(-150, 150);</span><br><span class=\"line\">            var floatChange = randomizedChange / 100;</span><br><span class=\"line\">            stocks[symbol] += floatChange;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var randomMSTime = randomInterval(500, 2500);</span><br><span class=\"line\">    stockUpdater = setTimeout(function() &#123;</span><br><span class=\"line\">        randomStockUpdater();</span><br><span class=\"line\">    &#125;, randomMSTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">randomStockUpdater();</span><br></pre></td></tr></table></figure></p>\n<p>2.连接建立之后就开始更新数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wss.on(&apos;connection&apos;, function (ws) &#123;</span><br><span class=\"line\">  var sendStockUpdates = function (ws) &#123;</span><br><span class=\"line\">      if (ws.readyState == 1) &#123;</span><br><span class=\"line\">          var stocksObj = &#123;&#125;;</span><br><span class=\"line\">          for (var i = 0; i &lt; clientStocks.length; i++) &#123;</span><br><span class=\"line\">            var symbol = clientStocks[i];</span><br><span class=\"line\">              stocksObj[symbol] = stocks[symbol];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (stocksObj.length !== 0) &#123;</span><br><span class=\"line\">              ws.send(JSON.stringify(stocksObj));//需要将对象转成字符串。WebSocket只支持文本和二进制数据</span><br><span class=\"line\">              console.log(&quot;更新&quot;, JSON.stringify(stocksObj));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var clientStockUpdater = setInterval(function () &#123;</span><br><span class=\"line\">      sendStockUpdates(ws);</span><br><span class=\"line\">  &#125;, 1000);</span><br><span class=\"line\">  ws.on(&apos;message&apos;, function (message) &#123;</span><br><span class=\"line\">      var stockRequest = JSON.parse(message);//根据请求过来的数据来更新。</span><br><span class=\"line\">      console.log(&quot;收到消息&quot;, stockRequest);</span><br><span class=\"line\">      clientStocks = stockRequest[&apos;stocks&apos;];</span><br><span class=\"line\">      sendStockUpdates(ws);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>客户端：<br>建立连接：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = new WebSocket(&quot;ws://localhost:8181&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>onopen直接只有在连接成功后才会触发，在这个时候将客户端需要请求的股票发送给服务端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isClose = false;</span><br><span class=\"line\">  var stocks = &#123;</span><br><span class=\"line\">      &quot;AAPL&quot;: 0, &quot;MSFT&quot;: 0, &quot;AMZN&quot;: 0, &quot;GOOG&quot;: 0, &quot;YHOO&quot;: 0</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  function updataUI() &#123;</span><br><span class=\"line\">      ws.onopen = function (e) &#123;</span><br><span class=\"line\">          console.log(&apos;Connection to server opened&apos;);</span><br><span class=\"line\">          isClose = false;</span><br><span class=\"line\">          ws.send(JSON.stringify(stock_request));</span><br><span class=\"line\">          console.log(&quot;sened a mesg&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      //更新UI</span><br><span class=\"line\">      var changeStockEntry = function (symbol, originalValue, newValue) &#123;</span><br><span class=\"line\">          var valElem = $(&apos;#&apos; + symbol + &apos; span&apos;);</span><br><span class=\"line\">          valElem.html(newValue.toFixed(2));</span><br><span class=\"line\">          if (newValue &lt; originalValue) &#123;</span><br><span class=\"line\">              valElem.addClass(&apos;label-danger&apos;);</span><br><span class=\"line\">              valElem.removeClass(&apos;label-success&apos;);</span><br><span class=\"line\">          &#125; else if (newValue &gt; originalValue) &#123;</span><br><span class=\"line\">              valElem.addClass(&apos;label-success&apos;);</span><br><span class=\"line\">              valElem.removeClass(&apos;label-danger&apos;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 处理受到的消息</span><br><span class=\"line\">      ws.onmessage = function (e) &#123;</span><br><span class=\"line\">          var stocksData = JSON.parse(e.data);</span><br><span class=\"line\">          console.log(stocksData);</span><br><span class=\"line\">          for (var symbol in stocksData) &#123;</span><br><span class=\"line\">              if (stocksData.hasOwnProperty(symbol)) &#123;</span><br><span class=\"line\">                  changeStockEntry(symbol, stocks[symbol], stocksData[symbol]);</span><br><span class=\"line\">                  stocks[symbol] = stocksData[symbol];</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  updataUI();</span><br></pre></td></tr></table></figure></p>\n<p>运行可以看到效果，只需要请求一次，数据就会不断的更新，效果是不是很赞，不用轮询，也不用长连接那么麻烦了。</p>\n<h1 id=\"五、socket-io\"><a href=\"#五、socket-io\" class=\"headerlink\" title=\"五、socket.io\"></a>五、socket.io</h1><p>socket.IO是一个websocket库，包括了客户端的js和服务器端的nodejs。官方地址：<a href=\"http://socket.io\" target=\"_blank\" rel=\"noopener\">http://socket.io</a></p>\n<h4 id=\"客户端使用socket-io\"><a href=\"#客户端使用socket-io\" class=\"headerlink\" title=\"客户端使用socket.io\"></a>客户端使用socket.io</h4><p>去github clone socket.io的最新版本，或者直接饮用使用socket.io的CDN服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://cdn.socket.io/stable/socket.io.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>下面可以创建使用socket.io库来创建客户端js代码了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socket = io.connect(&apos;http://localhost&apos;);</span><br><span class=\"line\">socket.on(&apos;news&apos;, function (data) &#123;</span><br><span class=\"line\">\tconsole.log(data);</span><br><span class=\"line\">\tsocket.emit(&apos;my other event&apos;, &#123; my: &apos;data&apos; &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>socket.on是监听，收到服务器端发来的news的内容，则运行function，其中data就是请求回来的数据，socket.emit是发送消息给服务器端的方法。</p>\n<h4 id=\"使用socket-io和nodejs搭建websocket服务器端\"><a href=\"#使用socket-io和nodejs搭建websocket服务器端\" class=\"headerlink\" title=\"使用socket.io和nodejs搭建websocket服务器端\"></a>使用socket.io和nodejs搭建websocket服务器端</h4><p>socket.io不仅可以搭建客户端的websocket服务，而且支持nodejs服务器端的websocket。</p>\n<p>nodejs安装socket.io<br>使用node插件管理包，运行下面的命令就可以安装成功socket.io<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install socket.io</span><br></pre></td></tr></table></figure></p>\n<p>没有npm的或者windows用户可以使用github下载socket.io并且放入到node_modules文件夹中。</p>\n<h4 id=\"nodejs建立socket-io服务\"><a href=\"#nodejs建立socket-io服务\" class=\"headerlink\" title=\"nodejs建立socket.io服务\"></a>nodejs建立socket.io服务</h4><p>通过nodejs的http模块就可以方便的搭建websocket服务器环境，例如下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 引入需要的模块：http和socket.io</span><br><span class=\"line\">var http = require(&apos;http&apos;), io = require(&apos;socket.io&apos;);</span><br><span class=\"line\">//创建server</span><br><span class=\"line\">var server = http.createServer(function(req, res)&#123; </span><br><span class=\"line\">  // Send HTML headers and message</span><br><span class=\"line\">  res.writeHead(200,&#123; &apos;Content-Type&apos;: &apos;text/html&apos; &#125;); </span><br><span class=\"line\">  res.end(&apos;&lt;h1&gt;Hello Socket Lover!&lt;/h1&gt;&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//端口8000</span><br><span class=\"line\">server.listen(8080);</span><br><span class=\"line\">//创建socket</span><br><span class=\"line\">var socket = io.listen(server);</span><br><span class=\"line\">//添加连接监听</span><br><span class=\"line\">socket.on(&apos;connection&apos;, function(client)&#123;   </span><br><span class=\"line\">\t//连接成功则执行下面的监听</span><br><span class=\"line\">\tclient.on(&apos;message&apos;,function(event)&#123; </span><br><span class=\"line\">\t\tconsole.log(&apos;Received message from client!&apos;,event);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t//断开连接callback</span><br><span class=\"line\">\tclient.on(&apos;disconnect&apos;,function()&#123;</span><br><span class=\"line\">\t\tconsole.log(&apos;Server has disconnected&apos;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>保存为socket.js然后在命令行执行：node socket.js 即可启动服务器，现在访问localhost:8000就可以了。</p>\n<p>目标：Socket.IO旨在让各种浏览器与移动设备上实现实时app功能，模糊化各种传输机制。</p>\n<p>缺点：socket.io 在高并发的情况下，稳定性与可靠性其实是不高的。特别是其websocket的实现，websocket本身就存在很多局限，对服务端，客户端的要求都比较高，要使其稳定的运行，还是有蛮多的工作要做的。 另外，socket.io 的作者又开发了另一个类似的实现：<a href=\"https://github.com/socketio/engine.io\" target=\"_blank\" rel=\"noopener\">engine.io</a> 应该是就socket.io的一些不足作了改进。</p>\n<h4 id=\"socket-io搭建多人聊天室实例\"><a href=\"#socket-io搭建多人聊天室实例\" class=\"headerlink\" title=\"socket.io搭建多人聊天室实例\"></a>socket.io搭建多人聊天室实例</h4><p>需求分析<br>1、兼容不支持WebSocket的低版本浏览器。<br>2、允许客户端有相同的用户名。<br>3、进入聊天室后可以看到当前在线的用户和在线人数。<br>4、用户上线或退出，所有在线的客户端应该实时更新。<br>5、用户发送消息，所有客户端实时收取。</p>\n<p>有了前面的搭建基础，就不多啰嗦了，直接上代码：</p>\n<p>index.html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt;</span><br><span class=\"line\">        &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;/&gt;</span><br><span class=\"line\">&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;多人聊天室&lt;/title&gt;</span><br><span class=\"line\">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot; /&gt;</span><br><span class=\"line\">        &lt;!--[if lt IE 8]&gt;&lt;script src=&quot;./json3.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;</span><br><span class=\"line\">        &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.dev.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;div id=&quot;loginbox&quot;&gt;</span><br><span class=\"line\">            &lt;div style=&quot;width:260px;margin:200px auto;&quot;&gt;</span><br><span class=\"line\">                请先输入你在聊天室的昵称</span><br><span class=\"line\">                &lt;br/&gt;</span><br><span class=\"line\">                &lt;br/&gt;</span><br><span class=\"line\">                &lt;input type=&quot;text&quot; style=&quot;width:180px;&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;input type=&quot;button&quot; style=&quot;width:50px;&quot; value=&quot;提交&quot; onclick=&quot;CHAT.usernameSubmit();&quot;/&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div id=&quot;chatbox&quot; style=&quot;display:none;&quot;&gt;</span><br><span class=\"line\">            &lt;div style=&quot;background:#3d3d3d;height: 28px; width: 100%;font-size:12px;&quot;&gt;</span><br><span class=\"line\">                &lt;div style=&quot;line-height: 28px;color:#fff;&quot;&gt;</span><br><span class=\"line\">                    &lt;span style=&quot;text-align:left;margin-left:10px;&quot;&gt;Websocket多人聊天室&lt;/span&gt;</span><br><span class=\"line\">                    &lt;span style=&quot;float:right; margin-right:10px;&quot;&gt;&lt;span id=&quot;showusername&quot;&gt;&lt;/span&gt; | </span><br><span class=\"line\">\t\t\t\t\t&lt;a href=&quot;javascript:;&quot; onclick=&quot;CHAT.logout()&quot; style=&quot;color:#fff;&quot;&gt;退出&lt;/a&gt;&lt;/span&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">            &lt;div id=&quot;doc&quot;&gt;</span><br><span class=\"line\">                &lt;div id=&quot;chat&quot;&gt;</span><br><span class=\"line\">                    &lt;div id=&quot;message&quot; class=&quot;message&quot;&gt;</span><br><span class=\"line\">&lt;div id=&quot;onlinecount&quot; style=&quot;background:#EFEFF4; font-size:12px; margin-top:10px; margin-left:10px; color:#666;&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                    &lt;div class=&quot;input-box&quot;&gt;</span><br><span class=\"line\">                        &lt;div class=&quot;input&quot;&gt;</span><br><span class=\"line\">&lt;input type=&quot;text&quot; maxlength=&quot;140&quot; placeholder=&quot;请输入聊天内容，按Enter提交&quot; id=&quot;content&quot; name=&quot;content&quot;&gt;</span><br><span class=\"line\">                        &lt;/div&gt;</span><br><span class=\"line\">                        &lt;div class=&quot;action&quot;&gt;</span><br><span class=\"line\">                            &lt;button type=&quot;button&quot; id=&quot;mjr_send&quot; onclick=&quot;CHAT.submit();&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">                        &lt;/div&gt;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &lt;/div&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;script type=&quot;text/javascript&quot; src=&quot;./client.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>client.js 客户端代码，里面有详细注释，很清晰。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function () &#123;</span><br><span class=\"line\">\tvar d = document,</span><br><span class=\"line\">\tw = window,</span><br><span class=\"line\">\tp = parseInt,</span><br><span class=\"line\">\tdd = d.documentElement,</span><br><span class=\"line\">\tdb = d.body,</span><br><span class=\"line\">\tdc = d.compatMode == &apos;CSS1Compat&apos;,</span><br><span class=\"line\">\tdx = dc ? dd: db,</span><br><span class=\"line\">\tec = encodeURIComponent;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tw.CHAT = &#123;</span><br><span class=\"line\">\t\tmsgObj:d.getElementById(&quot;message&quot;),</span><br><span class=\"line\">\t\tscreenheight:w.innerHeight ? w.innerHeight : dx.clientHeight,</span><br><span class=\"line\">\t\tusername:null,</span><br><span class=\"line\">\t\tuserid:null,</span><br><span class=\"line\">\t\tsocket:null,</span><br><span class=\"line\">\t\t//让浏览器滚动条保持在最低部</span><br><span class=\"line\">\t\tscrollToBottom:function()&#123;</span><br><span class=\"line\">\t\t\tw.scrollTo(0, this.msgObj.clientHeight);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t//退出，本例只是一个简单的刷新</span><br><span class=\"line\">\t\tlogout:function()&#123;</span><br><span class=\"line\">\t\t\t//this.socket.disconnect();</span><br><span class=\"line\">\t\t\tlocation.reload();</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t//提交聊天消息内容</span><br><span class=\"line\">\t\tsubmit:function()&#123;</span><br><span class=\"line\">\t\t\tvar content = d.getElementById(&quot;content&quot;).value;</span><br><span class=\"line\">\t\t\tif(content != &apos;&apos;)&#123;</span><br><span class=\"line\">\t\t\t\tvar obj = &#123;</span><br><span class=\"line\">\t\t\t\t\tuserid: this.userid,</span><br><span class=\"line\">\t\t\t\t\tusername: this.username,</span><br><span class=\"line\">\t\t\t\t\tcontent: content</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t\tthis.socket.emit(&apos;message&apos;, obj);</span><br><span class=\"line\">\t\t\t\td.getElementById(&quot;content&quot;).value = &apos;&apos;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tgenUid:function()&#123;</span><br><span class=\"line\">\t\t\treturn new Date().getTime()+&quot;&quot;+Math.floor(Math.random()*899+100);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t//更新系统消息，本例中在用户加入、退出的时候调用</span><br><span class=\"line\">\t\tupdateSysMsg:function(o, action)&#123;</span><br><span class=\"line\">\t\t\t//当前在线用户列表</span><br><span class=\"line\">\t\t\tvar onlineUsers = o.onlineUsers;</span><br><span class=\"line\">\t\t\t//当前在线人数</span><br><span class=\"line\">\t\t\tvar onlineCount = o.onlineCount;</span><br><span class=\"line\">\t\t\t//新加入用户的信息</span><br><span class=\"line\">\t\t\tvar user = o.user;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t//更新在线人数</span><br><span class=\"line\">\t\t\tvar userhtml = &apos;&apos;;</span><br><span class=\"line\">\t\t\tvar separator = &apos;&apos;;</span><br><span class=\"line\">\t\t\tfor(key in onlineUsers) &#123;</span><br><span class=\"line\">\t\t        if(onlineUsers.hasOwnProperty(key))&#123;</span><br><span class=\"line\">\t\t\t\t\tuserhtml += separator+onlineUsers[key];</span><br><span class=\"line\">\t\t\t\t\tseparator = &apos;、&apos;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t\td.getElementById(&quot;onlinecount&quot;).innerHTML = &apos;当前共有 &apos;+onlineCount+&apos; 人在线，在线列表：&apos;+userhtml;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//添加系统消息</span><br><span class=\"line\">\t\t\tvar html = &apos;&apos;;</span><br><span class=\"line\">\t\t\thtml += &apos;&lt;div class=&quot;msg-system&quot;&gt;&apos;;</span><br><span class=\"line\">\t\t\thtml += user.username;</span><br><span class=\"line\">\t\t\thtml += (action == &apos;login&apos;) ? &apos; 加入了聊天室&apos; : &apos; 退出了聊天室&apos;;</span><br><span class=\"line\">\t\t\thtml += &apos;&lt;/div&gt;&apos;;</span><br><span class=\"line\">\t\t\tvar section = d.createElement(&apos;section&apos;);</span><br><span class=\"line\">\t\t\tsection.className = &apos;system J-mjrlinkWrap J-cutMsg&apos;;</span><br><span class=\"line\">\t\t\tsection.innerHTML = html;</span><br><span class=\"line\">\t\t\tthis.msgObj.appendChild(section);\t</span><br><span class=\"line\">\t\t\tthis.scrollToBottom();</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t//第一个界面用户提交用户名</span><br><span class=\"line\">\t\tusernameSubmit:function()&#123;</span><br><span class=\"line\">\t\t\tvar username = d.getElementById(&quot;username&quot;).value;</span><br><span class=\"line\">\t\t\tif(username != &quot;&quot;)&#123;</span><br><span class=\"line\">\t\t\t\td.getElementById(&quot;username&quot;).value = &apos;&apos;;</span><br><span class=\"line\">\t\t\t\td.getElementById(&quot;loginbox&quot;).style.display = &apos;none&apos;;</span><br><span class=\"line\">\t\t\t\td.getElementById(&quot;chatbox&quot;).style.display = &apos;block&apos;;</span><br><span class=\"line\">\t\t\t\tthis.init(username);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tinit:function(username)&#123;</span><br><span class=\"line\">\t\t\t/*</span><br><span class=\"line\">\t\t\t客户端根据时间和随机数生成uid,这样使得聊天室用户名称可以重复。</span><br><span class=\"line\">\t\t\t实际项目中，如果是需要用户登录，那么直接采用用户的uid来做标识就可以</span><br><span class=\"line\">\t\t\t*/</span><br><span class=\"line\">\t\t\tthis.userid = this.genUid();</span><br><span class=\"line\">\t\t\tthis.username = username;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\td.getElementById(&quot;showusername&quot;).innerHTML = this.username;</span><br><span class=\"line\">\t\t\t//this.msgObj.style.minHeight = (this.screenheight - db.clientHeight + this.msgObj.clientHeight) + &quot;px&quot;;</span><br><span class=\"line\">\t\t\tthis.scrollToBottom();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//连接websocket后端服务器</span><br><span class=\"line\">\t\t\tthis.socket = io.connect(&apos;ws://10.254.124.8:8383&apos;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//告诉服务器端有用户登录</span><br><span class=\"line\">\t\t\tthis.socket.emit(&apos;login&apos;, &#123;userid:this.userid, username:this.username&#125;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//监听新用户登录</span><br><span class=\"line\">\t\t\tthis.socket.on(&apos;login&apos;, function(o)&#123;</span><br><span class=\"line\">\t\t\t\tCHAT.updateSysMsg(o, &apos;login&apos;);\t</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//监听用户退出</span><br><span class=\"line\">\t\t\tthis.socket.on(&apos;logout&apos;, function(o)&#123;</span><br><span class=\"line\">\t\t\t\tCHAT.updateSysMsg(o, &apos;logout&apos;);</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//监听消息发送</span><br><span class=\"line\">\t\t\tthis.socket.on(&apos;message&apos;, function(obj)&#123;</span><br><span class=\"line\">\t\t\t\tvar isme = (obj.userid == CHAT.userid) ? true : false;</span><br><span class=\"line\">\t\t\t\tvar contentDiv = &apos;&lt;div&gt;&apos;+obj.content+&apos;&lt;/div&gt;&apos;;</span><br><span class=\"line\">\t\t\t\tvar usernameDiv = &apos;&lt;span&gt;&apos;+obj.username+&apos;&lt;/span&gt;&apos;;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\tvar section = d.createElement(&apos;section&apos;);</span><br><span class=\"line\">\t\t\t\tif(isme)&#123;</span><br><span class=\"line\">\t\t\t\t\tsection.className = &apos;user&apos;;</span><br><span class=\"line\">\t\t\t\t\tsection.innerHTML = contentDiv + usernameDiv;</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tsection.className = &apos;service&apos;;</span><br><span class=\"line\">\t\t\t\t\tsection.innerHTML = usernameDiv + contentDiv;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tCHAT.msgObj.appendChild(section);</span><br><span class=\"line\">\t\t\t\tCHAT.scrollToBottom();\t</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t//通过“回车”提交用户名</span><br><span class=\"line\">\td.getElementById(&quot;username&quot;).onkeydown = function(e) &#123;</span><br><span class=\"line\">\t\te = e || event;</span><br><span class=\"line\">\t\tif (e.keyCode === 13) &#123;</span><br><span class=\"line\">\t\t\tCHAT.usernameSubmit();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t//通过“回车”提交信息</span><br><span class=\"line\">\td.getElementById(&quot;content&quot;).onkeydown = function(e) &#123;</span><br><span class=\"line\">\t\te = e || event;</span><br><span class=\"line\">\t\tif (e.keyCode === 13) &#123;</span><br><span class=\"line\">\t\t\tCHAT.submit();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>server.js 服务端代码，同样代码里有详细注释。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = require(&apos;express&apos;)();</span><br><span class=\"line\">var http = require(&apos;http&apos;).Server(app);</span><br><span class=\"line\">var io = require(&apos;socket.io&apos;)(http);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class=\"line\">\tres.send(&apos;&lt;h1&gt;Welcome Realtime Server&lt;/h1&gt;&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//在线用户</span><br><span class=\"line\">var onlineUsers = &#123;&#125;;</span><br><span class=\"line\">//当前在线人数</span><br><span class=\"line\">var onlineCount = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(&apos;connection&apos;, function(socket)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;a user connected&apos;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//监听新用户加入</span><br><span class=\"line\">\tsocket.on(&apos;login&apos;, function(obj)&#123;</span><br><span class=\"line\">\t\t//将新加入用户的唯一标识当作socket的名称，后面退出的时候会用到</span><br><span class=\"line\">\t\tsocket.name = obj.userid;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//检查在线列表，如果不在里面就加入</span><br><span class=\"line\">\t\tif(!onlineUsers.hasOwnProperty(obj.userid)) &#123;</span><br><span class=\"line\">\t\t\tonlineUsers[obj.userid] = obj.username;</span><br><span class=\"line\">\t\t\t//在线人数+1</span><br><span class=\"line\">\t\t\tonlineCount++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//向所有客户端广播用户加入</span><br><span class=\"line\">\t\tio.emit(&apos;login&apos;, &#123;onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj&#125;);</span><br><span class=\"line\">\t\tconsole.log(obj.username+&apos;加入了聊天室&apos;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//监听用户退出</span><br><span class=\"line\">\tsocket.on(&apos;disconnect&apos;, function()&#123;</span><br><span class=\"line\">\t\t//将退出的用户从在线列表中删除</span><br><span class=\"line\">\t\tif(onlineUsers.hasOwnProperty(socket.name)) &#123;</span><br><span class=\"line\">\t\t\t//退出用户的信息</span><br><span class=\"line\">\t\t\tvar obj = &#123;userid:socket.name, username:onlineUsers[socket.name]&#125;;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//删除</span><br><span class=\"line\">\t\t\tdelete onlineUsers[socket.name];</span><br><span class=\"line\">\t\t\t//在线人数-1</span><br><span class=\"line\">\t\t\tonlineCount--;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//向所有客户端广播用户退出</span><br><span class=\"line\">\t\t\tio.emit(&apos;logout&apos;, &#123;onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj&#125;);</span><br><span class=\"line\">\t\t\tconsole.log(obj.username+&apos;退出了聊天室&apos;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//监听用户发布聊天内容</span><br><span class=\"line\">\tsocket.on(&apos;message&apos;, function(obj)&#123;</span><br><span class=\"line\">\t\t//向所有客户端广播发布的消息</span><br><span class=\"line\">\t\tio.emit(&apos;message&apos;, obj);</span><br><span class=\"line\">\t\tconsole.log(obj.username+&apos;说：&apos;+obj.content);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.listen(8383, function()&#123;</span><br><span class=\"line\">\tconsole.log(&apos;listening on *:8383&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>实现效果：<br><img src=\"https://img.fengjr.com/image/2019/11/28/21a61b1204f4722431232f133b129b00.png\" width=\"50%\"></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>websocket学起来并不难，api也不多，但可扩张和延伸的东西很多，想实现一个完整的项目，需要先有一个完整的设计思路才行。比如是一个在线WebIM系统，实现类似微信，qq的功能，客户端可以看到好友在线状态，在线列表，添加好友，删除好友，新建群组等，消息的发送除了支持基本的文字外，还能支持表情、图片和文件。有兴趣的同学可以继续一起深入研究。</p>\n"},{"title":"js继承介绍及应用实例","comments":1,"date":"2019-12-26T05:40:50.000Z","author":"jun.zhou","_content":"\n![](https://img.fengjr.com/image/2019/12/26/8a99a91c4e358ca58a39f074681a2a7f.jpg)\n\n# 一、js继承介绍\n\n说起JavaScript 的继承，相信许多初学者对它感到一头雾水，特别是当你了解或学过基于类的语言（例如Java或C++）。javascript作为动态和弱类型的语言，它没有提供类Class来实现继承。直到ES6才有了class的语法糖，但JavaScript保留了prototype这个基本属性。\n\n关于继承，JavaScript是通过对象来实现的。 每个对象都有一个私有属性，该属性包含指向另一个称为其原型的对象的链接。该原型对象具有自己的原型，依此类推，直到到达以null为原型的对象。根据定义，null没有原型，并充当该原型链中的最终链接。\n\n接下来的继承相关案例，就是围绕prototype,prototype chain展开的。\n\n#### 1、原型链继承\n子类的原型指向父类的实例，这就是原型链的指向方式。\n```\nfunction Parent () {\n    this.name = 'haha';\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name);\n}\n\nfunction Child () {\n\n}\nChild.prototype = new Parent();\n\nvar child1 = new Child();\n\nconsole.log(child1.getName()) // haha\n```\n#### 2、借用构造函数(经典继承)\n```\nfunction Parent() {\n    this.x = 100;\n    this.y = 199;\n}\nParent.prototype.fn = function() {}\n\nfunction Child() {\n    this.d = 100;\n    Parent.call(this); //构造函数中的this就是当前实例\n}\nvar p = new Parent();\nvar c = new Child();\nconsole.log(p)  //Parent {x: 100, y: 199}\nconsole.log(c)  //Child {d: 100, x: 100, y: 199}\n```\n优点：通过Funtion的call方法改变this指向，子类继承了父类的私有属性和方法，\n\n避免了引用类型的属性被所有实例共享。还可以在 Child 中向 Parent 传参，覆盖父类的私有属性，如下：\n```\nfunction Parent(z) {\n  this.x = 100;\n  this.y = 199;\n  this.z=z;\n}\nParent.prototype.fn = function() {}\n\nfunction Child(z) {\n  Parent.call(this,z); //构造函数中的this就是当前实例\n}\nvar p = new Parent(666);\nvar c = new Child(777);\nconsole.log(p)  //Parent {x: 100, y: 199, z: 666}\nconsole.log(c)  //Child {x: 100, y: 199, z: 777}\n```\n\n#### 3、组合继承\n结合了原型链继承和构造函数经典继承，拥有公有和私有的方法属性。\n```\nfunction Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n    Parent.call(this, name);//new Child()的时候，调用一次构造函数\n    this.age = age;\n}\n//子类的原型指向父类的实例对象\nChild.prototype = new Parent(); //这里也调用一次构造函数\n//改变子类的原型的constructor属性为Child,而不是Parent\nChild.prototype.constructor = Child;\n\nvar child1 = new Child('Mary', '18');\n\nchild1.colors.push('black');\n\nconsole.log(child1.name); // Mary\nconsole.log(child1.age); // 18\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]\n```\n优点：融合原型链继承和构造函数的优点，是 JavaScript 中常用的继承模式。\n\n缺点：每次都会调用两次构造函数：一次是在创建子类的原型的时候，另一次是在子类型构造函数的内部。子类最终会包含父类型对象的全部实例属性，但我们不得不在调用子类构造函数时重写这些属性。\n\n通过几个实例我们发现prototype有很多属性，下面我们了解一下：\n#### Object.prototype的成员\n1.constructor：原型对象内的一个属性，指向该原型对象相关联的构造函数\n2.hasOwnProperty：一个方法，用来判断对象本身（不包含原型）是否有某个属性\n3.propertyIsEnumerable\n（1）判断属性是否属于对象本身\n（2）判断属性是否可以被遍历\n4.defineProperty()：添加属性，可以加一些附加信息（比如可写、可读、可遍历等）\n5.toString和toLocaleString\n6.valueOf：获取当前对象的值\n    在对象参与运算的时候：\n    （1）默认会先去调用对象的valueOf()方法\n    （2）如果valueOf获取到的值无法进行运算，就去调用toString方法，最终做的就是拼接字符串的工作\n7.__proto__：原型对象中的属性，可以使用 对象.__proto__ 去访问原型对象\n\n\n# 二、Javascript继承机制的设计思想\n\n我们一直很难理解Javascript语言的继承机制。\n\n它没有\"子类\"和\"父类\"的概念，也没有\"类\"（class）和\"实例\"（instance）的区分，全靠一种很奇特的\"原型链\"（prototype chain）模式，来实现继承。\n\n我们常常花了很多时间，学习这个部分。但是都属于强行记忆，无法从根本上理解。\n\n下面，我尝试用自己的语言，来解释它的设计思想。彻底说明白prototype对象到底是怎么回事。其实根本就没那么复杂，真相非常简单。\n\n#### 1、从古代说起\n\n要理解Javascript的设计思想，必须从它的诞生说起。\n\n1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏\"用户名\"要求填写，浏览器就无法判断访问者是否真的填写了，只有让服务器端判断。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。\n\n因此，网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师Brendan Eich负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。\n\n1994年正是面向对象编程（object-oriented programming）最兴盛的时期，C++是当时最流行的语言，而Java语言的1.0版即将于第二年推出，Sun公司正在大肆造势。\n\nBrendan Eich无疑受到了影响，Javascript里面所有的数据类型都是对象（object），这一点与Java非常相似。但是，他随即就遇到了一个难题，到底要不要设计\"继承\"机制呢？\n\n#### 2、Brendan Eich的选择\n如果真的是一种简易的脚本语言，其实不需要有\"继承\"机制。但是，Javascript里面都是对象，必须有一种机制，将所有对象联系起来。所以，Brendan Eich最后还是设计了\"继承\"。\n\n但是，他不打算引入\"类\"（class）的概念，因为一旦有了\"类\"，Javascript就是一种完整的面向对象编程语言了，这好像有点太正式了，而且增加了初学者的入门难度。\n\n他考虑到，C++和Java语言都使用new命令，生成实例。\n\nC++的写法是：\n```\nClassName *object = new ClassName(param);\n```\nJava的写法是：\n```\n　　Foo foo = new Foo();\n```\n因此，他就把new命令引入了Javascript，用来从原型对象生成一个实例对象。但是，Javascript没有\"类\"，怎么来表示原型对象呢？\n\n这时，他想到C++和Java使用new命令时，都会调用\"类\"的构造函数（constructor）。他就做了一个简化的设计，在Javascript语言中，new命令后面跟的不是类，而是构造函数。\n\n举例来说，现在有一个叫做DOG的构造函数，表示狗对象的原型。\n\n```\nfunction DOG(name){\n　　this.name = name;\n}\n```\n对这个构造函数使用new，就会生成一个狗对象的实例。\n```\n　　var dogA = new DOG('大毛');\n\n　　alert(dogA.name); // 大毛\n```\n注意构造函数中的this关键字，它就代表了新创建的实例对象。\n\n#### 3、new运算符的缺点\n\n用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。\n\n比如，在DOG对象的构造函数中，设置一个实例对象的共有属性species。\n```\n　　function DOG(name){\n\n　　　　this.name = name;\n\n　　　　this.species = '犬科';\n\n　　}\n```\n然后，生成两个实例对象：\n```\n　　var dogA = new DOG('大毛');\n\n　　var dogB = new DOG('二毛');\n```\n这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。\n```\n  dogA.species = '猫科';\n\n　alert(dogB.species); // 显示\"犬科\"，不受dogA的影响\n```\n每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。\n\n#### 4、prototype属性的引入\n\n考虑到这一点，Brendan Eich决定为构造函数设置一个prototype属性。\n\n这个属性包含一个对象（以下简称\"prototype对象\"），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。\n\n实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。\n\n还是以DOG构造函数为例，现在用prototype属性进行改写：\n\n```\nfunction DOG(name){\n\n　　　　this.name = name;\n\n　　}\n\n　　DOG.prototype = { species : '犬科' };\n\n\n　　var dogA = new DOG('大毛');\n\n　　var dogB = new DOG('二毛');\n\n\n　　alert(dogA.species); // 犬科\n\n　　alert(dogB.species); // 犬科\n```\n\n现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。\n```\n　　DOG.prototype.species = '猫科';\n\n\n　　alert(dogA.species); // 猫科\n\n　　alert(dogB.species); // 猫科\n```\n\n由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像\"继承\"了prototype对象一样。\n\n这就是Javascript继承机制的设计思想。\n\n# 三、构造函数的继承实例\n\n通过上面对继承的了解，我们继续看实例。\n\n比如，现在有一个\"动物\"对象的构造函数。\n```\nfunction Animal(){\n\n　　　　this.species = \"动物\";\n\n　　}\n```\n还有一个\"猫\"对象的构造函数。\n\n```\n　　function Cat(name,color){\n\n　　　　this.name = name;\n\n　　　　this.color = color;\n\n　　}\n```\n怎样才能使\"猫\"继承\"动物\"呢？\n\n#### 1、 构造函数绑定\n第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：\n```\n　　function Cat(name,color){\n\n　　　　Animal.apply(this, arguments);\n\n　　　　this.name = name;\n\n　　　　this.color = color;\n\n　　}\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n\n#### 2、 prototype模式\n\n第二种方法更常见，使用prototype属性。\n\n如果\"猫\"的prototype对象，指向一个Animal的实例，那么所有\"猫\"的实例，就能继承Animal了。\n```\n　　Cat.prototype = new Animal();\n\n　　Cat.prototype.constructor = Cat;\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。\n```\n　　Cat.prototype = new Animal();\n```\n它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？\n```\n　　Cat.prototype.constructor = Cat;\n```\n原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有\"Cat.prototype = new Animal();\"这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。\n```\n　　alert(Cat.prototype.constructor == Animal); //true\n```\n更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。\n```\n　　alert(cat1.constructor == Cat.prototype.constructor); // true\n```\n因此，在运行\"Cat.prototype = new Animal();\"这一行之后，cat1.constructor也指向Animal！\n```\n　　alert(cat1.constructor == Animal); // true\n```\n这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。\n\n这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，\n```\n　　o.prototype = {};\n```\n那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。\n```\no.prototype.constructor = o;\n```\n\n#### 3、 直接继承prototype\n第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n\n现在，我们先将Animal对象改写：\n```\n　　function Animal(){ }\n\n　　Animal.prototype.species = \"动物\";\n```\n然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。\n```\n　　Cat.prototype = Animal.prototype;\n\n　　Cat.prototype.constructor = Cat;\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。\n\n所以，上面这一段代码其实是有问题的。请看第二行\n```\n　　Cat.prototype.constructor = Cat;\n```\n这一句实际上把Animal.prototype对象的constructor属性也改掉了！\n```\n　　alert(Animal.prototype.constructor); // Cat\n```\n#### 4、 利用空对象作为中介\n\n由于\"直接继承prototype\"存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。\n```\n　　var F = function(){};\n\n　　F.prototype = Animal.prototype;\n\n　　Cat.prototype = new F();\n\n　　Cat.prototype.constructor = Cat;\n```\nF是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。\n```\n　　alert(Animal.prototype.constructor); // Animal\n```\n我们将上面的方法，封装成一个函数，便于使用。\n```\n　function extend(Child, Parent) {\n\n　　　　var F = function(){};\n\n　　　　F.prototype = Parent.prototype;\n\n　　　　Child.prototype = new F();\n\n　　　　Child.prototype.constructor = Child;\n\n　　　　Child.uber = Parent.prototype;\n\n　　}\n```\n使用的时候，方法如下\n```\n　　extend(Cat,Animal);\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n这个extend函数，就是YUI库如何实现继承的方法。\n\n另外，说明一点，函数体最后一行\n```\n　　Child.uber = Parent.prototype;\n```\n意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是\"向上\"、\"上一层\"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。\n\n#### 5、 拷贝继承\n\n上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用\"拷贝\"方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。\n\n首先，还是把Animal的所有不变属性，都放到它的prototype对象上。\n```\n　　function Animal(){}\n\n　　Animal.prototype.species = \"动物\";\n```\n然后，再写一个函数，实现属性拷贝的目的。\n```\nfunction extend2(Child, Parent) {\n\n　　　　var p = Parent.prototype;\n\n　　　　var c = Child.prototype;\n\n　　　　for (var i in p) {\n\n　　　　　　c[i] = p[i];\n\n　　　　　　}\n\n　　　　c.uber = p;\n\n　　}\n```\n这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。\n\n使用的时候，这样写：\n```\n　　extend2(Cat, Animal);\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n\n# 四、完整的项目实例\n\n下面是一个拖拽的实例。\nhtml\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>drag Div</title>\n    <style type=\"text/css\">\n        #div1{width: 100px;height: 100px;background: red;position: absolute;}\n        #div2{width: 100px;height: 100px;background: yellow;position: absolute;}\n    </style>\n    <script src=\"drag.js\"></script>\n    <script src=\"Limitdrag.js\"></script>\n    <script type=\"text/javascript\">\n    window.onload=function(){\n        new Drag('div1');\n        new LimitDrag('div2');\n    }\n    </script>\n</head>\n<body>\n    <div id=\"div1\"></div>\n    <div id=\"div2\"></div>\n</body>\n</html>\n```\n首先创建一个基础的Drag构造函数，实现基础拖拽功能。\ndrag.js\n```\nfunction Drag(id){\n    var _this=this;\n    this.disX=0;\n    this.dixY=0;\n    this.oDiv=document.getElementById(id);\n    this.oDiv.onmousedown=function(ev)\n    {\n        _this.fnDown(ev);\n        return false;\n    };\n\n}\nDrag.prototype.fnDown=function(ev){\n    var _this=this;\n    var oEvent=ev||event;\n    this.disX=oEvent.clientX-this.oDiv.offsetLeft;\n    this.disY=oEvent.clientY-this.oDiv.offsetTop;\n    document.onmousemove=function(ev){\n        _this.fnMove(ev);\n    };\n    document.onmouseup=function(){\n        _this.fnUp();\n    };\n};\nDrag.prototype.fnMove=function(ev){\n    var oEvent=ev||event;\n    this.oDiv.style.left=oEvent.clientX-this.disX+'px';\n    this.oDiv.style.top=oEvent.clientY-this.disY+'px';\n    // this.oDiv.style.left=l+'px';\n    // this.oDiv.style.top=t+'px';\n};\nDrag.prototype.fnUp=function(){\n    document.onmousemove=null;\n    document.onmouseup=null;\n};\n```\n\n在上面基础实例上通过继承来完成进一步功能优化。\nLimitdrag.js\n```\nfunction LimitDrag(id){\n    Drag.call(this,id);\n}\nconsole.log(Drag.prototype,'111')\nconsole.log(Drag.LimitDrag,'222')\nfor(var i in Drag.prototype){\n    LimitDrag.prototype[i]=Drag.prototype[i];\n}\nconsole.log(LimitDrag.prototype,'333')\nLimitDrag.prototype.fnMove=function(ev){\n    var oEvent=ev||event;\n    var l=oEvent.clientX-this.disX;\n    var t=oEvent.clientY-this.disY;\n\n        if (l<0)\n        {l=0;}\n    else if(l>document.documentElement.clientWidth-this.oDiv.offsetWidth){\n        l=document.documentElement.clientWidth-this.oDiv.offsetWidth;\n    }\n        if (t<0)\n        {t=0;}\n    else if(t>document.documentElement.clientHeight-this.oDiv.offsetHeight){\n        t=document.documentElement.clientHeight-this.oDiv.offsetHeight;\n    }\n    this.oDiv.style.left=l+'px';\n    this.oDiv.style.top=t+'px';\n};\n```\n\n通过继承实现封装的代码看起来是不是很优雅，也非常方便后续修改和更新。\n\n# 五、class继承\n在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。\n\n有没有更简单的写法？有！\n\n新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。\n\n我们先用函数实现Student的方法：\n```\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n}\n```\n如果用新的class关键字来编写Student，可以这样写：\n```\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n\n    hello() {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n\n比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {...}这样分散的代码。\n最后实现的效果是一样的。\n\n用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：\n```\nclass PrimaryStudent extends Student {\n    constructor(name, grade) {\n        super(name); // 记得用super调用父类的构造方法!\n        this.grade = grade;\n    }\n\n    myGrade() {\n        alert('I am at grade ' + this.grade);\n    }\n}\n```\n\n注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。\n\nPrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。\n\nES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。\n\n那么，class这么好用，兼容性怎么样呢？\n\n不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以用Babel这个工具。","source":"_posts/2019-12-26-js-inheritance.md","raw":"---\ntitle: js继承介绍及应用实例\ncomments: true\ndate: 2019-12-26 13:40:50\ntags:\n- js\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n![](https://img.fengjr.com/image/2019/12/26/8a99a91c4e358ca58a39f074681a2a7f.jpg)\n\n# 一、js继承介绍\n\n说起JavaScript 的继承，相信许多初学者对它感到一头雾水，特别是当你了解或学过基于类的语言（例如Java或C++）。javascript作为动态和弱类型的语言，它没有提供类Class来实现继承。直到ES6才有了class的语法糖，但JavaScript保留了prototype这个基本属性。\n\n关于继承，JavaScript是通过对象来实现的。 每个对象都有一个私有属性，该属性包含指向另一个称为其原型的对象的链接。该原型对象具有自己的原型，依此类推，直到到达以null为原型的对象。根据定义，null没有原型，并充当该原型链中的最终链接。\n\n接下来的继承相关案例，就是围绕prototype,prototype chain展开的。\n\n#### 1、原型链继承\n子类的原型指向父类的实例，这就是原型链的指向方式。\n```\nfunction Parent () {\n    this.name = 'haha';\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name);\n}\n\nfunction Child () {\n\n}\nChild.prototype = new Parent();\n\nvar child1 = new Child();\n\nconsole.log(child1.getName()) // haha\n```\n#### 2、借用构造函数(经典继承)\n```\nfunction Parent() {\n    this.x = 100;\n    this.y = 199;\n}\nParent.prototype.fn = function() {}\n\nfunction Child() {\n    this.d = 100;\n    Parent.call(this); //构造函数中的this就是当前实例\n}\nvar p = new Parent();\nvar c = new Child();\nconsole.log(p)  //Parent {x: 100, y: 199}\nconsole.log(c)  //Child {d: 100, x: 100, y: 199}\n```\n优点：通过Funtion的call方法改变this指向，子类继承了父类的私有属性和方法，\n\n避免了引用类型的属性被所有实例共享。还可以在 Child 中向 Parent 传参，覆盖父类的私有属性，如下：\n```\nfunction Parent(z) {\n  this.x = 100;\n  this.y = 199;\n  this.z=z;\n}\nParent.prototype.fn = function() {}\n\nfunction Child(z) {\n  Parent.call(this,z); //构造函数中的this就是当前实例\n}\nvar p = new Parent(666);\nvar c = new Child(777);\nconsole.log(p)  //Parent {x: 100, y: 199, z: 666}\nconsole.log(c)  //Child {x: 100, y: 199, z: 777}\n```\n\n#### 3、组合继承\n结合了原型链继承和构造函数经典继承，拥有公有和私有的方法属性。\n```\nfunction Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n    Parent.call(this, name);//new Child()的时候，调用一次构造函数\n    this.age = age;\n}\n//子类的原型指向父类的实例对象\nChild.prototype = new Parent(); //这里也调用一次构造函数\n//改变子类的原型的constructor属性为Child,而不是Parent\nChild.prototype.constructor = Child;\n\nvar child1 = new Child('Mary', '18');\n\nchild1.colors.push('black');\n\nconsole.log(child1.name); // Mary\nconsole.log(child1.age); // 18\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]\n```\n优点：融合原型链继承和构造函数的优点，是 JavaScript 中常用的继承模式。\n\n缺点：每次都会调用两次构造函数：一次是在创建子类的原型的时候，另一次是在子类型构造函数的内部。子类最终会包含父类型对象的全部实例属性，但我们不得不在调用子类构造函数时重写这些属性。\n\n通过几个实例我们发现prototype有很多属性，下面我们了解一下：\n#### Object.prototype的成员\n1.constructor：原型对象内的一个属性，指向该原型对象相关联的构造函数\n2.hasOwnProperty：一个方法，用来判断对象本身（不包含原型）是否有某个属性\n3.propertyIsEnumerable\n（1）判断属性是否属于对象本身\n（2）判断属性是否可以被遍历\n4.defineProperty()：添加属性，可以加一些附加信息（比如可写、可读、可遍历等）\n5.toString和toLocaleString\n6.valueOf：获取当前对象的值\n    在对象参与运算的时候：\n    （1）默认会先去调用对象的valueOf()方法\n    （2）如果valueOf获取到的值无法进行运算，就去调用toString方法，最终做的就是拼接字符串的工作\n7.__proto__：原型对象中的属性，可以使用 对象.__proto__ 去访问原型对象\n\n\n# 二、Javascript继承机制的设计思想\n\n我们一直很难理解Javascript语言的继承机制。\n\n它没有\"子类\"和\"父类\"的概念，也没有\"类\"（class）和\"实例\"（instance）的区分，全靠一种很奇特的\"原型链\"（prototype chain）模式，来实现继承。\n\n我们常常花了很多时间，学习这个部分。但是都属于强行记忆，无法从根本上理解。\n\n下面，我尝试用自己的语言，来解释它的设计思想。彻底说明白prototype对象到底是怎么回事。其实根本就没那么复杂，真相非常简单。\n\n#### 1、从古代说起\n\n要理解Javascript的设计思想，必须从它的诞生说起。\n\n1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏\"用户名\"要求填写，浏览器就无法判断访问者是否真的填写了，只有让服务器端判断。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。\n\n因此，网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师Brendan Eich负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。\n\n1994年正是面向对象编程（object-oriented programming）最兴盛的时期，C++是当时最流行的语言，而Java语言的1.0版即将于第二年推出，Sun公司正在大肆造势。\n\nBrendan Eich无疑受到了影响，Javascript里面所有的数据类型都是对象（object），这一点与Java非常相似。但是，他随即就遇到了一个难题，到底要不要设计\"继承\"机制呢？\n\n#### 2、Brendan Eich的选择\n如果真的是一种简易的脚本语言，其实不需要有\"继承\"机制。但是，Javascript里面都是对象，必须有一种机制，将所有对象联系起来。所以，Brendan Eich最后还是设计了\"继承\"。\n\n但是，他不打算引入\"类\"（class）的概念，因为一旦有了\"类\"，Javascript就是一种完整的面向对象编程语言了，这好像有点太正式了，而且增加了初学者的入门难度。\n\n他考虑到，C++和Java语言都使用new命令，生成实例。\n\nC++的写法是：\n```\nClassName *object = new ClassName(param);\n```\nJava的写法是：\n```\n　　Foo foo = new Foo();\n```\n因此，他就把new命令引入了Javascript，用来从原型对象生成一个实例对象。但是，Javascript没有\"类\"，怎么来表示原型对象呢？\n\n这时，他想到C++和Java使用new命令时，都会调用\"类\"的构造函数（constructor）。他就做了一个简化的设计，在Javascript语言中，new命令后面跟的不是类，而是构造函数。\n\n举例来说，现在有一个叫做DOG的构造函数，表示狗对象的原型。\n\n```\nfunction DOG(name){\n　　this.name = name;\n}\n```\n对这个构造函数使用new，就会生成一个狗对象的实例。\n```\n　　var dogA = new DOG('大毛');\n\n　　alert(dogA.name); // 大毛\n```\n注意构造函数中的this关键字，它就代表了新创建的实例对象。\n\n#### 3、new运算符的缺点\n\n用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。\n\n比如，在DOG对象的构造函数中，设置一个实例对象的共有属性species。\n```\n　　function DOG(name){\n\n　　　　this.name = name;\n\n　　　　this.species = '犬科';\n\n　　}\n```\n然后，生成两个实例对象：\n```\n　　var dogA = new DOG('大毛');\n\n　　var dogB = new DOG('二毛');\n```\n这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。\n```\n  dogA.species = '猫科';\n\n　alert(dogB.species); // 显示\"犬科\"，不受dogA的影响\n```\n每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。\n\n#### 4、prototype属性的引入\n\n考虑到这一点，Brendan Eich决定为构造函数设置一个prototype属性。\n\n这个属性包含一个对象（以下简称\"prototype对象\"），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。\n\n实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。\n\n还是以DOG构造函数为例，现在用prototype属性进行改写：\n\n```\nfunction DOG(name){\n\n　　　　this.name = name;\n\n　　}\n\n　　DOG.prototype = { species : '犬科' };\n\n\n　　var dogA = new DOG('大毛');\n\n　　var dogB = new DOG('二毛');\n\n\n　　alert(dogA.species); // 犬科\n\n　　alert(dogB.species); // 犬科\n```\n\n现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。\n```\n　　DOG.prototype.species = '猫科';\n\n\n　　alert(dogA.species); // 猫科\n\n　　alert(dogB.species); // 猫科\n```\n\n由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像\"继承\"了prototype对象一样。\n\n这就是Javascript继承机制的设计思想。\n\n# 三、构造函数的继承实例\n\n通过上面对继承的了解，我们继续看实例。\n\n比如，现在有一个\"动物\"对象的构造函数。\n```\nfunction Animal(){\n\n　　　　this.species = \"动物\";\n\n　　}\n```\n还有一个\"猫\"对象的构造函数。\n\n```\n　　function Cat(name,color){\n\n　　　　this.name = name;\n\n　　　　this.color = color;\n\n　　}\n```\n怎样才能使\"猫\"继承\"动物\"呢？\n\n#### 1、 构造函数绑定\n第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：\n```\n　　function Cat(name,color){\n\n　　　　Animal.apply(this, arguments);\n\n　　　　this.name = name;\n\n　　　　this.color = color;\n\n　　}\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n\n#### 2、 prototype模式\n\n第二种方法更常见，使用prototype属性。\n\n如果\"猫\"的prototype对象，指向一个Animal的实例，那么所有\"猫\"的实例，就能继承Animal了。\n```\n　　Cat.prototype = new Animal();\n\n　　Cat.prototype.constructor = Cat;\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。\n```\n　　Cat.prototype = new Animal();\n```\n它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？\n```\n　　Cat.prototype.constructor = Cat;\n```\n原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有\"Cat.prototype = new Animal();\"这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。\n```\n　　alert(Cat.prototype.constructor == Animal); //true\n```\n更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。\n```\n　　alert(cat1.constructor == Cat.prototype.constructor); // true\n```\n因此，在运行\"Cat.prototype = new Animal();\"这一行之后，cat1.constructor也指向Animal！\n```\n　　alert(cat1.constructor == Animal); // true\n```\n这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。\n\n这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，\n```\n　　o.prototype = {};\n```\n那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。\n```\no.prototype.constructor = o;\n```\n\n#### 3、 直接继承prototype\n第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。\n\n现在，我们先将Animal对象改写：\n```\n　　function Animal(){ }\n\n　　Animal.prototype.species = \"动物\";\n```\n然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。\n```\n　　Cat.prototype = Animal.prototype;\n\n　　Cat.prototype.constructor = Cat;\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。\n\n所以，上面这一段代码其实是有问题的。请看第二行\n```\n　　Cat.prototype.constructor = Cat;\n```\n这一句实际上把Animal.prototype对象的constructor属性也改掉了！\n```\n　　alert(Animal.prototype.constructor); // Cat\n```\n#### 4、 利用空对象作为中介\n\n由于\"直接继承prototype\"存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。\n```\n　　var F = function(){};\n\n　　F.prototype = Animal.prototype;\n\n　　Cat.prototype = new F();\n\n　　Cat.prototype.constructor = Cat;\n```\nF是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。\n```\n　　alert(Animal.prototype.constructor); // Animal\n```\n我们将上面的方法，封装成一个函数，便于使用。\n```\n　function extend(Child, Parent) {\n\n　　　　var F = function(){};\n\n　　　　F.prototype = Parent.prototype;\n\n　　　　Child.prototype = new F();\n\n　　　　Child.prototype.constructor = Child;\n\n　　　　Child.uber = Parent.prototype;\n\n　　}\n```\n使用的时候，方法如下\n```\n　　extend(Cat,Animal);\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n这个extend函数，就是YUI库如何实现继承的方法。\n\n另外，说明一点，函数体最后一行\n```\n　　Child.uber = Parent.prototype;\n```\n意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是\"向上\"、\"上一层\"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。\n\n#### 5、 拷贝继承\n\n上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用\"拷贝\"方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。\n\n首先，还是把Animal的所有不变属性，都放到它的prototype对象上。\n```\n　　function Animal(){}\n\n　　Animal.prototype.species = \"动物\";\n```\n然后，再写一个函数，实现属性拷贝的目的。\n```\nfunction extend2(Child, Parent) {\n\n　　　　var p = Parent.prototype;\n\n　　　　var c = Child.prototype;\n\n　　　　for (var i in p) {\n\n　　　　　　c[i] = p[i];\n\n　　　　　　}\n\n　　　　c.uber = p;\n\n　　}\n```\n这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。\n\n使用的时候，这样写：\n```\n　　extend2(Cat, Animal);\n\n　　var cat1 = new Cat(\"大毛\",\"黄色\");\n\n　　alert(cat1.species); // 动物\n```\n\n# 四、完整的项目实例\n\n下面是一个拖拽的实例。\nhtml\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>drag Div</title>\n    <style type=\"text/css\">\n        #div1{width: 100px;height: 100px;background: red;position: absolute;}\n        #div2{width: 100px;height: 100px;background: yellow;position: absolute;}\n    </style>\n    <script src=\"drag.js\"></script>\n    <script src=\"Limitdrag.js\"></script>\n    <script type=\"text/javascript\">\n    window.onload=function(){\n        new Drag('div1');\n        new LimitDrag('div2');\n    }\n    </script>\n</head>\n<body>\n    <div id=\"div1\"></div>\n    <div id=\"div2\"></div>\n</body>\n</html>\n```\n首先创建一个基础的Drag构造函数，实现基础拖拽功能。\ndrag.js\n```\nfunction Drag(id){\n    var _this=this;\n    this.disX=0;\n    this.dixY=0;\n    this.oDiv=document.getElementById(id);\n    this.oDiv.onmousedown=function(ev)\n    {\n        _this.fnDown(ev);\n        return false;\n    };\n\n}\nDrag.prototype.fnDown=function(ev){\n    var _this=this;\n    var oEvent=ev||event;\n    this.disX=oEvent.clientX-this.oDiv.offsetLeft;\n    this.disY=oEvent.clientY-this.oDiv.offsetTop;\n    document.onmousemove=function(ev){\n        _this.fnMove(ev);\n    };\n    document.onmouseup=function(){\n        _this.fnUp();\n    };\n};\nDrag.prototype.fnMove=function(ev){\n    var oEvent=ev||event;\n    this.oDiv.style.left=oEvent.clientX-this.disX+'px';\n    this.oDiv.style.top=oEvent.clientY-this.disY+'px';\n    // this.oDiv.style.left=l+'px';\n    // this.oDiv.style.top=t+'px';\n};\nDrag.prototype.fnUp=function(){\n    document.onmousemove=null;\n    document.onmouseup=null;\n};\n```\n\n在上面基础实例上通过继承来完成进一步功能优化。\nLimitdrag.js\n```\nfunction LimitDrag(id){\n    Drag.call(this,id);\n}\nconsole.log(Drag.prototype,'111')\nconsole.log(Drag.LimitDrag,'222')\nfor(var i in Drag.prototype){\n    LimitDrag.prototype[i]=Drag.prototype[i];\n}\nconsole.log(LimitDrag.prototype,'333')\nLimitDrag.prototype.fnMove=function(ev){\n    var oEvent=ev||event;\n    var l=oEvent.clientX-this.disX;\n    var t=oEvent.clientY-this.disY;\n\n        if (l<0)\n        {l=0;}\n    else if(l>document.documentElement.clientWidth-this.oDiv.offsetWidth){\n        l=document.documentElement.clientWidth-this.oDiv.offsetWidth;\n    }\n        if (t<0)\n        {t=0;}\n    else if(t>document.documentElement.clientHeight-this.oDiv.offsetHeight){\n        t=document.documentElement.clientHeight-this.oDiv.offsetHeight;\n    }\n    this.oDiv.style.left=l+'px';\n    this.oDiv.style.top=t+'px';\n};\n```\n\n通过继承实现封装的代码看起来是不是很优雅，也非常方便后续修改和更新。\n\n# 五、class继承\n在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。\n\n有没有更简单的写法？有！\n\n新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。\n\n我们先用函数实现Student的方法：\n```\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n}\n```\n如果用新的class关键字来编写Student，可以这样写：\n```\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n\n    hello() {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n\n比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {...}这样分散的代码。\n最后实现的效果是一样的。\n\n用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：\n```\nclass PrimaryStudent extends Student {\n    constructor(name, grade) {\n        super(name); // 记得用super调用父类的构造方法!\n        this.grade = grade;\n    }\n\n    myGrade() {\n        alert('I am at grade ' + this.grade);\n    }\n}\n```\n\n注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。\n\nPrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。\n\nES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。\n\n那么，class这么好用，兼容性怎么样呢？\n\n不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以用Babel这个工具。","slug":"js-inheritance","published":1,"updated":"2020-06-10T06:01:32.410Z","_id":"ck8r6c15h0000imq6a8igkejv","layout":"post","photos":[],"link":"","content":"<p><img src=\"https://img.fengjr.com/image/2019/12/26/8a99a91c4e358ca58a39f074681a2a7f.jpg\" alt></p>\n<h1 id=\"一、js继承介绍\"><a href=\"#一、js继承介绍\" class=\"headerlink\" title=\"一、js继承介绍\"></a>一、js继承介绍</h1><p>说起JavaScript 的继承，相信许多初学者对它感到一头雾水，特别是当你了解或学过基于类的语言（例如Java或C++）。javascript作为动态和弱类型的语言，它没有提供类Class来实现继承。直到ES6才有了class的语法糖，但JavaScript保留了prototype这个基本属性。</p>\n<p>关于继承，JavaScript是通过对象来实现的。 每个对象都有一个私有属性，该属性包含指向另一个称为其原型的对象的链接。该原型对象具有自己的原型，依此类推，直到到达以null为原型的对象。根据定义，null没有原型，并充当该原型链中的最终链接。</p>\n<p>接下来的继承相关案例，就是围绕prototype,prototype chain展开的。</p>\n<h4 id=\"1、原型链继承\"><a href=\"#1、原型链继承\" class=\"headerlink\" title=\"1、原型链继承\"></a>1、原型链继承</h4><p>子类的原型指向父类的实例，这就是原型链的指向方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent () &#123;</span><br><span class=\"line\">    this.name = &apos;haha&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = function () &#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = new Parent();</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 = new Child();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.getName()) // haha</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2、借用构造函数-经典继承\"><a href=\"#2、借用构造函数-经典继承\" class=\"headerlink\" title=\"2、借用构造函数(经典继承)\"></a>2、借用构造函数(经典继承)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">    this.x = 100;</span><br><span class=\"line\">    this.y = 199;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.fn = function() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child() &#123;</span><br><span class=\"line\">    this.d = 100;</span><br><span class=\"line\">    Parent.call(this); //构造函数中的this就是当前实例</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p = new Parent();</span><br><span class=\"line\">var c = new Child();</span><br><span class=\"line\">console.log(p)  //Parent &#123;x: 100, y: 199&#125;</span><br><span class=\"line\">console.log(c)  //Child &#123;d: 100, x: 100, y: 199&#125;</span><br></pre></td></tr></table></figure>\n<p>优点：通过Funtion的call方法改变this指向，子类继承了父类的私有属性和方法，</p>\n<p>避免了引用类型的属性被所有实例共享。还可以在 Child 中向 Parent 传参，覆盖父类的私有属性，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent(z) &#123;</span><br><span class=\"line\">  this.x = 100;</span><br><span class=\"line\">  this.y = 199;</span><br><span class=\"line\">  this.z=z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.fn = function() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child(z) &#123;</span><br><span class=\"line\">  Parent.call(this,z); //构造函数中的this就是当前实例</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p = new Parent(666);</span><br><span class=\"line\">var c = new Child(777);</span><br><span class=\"line\">console.log(p)  //Parent &#123;x: 100, y: 199, z: 666&#125;</span><br><span class=\"line\">console.log(c)  //Child &#123;x: 100, y: 199, z: 777&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、组合继承\"><a href=\"#3、组合继承\" class=\"headerlink\" title=\"3、组合继承\"></a>3、组合继承</h4><p>结合了原型链继承和构造函数经典继承，拥有公有和私有的方法属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent (name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = function () &#123;</span><br><span class=\"line\">    console.log(this.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child (name, age) &#123;</span><br><span class=\"line\">    Parent.call(this, name);//new Child()的时候，调用一次构造函数</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//子类的原型指向父类的实例对象</span><br><span class=\"line\">Child.prototype = new Parent(); //这里也调用一次构造函数</span><br><span class=\"line\">//改变子类的原型的constructor属性为Child,而不是Parent</span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 = new Child(&apos;Mary&apos;, &apos;18&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">child1.colors.push(&apos;black&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.name); // Mary</span><br><span class=\"line\">console.log(child1.age); // 18</span><br><span class=\"line\">console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中常用的继承模式。</p>\n<p>缺点：每次都会调用两次构造函数：一次是在创建子类的原型的时候，另一次是在子类型构造函数的内部。子类最终会包含父类型对象的全部实例属性，但我们不得不在调用子类构造函数时重写这些属性。</p>\n<p>通过几个实例我们发现prototype有很多属性，下面我们了解一下：</p>\n<h4 id=\"Object-prototype的成员\"><a href=\"#Object-prototype的成员\" class=\"headerlink\" title=\"Object.prototype的成员\"></a>Object.prototype的成员</h4><p>1.constructor：原型对象内的一个属性，指向该原型对象相关联的构造函数<br>2.hasOwnProperty：一个方法，用来判断对象本身（不包含原型）是否有某个属性<br>3.propertyIsEnumerable<br>（1）判断属性是否属于对象本身<br>（2）判断属性是否可以被遍历<br>4.defineProperty()：添加属性，可以加一些附加信息（比如可写、可读、可遍历等）<br>5.toString和toLocaleString<br>6.valueOf：获取当前对象的值<br>    在对象参与运算的时候：<br>    （1）默认会先去调用对象的valueOf()方法<br>    （2）如果valueOf获取到的值无法进行运算，就去调用toString方法，最终做的就是拼接字符串的工作<br>7.<strong>proto</strong>：原型对象中的属性，可以使用 对象.<strong>proto</strong> 去访问原型对象</p>\n<h1 id=\"二、Javascript继承机制的设计思想\"><a href=\"#二、Javascript继承机制的设计思想\" class=\"headerlink\" title=\"二、Javascript继承机制的设计思想\"></a>二、Javascript继承机制的设计思想</h1><p>我们一直很难理解Javascript语言的继承机制。</p>\n<p>它没有”子类”和”父类”的概念，也没有”类”（class）和”实例”（instance）的区分，全靠一种很奇特的”原型链”（prototype chain）模式，来实现继承。</p>\n<p>我们常常花了很多时间，学习这个部分。但是都属于强行记忆，无法从根本上理解。</p>\n<p>下面，我尝试用自己的语言，来解释它的设计思想。彻底说明白prototype对象到底是怎么回事。其实根本就没那么复杂，真相非常简单。</p>\n<h4 id=\"1、从古代说起\"><a href=\"#1、从古代说起\" class=\"headerlink\" title=\"1、从古代说起\"></a>1、从古代说起</h4><p>要理解Javascript的设计思想，必须从它的诞生说起。</p>\n<p>1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏”用户名”要求填写，浏览器就无法判断访问者是否真的填写了，只有让服务器端判断。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。</p>\n<p>因此，网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师Brendan Eich负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。</p>\n<p>1994年正是面向对象编程（object-oriented programming）最兴盛的时期，C++是当时最流行的语言，而Java语言的1.0版即将于第二年推出，Sun公司正在大肆造势。</p>\n<p>Brendan Eich无疑受到了影响，Javascript里面所有的数据类型都是对象（object），这一点与Java非常相似。但是，他随即就遇到了一个难题，到底要不要设计”继承”机制呢？</p>\n<h4 id=\"2、Brendan-Eich的选择\"><a href=\"#2、Brendan-Eich的选择\" class=\"headerlink\" title=\"2、Brendan Eich的选择\"></a>2、Brendan Eich的选择</h4><p>如果真的是一种简易的脚本语言，其实不需要有”继承”机制。但是，Javascript里面都是对象，必须有一种机制，将所有对象联系起来。所以，Brendan Eich最后还是设计了”继承”。</p>\n<p>但是，他不打算引入”类”（class）的概念，因为一旦有了”类”，Javascript就是一种完整的面向对象编程语言了，这好像有点太正式了，而且增加了初学者的入门难度。</p>\n<p>他考虑到，C++和Java语言都使用new命令，生成实例。</p>\n<p>C++的写法是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassName *object = new ClassName(param);</span><br></pre></td></tr></table></figure></p>\n<p>Java的写法是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Foo foo = new Foo();</span><br></pre></td></tr></table></figure></p>\n<p>因此，他就把new命令引入了Javascript，用来从原型对象生成一个实例对象。但是，Javascript没有”类”，怎么来表示原型对象呢？</p>\n<p>这时，他想到C++和Java使用new命令时，都会调用”类”的构造函数（constructor）。他就做了一个简化的设计，在Javascript语言中，new命令后面跟的不是类，而是构造函数。</p>\n<p>举例来说，现在有一个叫做DOG的构造函数，表示狗对象的原型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function DOG(name)&#123;</span><br><span class=\"line\">　　this.name = name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对这个构造函数使用new，就会生成一个狗对象的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　var dogA = new DOG(&apos;大毛&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogA.name); // 大毛</span><br></pre></td></tr></table></figure></p>\n<p>注意构造函数中的this关键字，它就代表了新创建的实例对象。</p>\n<h4 id=\"3、new运算符的缺点\"><a href=\"#3、new运算符的缺点\" class=\"headerlink\" title=\"3、new运算符的缺点\"></a>3、new运算符的缺点</h4><p>用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。</p>\n<p>比如，在DOG对象的构造函数中，设置一个实例对象的共有属性species。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function DOG(name)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.species = &apos;犬科&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后，生成两个实例对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　var dogA = new DOG(&apos;大毛&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　var dogB = new DOG(&apos;二毛&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dogA.species = &apos;猫科&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">　alert(dogB.species); // 显示&quot;犬科&quot;，不受dogA的影响</span><br></pre></td></tr></table></figure></p>\n<p>每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。</p>\n<h4 id=\"4、prototype属性的引入\"><a href=\"#4、prototype属性的引入\" class=\"headerlink\" title=\"4、prototype属性的引入\"></a>4、prototype属性的引入</h4><p>考虑到这一点，Brendan Eich决定为构造函数设置一个prototype属性。</p>\n<p>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</p>\n<p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p>\n<p>还是以DOG构造函数为例，现在用prototype属性进行改写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function DOG(name)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　DOG.prototype = &#123; species : &apos;犬科&apos; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">　　var dogA = new DOG(&apos;大毛&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　var dogB = new DOG(&apos;二毛&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogA.species); // 犬科</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogB.species); // 犬科</span><br></pre></td></tr></table></figure>\n<p>现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　DOG.prototype.species = &apos;猫科&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogA.species); // 猫科</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogB.species); // 猫科</span><br></pre></td></tr></table></figure></p>\n<p>由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像”继承”了prototype对象一样。</p>\n<p>这就是Javascript继承机制的设计思想。</p>\n<h1 id=\"三、构造函数的继承实例\"><a href=\"#三、构造函数的继承实例\" class=\"headerlink\" title=\"三、构造函数的继承实例\"></a>三、构造函数的继承实例</h1><p>通过上面对继承的了解，我们继续看实例。</p>\n<p>比如，现在有一个”动物”对象的构造函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.species = &quot;动物&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有一个”猫”对象的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function Cat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.color = color;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure>\n<p>怎样才能使”猫”继承”动物”呢？</p>\n<h4 id=\"1、-构造函数绑定\"><a href=\"#1、-构造函数绑定\" class=\"headerlink\" title=\"1、 构造函数绑定\"></a>1、 构造函数绑定</h4><p>第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function Cat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　Animal.apply(this, arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.color = color;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2、-prototype模式\"><a href=\"#2、-prototype模式\" class=\"headerlink\" title=\"2、 prototype模式\"></a>2、 prototype模式</h4><p>第二种方法更常见，使用prototype属性。</p>\n<p>如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype = new Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<p>代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype = new Animal();</span><br></pre></td></tr></table></figure></p>\n<p>它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure></p>\n<p>原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(Cat.prototype.constructor == Animal); //true</span><br></pre></td></tr></table></figure></p>\n<p>更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(cat1.constructor == Cat.prototype.constructor); // true</span><br></pre></td></tr></table></figure></p>\n<p>因此，在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(cat1.constructor == Animal); // true</span><br></pre></td></tr></table></figure></p>\n<p>这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</p>\n<p>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　o.prototype = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o.prototype.constructor = o;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、-直接继承prototype\"><a href=\"#3、-直接继承prototype\" class=\"headerlink\" title=\"3、 直接继承prototype\"></a>3、 直接继承prototype</h4><p>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<p>现在，我们先将Animal对象改写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function Animal()&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　Animal.prototype.species = &quot;动物&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype = Animal.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。</p>\n<p>所以，上面这一段代码其实是有问题的。请看第二行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure></p>\n<p>这一句实际上把Animal.prototype对象的constructor属性也改掉了！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(Animal.prototype.constructor); // Cat</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4、-利用空对象作为中介\"><a href=\"#4、-利用空对象作为中介\" class=\"headerlink\" title=\"4、 利用空对象作为中介\"></a>4、 利用空对象作为中介</h4><p>由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　var F = function()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">　　F.prototype = Animal.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　Cat.prototype = new F();</span><br><span class=\"line\"></span><br><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure></p>\n<p>F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(Animal.prototype.constructor); // Animal</span><br></pre></td></tr></table></figure></p>\n<p>我们将上面的方法，封装成一个函数，便于使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　function extend(Child, Parent) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　var F = function()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　F.prototype = Parent.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　Child.prototype = new F();</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　Child.uber = Parent.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用的时候，方法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　extend(Cat,Animal);</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<p>这个extend函数，就是YUI库如何实现继承的方法。</p>\n<p>另外，说明一点，函数体最后一行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Child.uber = Parent.prototype;</span><br></pre></td></tr></table></figure></p>\n<p>意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>\n<h4 id=\"5、-拷贝继承\"><a href=\"#5、-拷贝继承\" class=\"headerlink\" title=\"5、 拷贝继承\"></a>5、 拷贝继承</h4><p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>\n<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function Animal()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　Animal.prototype.species = &quot;动物&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>然后，再写一个函数，实现属性拷贝的目的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function extend2(Child, Parent) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　var p = Parent.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　var c = Child.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　for (var i in p) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　　　c[i] = p[i];</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　c.uber = p;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。</p>\n<p>使用的时候，这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　extend2(Cat, Animal);</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"四、完整的项目实例\"><a href=\"#四、完整的项目实例\" class=\"headerlink\" title=\"四、完整的项目实例\"></a>四、完整的项目实例</h1><p>下面是一个拖拽的实例。<br>html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;drag Div&lt;/title&gt;</span><br><span class=\"line\">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">        #div1&#123;width: 100px;height: 100px;background: red;position: absolute;&#125;</span><br><span class=\"line\">        #div2&#123;width: 100px;height: 100px;background: yellow;position: absolute;&#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">    &lt;script src=&quot;drag.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;Limitdrag.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    window.onload=function()&#123;</span><br><span class=\"line\">        new Drag(&apos;div1&apos;);</span><br><span class=\"line\">        new LimitDrag(&apos;div2&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>首先创建一个基础的Drag构造函数，实现基础拖拽功能。<br>drag.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Drag(id)&#123;</span><br><span class=\"line\">    var _this=this;</span><br><span class=\"line\">    this.disX=0;</span><br><span class=\"line\">    this.dixY=0;</span><br><span class=\"line\">    this.oDiv=document.getElementById(id);</span><br><span class=\"line\">    this.oDiv.onmousedown=function(ev)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _this.fnDown(ev);</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Drag.prototype.fnDown=function(ev)&#123;</span><br><span class=\"line\">    var _this=this;</span><br><span class=\"line\">    var oEvent=ev||event;</span><br><span class=\"line\">    this.disX=oEvent.clientX-this.oDiv.offsetLeft;</span><br><span class=\"line\">    this.disY=oEvent.clientY-this.oDiv.offsetTop;</span><br><span class=\"line\">    document.onmousemove=function(ev)&#123;</span><br><span class=\"line\">        _this.fnMove(ev);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    document.onmouseup=function()&#123;</span><br><span class=\"line\">        _this.fnUp();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Drag.prototype.fnMove=function(ev)&#123;</span><br><span class=\"line\">    var oEvent=ev||event;</span><br><span class=\"line\">    this.oDiv.style.left=oEvent.clientX-this.disX+&apos;px&apos;;</span><br><span class=\"line\">    this.oDiv.style.top=oEvent.clientY-this.disY+&apos;px&apos;;</span><br><span class=\"line\">    // this.oDiv.style.left=l+&apos;px&apos;;</span><br><span class=\"line\">    // this.oDiv.style.top=t+&apos;px&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Drag.prototype.fnUp=function()&#123;</span><br><span class=\"line\">    document.onmousemove=null;</span><br><span class=\"line\">    document.onmouseup=null;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在上面基础实例上通过继承来完成进一步功能优化。<br>Limitdrag.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function LimitDrag(id)&#123;</span><br><span class=\"line\">    Drag.call(this,id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Drag.prototype,&apos;111&apos;)</span><br><span class=\"line\">console.log(Drag.LimitDrag,&apos;222&apos;)</span><br><span class=\"line\">for(var i in Drag.prototype)&#123;</span><br><span class=\"line\">    LimitDrag.prototype[i]=Drag.prototype[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(LimitDrag.prototype,&apos;333&apos;)</span><br><span class=\"line\">LimitDrag.prototype.fnMove=function(ev)&#123;</span><br><span class=\"line\">    var oEvent=ev||event;</span><br><span class=\"line\">    var l=oEvent.clientX-this.disX;</span><br><span class=\"line\">    var t=oEvent.clientY-this.disY;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (l&lt;0)</span><br><span class=\"line\">        &#123;l=0;&#125;</span><br><span class=\"line\">    else if(l&gt;document.documentElement.clientWidth-this.oDiv.offsetWidth)&#123;</span><br><span class=\"line\">        l=document.documentElement.clientWidth-this.oDiv.offsetWidth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        if (t&lt;0)</span><br><span class=\"line\">        &#123;t=0;&#125;</span><br><span class=\"line\">    else if(t&gt;document.documentElement.clientHeight-this.oDiv.offsetHeight)&#123;</span><br><span class=\"line\">        t=document.documentElement.clientHeight-this.oDiv.offsetHeight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.oDiv.style.left=l+&apos;px&apos;;</span><br><span class=\"line\">    this.oDiv.style.top=t+&apos;px&apos;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通过继承实现封装的代码看起来是不是很优雅，也非常方便后续修改和更新。</p>\n<h1 id=\"五、class继承\"><a href=\"#五、class继承\" class=\"headerlink\" title=\"五、class继承\"></a>五、class继承</h1><p>在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</p>\n<p>有没有更简单的写法？有！</p>\n<p>新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。</p>\n<p>我们先用函数实现Student的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Student(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.hello = function () &#123;</span><br><span class=\"line\">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用新的class关键字来编写Student，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student &#123;</span><br><span class=\"line\">    constructor(name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    hello() &#123;</span><br><span class=\"line\">        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {…}这样分散的代码。<br>最后实现的效果是一样的。</p>\n<p>用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PrimaryStudent extends Student &#123;</span><br><span class=\"line\">    constructor(name, grade) &#123;</span><br><span class=\"line\">        super(name); // 记得用super调用父类的构造方法!</span><br><span class=\"line\">        this.grade = grade;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    myGrade() &#123;</span><br><span class=\"line\">        alert(&apos;I am at grade &apos; + this.grade);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。</p>\n<p>PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。</p>\n<p>ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。</p>\n<p>那么，class这么好用，兼容性怎么样呢？</p>\n<p>不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以用Babel这个工具。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://img.fengjr.com/image/2019/12/26/8a99a91c4e358ca58a39f074681a2a7f.jpg\" alt></p>\n<h1 id=\"一、js继承介绍\"><a href=\"#一、js继承介绍\" class=\"headerlink\" title=\"一、js继承介绍\"></a>一、js继承介绍</h1><p>说起JavaScript 的继承，相信许多初学者对它感到一头雾水，特别是当你了解或学过基于类的语言（例如Java或C++）。javascript作为动态和弱类型的语言，它没有提供类Class来实现继承。直到ES6才有了class的语法糖，但JavaScript保留了prototype这个基本属性。</p>\n<p>关于继承，JavaScript是通过对象来实现的。 每个对象都有一个私有属性，该属性包含指向另一个称为其原型的对象的链接。该原型对象具有自己的原型，依此类推，直到到达以null为原型的对象。根据定义，null没有原型，并充当该原型链中的最终链接。</p>\n<p>接下来的继承相关案例，就是围绕prototype,prototype chain展开的。</p>\n<h4 id=\"1、原型链继承\"><a href=\"#1、原型链继承\" class=\"headerlink\" title=\"1、原型链继承\"></a>1、原型链继承</h4><p>子类的原型指向父类的实例，这就是原型链的指向方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent () &#123;</span><br><span class=\"line\">    this.name = &apos;haha&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = function () &#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = new Parent();</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 = new Child();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.getName()) // haha</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2、借用构造函数-经典继承\"><a href=\"#2、借用构造函数-经典继承\" class=\"headerlink\" title=\"2、借用构造函数(经典继承)\"></a>2、借用构造函数(经典继承)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">    this.x = 100;</span><br><span class=\"line\">    this.y = 199;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.fn = function() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child() &#123;</span><br><span class=\"line\">    this.d = 100;</span><br><span class=\"line\">    Parent.call(this); //构造函数中的this就是当前实例</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p = new Parent();</span><br><span class=\"line\">var c = new Child();</span><br><span class=\"line\">console.log(p)  //Parent &#123;x: 100, y: 199&#125;</span><br><span class=\"line\">console.log(c)  //Child &#123;d: 100, x: 100, y: 199&#125;</span><br></pre></td></tr></table></figure>\n<p>优点：通过Funtion的call方法改变this指向，子类继承了父类的私有属性和方法，</p>\n<p>避免了引用类型的属性被所有实例共享。还可以在 Child 中向 Parent 传参，覆盖父类的私有属性，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent(z) &#123;</span><br><span class=\"line\">  this.x = 100;</span><br><span class=\"line\">  this.y = 199;</span><br><span class=\"line\">  this.z=z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.fn = function() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child(z) &#123;</span><br><span class=\"line\">  Parent.call(this,z); //构造函数中的this就是当前实例</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p = new Parent(666);</span><br><span class=\"line\">var c = new Child(777);</span><br><span class=\"line\">console.log(p)  //Parent &#123;x: 100, y: 199, z: 666&#125;</span><br><span class=\"line\">console.log(c)  //Child &#123;x: 100, y: 199, z: 777&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、组合继承\"><a href=\"#3、组合继承\" class=\"headerlink\" title=\"3、组合继承\"></a>3、组合继承</h4><p>结合了原型链继承和构造函数经典继承，拥有公有和私有的方法属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent (name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = function () &#123;</span><br><span class=\"line\">    console.log(this.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child (name, age) &#123;</span><br><span class=\"line\">    Parent.call(this, name);//new Child()的时候，调用一次构造函数</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//子类的原型指向父类的实例对象</span><br><span class=\"line\">Child.prototype = new Parent(); //这里也调用一次构造函数</span><br><span class=\"line\">//改变子类的原型的constructor属性为Child,而不是Parent</span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 = new Child(&apos;Mary&apos;, &apos;18&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">child1.colors.push(&apos;black&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.name); // Mary</span><br><span class=\"line\">console.log(child1.age); // 18</span><br><span class=\"line\">console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中常用的继承模式。</p>\n<p>缺点：每次都会调用两次构造函数：一次是在创建子类的原型的时候，另一次是在子类型构造函数的内部。子类最终会包含父类型对象的全部实例属性，但我们不得不在调用子类构造函数时重写这些属性。</p>\n<p>通过几个实例我们发现prototype有很多属性，下面我们了解一下：</p>\n<h4 id=\"Object-prototype的成员\"><a href=\"#Object-prototype的成员\" class=\"headerlink\" title=\"Object.prototype的成员\"></a>Object.prototype的成员</h4><p>1.constructor：原型对象内的一个属性，指向该原型对象相关联的构造函数<br>2.hasOwnProperty：一个方法，用来判断对象本身（不包含原型）是否有某个属性<br>3.propertyIsEnumerable<br>（1）判断属性是否属于对象本身<br>（2）判断属性是否可以被遍历<br>4.defineProperty()：添加属性，可以加一些附加信息（比如可写、可读、可遍历等）<br>5.toString和toLocaleString<br>6.valueOf：获取当前对象的值<br>    在对象参与运算的时候：<br>    （1）默认会先去调用对象的valueOf()方法<br>    （2）如果valueOf获取到的值无法进行运算，就去调用toString方法，最终做的就是拼接字符串的工作<br>7.<strong>proto</strong>：原型对象中的属性，可以使用 对象.<strong>proto</strong> 去访问原型对象</p>\n<h1 id=\"二、Javascript继承机制的设计思想\"><a href=\"#二、Javascript继承机制的设计思想\" class=\"headerlink\" title=\"二、Javascript继承机制的设计思想\"></a>二、Javascript继承机制的设计思想</h1><p>我们一直很难理解Javascript语言的继承机制。</p>\n<p>它没有”子类”和”父类”的概念，也没有”类”（class）和”实例”（instance）的区分，全靠一种很奇特的”原型链”（prototype chain）模式，来实现继承。</p>\n<p>我们常常花了很多时间，学习这个部分。但是都属于强行记忆，无法从根本上理解。</p>\n<p>下面，我尝试用自己的语言，来解释它的设计思想。彻底说明白prototype对象到底是怎么回事。其实根本就没那么复杂，真相非常简单。</p>\n<h4 id=\"1、从古代说起\"><a href=\"#1、从古代说起\" class=\"headerlink\" title=\"1、从古代说起\"></a>1、从古代说起</h4><p>要理解Javascript的设计思想，必须从它的诞生说起。</p>\n<p>1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏”用户名”要求填写，浏览器就无法判断访问者是否真的填写了，只有让服务器端判断。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。</p>\n<p>因此，网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师Brendan Eich负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。</p>\n<p>1994年正是面向对象编程（object-oriented programming）最兴盛的时期，C++是当时最流行的语言，而Java语言的1.0版即将于第二年推出，Sun公司正在大肆造势。</p>\n<p>Brendan Eich无疑受到了影响，Javascript里面所有的数据类型都是对象（object），这一点与Java非常相似。但是，他随即就遇到了一个难题，到底要不要设计”继承”机制呢？</p>\n<h4 id=\"2、Brendan-Eich的选择\"><a href=\"#2、Brendan-Eich的选择\" class=\"headerlink\" title=\"2、Brendan Eich的选择\"></a>2、Brendan Eich的选择</h4><p>如果真的是一种简易的脚本语言，其实不需要有”继承”机制。但是，Javascript里面都是对象，必须有一种机制，将所有对象联系起来。所以，Brendan Eich最后还是设计了”继承”。</p>\n<p>但是，他不打算引入”类”（class）的概念，因为一旦有了”类”，Javascript就是一种完整的面向对象编程语言了，这好像有点太正式了，而且增加了初学者的入门难度。</p>\n<p>他考虑到，C++和Java语言都使用new命令，生成实例。</p>\n<p>C++的写法是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassName *object = new ClassName(param);</span><br></pre></td></tr></table></figure></p>\n<p>Java的写法是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Foo foo = new Foo();</span><br></pre></td></tr></table></figure></p>\n<p>因此，他就把new命令引入了Javascript，用来从原型对象生成一个实例对象。但是，Javascript没有”类”，怎么来表示原型对象呢？</p>\n<p>这时，他想到C++和Java使用new命令时，都会调用”类”的构造函数（constructor）。他就做了一个简化的设计，在Javascript语言中，new命令后面跟的不是类，而是构造函数。</p>\n<p>举例来说，现在有一个叫做DOG的构造函数，表示狗对象的原型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function DOG(name)&#123;</span><br><span class=\"line\">　　this.name = name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对这个构造函数使用new，就会生成一个狗对象的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　var dogA = new DOG(&apos;大毛&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogA.name); // 大毛</span><br></pre></td></tr></table></figure></p>\n<p>注意构造函数中的this关键字，它就代表了新创建的实例对象。</p>\n<h4 id=\"3、new运算符的缺点\"><a href=\"#3、new运算符的缺点\" class=\"headerlink\" title=\"3、new运算符的缺点\"></a>3、new运算符的缺点</h4><p>用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。</p>\n<p>比如，在DOG对象的构造函数中，设置一个实例对象的共有属性species。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function DOG(name)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.species = &apos;犬科&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后，生成两个实例对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　var dogA = new DOG(&apos;大毛&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　var dogB = new DOG(&apos;二毛&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dogA.species = &apos;猫科&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">　alert(dogB.species); // 显示&quot;犬科&quot;，不受dogA的影响</span><br></pre></td></tr></table></figure></p>\n<p>每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。</p>\n<h4 id=\"4、prototype属性的引入\"><a href=\"#4、prototype属性的引入\" class=\"headerlink\" title=\"4、prototype属性的引入\"></a>4、prototype属性的引入</h4><p>考虑到这一点，Brendan Eich决定为构造函数设置一个prototype属性。</p>\n<p>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</p>\n<p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p>\n<p>还是以DOG构造函数为例，现在用prototype属性进行改写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function DOG(name)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　DOG.prototype = &#123; species : &apos;犬科&apos; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">　　var dogA = new DOG(&apos;大毛&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　var dogB = new DOG(&apos;二毛&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogA.species); // 犬科</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogB.species); // 犬科</span><br></pre></td></tr></table></figure>\n<p>现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　DOG.prototype.species = &apos;猫科&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogA.species); // 猫科</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(dogB.species); // 猫科</span><br></pre></td></tr></table></figure></p>\n<p>由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像”继承”了prototype对象一样。</p>\n<p>这就是Javascript继承机制的设计思想。</p>\n<h1 id=\"三、构造函数的继承实例\"><a href=\"#三、构造函数的继承实例\" class=\"headerlink\" title=\"三、构造函数的继承实例\"></a>三、构造函数的继承实例</h1><p>通过上面对继承的了解，我们继续看实例。</p>\n<p>比如，现在有一个”动物”对象的构造函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.species = &quot;动物&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有一个”猫”对象的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function Cat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.color = color;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure>\n<p>怎样才能使”猫”继承”动物”呢？</p>\n<h4 id=\"1、-构造函数绑定\"><a href=\"#1、-构造函数绑定\" class=\"headerlink\" title=\"1、 构造函数绑定\"></a>1、 构造函数绑定</h4><p>第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function Cat(name,color)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　Animal.apply(this, arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　this.color = color;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2、-prototype模式\"><a href=\"#2、-prototype模式\" class=\"headerlink\" title=\"2、 prototype模式\"></a>2、 prototype模式</h4><p>第二种方法更常见，使用prototype属性。</p>\n<p>如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype = new Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<p>代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype = new Animal();</span><br></pre></td></tr></table></figure></p>\n<p>它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure></p>\n<p>原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(Cat.prototype.constructor == Animal); //true</span><br></pre></td></tr></table></figure></p>\n<p>更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(cat1.constructor == Cat.prototype.constructor); // true</span><br></pre></td></tr></table></figure></p>\n<p>因此，在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(cat1.constructor == Animal); // true</span><br></pre></td></tr></table></figure></p>\n<p>这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</p>\n<p>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　o.prototype = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o.prototype.constructor = o;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、-直接继承prototype\"><a href=\"#3、-直接继承prototype\" class=\"headerlink\" title=\"3、 直接继承prototype\"></a>3、 直接继承prototype</h4><p>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>\n<p>现在，我们先将Animal对象改写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function Animal()&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　Animal.prototype.species = &quot;动物&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype = Animal.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。</p>\n<p>所以，上面这一段代码其实是有问题的。请看第二行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure></p>\n<p>这一句实际上把Animal.prototype对象的constructor属性也改掉了！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(Animal.prototype.constructor); // Cat</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4、-利用空对象作为中介\"><a href=\"#4、-利用空对象作为中介\" class=\"headerlink\" title=\"4、 利用空对象作为中介\"></a>4、 利用空对象作为中介</h4><p>由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　var F = function()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">　　F.prototype = Animal.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　Cat.prototype = new F();</span><br><span class=\"line\"></span><br><span class=\"line\">　　Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure></p>\n<p>F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　alert(Animal.prototype.constructor); // Animal</span><br></pre></td></tr></table></figure></p>\n<p>我们将上面的方法，封装成一个函数，便于使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　function extend(Child, Parent) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　var F = function()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　F.prototype = Parent.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　Child.prototype = new F();</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　Child.uber = Parent.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用的时候，方法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　extend(Cat,Animal);</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<p>这个extend函数，就是YUI库如何实现继承的方法。</p>\n<p>另外，说明一点，函数体最后一行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　Child.uber = Parent.prototype;</span><br></pre></td></tr></table></figure></p>\n<p>意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>\n<h4 id=\"5、-拷贝继承\"><a href=\"#5、-拷贝继承\" class=\"headerlink\" title=\"5、 拷贝继承\"></a>5、 拷贝继承</h4><p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>\n<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function Animal()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　Animal.prototype.species = &quot;动物&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>然后，再写一个函数，实现属性拷贝的目的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function extend2(Child, Parent) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　var p = Parent.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　var c = Child.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　for (var i in p) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　　　c[i] = p[i];</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　c.uber = p;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。</p>\n<p>使用的时候，这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　extend2(Cat, Animal);</span><br><span class=\"line\"></span><br><span class=\"line\">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"四、完整的项目实例\"><a href=\"#四、完整的项目实例\" class=\"headerlink\" title=\"四、完整的项目实例\"></a>四、完整的项目实例</h1><p>下面是一个拖拽的实例。<br>html<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;drag Div&lt;/title&gt;</span><br><span class=\"line\">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">        #div1&#123;width: 100px;height: 100px;background: red;position: absolute;&#125;</span><br><span class=\"line\">        #div2&#123;width: 100px;height: 100px;background: yellow;position: absolute;&#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">    &lt;script src=&quot;drag.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;Limitdrag.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    window.onload=function()&#123;</span><br><span class=\"line\">        new Drag(&apos;div1&apos;);</span><br><span class=\"line\">        new LimitDrag(&apos;div2&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>首先创建一个基础的Drag构造函数，实现基础拖拽功能。<br>drag.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Drag(id)&#123;</span><br><span class=\"line\">    var _this=this;</span><br><span class=\"line\">    this.disX=0;</span><br><span class=\"line\">    this.dixY=0;</span><br><span class=\"line\">    this.oDiv=document.getElementById(id);</span><br><span class=\"line\">    this.oDiv.onmousedown=function(ev)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _this.fnDown(ev);</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Drag.prototype.fnDown=function(ev)&#123;</span><br><span class=\"line\">    var _this=this;</span><br><span class=\"line\">    var oEvent=ev||event;</span><br><span class=\"line\">    this.disX=oEvent.clientX-this.oDiv.offsetLeft;</span><br><span class=\"line\">    this.disY=oEvent.clientY-this.oDiv.offsetTop;</span><br><span class=\"line\">    document.onmousemove=function(ev)&#123;</span><br><span class=\"line\">        _this.fnMove(ev);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    document.onmouseup=function()&#123;</span><br><span class=\"line\">        _this.fnUp();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Drag.prototype.fnMove=function(ev)&#123;</span><br><span class=\"line\">    var oEvent=ev||event;</span><br><span class=\"line\">    this.oDiv.style.left=oEvent.clientX-this.disX+&apos;px&apos;;</span><br><span class=\"line\">    this.oDiv.style.top=oEvent.clientY-this.disY+&apos;px&apos;;</span><br><span class=\"line\">    // this.oDiv.style.left=l+&apos;px&apos;;</span><br><span class=\"line\">    // this.oDiv.style.top=t+&apos;px&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Drag.prototype.fnUp=function()&#123;</span><br><span class=\"line\">    document.onmousemove=null;</span><br><span class=\"line\">    document.onmouseup=null;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在上面基础实例上通过继承来完成进一步功能优化。<br>Limitdrag.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function LimitDrag(id)&#123;</span><br><span class=\"line\">    Drag.call(this,id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Drag.prototype,&apos;111&apos;)</span><br><span class=\"line\">console.log(Drag.LimitDrag,&apos;222&apos;)</span><br><span class=\"line\">for(var i in Drag.prototype)&#123;</span><br><span class=\"line\">    LimitDrag.prototype[i]=Drag.prototype[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(LimitDrag.prototype,&apos;333&apos;)</span><br><span class=\"line\">LimitDrag.prototype.fnMove=function(ev)&#123;</span><br><span class=\"line\">    var oEvent=ev||event;</span><br><span class=\"line\">    var l=oEvent.clientX-this.disX;</span><br><span class=\"line\">    var t=oEvent.clientY-this.disY;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (l&lt;0)</span><br><span class=\"line\">        &#123;l=0;&#125;</span><br><span class=\"line\">    else if(l&gt;document.documentElement.clientWidth-this.oDiv.offsetWidth)&#123;</span><br><span class=\"line\">        l=document.documentElement.clientWidth-this.oDiv.offsetWidth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        if (t&lt;0)</span><br><span class=\"line\">        &#123;t=0;&#125;</span><br><span class=\"line\">    else if(t&gt;document.documentElement.clientHeight-this.oDiv.offsetHeight)&#123;</span><br><span class=\"line\">        t=document.documentElement.clientHeight-this.oDiv.offsetHeight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.oDiv.style.left=l+&apos;px&apos;;</span><br><span class=\"line\">    this.oDiv.style.top=t+&apos;px&apos;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通过继承实现封装的代码看起来是不是很优雅，也非常方便后续修改和更新。</p>\n<h1 id=\"五、class继承\"><a href=\"#五、class继承\" class=\"headerlink\" title=\"五、class继承\"></a>五、class继承</h1><p>在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</p>\n<p>有没有更简单的写法？有！</p>\n<p>新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。</p>\n<p>我们先用函数实现Student的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Student(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.hello = function () &#123;</span><br><span class=\"line\">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用新的class关键字来编写Student，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student &#123;</span><br><span class=\"line\">    constructor(name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    hello() &#123;</span><br><span class=\"line\">        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {…}这样分散的代码。<br>最后实现的效果是一样的。</p>\n<p>用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PrimaryStudent extends Student &#123;</span><br><span class=\"line\">    constructor(name, grade) &#123;</span><br><span class=\"line\">        super(name); // 记得用super调用父类的构造方法!</span><br><span class=\"line\">        this.grade = grade;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    myGrade() &#123;</span><br><span class=\"line\">        alert(&apos;I am at grade &apos; + this.grade);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。</p>\n<p>PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。</p>\n<p>ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。</p>\n<p>那么，class这么好用，兼容性怎么样呢？</p>\n<p>不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以用Babel这个工具。</p>\n"},{"title":"深入理解React高阶组件","comments":1,"date":"2019-12-20T02:58:35.000Z","author":"jun.zhou","_content":"\n# 深入理解React高阶组件\n\n![image](https://img.fengjr.com/image/2019/12/20/60d95ae4b581d3ddb320d1fbba1d0ad3.jpg)\n\n## React 中的五种组件形式\n\n### 无状态组件\n\n无状态组件(Stateless Component)是最基础的组件形式，由于没有状态的影响所以就是纯静态展示的作用。一般来说，各种UI库里也是最开始会开发的组件类别。如按钮、标签、输入框等。它的基本组成结构就是属性（props）加上一个渲染函数（render）。由于不涉及到状态的更新，所以这种组件的复用性也最强。例如无状态的Hook 函数\n\n```JS\nconst PureComponent = (props) => (\n    <div>\n        //use props\n    </div>\n)\n```\n\n### 有状态组件\n\n在无状态组件的基础上，如果组件内部包含状态（state）且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件（Stateful Component）。有状态组件通常会带有生命周期(lifecycle)，用以在不同的时刻触发状态的更新。\n\n\n```JS\nclass StatefulComponent extends Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n           name: 1\n        }\n    }\n\n    componentWillMount() {\n        //do something\n    }\n\n    componentDidMount() {\n        //do something\n    }\n\n    render() {\n        return (\n           <div>\n            {this.state.name}\n           </div>\n        );\n    }\n}\n```\n\n### 容器组件\n\n容器组件的概念是将组件进一步解耦，将数据部分和UI进一步分离，所以为了使组件的功能进一步单一，引入了容器组件的概念（Container Component）\n\n\n```JS\nvar UserListContainer = React.createClass({\n  getInitialState: function() {\n    return {\n      users: []\n    }\n  },\n\n  componentDidMount: function() {\n    var _this = this;\n    axios.get('/path/to/user-api').then(function(response) {\n      _this.setState({users: response.data});\n    });\n  },\n\n  render: function() {\n    return (<UserList users={this.state.users} />);\n  }\n});\n```\n\n### 高阶组件\n\n高阶组件（HOC）是React中用作替代组件逻辑的一种高级技巧。HOC本身不是React API的一部分，它是一种基于React的组合特性而形成的设计模式。\n\n具体而言，高阶组件是参数为组件，返回更多新组件的函数。高阶组件本质上是一个函数，并不是一个组件\n\n\n```\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n```\n\n组件是将props转换为UI，而高阶组件是将组件转换为另外一个组件，高阶组件在第三方哭中也很常见，如Redux 的Connect \n\n例子如下\n\n```JS\nexport default function withLocalData (WrappedComponent){\n  return class extends Component {\n    constructor(props) {\n      super(props)\n      this.state = {}\n    }\n    componentWillMount() {\n      let data = localStorage.getItem('test_data')\n      this.setState({data})\n    }\n    render () {\n      return (\n        <WrappedComponent {...this.props} data={this.state.data} />\n      )\n    }\n  }\n}\n```\n\n### Render Callback 组件\n\n还有一种组件模式是在组件中使用渲染回调的方式，将组件中的渲染逻辑委托给其子组件。就像这样\n\n```JS\nimport { Component } from \"react\";\n\nclass RenderCallbackCmp extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      msg: \"hello\"\n    };\n  }\n\n  render() {\n    return this.props.children(this.state.msg);\n  }\n}\n\nconst ParentComponent = () =>\n  (<RenderCallbackCmp>\n    {msg =>\n      //use the msg\n      <div>\n        {msg}\n      </div>}\n  </RenderCallbackCmp>);\n```\n\n## 为什么要用高阶组件\n\nReact 中的高阶组件主要有两种形式：属性代理和反向继承\n\n### 属性代理\n\n\n```JS\n// 有状态\nfunction HigherOrderComponent(WrappedComponent) {\n    return class extends React.Component {\n        render() {\n            return <WrappedComponent {...this.props} />;\n        }\n    };\n}\n```\n\n可以发现，属性代理其实就是 一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件。\n\n属性代理可以做的事情：\n\n- 操作 props\n- 抽离 state\n- 通过 ref 访问到组件实例\n- 用其他元素包裹传入的组件 WrappedComponent\n\n\n\n假设现在有一个组件需要从localStorage 取数据渲染出来，那么可以这么处理\n\n\n```JS\nimport React, { Component } from 'react'\n\nclass MyComponent extends Component {\n\n  componentWillMount() {\n      let data = localStorage.getItem('data');\n      this.setState({data});\n  }\n\n  render() {\n    return <div>{this.state.data}</div>\n  }\n}\n```\n\n如果另外一个组件也要从localStorage 取出data的数据，那么还得需要在另外一个组件中也写同样的操作\n\n```JS\nimport React, { Component } from 'react'\n\nclass ExtraComponent extends Component {\n\n  componentWillMount() {\n      let data = localStorage.getItem('data');\n      this.setState({data});\n  }\n\n  render() {\n    return <div>{this.state.data}</div>\n  }\n}\n```\n\n大家可以看到同样的同样的代码执行了同样的代码，造成了代码冗余，下面我们看看用高阶组件怎么改成上面代码\n\n\n```JS\nfunction withLocalData (WrappedComponent){\n  return class extends Component {\n    constructor(props) {\n      super(props)\n      this.state = {}\n    }\n    componentWillMount() {\n      let data = localStorage.getItem('test_data')\n      this.setState({data})\n    }\n    render () {\n      return (\n        <WrappedComponent {...this.props} data={this.state.data} />\n      )\n    }\n  }\n}\n\nclass MyComponent extends Component {  \n  render() {\n    return <div>{this.props.data}</div>\n  }\n}\n\nconst MyComponentWithLocalData = withLocalData(MyComponent)\n\n```\n\nwithLocalData 就是一个高阶组件，它返回一个新的组件，在新组件的componentWillMount中统一处理从LocalStorage中获取数据的逻辑，然后将获取到的数据以属性的方式传递给被包装的组件WrappedComponent，这样在WrappedComponent中就可以直接使用this.props.data获取需要展示的数据了，其它组件也可以复用该高阶组件\n\n\n高阶组件的参数并非只能是一个组件，它还可以接收其他参数,比如上面是写死的test_data，我们要想获取传入的localStorage 值可以这么改写\n\n\n```JS\nfunction withLocalData (WrappedComponent, key){\n  return class extends Component {\n    constructor(props) {\n      super(props)\n      this.state = {}\n    }\n    componentWillMount() {\n      let data = localStorage.getItem(key)\n      this.setState({data})\n    }\n    render () {\n      return (\n        <WrappedComponent {...this.props} data={this.state.data} />\n      )\n    }\n  }\n}\n\nclass MyComponent extends Component {  \n  render() {\n    return <div>{this.props.data}</div>\n  }\n}\n\nclass MyComponent2 extends Component {  \n  render() {\n    return <div>{this.props.data}</div>\n  }\n}\n\nconst MyComponentWithLocalData = withLocalData(MyComponent, 'test_data')\nconst MyComponentWithLocalData2 = withLocalData(MyComponent2, 'name')\n\n```\n\n但我们常见的高阶组件一般都是这种格式，例如Redux 的connect函数\n\n```\nconst MyComponent = connect(mapStateToProps,mapDispatchToProps)(Component)\n```\n\n这种函数是这么实现的呢？我们可以对上面的函数进行如下改写\n\n```JS\nfunction withLocalData (key){\n  return (WrappedComponent) => {\n    return class extends Component {\n      constructor(props) {\n        super(props)\n        this.state = {}\n      }\n      componentWillMount() {\n        let data = localStorage.getItem(key)\n        this.setState({data})\n      }\n      render () {\n        return (\n          <WrappedComponent {...this.props} data={this.state.data} />\n        )\n      }\n    }\n  }\n}\n\nclass MyComponent extends Component {  \n  render() {\n    return <div>{this.props.data}</div>\n  }\n}\n\nconst MyComponentWithLocalData = withLocalData('test_data')(MyComponent)\n\n```\n\n我们会在redux中常看到上面的用法，Redux 的connect 其实就是使用了高阶组件，connect 函数如下\n\n```JS\nimport React from 'react'\nimport PropTypes from 'prop-types'\nconst connect = (mapStateToProps = state=>state, mapDispatchToProps = dispatch=>({}))=>(WrappedComponent)=> {\n    class Connect extends React.Component {\n        constructor() {\n            super()\n            this.state = {};\n        }\n\n        componentWillMount() {\n            this.unSubscribe = this.context.store.subscribe(()=> {\n                this.setState(mapStateToProps(this.context.store.getState()))\n            });\n        }\n\n        componentWillUnmount() {\n            this.unSubscribe();\n        }\n\n        render() {\n            return <WrappedComponent {...this.state}\n                {...mapDispatchToProps(this.context.store.dispatch)}\n            />\n        }\n    }\n    Connect.contextTypes = {\n        store: PropTypes.object\n    }\n    return Connect;\n}\n\n\nexport default connect\n```\n\nHOC不会修改继承的组件，也不会使用继承来复制其行为。相反，HOC通过将组件包装在容器组件中来组成新组件。HOC是纯函数，没有替代。\n\n### 反向继承（Inheritance Inversion）\n\n反向继承的实现\n\n\n```JS\nexport default function (WrappedComponent) {\n  return class Enhancer extends WrappedComponent {\n    static displayName = `InheritanceHOC(${getDisplayName(WrappedComponent)})`;\n\n    componentWillMount() {\n      // 可以方便地得到state，做一些更深入的修改。\n      this.setState({\n        innerText: '我被Inheritance修改了值'\n      });\n    }\n\n    render() {\n      return super.render();\n    }\n  };\n}\n```\n\n如你所见返回的高阶组件类（Enhancer）继承了 WrappedComponent。而之所以被称为反向继承是因为 WrappedComponent 被动地被 Enhancer\n继承，而不是 WrappedComponent 去继承 Enhancer。通过这种方式他们之间的关系倒转了。\n\n反向继承可以做什么：\n- 操作state\n- 渲染劫持\n\n\n#### 操作state\n\n高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state。甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理。\n\n\n```JS\nfunction withLogging(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            return (\n                <div>\n                    <h2>Debugger Component Logging...</h2>\n                    <p>state:</p>\n                    <pre>{JSON.stringify(this.state, null, 4)}</pre>\n                    <p>props:</p>\n                    <pre>{JSON.stringify(this.props, null, 4)}</pre>\n                    {super.render()}\n                </div>\n            );\n        }\n    };\n}\n\n```\n\n#### 渲染劫持\n\n之所以称之为 渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以\n\n- 有条件地展示元素树（element tree）\n- 操作由 render() 输出的 React 元素树\n- 在任何由 render() 输出的 React 元素中操作 props\n- 用其他元素包裹传入的组件 WrappedComponent （同 属性代理）\n\n##### 条件渲染\n\n通过 props.isLoading 这个条件来判断渲染哪个组件\n\n\n```JS\nfunction withLoading(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            if(this.props.isLoading) {\n                return <Loading />;\n            } else {\n                return super.render();\n            }\n        }\n    };\n}\n\n```\n\n##### 修改元素树\n\n\n```JS\nfunction HigherOrderComponent(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            const tree = super.render();\n            const newProps = {};\n            if (tree && tree.type === 'input') {\n                newProps.value = 'something here';\n            }\n            const props = {\n                ...tree.props,\n                ...newProps,\n            };\n            const newTree = React.cloneElement(tree, props, tree.props.children);\n            return newTree;\n        }\n    };\n}\n```\n\n## 注意事项\n\n### 不要改变原始组件，要用组合\n\n\n```JS\nfunction logProps(InputComponent) {\n  InputComponent.prototype.componentWillReceiveProps = function(nextProps) {\n    console.log('Current props: ', this.props);\n    console.log('Next props: ', nextProps);\n  };\n  // 返回原始的 input 组件，暗示它已经被修改。\n  return InputComponent;\n}\n\n// 每次调用 logProps 时，增强组件都会有 log 输出。\nconst EnhancedComponent = logProps(InputComponent);\n```\n\n这样做会产生一些不良后果。其一是输入组件再也无法像HOC增强之前那样使用了。更严重的是，如果你再用另一个相同会修改componentWillReceiveProps的HOC增强它，那么前面的HOC就会失效！同时，这个HOC也无法消除没有生命周期的函数组件。\n\nHOC不应该修改重构组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：\n\n\n```JS\nfunction logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    }\n    render() {\n      // 将 input 组件包装在容器中，而不对其进行修改。Good!\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n```\n\n您可能已经注意到HOC与容器组件模式之间有相似之处。容器组件保持分离将高层和低层关注的责任，由容器管理订阅和状态，并通过道具传递给处理渲染UI。HOC使用容器作为其实现的一部分，你可以将HOC视为参数化容器组件。\n\n### 包装显示名称方便调试\n\n最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 withSubscription，并且被包装组件的显示名称为 CommentList，显示名称应该为 WithSubscription(CommentList)：\n\n\n```JS\nfunction withSubscription(WrappedComponent) {\n  class WithSubscription extends React.Component {/* ... */}\n  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n  return WithSubscription;\n}\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n```\n\n### 不要在 render 方法中使用 HOC\n\nReact 的 diff 算法使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。\n\n通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：\n\n\n```JS\nrender() {\n  // 每次调用 render 函数都会创建一个新的 EnhancedComponent\n  // EnhancedComponent1 !== EnhancedComponent2\n  const EnhancedComponent = enhance(MyComponent);\n  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！\n  return <EnhancedComponent />;\n}\n```\n\n这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。\n\n如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。\n\n### 务必复制静态方法\n\n有时在 React 组件上定义静态方法很有用，但是，当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。\n\n```JS\n// 定义静态函数\nWrappedComponent.staticMethod = function() {/*...*/}\n// 现在使用 HOC\nconst EnhancedComponent = enhance(WrappedComponent);\n\n// 增强组件没有 staticMethod\ntypeof EnhancedComponent.staticMethod === 'undefined' // true\n```\n\n为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：\n\n```JS\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  // 必须准确知道应该拷贝哪些方法 :(\n  Enhance.staticMethod = WrappedComponent.staticMethod;\n  return Enhance;\n}\n```\n\n但要这样做，你需要知道哪些方法应该被拷贝。你可以使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:\n\n\n```JS\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  hoistNonReactStatic(Enhance, WrappedComponent);\n  return Enhance;\n}\n```\n\n除了导出组件，另一个可行的方案是再额外导出这个静态方法。\n\n\n```JS\n// 使用这种方式代替...\nMyComponent.someFunction = someFunction;\nexport default MyComponent;\n\n// ...单独导出该方法...\nexport { someFunction };\n\n// ...并在要使用的组件中，import 它们\nimport MyComponent, { someFunction } from './MyComponent.js';\n```\n\n### Refs 不会被传递\n\n虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。\n\n这个问题的解决方案可以通过使用React.forwardRef API（React 16.3 中引入）。\n\n\n```JS\nfunction logProps(Component) {\n  class LogProps extends React.Component {\n    componentDidUpdate(prevProps) {\n      console.log('old props:', prevProps);\n      console.log('new props:', this.props);\n    }\n\n    render() {\n      const {forwardedRef, ...rest} = this.props;\n\n      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref\n      return <Component ref={forwardedRef} {...rest} />;\n    }\n  }\n\n  // 注意 React.forwardRef 回调的第二个参数 “ref”。\n  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”\n  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。\n  return React.forwardRef((props, ref) => {\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n\n\n```\n\n\n\n\n","source":"_posts/2019-12-20-react-hoc.md","raw":"---\ntitle: 深入理解React高阶组件\ncomments: true\ndate: 2019-12-20 10:58:35\ntags:\n- react hoc html js\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n# 深入理解React高阶组件\n\n![image](https://img.fengjr.com/image/2019/12/20/60d95ae4b581d3ddb320d1fbba1d0ad3.jpg)\n\n## React 中的五种组件形式\n\n### 无状态组件\n\n无状态组件(Stateless Component)是最基础的组件形式，由于没有状态的影响所以就是纯静态展示的作用。一般来说，各种UI库里也是最开始会开发的组件类别。如按钮、标签、输入框等。它的基本组成结构就是属性（props）加上一个渲染函数（render）。由于不涉及到状态的更新，所以这种组件的复用性也最强。例如无状态的Hook 函数\n\n```JS\nconst PureComponent = (props) => (\n    <div>\n        //use props\n    </div>\n)\n```\n\n### 有状态组件\n\n在无状态组件的基础上，如果组件内部包含状态（state）且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件（Stateful Component）。有状态组件通常会带有生命周期(lifecycle)，用以在不同的时刻触发状态的更新。\n\n\n```JS\nclass StatefulComponent extends Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n           name: 1\n        }\n    }\n\n    componentWillMount() {\n        //do something\n    }\n\n    componentDidMount() {\n        //do something\n    }\n\n    render() {\n        return (\n           <div>\n            {this.state.name}\n           </div>\n        );\n    }\n}\n```\n\n### 容器组件\n\n容器组件的概念是将组件进一步解耦，将数据部分和UI进一步分离，所以为了使组件的功能进一步单一，引入了容器组件的概念（Container Component）\n\n\n```JS\nvar UserListContainer = React.createClass({\n  getInitialState: function() {\n    return {\n      users: []\n    }\n  },\n\n  componentDidMount: function() {\n    var _this = this;\n    axios.get('/path/to/user-api').then(function(response) {\n      _this.setState({users: response.data});\n    });\n  },\n\n  render: function() {\n    return (<UserList users={this.state.users} />);\n  }\n});\n```\n\n### 高阶组件\n\n高阶组件（HOC）是React中用作替代组件逻辑的一种高级技巧。HOC本身不是React API的一部分，它是一种基于React的组合特性而形成的设计模式。\n\n具体而言，高阶组件是参数为组件，返回更多新组件的函数。高阶组件本质上是一个函数，并不是一个组件\n\n\n```\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n```\n\n组件是将props转换为UI，而高阶组件是将组件转换为另外一个组件，高阶组件在第三方哭中也很常见，如Redux 的Connect \n\n例子如下\n\n```JS\nexport default function withLocalData (WrappedComponent){\n  return class extends Component {\n    constructor(props) {\n      super(props)\n      this.state = {}\n    }\n    componentWillMount() {\n      let data = localStorage.getItem('test_data')\n      this.setState({data})\n    }\n    render () {\n      return (\n        <WrappedComponent {...this.props} data={this.state.data} />\n      )\n    }\n  }\n}\n```\n\n### Render Callback 组件\n\n还有一种组件模式是在组件中使用渲染回调的方式，将组件中的渲染逻辑委托给其子组件。就像这样\n\n```JS\nimport { Component } from \"react\";\n\nclass RenderCallbackCmp extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      msg: \"hello\"\n    };\n  }\n\n  render() {\n    return this.props.children(this.state.msg);\n  }\n}\n\nconst ParentComponent = () =>\n  (<RenderCallbackCmp>\n    {msg =>\n      //use the msg\n      <div>\n        {msg}\n      </div>}\n  </RenderCallbackCmp>);\n```\n\n## 为什么要用高阶组件\n\nReact 中的高阶组件主要有两种形式：属性代理和反向继承\n\n### 属性代理\n\n\n```JS\n// 有状态\nfunction HigherOrderComponent(WrappedComponent) {\n    return class extends React.Component {\n        render() {\n            return <WrappedComponent {...this.props} />;\n        }\n    };\n}\n```\n\n可以发现，属性代理其实就是 一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件。\n\n属性代理可以做的事情：\n\n- 操作 props\n- 抽离 state\n- 通过 ref 访问到组件实例\n- 用其他元素包裹传入的组件 WrappedComponent\n\n\n\n假设现在有一个组件需要从localStorage 取数据渲染出来，那么可以这么处理\n\n\n```JS\nimport React, { Component } from 'react'\n\nclass MyComponent extends Component {\n\n  componentWillMount() {\n      let data = localStorage.getItem('data');\n      this.setState({data});\n  }\n\n  render() {\n    return <div>{this.state.data}</div>\n  }\n}\n```\n\n如果另外一个组件也要从localStorage 取出data的数据，那么还得需要在另外一个组件中也写同样的操作\n\n```JS\nimport React, { Component } from 'react'\n\nclass ExtraComponent extends Component {\n\n  componentWillMount() {\n      let data = localStorage.getItem('data');\n      this.setState({data});\n  }\n\n  render() {\n    return <div>{this.state.data}</div>\n  }\n}\n```\n\n大家可以看到同样的同样的代码执行了同样的代码，造成了代码冗余，下面我们看看用高阶组件怎么改成上面代码\n\n\n```JS\nfunction withLocalData (WrappedComponent){\n  return class extends Component {\n    constructor(props) {\n      super(props)\n      this.state = {}\n    }\n    componentWillMount() {\n      let data = localStorage.getItem('test_data')\n      this.setState({data})\n    }\n    render () {\n      return (\n        <WrappedComponent {...this.props} data={this.state.data} />\n      )\n    }\n  }\n}\n\nclass MyComponent extends Component {  \n  render() {\n    return <div>{this.props.data}</div>\n  }\n}\n\nconst MyComponentWithLocalData = withLocalData(MyComponent)\n\n```\n\nwithLocalData 就是一个高阶组件，它返回一个新的组件，在新组件的componentWillMount中统一处理从LocalStorage中获取数据的逻辑，然后将获取到的数据以属性的方式传递给被包装的组件WrappedComponent，这样在WrappedComponent中就可以直接使用this.props.data获取需要展示的数据了，其它组件也可以复用该高阶组件\n\n\n高阶组件的参数并非只能是一个组件，它还可以接收其他参数,比如上面是写死的test_data，我们要想获取传入的localStorage 值可以这么改写\n\n\n```JS\nfunction withLocalData (WrappedComponent, key){\n  return class extends Component {\n    constructor(props) {\n      super(props)\n      this.state = {}\n    }\n    componentWillMount() {\n      let data = localStorage.getItem(key)\n      this.setState({data})\n    }\n    render () {\n      return (\n        <WrappedComponent {...this.props} data={this.state.data} />\n      )\n    }\n  }\n}\n\nclass MyComponent extends Component {  \n  render() {\n    return <div>{this.props.data}</div>\n  }\n}\n\nclass MyComponent2 extends Component {  \n  render() {\n    return <div>{this.props.data}</div>\n  }\n}\n\nconst MyComponentWithLocalData = withLocalData(MyComponent, 'test_data')\nconst MyComponentWithLocalData2 = withLocalData(MyComponent2, 'name')\n\n```\n\n但我们常见的高阶组件一般都是这种格式，例如Redux 的connect函数\n\n```\nconst MyComponent = connect(mapStateToProps,mapDispatchToProps)(Component)\n```\n\n这种函数是这么实现的呢？我们可以对上面的函数进行如下改写\n\n```JS\nfunction withLocalData (key){\n  return (WrappedComponent) => {\n    return class extends Component {\n      constructor(props) {\n        super(props)\n        this.state = {}\n      }\n      componentWillMount() {\n        let data = localStorage.getItem(key)\n        this.setState({data})\n      }\n      render () {\n        return (\n          <WrappedComponent {...this.props} data={this.state.data} />\n        )\n      }\n    }\n  }\n}\n\nclass MyComponent extends Component {  \n  render() {\n    return <div>{this.props.data}</div>\n  }\n}\n\nconst MyComponentWithLocalData = withLocalData('test_data')(MyComponent)\n\n```\n\n我们会在redux中常看到上面的用法，Redux 的connect 其实就是使用了高阶组件，connect 函数如下\n\n```JS\nimport React from 'react'\nimport PropTypes from 'prop-types'\nconst connect = (mapStateToProps = state=>state, mapDispatchToProps = dispatch=>({}))=>(WrappedComponent)=> {\n    class Connect extends React.Component {\n        constructor() {\n            super()\n            this.state = {};\n        }\n\n        componentWillMount() {\n            this.unSubscribe = this.context.store.subscribe(()=> {\n                this.setState(mapStateToProps(this.context.store.getState()))\n            });\n        }\n\n        componentWillUnmount() {\n            this.unSubscribe();\n        }\n\n        render() {\n            return <WrappedComponent {...this.state}\n                {...mapDispatchToProps(this.context.store.dispatch)}\n            />\n        }\n    }\n    Connect.contextTypes = {\n        store: PropTypes.object\n    }\n    return Connect;\n}\n\n\nexport default connect\n```\n\nHOC不会修改继承的组件，也不会使用继承来复制其行为。相反，HOC通过将组件包装在容器组件中来组成新组件。HOC是纯函数，没有替代。\n\n### 反向继承（Inheritance Inversion）\n\n反向继承的实现\n\n\n```JS\nexport default function (WrappedComponent) {\n  return class Enhancer extends WrappedComponent {\n    static displayName = `InheritanceHOC(${getDisplayName(WrappedComponent)})`;\n\n    componentWillMount() {\n      // 可以方便地得到state，做一些更深入的修改。\n      this.setState({\n        innerText: '我被Inheritance修改了值'\n      });\n    }\n\n    render() {\n      return super.render();\n    }\n  };\n}\n```\n\n如你所见返回的高阶组件类（Enhancer）继承了 WrappedComponent。而之所以被称为反向继承是因为 WrappedComponent 被动地被 Enhancer\n继承，而不是 WrappedComponent 去继承 Enhancer。通过这种方式他们之间的关系倒转了。\n\n反向继承可以做什么：\n- 操作state\n- 渲染劫持\n\n\n#### 操作state\n\n高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state。甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理。\n\n\n```JS\nfunction withLogging(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            return (\n                <div>\n                    <h2>Debugger Component Logging...</h2>\n                    <p>state:</p>\n                    <pre>{JSON.stringify(this.state, null, 4)}</pre>\n                    <p>props:</p>\n                    <pre>{JSON.stringify(this.props, null, 4)}</pre>\n                    {super.render()}\n                </div>\n            );\n        }\n    };\n}\n\n```\n\n#### 渲染劫持\n\n之所以称之为 渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以\n\n- 有条件地展示元素树（element tree）\n- 操作由 render() 输出的 React 元素树\n- 在任何由 render() 输出的 React 元素中操作 props\n- 用其他元素包裹传入的组件 WrappedComponent （同 属性代理）\n\n##### 条件渲染\n\n通过 props.isLoading 这个条件来判断渲染哪个组件\n\n\n```JS\nfunction withLoading(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            if(this.props.isLoading) {\n                return <Loading />;\n            } else {\n                return super.render();\n            }\n        }\n    };\n}\n\n```\n\n##### 修改元素树\n\n\n```JS\nfunction HigherOrderComponent(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            const tree = super.render();\n            const newProps = {};\n            if (tree && tree.type === 'input') {\n                newProps.value = 'something here';\n            }\n            const props = {\n                ...tree.props,\n                ...newProps,\n            };\n            const newTree = React.cloneElement(tree, props, tree.props.children);\n            return newTree;\n        }\n    };\n}\n```\n\n## 注意事项\n\n### 不要改变原始组件，要用组合\n\n\n```JS\nfunction logProps(InputComponent) {\n  InputComponent.prototype.componentWillReceiveProps = function(nextProps) {\n    console.log('Current props: ', this.props);\n    console.log('Next props: ', nextProps);\n  };\n  // 返回原始的 input 组件，暗示它已经被修改。\n  return InputComponent;\n}\n\n// 每次调用 logProps 时，增强组件都会有 log 输出。\nconst EnhancedComponent = logProps(InputComponent);\n```\n\n这样做会产生一些不良后果。其一是输入组件再也无法像HOC增强之前那样使用了。更严重的是，如果你再用另一个相同会修改componentWillReceiveProps的HOC增强它，那么前面的HOC就会失效！同时，这个HOC也无法消除没有生命周期的函数组件。\n\nHOC不应该修改重构组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：\n\n\n```JS\nfunction logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    }\n    render() {\n      // 将 input 组件包装在容器中，而不对其进行修改。Good!\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n```\n\n您可能已经注意到HOC与容器组件模式之间有相似之处。容器组件保持分离将高层和低层关注的责任，由容器管理订阅和状态，并通过道具传递给处理渲染UI。HOC使用容器作为其实现的一部分，你可以将HOC视为参数化容器组件。\n\n### 包装显示名称方便调试\n\n最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 withSubscription，并且被包装组件的显示名称为 CommentList，显示名称应该为 WithSubscription(CommentList)：\n\n\n```JS\nfunction withSubscription(WrappedComponent) {\n  class WithSubscription extends React.Component {/* ... */}\n  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n  return WithSubscription;\n}\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n```\n\n### 不要在 render 方法中使用 HOC\n\nReact 的 diff 算法使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。\n\n通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：\n\n\n```JS\nrender() {\n  // 每次调用 render 函数都会创建一个新的 EnhancedComponent\n  // EnhancedComponent1 !== EnhancedComponent2\n  const EnhancedComponent = enhance(MyComponent);\n  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！\n  return <EnhancedComponent />;\n}\n```\n\n这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。\n\n如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。\n\n### 务必复制静态方法\n\n有时在 React 组件上定义静态方法很有用，但是，当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。\n\n```JS\n// 定义静态函数\nWrappedComponent.staticMethod = function() {/*...*/}\n// 现在使用 HOC\nconst EnhancedComponent = enhance(WrappedComponent);\n\n// 增强组件没有 staticMethod\ntypeof EnhancedComponent.staticMethod === 'undefined' // true\n```\n\n为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：\n\n```JS\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  // 必须准确知道应该拷贝哪些方法 :(\n  Enhance.staticMethod = WrappedComponent.staticMethod;\n  return Enhance;\n}\n```\n\n但要这样做，你需要知道哪些方法应该被拷贝。你可以使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:\n\n\n```JS\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  hoistNonReactStatic(Enhance, WrappedComponent);\n  return Enhance;\n}\n```\n\n除了导出组件，另一个可行的方案是再额外导出这个静态方法。\n\n\n```JS\n// 使用这种方式代替...\nMyComponent.someFunction = someFunction;\nexport default MyComponent;\n\n// ...单独导出该方法...\nexport { someFunction };\n\n// ...并在要使用的组件中，import 它们\nimport MyComponent, { someFunction } from './MyComponent.js';\n```\n\n### Refs 不会被传递\n\n虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。\n\n这个问题的解决方案可以通过使用React.forwardRef API（React 16.3 中引入）。\n\n\n```JS\nfunction logProps(Component) {\n  class LogProps extends React.Component {\n    componentDidUpdate(prevProps) {\n      console.log('old props:', prevProps);\n      console.log('new props:', this.props);\n    }\n\n    render() {\n      const {forwardedRef, ...rest} = this.props;\n\n      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref\n      return <Component ref={forwardedRef} {...rest} />;\n    }\n  }\n\n  // 注意 React.forwardRef 回调的第二个参数 “ref”。\n  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”\n  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。\n  return React.forwardRef((props, ref) => {\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n\n\n```\n\n\n\n\n","slug":"react-hoc","published":1,"updated":"2020-06-10T06:01:33.958Z","_id":"ck8r6c15o0001imq6ixxwvdn4","layout":"post","photos":[],"link":"","content":"<h1 id=\"深入理解React高阶组件\"><a href=\"#深入理解React高阶组件\" class=\"headerlink\" title=\"深入理解React高阶组件\"></a>深入理解React高阶组件</h1><p><img src=\"https://img.fengjr.com/image/2019/12/20/60d95ae4b581d3ddb320d1fbba1d0ad3.jpg\" alt=\"image\"></p>\n<h2 id=\"React-中的五种组件形式\"><a href=\"#React-中的五种组件形式\" class=\"headerlink\" title=\"React 中的五种组件形式\"></a>React 中的五种组件形式</h2><h3 id=\"无状态组件\"><a href=\"#无状态组件\" class=\"headerlink\" title=\"无状态组件\"></a>无状态组件</h3><p>无状态组件(Stateless Component)是最基础的组件形式，由于没有状态的影响所以就是纯静态展示的作用。一般来说，各种UI库里也是最开始会开发的组件类别。如按钮、标签、输入框等。它的基本组成结构就是属性（props）加上一个渲染函数（render）。由于不涉及到状态的更新，所以这种组件的复用性也最强。例如无状态的Hook 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PureComponent = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        <span class=\"comment\">//use props</span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"有状态组件\"><a href=\"#有状态组件\" class=\"headerlink\" title=\"有状态组件\"></a>有状态组件</h3><p>在无状态组件的基础上，如果组件内部包含状态（state）且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件（Stateful Component）。有状态组件通常会带有生命周期(lifecycle)，用以在不同的时刻触发状态的更新。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">           name: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">           &lt;div&gt;</span><br><span class=\"line\">            &#123;<span class=\"keyword\">this</span>.state.name&#125;</span><br><span class=\"line\">           &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"容器组件\"><a href=\"#容器组件\" class=\"headerlink\" title=\"容器组件\"></a>容器组件</h3><p>容器组件的概念是将组件进一步解耦，将数据部分和UI进一步分离，所以为了使组件的功能进一步单一，引入了容器组件的概念（Container Component）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> UserListContainer = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      users: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    axios.get(<span class=\"string\">'/path/to/user-api'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">      _this.setState(&#123;<span class=\"attr\">users</span>: response.data&#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UserList</span> <span class=\"attr\">users</span>=<span class=\"string\">&#123;this.state.users&#125;</span> /&gt;</span>);</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><p>高阶组件（HOC）是React中用作替代组件逻辑的一种高级技巧。HOC本身不是React API的一部分，它是一种基于React的组合特性而形成的设计模式。</p>\n<p>具体而言，高阶组件是参数为组件，返回更多新组件的函数。高阶组件本质上是一个函数，并不是一个组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>\n<p>组件是将props转换为UI，而高阶组件是将组件转换为另外一个组件，高阶组件在第三方哭中也很常见，如Redux 的Connect </p>\n<p>例子如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLocalData</span> (<span class=\"params\">WrappedComponent</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(<span class=\"string\">'test_data'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;WrappedComponent &#123;...this.props&#125; data=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Render-Callback-组件\"><a href=\"#Render-Callback-组件\" class=\"headerlink\" title=\"Render Callback 组件\"></a>Render Callback 组件</h3><p>还有一种组件模式是在组件中使用渲染回调的方式，将组件中的渲染逻辑委托给其子组件。就像这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RenderCallbackCmp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      msg: <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ParentComponent = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">RenderCallbackCmp</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#123;msg =&gt;</span></span><br><span class=\"line\"><span class=\"xml\">      //use the msg</span></span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;msg&#125;</span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>&#125;</span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">RenderCallbackCmp</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么要用高阶组件\"><a href=\"#为什么要用高阶组件\" class=\"headerlink\" title=\"为什么要用高阶组件\"></a>为什么要用高阶组件</h2><p>React 中的高阶组件主要有两种形式：属性代理和反向继承</p>\n<h3 id=\"属性代理\"><a href=\"#属性代理\" class=\"headerlink\" title=\"属性代理\"></a>属性代理</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，属性代理其实就是 一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件。</p>\n<p>属性代理可以做的事情：</p>\n<ul>\n<li>操作 props</li>\n<li>抽离 state</li>\n<li>通过 ref 访问到组件实例</li>\n<li>用其他元素包裹传入的组件 WrappedComponent</li>\n</ul>\n<p>假设现在有一个组件需要从localStorage 取数据渲染出来，那么可以这么处理</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(<span class=\"string\">'data'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.state.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果另外一个组件也要从localStorage 取出data的数据，那么还得需要在另外一个组件中也写同样的操作</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtraComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(<span class=\"string\">'data'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.state.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家可以看到同样的同样的代码执行了同样的代码，造成了代码冗余，下面我们看看用高阶组件怎么改成上面代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLocalData</span> (<span class=\"params\">WrappedComponent</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(<span class=\"string\">'test_data'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;WrappedComponent &#123;...this.props&#125; data=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponentWithLocalData = withLocalData(MyComponent)</span><br></pre></td></tr></table></figure>\n<p>withLocalData 就是一个高阶组件，它返回一个新的组件，在新组件的componentWillMount中统一处理从LocalStorage中获取数据的逻辑，然后将获取到的数据以属性的方式传递给被包装的组件WrappedComponent，这样在WrappedComponent中就可以直接使用this.props.data获取需要展示的数据了，其它组件也可以复用该高阶组件</p>\n<p>高阶组件的参数并非只能是一个组件，它还可以接收其他参数,比如上面是写死的test_data，我们要想获取传入的localStorage 值可以这么改写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLocalData</span> (<span class=\"params\">WrappedComponent, key</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(key)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;WrappedComponent &#123;...this.props&#125; data=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponentWithLocalData = withLocalData(MyComponent, <span class=\"string\">'test_data'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponentWithLocalData2 = withLocalData(MyComponent2, <span class=\"string\">'name'</span>)</span><br></pre></td></tr></table></figure>\n<p>但我们常见的高阶组件一般都是这种格式，例如Redux 的connect函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyComponent = connect(mapStateToProps,mapDispatchToProps)(Component)</span><br></pre></td></tr></table></figure>\n<p>这种函数是这么实现的呢？我们可以对上面的函数进行如下改写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLocalData</span> (<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      componentWillMount() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = localStorage.getItem(key)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;data&#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          &lt;WrappedComponent &#123;...this.props&#125; data=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponentWithLocalData = withLocalData(<span class=\"string\">'test_data'</span>)(MyComponent)</span><br></pre></td></tr></table></figure>\n<p>我们会在redux中常看到上面的用法，Redux 的connect 其实就是使用了高阶组件，connect 函数如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state=&gt;state, mapDispatchToProps = dispatch=&gt;(&#123;&#125;</span>))=&gt;</span><span class=\"function\">(<span class=\"params\">WrappedComponent</span>)=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>()</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.state = &#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentWillMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.unSubscribe = <span class=\"keyword\">this</span>.context.store.subscribe(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.setState(mapStateToProps(<span class=\"keyword\">this</span>.context.store.getState()))</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentWillUnmount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.unSubscribe();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.state</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"xml\">                &#123;...mapDispatchToProps(this.context.store.dispatch)&#125;</span></span><br><span class=\"line\"><span class=\"xml\">            /&gt;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    Connect.contextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"xml\">        store: PropTypes.object</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    return Connect;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">export default connect</span></span><br></pre></td></tr></table></figure>\n<p>HOC不会修改继承的组件，也不会使用继承来复制其行为。相反，HOC通过将组件包装在容器组件中来组成新组件。HOC是纯函数，没有替代。</p>\n<h3 id=\"反向继承（Inheritance-Inversion）\"><a href=\"#反向继承（Inheritance-Inversion）\" class=\"headerlink\" title=\"反向继承（Inheritance Inversion）\"></a>反向继承（Inheritance Inversion）</h3><p>反向继承的实现</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhancer</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> displayName = <span class=\"string\">`InheritanceHOC(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 可以方便地得到state，做一些更深入的修改。</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        innerText: <span class=\"string\">'我被Inheritance修改了值'</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如你所见返回的高阶组件类（Enhancer）继承了 WrappedComponent。而之所以被称为反向继承是因为 WrappedComponent 被动地被 Enhancer<br>继承，而不是 WrappedComponent 去继承 Enhancer。通过这种方式他们之间的关系倒转了。</p>\n<p>反向继承可以做什么：</p>\n<ul>\n<li>操作state</li>\n<li>渲染劫持</li>\n</ul>\n<h4 id=\"操作state\"><a href=\"#操作state\" class=\"headerlink\" title=\"操作state\"></a>操作state</h4><p>高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state。甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLogging</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;h2&gt;Debugger Component Logging...&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                    &lt;p&gt;state:&lt;/</span>p&gt;</span><br><span class=\"line\">                    &lt;pre&gt;&#123;<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.state, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)&#125;&lt;<span class=\"regexp\">/pre&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                    &lt;p&gt;props:&lt;/</span>p&gt;</span><br><span class=\"line\">                    &lt;pre&gt;&#123;<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.props, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)&#125;&lt;<span class=\"regexp\">/pre&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                    &#123;super.render()&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;/</span>div&gt;</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"渲染劫持\"><a href=\"#渲染劫持\" class=\"headerlink\" title=\"渲染劫持\"></a>渲染劫持</h4><p>之所以称之为 渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以</p>\n<ul>\n<li>有条件地展示元素树（element tree）</li>\n<li>操作由 render() 输出的 React 元素树</li>\n<li>在任何由 render() 输出的 React 元素中操作 props</li>\n<li>用其他元素包裹传入的组件 WrappedComponent （同 属性代理）</li>\n</ul>\n<h5 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h5><p>通过 props.isLoading 这个条件来判断渲染哪个组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLoading</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.isLoading) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Loading</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">            &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"xml\">                return super.render();</span></span><br><span class=\"line\"><span class=\"xml\">            &#125;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"修改元素树\"><a href=\"#修改元素树\" class=\"headerlink\" title=\"修改元素树\"></a>修改元素树</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> tree = <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newProps = &#123;&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tree &amp;&amp; tree.type === <span class=\"string\">'input'</span>) &#123;</span><br><span class=\"line\">                newProps.value = <span class=\"string\">'something here'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> props = &#123;</span><br><span class=\"line\">                ...tree.props,</span><br><span class=\"line\">                ...newProps,</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newTree = React.cloneElement(tree, props, tree.props.children);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newTree;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"不要改变原始组件，要用组合\"><a href=\"#不要改变原始组件，要用组合\" class=\"headerlink\" title=\"不要改变原始组件，要用组合\"></a>不要改变原始组件，要用组合</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">InputComponent</span>) </span>&#123;</span><br><span class=\"line\">  InputComponent.prototype.componentWillReceiveProps = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextProps</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props: '</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props: '</span>, nextProps);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 返回原始的 input 组件，暗示它已经被修改。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> InputComponent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每次调用 logProps 时，增强组件都会有 log 输出。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure>\n<p>这样做会产生一些不良后果。其一是输入组件再也无法像HOC增强之前那样使用了。更严重的是，如果你再用另一个相同会修改componentWillReceiveProps的HOC增强它，那么前面的HOC就会失效！同时，这个HOC也无法消除没有生命周期的函数组件。</p>\n<p>HOC不应该修改重构组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props: '</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props: '</span>, nextProps);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 将 input 组件包装在容器中，而不对其进行修改。Good!</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>您可能已经注意到HOC与容器组件模式之间有相似之处。容器组件保持分离将高层和低层关注的责任，由容器管理订阅和状态，并通过道具传递给处理渲染UI。HOC使用容器作为其实现的一部分，你可以将HOC视为参数化容器组件。</p>\n<h3 id=\"包装显示名称方便调试\"><a href=\"#包装显示名称方便调试\" class=\"headerlink\" title=\"包装显示名称方便调试\"></a>包装显示名称方便调试</h3><p>最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 withSubscription，并且被包装组件的显示名称为 CommentList，显示名称应该为 WithSubscription(CommentList)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withSubscription</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WithSubscription</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">  WithSubscription.displayName = <span class=\"string\">`WithSubscription(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> WithSubscription;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDisplayName</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class=\"string\">'Component'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不要在-render-方法中使用-HOC\"><a href=\"#不要在-render-方法中使用-HOC\" class=\"headerlink\" title=\"不要在 render 方法中使用 HOC\"></a>不要在 render 方法中使用 HOC</h3><p>React 的 diff 算法使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。</p>\n<p>通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 每次调用 render 函数都会创建一个新的 EnhancedComponent</span></span><br><span class=\"line\">  <span class=\"comment\">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class=\"line\">  <span class=\"comment\">// 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">EnhancedComponent</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。</p>\n<p>如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。</p>\n<h3 id=\"务必复制静态方法\"><a href=\"#务必复制静态方法\" class=\"headerlink\" title=\"务必复制静态方法\"></a>务必复制静态方法</h3><p>有时在 React 组件上定义静态方法很有用，但是，当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义静态函数</span></span><br><span class=\"line\">WrappedComponent.staticMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// 现在使用 HOC</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = enhance(WrappedComponent);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 增强组件没有 staticMethod</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> EnhancedComponent.staticMethod === <span class=\"string\">'undefined'</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhance</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 必须准确知道应该拷贝哪些方法 :(</span></span><br><span class=\"line\">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但要这样做，你需要知道哪些方法应该被拷贝。你可以使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hoistNonReactStatic <span class=\"keyword\">from</span> <span class=\"string\">'hoist-non-react-statics'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhance</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了导出组件，另一个可行的方案是再额外导出这个静态方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用这种方式代替...</span></span><br><span class=\"line\">MyComponent.someFunction = someFunction;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyComponent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...单独导出该方法...</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; someFunction &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...并在要使用的组件中，import 它们</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> MyComponent, &#123; someFunction &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./MyComponent.js'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Refs-不会被传递\"><a href=\"#Refs-不会被传递\" class=\"headerlink\" title=\"Refs 不会被传递\"></a>Refs 不会被传递</h3><p>虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p>\n<p>这个问题的解决方案可以通过使用React.forwardRef API（React 16.3 中引入）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">Component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogProps</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    componentDidUpdate(prevProps) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'old props:'</span>, prevProps);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'new props:'</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123;forwardedRef, ...rest&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;forwardedRef&#125;</span> &#123;<span class=\"attr\">...rest</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // 注意 React.forwardRef 回调的第二个参数 “ref”。</span></span><br><span class=\"line\"><span class=\"xml\">  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span></span><br><span class=\"line\"><span class=\"xml\">  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span></span><br><span class=\"line\"><span class=\"xml\">  return React.forwardRef((props, ref) =&gt; &#123;</span></span><br><span class=\"line\">    return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"深入理解React高阶组件\"><a href=\"#深入理解React高阶组件\" class=\"headerlink\" title=\"深入理解React高阶组件\"></a>深入理解React高阶组件</h1><p><img src=\"https://img.fengjr.com/image/2019/12/20/60d95ae4b581d3ddb320d1fbba1d0ad3.jpg\" alt=\"image\"></p>\n<h2 id=\"React-中的五种组件形式\"><a href=\"#React-中的五种组件形式\" class=\"headerlink\" title=\"React 中的五种组件形式\"></a>React 中的五种组件形式</h2><h3 id=\"无状态组件\"><a href=\"#无状态组件\" class=\"headerlink\" title=\"无状态组件\"></a>无状态组件</h3><p>无状态组件(Stateless Component)是最基础的组件形式，由于没有状态的影响所以就是纯静态展示的作用。一般来说，各种UI库里也是最开始会开发的组件类别。如按钮、标签、输入框等。它的基本组成结构就是属性（props）加上一个渲染函数（render）。由于不涉及到状态的更新，所以这种组件的复用性也最强。例如无状态的Hook 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PureComponent = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        <span class=\"comment\">//use props</span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"有状态组件\"><a href=\"#有状态组件\" class=\"headerlink\" title=\"有状态组件\"></a>有状态组件</h3><p>在无状态组件的基础上，如果组件内部包含状态（state）且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件（Stateful Component）。有状态组件通常会带有生命周期(lifecycle)，用以在不同的时刻触发状态的更新。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">           name: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">           &lt;div&gt;</span><br><span class=\"line\">            &#123;<span class=\"keyword\">this</span>.state.name&#125;</span><br><span class=\"line\">           &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"容器组件\"><a href=\"#容器组件\" class=\"headerlink\" title=\"容器组件\"></a>容器组件</h3><p>容器组件的概念是将组件进一步解耦，将数据部分和UI进一步分离，所以为了使组件的功能进一步单一，引入了容器组件的概念（Container Component）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> UserListContainer = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      users: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    axios.get(<span class=\"string\">'/path/to/user-api'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">      _this.setState(&#123;<span class=\"attr\">users</span>: response.data&#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UserList</span> <span class=\"attr\">users</span>=<span class=\"string\">&#123;this.state.users&#125;</span> /&gt;</span>);</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><p>高阶组件（HOC）是React中用作替代组件逻辑的一种高级技巧。HOC本身不是React API的一部分，它是一种基于React的组合特性而形成的设计模式。</p>\n<p>具体而言，高阶组件是参数为组件，返回更多新组件的函数。高阶组件本质上是一个函数，并不是一个组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>\n<p>组件是将props转换为UI，而高阶组件是将组件转换为另外一个组件，高阶组件在第三方哭中也很常见，如Redux 的Connect </p>\n<p>例子如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLocalData</span> (<span class=\"params\">WrappedComponent</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(<span class=\"string\">'test_data'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;WrappedComponent &#123;...this.props&#125; data=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Render-Callback-组件\"><a href=\"#Render-Callback-组件\" class=\"headerlink\" title=\"Render Callback 组件\"></a>Render Callback 组件</h3><p>还有一种组件模式是在组件中使用渲染回调的方式，将组件中的渲染逻辑委托给其子组件。就像这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RenderCallbackCmp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      msg: <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ParentComponent = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">RenderCallbackCmp</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#123;msg =&gt;</span></span><br><span class=\"line\"><span class=\"xml\">      //use the msg</span></span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;msg&#125;</span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>&#125;</span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">RenderCallbackCmp</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么要用高阶组件\"><a href=\"#为什么要用高阶组件\" class=\"headerlink\" title=\"为什么要用高阶组件\"></a>为什么要用高阶组件</h2><p>React 中的高阶组件主要有两种形式：属性代理和反向继承</p>\n<h3 id=\"属性代理\"><a href=\"#属性代理\" class=\"headerlink\" title=\"属性代理\"></a>属性代理</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，属性代理其实就是 一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件。</p>\n<p>属性代理可以做的事情：</p>\n<ul>\n<li>操作 props</li>\n<li>抽离 state</li>\n<li>通过 ref 访问到组件实例</li>\n<li>用其他元素包裹传入的组件 WrappedComponent</li>\n</ul>\n<p>假设现在有一个组件需要从localStorage 取数据渲染出来，那么可以这么处理</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(<span class=\"string\">'data'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.state.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果另外一个组件也要从localStorage 取出data的数据，那么还得需要在另外一个组件中也写同样的操作</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtraComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(<span class=\"string\">'data'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.state.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家可以看到同样的同样的代码执行了同样的代码，造成了代码冗余，下面我们看看用高阶组件怎么改成上面代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLocalData</span> (<span class=\"params\">WrappedComponent</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(<span class=\"string\">'test_data'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;WrappedComponent &#123;...this.props&#125; data=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponentWithLocalData = withLocalData(MyComponent)</span><br></pre></td></tr></table></figure>\n<p>withLocalData 就是一个高阶组件，它返回一个新的组件，在新组件的componentWillMount中统一处理从LocalStorage中获取数据的逻辑，然后将获取到的数据以属性的方式传递给被包装的组件WrappedComponent，这样在WrappedComponent中就可以直接使用this.props.data获取需要展示的数据了，其它组件也可以复用该高阶组件</p>\n<p>高阶组件的参数并非只能是一个组件，它还可以接收其他参数,比如上面是写死的test_data，我们要想获取传入的localStorage 值可以这么改写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLocalData</span> (<span class=\"params\">WrappedComponent, key</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = localStorage.getItem(key)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;data&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;WrappedComponent &#123;...this.props&#125; data=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponentWithLocalData = withLocalData(MyComponent, <span class=\"string\">'test_data'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponentWithLocalData2 = withLocalData(MyComponent2, <span class=\"string\">'name'</span>)</span><br></pre></td></tr></table></figure>\n<p>但我们常见的高阶组件一般都是这种格式，例如Redux 的connect函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyComponent = connect(mapStateToProps,mapDispatchToProps)(Component)</span><br></pre></td></tr></table></figure>\n<p>这种函数是这么实现的呢？我们可以对上面的函数进行如下改写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLocalData</span> (<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      componentWillMount() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = localStorage.getItem(key)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;data&#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          &lt;WrappedComponent &#123;...this.props&#125; data=&#123;<span class=\"keyword\">this</span>.state.data&#125; /&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyComponentWithLocalData = withLocalData(<span class=\"string\">'test_data'</span>)(MyComponent)</span><br></pre></td></tr></table></figure>\n<p>我们会在redux中常看到上面的用法，Redux 的connect 其实就是使用了高阶组件，connect 函数如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state=&gt;state, mapDispatchToProps = dispatch=&gt;(&#123;&#125;</span>))=&gt;</span><span class=\"function\">(<span class=\"params\">WrappedComponent</span>)=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>()</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.state = &#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentWillMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.unSubscribe = <span class=\"keyword\">this</span>.context.store.subscribe(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.setState(mapStateToProps(<span class=\"keyword\">this</span>.context.store.getState()))</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentWillUnmount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.unSubscribe();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.state</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"xml\">                &#123;...mapDispatchToProps(this.context.store.dispatch)&#125;</span></span><br><span class=\"line\"><span class=\"xml\">            /&gt;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    Connect.contextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"xml\">        store: PropTypes.object</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    return Connect;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">export default connect</span></span><br></pre></td></tr></table></figure>\n<p>HOC不会修改继承的组件，也不会使用继承来复制其行为。相反，HOC通过将组件包装在容器组件中来组成新组件。HOC是纯函数，没有替代。</p>\n<h3 id=\"反向继承（Inheritance-Inversion）\"><a href=\"#反向继承（Inheritance-Inversion）\" class=\"headerlink\" title=\"反向继承（Inheritance Inversion）\"></a>反向继承（Inheritance Inversion）</h3><p>反向继承的实现</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhancer</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> displayName = <span class=\"string\">`InheritanceHOC(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 可以方便地得到state，做一些更深入的修改。</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        innerText: <span class=\"string\">'我被Inheritance修改了值'</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如你所见返回的高阶组件类（Enhancer）继承了 WrappedComponent。而之所以被称为反向继承是因为 WrappedComponent 被动地被 Enhancer<br>继承，而不是 WrappedComponent 去继承 Enhancer。通过这种方式他们之间的关系倒转了。</p>\n<p>反向继承可以做什么：</p>\n<ul>\n<li>操作state</li>\n<li>渲染劫持</li>\n</ul>\n<h4 id=\"操作state\"><a href=\"#操作state\" class=\"headerlink\" title=\"操作state\"></a>操作state</h4><p>高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state。甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLogging</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;h2&gt;Debugger Component Logging...&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                    &lt;p&gt;state:&lt;/</span>p&gt;</span><br><span class=\"line\">                    &lt;pre&gt;&#123;<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.state, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)&#125;&lt;<span class=\"regexp\">/pre&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                    &lt;p&gt;props:&lt;/</span>p&gt;</span><br><span class=\"line\">                    &lt;pre&gt;&#123;<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.props, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)&#125;&lt;<span class=\"regexp\">/pre&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                    &#123;super.render()&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;/</span>div&gt;</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"渲染劫持\"><a href=\"#渲染劫持\" class=\"headerlink\" title=\"渲染劫持\"></a>渲染劫持</h4><p>之所以称之为 渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以</p>\n<ul>\n<li>有条件地展示元素树（element tree）</li>\n<li>操作由 render() 输出的 React 元素树</li>\n<li>在任何由 render() 输出的 React 元素中操作 props</li>\n<li>用其他元素包裹传入的组件 WrappedComponent （同 属性代理）</li>\n</ul>\n<h5 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h5><p>通过 props.isLoading 这个条件来判断渲染哪个组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLoading</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.isLoading) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Loading</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">            &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"xml\">                return super.render();</span></span><br><span class=\"line\"><span class=\"xml\">            &#125;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"修改元素树\"><a href=\"#修改元素树\" class=\"headerlink\" title=\"修改元素树\"></a>修改元素树</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> tree = <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newProps = &#123;&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tree &amp;&amp; tree.type === <span class=\"string\">'input'</span>) &#123;</span><br><span class=\"line\">                newProps.value = <span class=\"string\">'something here'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> props = &#123;</span><br><span class=\"line\">                ...tree.props,</span><br><span class=\"line\">                ...newProps,</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newTree = React.cloneElement(tree, props, tree.props.children);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newTree;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"不要改变原始组件，要用组合\"><a href=\"#不要改变原始组件，要用组合\" class=\"headerlink\" title=\"不要改变原始组件，要用组合\"></a>不要改变原始组件，要用组合</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">InputComponent</span>) </span>&#123;</span><br><span class=\"line\">  InputComponent.prototype.componentWillReceiveProps = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextProps</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props: '</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props: '</span>, nextProps);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 返回原始的 input 组件，暗示它已经被修改。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> InputComponent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每次调用 logProps 时，增强组件都会有 log 输出。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure>\n<p>这样做会产生一些不良后果。其一是输入组件再也无法像HOC增强之前那样使用了。更严重的是，如果你再用另一个相同会修改componentWillReceiveProps的HOC增强它，那么前面的HOC就会失效！同时，这个HOC也无法消除没有生命周期的函数组件。</p>\n<p>HOC不应该修改重构组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props: '</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props: '</span>, nextProps);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 将 input 组件包装在容器中，而不对其进行修改。Good!</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>您可能已经注意到HOC与容器组件模式之间有相似之处。容器组件保持分离将高层和低层关注的责任，由容器管理订阅和状态，并通过道具传递给处理渲染UI。HOC使用容器作为其实现的一部分，你可以将HOC视为参数化容器组件。</p>\n<h3 id=\"包装显示名称方便调试\"><a href=\"#包装显示名称方便调试\" class=\"headerlink\" title=\"包装显示名称方便调试\"></a>包装显示名称方便调试</h3><p>最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 withSubscription，并且被包装组件的显示名称为 CommentList，显示名称应该为 WithSubscription(CommentList)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withSubscription</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WithSubscription</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">  WithSubscription.displayName = <span class=\"string\">`WithSubscription(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> WithSubscription;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDisplayName</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class=\"string\">'Component'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"不要在-render-方法中使用-HOC\"><a href=\"#不要在-render-方法中使用-HOC\" class=\"headerlink\" title=\"不要在 render 方法中使用 HOC\"></a>不要在 render 方法中使用 HOC</h3><p>React 的 diff 算法使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。</p>\n<p>通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 每次调用 render 函数都会创建一个新的 EnhancedComponent</span></span><br><span class=\"line\">  <span class=\"comment\">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class=\"line\">  <span class=\"comment\">// 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">EnhancedComponent</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。</p>\n<p>如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。</p>\n<h3 id=\"务必复制静态方法\"><a href=\"#务必复制静态方法\" class=\"headerlink\" title=\"务必复制静态方法\"></a>务必复制静态方法</h3><p>有时在 React 组件上定义静态方法很有用，但是，当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义静态函数</span></span><br><span class=\"line\">WrappedComponent.staticMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// 现在使用 HOC</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = enhance(WrappedComponent);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 增强组件没有 staticMethod</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> EnhancedComponent.staticMethod === <span class=\"string\">'undefined'</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhance</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 必须准确知道应该拷贝哪些方法 :(</span></span><br><span class=\"line\">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但要这样做，你需要知道哪些方法应该被拷贝。你可以使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hoistNonReactStatic <span class=\"keyword\">from</span> <span class=\"string\">'hoist-non-react-statics'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhance</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了导出组件，另一个可行的方案是再额外导出这个静态方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用这种方式代替...</span></span><br><span class=\"line\">MyComponent.someFunction = someFunction;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyComponent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...单独导出该方法...</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; someFunction &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...并在要使用的组件中，import 它们</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> MyComponent, &#123; someFunction &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./MyComponent.js'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Refs-不会被传递\"><a href=\"#Refs-不会被传递\" class=\"headerlink\" title=\"Refs 不会被传递\"></a>Refs 不会被传递</h3><p>虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p>\n<p>这个问题的解决方案可以通过使用React.forwardRef API（React 16.3 中引入）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">Component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogProps</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    componentDidUpdate(prevProps) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'old props:'</span>, prevProps);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'new props:'</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123;forwardedRef, ...rest&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;forwardedRef&#125;</span> &#123;<span class=\"attr\">...rest</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // 注意 React.forwardRef 回调的第二个参数 “ref”。</span></span><br><span class=\"line\"><span class=\"xml\">  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span></span><br><span class=\"line\"><span class=\"xml\">  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span></span><br><span class=\"line\"><span class=\"xml\">  return React.forwardRef((props, ref) =&gt; &#123;</span></span><br><span class=\"line\">    return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"WebRTC本地测试配置","comments":0,"date":"2019-12-30T02:58:28.000Z","updated":"2020-06-10T06:01:30.172Z","author":"jun.zhou","_content":"\n### 1 问题\nWebRTC是HTML5支持的重要特性之一，有了它，不再需要借助音视频相关的客户端，直接通过浏览器的Web页面就可以实现音视频对聊功能。在局域网中，通过信令服务器，\n可以建立两个客户端的链接。信令服务器是基于websocket的，用于实时传递消息。\n大概的过程是两个客户端同时连上服务器，然后其中一个发起视频请求。一般情况下我们用http协议，在pc上测试没有什么问题，但是在手机上，尤其是ios的微信中做测试就比较麻烦了，那要怎么配置呢？\n需求开启摄像头一般都需要https协议，对应的websocket也要用wss协议，由于微信里面只识别域名，因此还需要域名映射，ios手机对https还需要进行安全协议认证。\n### 2 创建证书\nhttps和wss协议需要安全证书，我们采用mkcert工具来生成\n1. 安装 在mac下 brew install mkcert\n2. 生成CA （certificate authority，即证书颁发机构）\nmkcert -install\n上面的命令可以生成CA，可以用 mkcert -CAROOT 来查看CA所在目录\n3. 创建自签名证书 例如创建test.qb.com创建证书，可以使用如下的命令\nmkcert test.qb.com\n上述命令会自动使用第3步创建的CA生成证书文件，其中qb.com+5.pem为证书，qb.com+5-key.pem为私钥。\n\n### 3 前端服务配置\n\n以create-react-app创建的项目为例，前端开启https服务，\n1. 在项目的package.json文件添加\n```javascript\n\"scripts\":{\n\"https\": \"HTTPS=true PORT=3020 node scripts/start.js\"\n}\n```\n2. 在config的webpackDevServer.config.js文件修改https的key和cert为之前生成的证书地址，代码如下：\n```javascript\n// Enable HTTPS if the HTTPS environment variable is set to 'true'\nhttps: protocol === 'https'?{\n  key: fs.readFileSync('/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem'),\n  cert: fs.readFileSync('/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem')\n}:false,\n```\n3. 启动 npm run https\n   这里面启动的3020端口，一般https默认采用443端口，如果启动443则需要 sudo npm run https\n4. 访问地址 https://localhost:3020/\n\n### 4 后端配置\nindexWss.js文件\n```JavaScript\nvar https = require('https');\nvar ws = require('ws');\nvar fs = require('fs');\nlet keypath='/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem';//mkcert 生成的key\nlet certpath='/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem';\nvar options = {\n    key: fs.readFileSync(keypath),\n    cert: fs.readFileSync(certpath),\n    passphrase: '123456'//如果秘钥文件有密码的话，用这个属性设置密码\n};\nlet port = process.env.PORT || 8095;\nvar server = https.createServer(options, function (req, res) {//要是单纯的https连接的话就会返回这个东西\n    res.writeHead(403);//403即可\n    res.end(\"This is a  WebSockets server!\\n\");\n}).listen(port);\nvar wss = new ws.Server({server: server});//把创建好的https服务器丢进websocket的创建函数里，ws会用这个服务器来创建wss服务\nwss.on('connection', function (conn) {\n    ///\n    /// 业务逻辑\n    ///\n});\n```\n启动代码：node indexWss.js\n访问地址：wss://localhost:8095\n\n到现在为止，我们可以通过ip地址的方式在电脑上访问。\n\n### 5 域名映射\n\n1. 打开在etc/hosts文件 sudo vi hosts\n2. 添加  127.0.0.1     test.qb.com  后保存\n\n### 6 nginx配置\n\n```nginx\nserver {\n   listen       443 ssl;\n   server_name  test.qb.com;\n\n   ssl_certificate      \"/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem\";\n   ssl_certificate_key  \"/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem\";\n\n   ssl_session_cache    shared:SSL:1m;\n   ssl_session_timeout  5m;\n\n   ssl_ciphers  HIGH:!aNULL:!MD5;\n   ssl_prefer_server_ciphers  on;\n\n   location /web/ {\n      proxy_pass   https://localhost:3020/;\n   }\n   location ^~ /wss2 {\n       proxy_pass   https://localhost:8095;\n       proxy_http_version   1.1;\n       proxy_set_header Upgrade   $http_upgrade;\n       proxy_set_header Connection   \"upgrade\";\n   }\n}\n```\n通过nginx，我们用test.qb.com域名服务代理转发了前端https和后端wss服务，\n我们可以通过 https://test.qb.com/web  来访问页面\n\n### 7 charles代理\n通过以上步骤，我们可以用域名访问服务了，但是手机上还是无法用，这时就需要charles代理了。\n1. 打开代理，安装pc端证书：help->SSL Proxying->Install Charles Root Certificate\n2. 手机端连接代理，先查看代理地址和端口号，help-SSL Proxying->Install Charles Root Certificate on a Mobile Device or Remote Browser\n   在弹出的对话框中可以看到ip地址和端口号\n   在手机wifi中开启代理，输入ip地址和端口号\n3. 安装手机端证书， 连接好代理后，在手机浏览器中打开 chls.pro/ssl 下载并安装证书\n   ios设备需要进入设置->通用->描述文件与设备中进行授权\n4. 访问 https://test.qb.com/web  此时发现ios下wss还是报错，可以下载安装我们生成的rootCA.pem和qb.com+5.pem证书\n5. 如果ios下面，wss还是报错，进入设置->通用->关于本机->证书信任设置->开启对证书的完全信任\n### 8 兼容性\n\n目前测试的兼容性\n    pc-mac  chrome    ✅️\n    pc-mac  safari    ✅️\n    pc-mac  opera     ✅️\n    android huawei    ❌\n    android chrome    ✅️\n    android weixin    ✅️\n    ios     safari    ✅️\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2019-12-30-webrtc本地测试配置.md","raw":"---\ntitle: WebRTC本地测试配置\ncomments: false\ndate: 2019-12-30 10:58:28\ntags:\n- js\nupdated:\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n### 1 问题\nWebRTC是HTML5支持的重要特性之一，有了它，不再需要借助音视频相关的客户端，直接通过浏览器的Web页面就可以实现音视频对聊功能。在局域网中，通过信令服务器，\n可以建立两个客户端的链接。信令服务器是基于websocket的，用于实时传递消息。\n大概的过程是两个客户端同时连上服务器，然后其中一个发起视频请求。一般情况下我们用http协议，在pc上测试没有什么问题，但是在手机上，尤其是ios的微信中做测试就比较麻烦了，那要怎么配置呢？\n需求开启摄像头一般都需要https协议，对应的websocket也要用wss协议，由于微信里面只识别域名，因此还需要域名映射，ios手机对https还需要进行安全协议认证。\n### 2 创建证书\nhttps和wss协议需要安全证书，我们采用mkcert工具来生成\n1. 安装 在mac下 brew install mkcert\n2. 生成CA （certificate authority，即证书颁发机构）\nmkcert -install\n上面的命令可以生成CA，可以用 mkcert -CAROOT 来查看CA所在目录\n3. 创建自签名证书 例如创建test.qb.com创建证书，可以使用如下的命令\nmkcert test.qb.com\n上述命令会自动使用第3步创建的CA生成证书文件，其中qb.com+5.pem为证书，qb.com+5-key.pem为私钥。\n\n### 3 前端服务配置\n\n以create-react-app创建的项目为例，前端开启https服务，\n1. 在项目的package.json文件添加\n```javascript\n\"scripts\":{\n\"https\": \"HTTPS=true PORT=3020 node scripts/start.js\"\n}\n```\n2. 在config的webpackDevServer.config.js文件修改https的key和cert为之前生成的证书地址，代码如下：\n```javascript\n// Enable HTTPS if the HTTPS environment variable is set to 'true'\nhttps: protocol === 'https'?{\n  key: fs.readFileSync('/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem'),\n  cert: fs.readFileSync('/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem')\n}:false,\n```\n3. 启动 npm run https\n   这里面启动的3020端口，一般https默认采用443端口，如果启动443则需要 sudo npm run https\n4. 访问地址 https://localhost:3020/\n\n### 4 后端配置\nindexWss.js文件\n```JavaScript\nvar https = require('https');\nvar ws = require('ws');\nvar fs = require('fs');\nlet keypath='/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem';//mkcert 生成的key\nlet certpath='/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem';\nvar options = {\n    key: fs.readFileSync(keypath),\n    cert: fs.readFileSync(certpath),\n    passphrase: '123456'//如果秘钥文件有密码的话，用这个属性设置密码\n};\nlet port = process.env.PORT || 8095;\nvar server = https.createServer(options, function (req, res) {//要是单纯的https连接的话就会返回这个东西\n    res.writeHead(403);//403即可\n    res.end(\"This is a  WebSockets server!\\n\");\n}).listen(port);\nvar wss = new ws.Server({server: server});//把创建好的https服务器丢进websocket的创建函数里，ws会用这个服务器来创建wss服务\nwss.on('connection', function (conn) {\n    ///\n    /// 业务逻辑\n    ///\n});\n```\n启动代码：node indexWss.js\n访问地址：wss://localhost:8095\n\n到现在为止，我们可以通过ip地址的方式在电脑上访问。\n\n### 5 域名映射\n\n1. 打开在etc/hosts文件 sudo vi hosts\n2. 添加  127.0.0.1     test.qb.com  后保存\n\n### 6 nginx配置\n\n```nginx\nserver {\n   listen       443 ssl;\n   server_name  test.qb.com;\n\n   ssl_certificate      \"/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem\";\n   ssl_certificate_key  \"/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem\";\n\n   ssl_session_cache    shared:SSL:1m;\n   ssl_session_timeout  5m;\n\n   ssl_ciphers  HIGH:!aNULL:!MD5;\n   ssl_prefer_server_ciphers  on;\n\n   location /web/ {\n      proxy_pass   https://localhost:3020/;\n   }\n   location ^~ /wss2 {\n       proxy_pass   https://localhost:8095;\n       proxy_http_version   1.1;\n       proxy_set_header Upgrade   $http_upgrade;\n       proxy_set_header Connection   \"upgrade\";\n   }\n}\n```\n通过nginx，我们用test.qb.com域名服务代理转发了前端https和后端wss服务，\n我们可以通过 https://test.qb.com/web  来访问页面\n\n### 7 charles代理\n通过以上步骤，我们可以用域名访问服务了，但是手机上还是无法用，这时就需要charles代理了。\n1. 打开代理，安装pc端证书：help->SSL Proxying->Install Charles Root Certificate\n2. 手机端连接代理，先查看代理地址和端口号，help-SSL Proxying->Install Charles Root Certificate on a Mobile Device or Remote Browser\n   在弹出的对话框中可以看到ip地址和端口号\n   在手机wifi中开启代理，输入ip地址和端口号\n3. 安装手机端证书， 连接好代理后，在手机浏览器中打开 chls.pro/ssl 下载并安装证书\n   ios设备需要进入设置->通用->描述文件与设备中进行授权\n4. 访问 https://test.qb.com/web  此时发现ios下wss还是报错，可以下载安装我们生成的rootCA.pem和qb.com+5.pem证书\n5. 如果ios下面，wss还是报错，进入设置->通用->关于本机->证书信任设置->开启对证书的完全信任\n### 8 兼容性\n\n目前测试的兼容性\n    pc-mac  chrome    ✅️\n    pc-mac  safari    ✅️\n    pc-mac  opera     ✅️\n    android huawei    ❌\n    android chrome    ✅️\n    android weixin    ✅️\n    ios     safari    ✅️\n\n\n\n\n\n\n\n\n\n\n","slug":"webrtc本地测试配置","published":1,"_id":"ck8r6c15v0003imq6t36tasyi","layout":"post","photos":[],"link":"","content":"<h3 id=\"1-问题\"><a href=\"#1-问题\" class=\"headerlink\" title=\"1 问题\"></a>1 问题</h3><p>WebRTC是HTML5支持的重要特性之一，有了它，不再需要借助音视频相关的客户端，直接通过浏览器的Web页面就可以实现音视频对聊功能。在局域网中，通过信令服务器，<br>可以建立两个客户端的链接。信令服务器是基于websocket的，用于实时传递消息。<br>大概的过程是两个客户端同时连上服务器，然后其中一个发起视频请求。一般情况下我们用http协议，在pc上测试没有什么问题，但是在手机上，尤其是ios的微信中做测试就比较麻烦了，那要怎么配置呢？<br>需求开启摄像头一般都需要https协议，对应的websocket也要用wss协议，由于微信里面只识别域名，因此还需要域名映射，ios手机对https还需要进行安全协议认证。</p>\n<h3 id=\"2-创建证书\"><a href=\"#2-创建证书\" class=\"headerlink\" title=\"2 创建证书\"></a>2 创建证书</h3><p>https和wss协议需要安全证书，我们采用mkcert工具来生成</p>\n<ol>\n<li>安装 在mac下 brew install mkcert</li>\n<li>生成CA （certificate authority，即证书颁发机构）<br>mkcert -install<br>上面的命令可以生成CA，可以用 mkcert -CAROOT 来查看CA所在目录</li>\n<li>创建自签名证书 例如创建test.qb.com创建证书，可以使用如下的命令<br>mkcert test.qb.com<br>上述命令会自动使用第3步创建的CA生成证书文件，其中qb.com+5.pem为证书，qb.com+5-key.pem为私钥。</li>\n</ol>\n<h3 id=\"3-前端服务配置\"><a href=\"#3-前端服务配置\" class=\"headerlink\" title=\"3 前端服务配置\"></a>3 前端服务配置</h3><p>以create-react-app创建的项目为例，前端开启https服务，</p>\n<ol>\n<li><p>在项目的package.json文件添加</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\"><span class=\"string\">\"https\"</span>: <span class=\"string\">\"HTTPS=true PORT=3020 node scripts/start.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在config的webpackDevServer.config.js文件修改https的key和cert为之前生成的证书地址，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Enable HTTPS if the HTTPS environment variable is set to 'true'</span></span><br><span class=\"line\">https: protocol === <span class=\"string\">'https'</span>?&#123;</span><br><span class=\"line\">  key: fs.readFileSync(<span class=\"string\">'/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem'</span>),</span><br><span class=\"line\">  cert: fs.readFileSync(<span class=\"string\">'/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem'</span>)</span><br><span class=\"line\">&#125;:<span class=\"literal\">false</span>,</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动 npm run https<br>这里面启动的3020端口，一般https默认采用443端口，如果启动443则需要 sudo npm run https</p>\n</li>\n<li>访问地址 <a href=\"https://localhost:3020/\" target=\"_blank\" rel=\"noopener\">https://localhost:3020/</a></li>\n</ol>\n<h3 id=\"4-后端配置\"><a href=\"#4-后端配置\" class=\"headerlink\" title=\"4 后端配置\"></a>4 后端配置</h3><p>indexWss.js文件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> https = <span class=\"built_in\">require</span>(<span class=\"string\">'https'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"built_in\">require</span>(<span class=\"string\">'ws'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> keypath=<span class=\"string\">'/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem'</span>;<span class=\"comment\">//mkcert 生成的key</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> certpath=<span class=\"string\">'/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">    key: fs.readFileSync(keypath),</span><br><span class=\"line\">    cert: fs.readFileSync(certpath),</span><br><span class=\"line\">    passphrase: <span class=\"string\">'123456'</span><span class=\"comment\">//如果秘钥文件有密码的话，用这个属性设置密码</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> port = process.env.PORT || <span class=\"number\">8095</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> server = https.createServer(options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;<span class=\"comment\">//要是单纯的https连接的话就会返回这个东西</span></span><br><span class=\"line\">    res.writeHead(<span class=\"number\">403</span>);<span class=\"comment\">//403即可</span></span><br><span class=\"line\">    res.end(<span class=\"string\">\"This is a  WebSockets server!\\n\"</span>);</span><br><span class=\"line\">&#125;).listen(port);</span><br><span class=\"line\"><span class=\"keyword\">var</span> wss = <span class=\"keyword\">new</span> ws.Server(&#123;<span class=\"attr\">server</span>: server&#125;);<span class=\"comment\">//把创建好的https服务器丢进websocket的创建函数里，ws会用这个服务器来创建wss服务</span></span><br><span class=\"line\">wss.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">conn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// 业务逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>启动代码：node indexWss.js<br>访问地址：wss://localhost:8095</p>\n<p>到现在为止，我们可以通过ip地址的方式在电脑上访问。</p>\n<h3 id=\"5-域名映射\"><a href=\"#5-域名映射\" class=\"headerlink\" title=\"5 域名映射\"></a>5 域名映射</h3><ol>\n<li>打开在etc/hosts文件 sudo vi hosts</li>\n<li>添加  127.0.0.1     test.qb.com  后保存</li>\n</ol>\n<h3 id=\"6-nginx配置\"><a href=\"#6-nginx配置\" class=\"headerlink\" title=\"6 nginx配置\"></a>6 nginx配置</h3><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">   <span class=\"attribute\">listen</span>       <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">   <span class=\"attribute\">server_name</span>  test.qb.com;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"attribute\">ssl_certificate</span>      <span class=\"string\">\"/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem\"</span>;</span><br><span class=\"line\">   <span class=\"attribute\">ssl_certificate_key</span>  <span class=\"string\">\"/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"attribute\">ssl_session_cache</span>    shared:SSL:<span class=\"number\">1m</span>;</span><br><span class=\"line\">   <span class=\"attribute\">ssl_session_timeout</span>  <span class=\"number\">5m</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"attribute\">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class=\"line\">   <span class=\"attribute\">ssl_prefer_server_ciphers</span>  <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"attribute\">location</span> /web/ &#123;</span><br><span class=\"line\">      <span class=\"attribute\">proxy_pass</span>   https://localhost:3020/;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"attribute\">location</span><span class=\"regexp\"> ^~</span> /wss2 &#123;</span><br><span class=\"line\">       <span class=\"attribute\">proxy_pass</span>   https://localhost:8095;</span><br><span class=\"line\">       <span class=\"attribute\">proxy_http_version</span>   <span class=\"number\">1</span>.<span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"attribute\">proxy_set_header</span> Upgrade   <span class=\"variable\">$http_upgrade</span>;</span><br><span class=\"line\">       <span class=\"attribute\">proxy_set_header</span> Connection   <span class=\"string\">\"upgrade\"</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过nginx，我们用test.qb.com域名服务代理转发了前端https和后端wss服务，<br>我们可以通过 <a href=\"https://test.qb.com/web\" target=\"_blank\" rel=\"noopener\">https://test.qb.com/web</a>  来访问页面</p>\n<h3 id=\"7-charles代理\"><a href=\"#7-charles代理\" class=\"headerlink\" title=\"7 charles代理\"></a>7 charles代理</h3><p>通过以上步骤，我们可以用域名访问服务了，但是手机上还是无法用，这时就需要charles代理了。</p>\n<ol>\n<li>打开代理，安装pc端证书：help-&gt;SSL Proxying-&gt;Install Charles Root Certificate</li>\n<li>手机端连接代理，先查看代理地址和端口号，help-SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser<br>在弹出的对话框中可以看到ip地址和端口号<br>在手机wifi中开启代理，输入ip地址和端口号</li>\n<li>安装手机端证书， 连接好代理后，在手机浏览器中打开 chls.pro/ssl 下载并安装证书<br>ios设备需要进入设置-&gt;通用-&gt;描述文件与设备中进行授权</li>\n<li>访问 <a href=\"https://test.qb.com/web\" target=\"_blank\" rel=\"noopener\">https://test.qb.com/web</a>  此时发现ios下wss还是报错，可以下载安装我们生成的rootCA.pem和qb.com+5.pem证书</li>\n<li>如果ios下面，wss还是报错，进入设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt;开启对证书的完全信任<h3 id=\"8-兼容性\"><a href=\"#8-兼容性\" class=\"headerlink\" title=\"8 兼容性\"></a>8 兼容性</h3></li>\n</ol>\n<p>目前测试的兼容性<br>    pc-mac  chrome    ✅️<br>    pc-mac  safari    ✅️<br>    pc-mac  opera     ✅️<br>    android huawei    ❌<br>    android chrome    ✅️<br>    android weixin    ✅️<br>    ios     safari    ✅️</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-问题\"><a href=\"#1-问题\" class=\"headerlink\" title=\"1 问题\"></a>1 问题</h3><p>WebRTC是HTML5支持的重要特性之一，有了它，不再需要借助音视频相关的客户端，直接通过浏览器的Web页面就可以实现音视频对聊功能。在局域网中，通过信令服务器，<br>可以建立两个客户端的链接。信令服务器是基于websocket的，用于实时传递消息。<br>大概的过程是两个客户端同时连上服务器，然后其中一个发起视频请求。一般情况下我们用http协议，在pc上测试没有什么问题，但是在手机上，尤其是ios的微信中做测试就比较麻烦了，那要怎么配置呢？<br>需求开启摄像头一般都需要https协议，对应的websocket也要用wss协议，由于微信里面只识别域名，因此还需要域名映射，ios手机对https还需要进行安全协议认证。</p>\n<h3 id=\"2-创建证书\"><a href=\"#2-创建证书\" class=\"headerlink\" title=\"2 创建证书\"></a>2 创建证书</h3><p>https和wss协议需要安全证书，我们采用mkcert工具来生成</p>\n<ol>\n<li>安装 在mac下 brew install mkcert</li>\n<li>生成CA （certificate authority，即证书颁发机构）<br>mkcert -install<br>上面的命令可以生成CA，可以用 mkcert -CAROOT 来查看CA所在目录</li>\n<li>创建自签名证书 例如创建test.qb.com创建证书，可以使用如下的命令<br>mkcert test.qb.com<br>上述命令会自动使用第3步创建的CA生成证书文件，其中qb.com+5.pem为证书，qb.com+5-key.pem为私钥。</li>\n</ol>\n<h3 id=\"3-前端服务配置\"><a href=\"#3-前端服务配置\" class=\"headerlink\" title=\"3 前端服务配置\"></a>3 前端服务配置</h3><p>以create-react-app创建的项目为例，前端开启https服务，</p>\n<ol>\n<li><p>在项目的package.json文件添加</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\"><span class=\"string\">\"https\"</span>: <span class=\"string\">\"HTTPS=true PORT=3020 node scripts/start.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在config的webpackDevServer.config.js文件修改https的key和cert为之前生成的证书地址，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Enable HTTPS if the HTTPS environment variable is set to 'true'</span></span><br><span class=\"line\">https: protocol === <span class=\"string\">'https'</span>?&#123;</span><br><span class=\"line\">  key: fs.readFileSync(<span class=\"string\">'/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem'</span>),</span><br><span class=\"line\">  cert: fs.readFileSync(<span class=\"string\">'/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem'</span>)</span><br><span class=\"line\">&#125;:<span class=\"literal\">false</span>,</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动 npm run https<br>这里面启动的3020端口，一般https默认采用443端口，如果启动443则需要 sudo npm run https</p>\n</li>\n<li>访问地址 <a href=\"https://localhost:3020/\" target=\"_blank\" rel=\"noopener\">https://localhost:3020/</a></li>\n</ol>\n<h3 id=\"4-后端配置\"><a href=\"#4-后端配置\" class=\"headerlink\" title=\"4 后端配置\"></a>4 后端配置</h3><p>indexWss.js文件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> https = <span class=\"built_in\">require</span>(<span class=\"string\">'https'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"built_in\">require</span>(<span class=\"string\">'ws'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> keypath=<span class=\"string\">'/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem'</span>;<span class=\"comment\">//mkcert 生成的key</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> certpath=<span class=\"string\">'/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">    key: fs.readFileSync(keypath),</span><br><span class=\"line\">    cert: fs.readFileSync(certpath),</span><br><span class=\"line\">    passphrase: <span class=\"string\">'123456'</span><span class=\"comment\">//如果秘钥文件有密码的话，用这个属性设置密码</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> port = process.env.PORT || <span class=\"number\">8095</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> server = https.createServer(options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;<span class=\"comment\">//要是单纯的https连接的话就会返回这个东西</span></span><br><span class=\"line\">    res.writeHead(<span class=\"number\">403</span>);<span class=\"comment\">//403即可</span></span><br><span class=\"line\">    res.end(<span class=\"string\">\"This is a  WebSockets server!\\n\"</span>);</span><br><span class=\"line\">&#125;).listen(port);</span><br><span class=\"line\"><span class=\"keyword\">var</span> wss = <span class=\"keyword\">new</span> ws.Server(&#123;<span class=\"attr\">server</span>: server&#125;);<span class=\"comment\">//把创建好的https服务器丢进websocket的创建函数里，ws会用这个服务器来创建wss服务</span></span><br><span class=\"line\">wss.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">conn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// 业务逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>启动代码：node indexWss.js<br>访问地址：wss://localhost:8095</p>\n<p>到现在为止，我们可以通过ip地址的方式在电脑上访问。</p>\n<h3 id=\"5-域名映射\"><a href=\"#5-域名映射\" class=\"headerlink\" title=\"5 域名映射\"></a>5 域名映射</h3><ol>\n<li>打开在etc/hosts文件 sudo vi hosts</li>\n<li>添加  127.0.0.1     test.qb.com  后保存</li>\n</ol>\n<h3 id=\"6-nginx配置\"><a href=\"#6-nginx配置\" class=\"headerlink\" title=\"6 nginx配置\"></a>6 nginx配置</h3><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">   <span class=\"attribute\">listen</span>       <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">   <span class=\"attribute\">server_name</span>  test.qb.com;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"attribute\">ssl_certificate</span>      <span class=\"string\">\"/Users/qiaobin/Library/Application Support/mkcert/qb.com+5.pem\"</span>;</span><br><span class=\"line\">   <span class=\"attribute\">ssl_certificate_key</span>  <span class=\"string\">\"/Users/qiaobin/Library/Application Support/mkcert/qb.com+5-key.pem\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"attribute\">ssl_session_cache</span>    shared:SSL:<span class=\"number\">1m</span>;</span><br><span class=\"line\">   <span class=\"attribute\">ssl_session_timeout</span>  <span class=\"number\">5m</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"attribute\">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class=\"line\">   <span class=\"attribute\">ssl_prefer_server_ciphers</span>  <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"attribute\">location</span> /web/ &#123;</span><br><span class=\"line\">      <span class=\"attribute\">proxy_pass</span>   https://localhost:3020/;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"attribute\">location</span><span class=\"regexp\"> ^~</span> /wss2 &#123;</span><br><span class=\"line\">       <span class=\"attribute\">proxy_pass</span>   https://localhost:8095;</span><br><span class=\"line\">       <span class=\"attribute\">proxy_http_version</span>   <span class=\"number\">1</span>.<span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"attribute\">proxy_set_header</span> Upgrade   <span class=\"variable\">$http_upgrade</span>;</span><br><span class=\"line\">       <span class=\"attribute\">proxy_set_header</span> Connection   <span class=\"string\">\"upgrade\"</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过nginx，我们用test.qb.com域名服务代理转发了前端https和后端wss服务，<br>我们可以通过 <a href=\"https://test.qb.com/web\" target=\"_blank\" rel=\"noopener\">https://test.qb.com/web</a>  来访问页面</p>\n<h3 id=\"7-charles代理\"><a href=\"#7-charles代理\" class=\"headerlink\" title=\"7 charles代理\"></a>7 charles代理</h3><p>通过以上步骤，我们可以用域名访问服务了，但是手机上还是无法用，这时就需要charles代理了。</p>\n<ol>\n<li>打开代理，安装pc端证书：help-&gt;SSL Proxying-&gt;Install Charles Root Certificate</li>\n<li>手机端连接代理，先查看代理地址和端口号，help-SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser<br>在弹出的对话框中可以看到ip地址和端口号<br>在手机wifi中开启代理，输入ip地址和端口号</li>\n<li>安装手机端证书， 连接好代理后，在手机浏览器中打开 chls.pro/ssl 下载并安装证书<br>ios设备需要进入设置-&gt;通用-&gt;描述文件与设备中进行授权</li>\n<li>访问 <a href=\"https://test.qb.com/web\" target=\"_blank\" rel=\"noopener\">https://test.qb.com/web</a>  此时发现ios下wss还是报错，可以下载安装我们生成的rootCA.pem和qb.com+5.pem证书</li>\n<li>如果ios下面，wss还是报错，进入设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt;开启对证书的完全信任<h3 id=\"8-兼容性\"><a href=\"#8-兼容性\" class=\"headerlink\" title=\"8 兼容性\"></a>8 兼容性</h3></li>\n</ol>\n<p>目前测试的兼容性<br>    pc-mac  chrome    ✅️<br>    pc-mac  safari    ✅️<br>    pc-mac  opera     ✅️<br>    android huawei    ❌<br>    android chrome    ✅️<br>    android weixin    ✅️<br>    ios     safari    ✅️</p>\n"},{"title":"vue-cli脚手架","comments":1,"date":"2020-01-07T16:00:00.000Z","author":"jun.zhou","_content":"\n\n![]()\n### 一、什么是vue-cli?\nvue脚手架指的是vue-cli，它是一个专门为单页面应用快速搭建繁杂的脚手架，它可以轻松的创建新的应用程序而且可用于自动生成vue和webpack的项目模板。\n\nvue-cli是有Vue提供的一个官方cli，专门为单页面应用快速搭建繁杂的脚手架。它是用于自动生成vue.js+webpack的项目模板，是为现代前端工作流提供了 batteries-included\n\n### 二、安装vue-cli\n安装vue-cli的前提是你已经安装了npm，安装npm你可以直接下载node的安装包进行安装。你可以在命令行工具里输入npm -v 检测你是否安装了npm和版本情况。出现版本号说明你已经安装了npm和node。\n\nnpm没有问题，接下来我们可以用npm 命令安装vue-cli了，在命令行输入下面的命令：\n```js\nnpm install vue-cli -g\n```\n- -g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue\n- -V来进行查看 vue-cli的版本号。注意这里的V是大写的。\n\n### 三、初始化项目\n用vue init命令来初始化项目如下：\n```js\nvue init <template-name> <project-name>\n```\ninit：表示我要用vue-cli来初始化项目\n<font color='red'>&lt;template-name&gt;</font>：表示模板名称，vue-cli官方为我们提供了5种模板，\n- webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。\n- webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。\n- browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。\n- browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。\n-simple-一个最简单的单页应用模板。\n\n<font color='red'>&lt;project-name&gt;</font>：标识项目名称，这个你可以根据自己的项目来起名字。\n\n在实际开发中，一般我们都会使用webpack这个模板，那我们这里也安装这个模板，在命令行输入以下命令：\n```js\nvue init webpack vuecliTest\n```\n输入命令后，会询问我们几个简单的选项，我们根据自己的需要进行填写就可以了。\n\n- Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了vueclitest\n- Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。\n- Author：作者，如果你有配置git的作者，他会读取。\n- Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y\n- Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。\n- setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。\n- Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。\n\n命令行出现上面的文字，说明我们已经初始化好了第一步。命令行提示我们现在可以作的三件事情。\n\n- cd vuecliTest 进入我们的vue项目目录。\n- npm install 安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。\n- npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。\n\n### 四、vue-cli结构\nvue-cli脚手架工具就是为我们搭建了开发所需要的环境，为我们省去了很多精力。有必要对这个环境进行熟悉，我们就从项目的结构讲起。\n\nPs：由于版本实时更新和你选择安装的不同（这里列出的是模板为webpack的目录结构），所以你看到的有可能和下边的有所差别。\n```js\n.\n|-- build                            // 项目构建(webpack)相关代码\n|   |-- build.js                     // 生产环境构建代码\n|   |-- check-version.js             // 检查node、npm等版本\n|   |-- dev-client.js                // 热重载相关\n|   |-- dev-server.js                // 构建本地服务器\n|   |-- utils.js                     // 构建工具相关\n|   |-- webpack.base.conf.js         // webpack基础配置\n|   |-- webpack.dev.conf.js          // webpack开发环境配置\n|   |-- webpack.prod.conf.js         // webpack生产环境配置\n|-- config                           // 项目开发环境配置\n|   |-- dev.env.js                   // 开发环境变量\n|   |-- index.js                     // 项目一些配置变量\n|   |-- prod.env.js                  // 生产环境变量\n|   |-- test.env.js                  // 测试环境变量\n|-- src                              // 源码目录\n|   |-- components                     // vue公共组件\n|   |-- store                          // vuex的状态管理\n|   |-- App.vue                        // 页面入口文件\n|   |-- main.js                        // 程序入口文件，加载各种公共组件\n|-- static                           // 静态文件，比如一些图片，json数据等\n|   |-- data                           // 群聊分析得到的数据用于数据可视化\n|-- .babelrc                         // ES6语法编译配置\n|-- .editorconfig                    // 定义代码格式\n|-- .gitignore                       // git上传需要忽略的文件格式\n|-- README.md                        // 项目说明\n|-- favicon.ico \n|-- index.html                       // 入口页面\n|-- package.json                     // 项目基本信息\n.\n```\n重要文件讲解：\npackage.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。\n\npackage.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写。\n```js\n\"scripts\": {\n    \"dev\": \"node build/dev-server.js\",\n    \"build\": \"node build/build.js\"\n},\n```\ndependencies字段和devDependencies字段\n- dependencies字段指项目运行时所依赖的模块；\n- devDependencies字段指定了项目开发时所依赖的模块；\n在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。package.json还有很多相关配置\n\n##### webpack相关配置\n我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。\n\ndev-server.js\n```js\n// 检查 Node 和 npm 版本\nrequire('./check-versions')()\n\n// 获取 config/index.js 的默认配置\nvar config = require('../config')\n\n// 如果 Node 的环境无法判断当前是 dev / product 环境\n// 使用 config.dev.env.NODE_ENV 作为当前的环境\n\nif (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n\n// 使用 NodeJS 自带的文件路径工具\nvar path = require('path')\n\n// 使用 express\nvar express = require('express')\n\n// 使用 webpack\nvar webpack = require('webpack')\n\n// 一个可以强制打开浏览器并跳转到指定 url 的插件\nvar opn = require('opn')\n\n// 使用 proxyTable\nvar proxyMiddleware = require('http-proxy-middleware')\n\n// 使用 dev 环境的 webpack 配置\nvar webpackConfig = require('./webpack.dev.conf')\n\n// default port where dev server listens for incoming traffic\n\n// 如果没有指定运行端口，使用 config.dev.port 作为运行端口\nvar port = process.env.PORT || config.dev.port\n\n// Define HTTP proxies to your custom API backend\n// https://github.com/chimurai/http-proxy-middleware\n\n// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\nvar proxyTable = config.dev.proxyTable\n\n// 使用 express 启动一个服务\nvar app = express()\n\n// 启动 webpack 进行编译\nvar compiler = webpack(webpackConfig)\n\n// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\nvar devMiddleware = require('webpack-dev-middleware')(compiler, {\n  publicPath: webpackConfig.output.publicPath,\n  stats: {\n    colors: true,\n    chunks: false\n  }\n})\n\n// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\nvar hotMiddleware = require('webpack-hot-middleware')(compiler)\n// force page reload when html-webpack-plugin template changes\ncompiler.plugin('compilation', function (compilation) {\n  compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n    hotMiddleware.publish({ action: 'reload' })\n    cb()\n  })\n})\n\n// proxy api requests\n// 将 proxyTable 中的请求配置挂在到启动的 express 服务上\nObject.keys(proxyTable).forEach(function (context) {\n  var options = proxyTable[context]\n  if (typeof options === 'string') {\n    options = { target: options }\n  }\n  app.use(proxyMiddleware(context, options))\n})\n\n// handle fallback for HTML5 history API\n// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\napp.use(require('connect-history-api-fallback')())\n\n// serve webpack bundle output\n// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\napp.use(devMiddleware)\n\n// enable hot-reload and state-preserving\n// compilation error display\n// 将 Hot-reload 挂在到 express 服务上\napp.use(hotMiddleware)\n\n// serve pure static assets\n// 拼接 static 文件夹的静态资源路径\nvar staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n// 为静态资源提供响应服务\napp.use(staticPath, express.static('./static'))\n\n// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\nmodule.exports = app.listen(port, function (err) {\n  if (err) {\n    console.log(err)\n    return\n  }\n  var uri = 'http://localhost:' + port\n  console.log('Listening at ' + uri + '\\n')\n\n  // when env is testing, don't need open it\n  // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n  if (process.env.NODE_ENV !== 'testing') {\n    opn(uri)\n  }\n})\n```\nwebpack.base.confg.js webpack的基础配置文件\n```js\n...\n...\nmodule.export = {\n    // 编译入口文件\n    entry: {},\n    // 编译输出路径\n    output: {},\n    // 一些解决方案配置\n    resolve: {},\n    resolveLoader: {},\n    module: {\n        // 各种不同类型文件加载器配置\n        loaders: {\n        ...\n        ...\n        // js文件用babel转码\n        {\n            test: /\\.js$/,\n            loader: 'babel',\n            include: projectRoot,\n            // 哪些文件不需要转码\n            exclude: /node_modules/\n        },\n        ...\n        ...\n        }\n    },\n    // vue文件一些相关配置\n    vue: {}\n}\n```\n##### .babelrc\nBabel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。\n```js\n{\n  //设定转码规则\n  \"presets\": [\n    [\"env\", { \"modules\": false }],\n    \"stage-2\"\n  ],\n  //转码用的插件\n  \"plugins\": [\"transform-runtime\"],\n  \"comments\": false,\n  //对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作\n  \"env\": {\n    \"test\": {\n      \"presets\": [\"env\", \"stage-2\"],\n      \"plugins\": [ \"istanbul\" ]\n    }\n  }\n}\n```\n##### .editorconfig\n该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。\n```js\nroot = true\n\n[*]    // 对所有文件应用下面的规则\ncharset = utf-8                    // 编码规则用utf-8\nindent_style = space               // 缩进用空格\nindent_size = 2                    // 缩进数量为2个空格\nend_of_line = lf                   // 换行符格式\ninsert_final_newline = true        // 是否在文件的最后插入一个空行\ntrim_trailing_whitespace = true    // 是否删除行尾的空格\n```\n这是比较重要的关于vue-cli的配置文件，当然还有很多其它文件这里就不多说了，你可以去百度了解下\n### 五、解读Vue-cli的模板\n我们通过两节课的讲解，你对vue-cli应该有了基本的了解，这节我们主要了解一下Vue-cli的模板操作，包括增加模板，修改模板，以及一个常规模板的基本结构。\n##### 1、npm run build 命令\n有小伙伴问我，如何把写好的Vue网页放到服务器上，那我就在这里讲解一下，主要的命令就是要用到npm run build 命令。我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。你在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 。\n\npackage.json的scripts 字段：\n```js\n\"scripts\": {\n    \"dev\": \"node build/dev-server.js\",\n    \"build\": \"node build/build.js\"\n  },\n```\n在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。\n\ndist文件夹下目录包括：\n- index.html主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。\n- static 静态资源文件夹：里边js、CSS和一些图片。\n\n##### 2、main.js解读\nmain.js是整个项目的入口文件,在src文件夹下：\n```js\nimport Vue from 'vue'      \nimport App from './App'\nimport router from './router'\n\nVue.config.productionTip = false   //生产环境提示，这里设置成了false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }\n})\n```\n通过代码可以看出这里引进了App的组件和的模板，它是通过 import App from ‘./App’这句代码引入的。 我们找到App.vue文件，打开查看。\n##### 3、app.vue文件\n```js\n<template>\n  <div id=\"app\">\n    <img src=\"./assets/logo.png\">\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'app'\n}\n</script>\n\n<style>\n#app {\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n```\napp.vue文件我们可以分成三部分解读，\n\n- <font color='red'>&lt;template&gt;</font><font color='red'>&lt;/template&gt;</font>标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和<font color='red'>&lt;router-view&gt;</font><font color='red'>&lt;/router-view&gt;</font>标签， <font color='red'>&lt;router-view&gt;</font>标签说明使用了路由机制。下一章我会讲到Vue-router。\n- <font color='red'>&lt;script&gt;</font><font color='red'>&lt;/script&gt;</font>标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。\n- <font color='red'>&lt;style&gt;</font><font color='red'>&lt;/style&gt;</font>标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用<font color='red'>&lt;style scoped&gt;</font><font color='red'>&lt;/style&gt;</font>来声明这些css样式只在本模板中起作用。\n##### 4、router/index.js 路由文件\n引文在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。下章我们就开始讲Vue-router。\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport Hello from '@/components/Hello'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'Hello',\n      component: Hello\n    }\n  ]\n})\n```\n我们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。\n\n##### 5、Hello.vue文件解读：\n这个文件就是我们在第一章看到的页面文件了。也是分为<font color='red'>&lt;template&gt;&lt;script&gt;&lt;style&gt;</font>三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。\n```js\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n    <h2>Essential Links</h2>\n    <ul>\n      <li><a href=\"https://vuejs.org\" target=\"_blank\">Core Docs</a></li>\n      <li><a href=\"https://forum.vuejs.org\" target=\"_blank\">Forum</a></li>\n      <li><a href=\"https://gitter.im/vuejs/vue\" target=\"_blank\">Gitter Chat</a></li>\n      <li><a href=\"https://twitter.com/vuejs\" target=\"_blank\">Twitter</a></li>\n      <br>\n      <li><a href=\"http://vuejs-templates.github.io/webpack/\" target=\"_blank\">Docs for This Template</a></li>\n    </ul>\n    <h2>Ecosystem</h2>\n    <ul>\n      <li><a href=\"http://router.vuejs.org/\" target=\"_blank\">vue-router</a></li>\n      <li><a href=\"http://vuex.vuejs.org/\" target=\"_blank\">vuex</a></li>\n      <li><a href=\"http://vue-loader.vuejs.org/\" target=\"_blank\">vue-loader</a></li>\n      <li><a href=\"https://github.com/vuejs/awesome-vue\" target=\"_blank\">awesome-vue</a></li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'hello',\n  data () {\n    return {\n      msg: 'Welcome to Your Vue.js App'\n    }\n  }\n}\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\nh1, h2 {\n  font-weight: normal;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n</style>\n```\n 这章只是带着你大概浏览和重点讲解了vue-cli的知识，如果你想完全弄明白vue-cli，我建议最好是有调理的阅读所有代码","source":"_posts/2020-01-08-Vue-cli脚手架.md","raw":"---\ntitle: vue-cli脚手架\ncomments: true\ndate: 2020-01-08\ntags:\n- vue-cli vue\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n\n![]()\n### 一、什么是vue-cli?\nvue脚手架指的是vue-cli，它是一个专门为单页面应用快速搭建繁杂的脚手架，它可以轻松的创建新的应用程序而且可用于自动生成vue和webpack的项目模板。\n\nvue-cli是有Vue提供的一个官方cli，专门为单页面应用快速搭建繁杂的脚手架。它是用于自动生成vue.js+webpack的项目模板，是为现代前端工作流提供了 batteries-included\n\n### 二、安装vue-cli\n安装vue-cli的前提是你已经安装了npm，安装npm你可以直接下载node的安装包进行安装。你可以在命令行工具里输入npm -v 检测你是否安装了npm和版本情况。出现版本号说明你已经安装了npm和node。\n\nnpm没有问题，接下来我们可以用npm 命令安装vue-cli了，在命令行输入下面的命令：\n```js\nnpm install vue-cli -g\n```\n- -g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue\n- -V来进行查看 vue-cli的版本号。注意这里的V是大写的。\n\n### 三、初始化项目\n用vue init命令来初始化项目如下：\n```js\nvue init <template-name> <project-name>\n```\ninit：表示我要用vue-cli来初始化项目\n<font color='red'>&lt;template-name&gt;</font>：表示模板名称，vue-cli官方为我们提供了5种模板，\n- webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。\n- webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。\n- browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。\n- browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。\n-simple-一个最简单的单页应用模板。\n\n<font color='red'>&lt;project-name&gt;</font>：标识项目名称，这个你可以根据自己的项目来起名字。\n\n在实际开发中，一般我们都会使用webpack这个模板，那我们这里也安装这个模板，在命令行输入以下命令：\n```js\nvue init webpack vuecliTest\n```\n输入命令后，会询问我们几个简单的选项，我们根据自己的需要进行填写就可以了。\n\n- Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了vueclitest\n- Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。\n- Author：作者，如果你有配置git的作者，他会读取。\n- Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y\n- Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。\n- setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。\n- Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。\n\n命令行出现上面的文字，说明我们已经初始化好了第一步。命令行提示我们现在可以作的三件事情。\n\n- cd vuecliTest 进入我们的vue项目目录。\n- npm install 安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。\n- npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。\n\n### 四、vue-cli结构\nvue-cli脚手架工具就是为我们搭建了开发所需要的环境，为我们省去了很多精力。有必要对这个环境进行熟悉，我们就从项目的结构讲起。\n\nPs：由于版本实时更新和你选择安装的不同（这里列出的是模板为webpack的目录结构），所以你看到的有可能和下边的有所差别。\n```js\n.\n|-- build                            // 项目构建(webpack)相关代码\n|   |-- build.js                     // 生产环境构建代码\n|   |-- check-version.js             // 检查node、npm等版本\n|   |-- dev-client.js                // 热重载相关\n|   |-- dev-server.js                // 构建本地服务器\n|   |-- utils.js                     // 构建工具相关\n|   |-- webpack.base.conf.js         // webpack基础配置\n|   |-- webpack.dev.conf.js          // webpack开发环境配置\n|   |-- webpack.prod.conf.js         // webpack生产环境配置\n|-- config                           // 项目开发环境配置\n|   |-- dev.env.js                   // 开发环境变量\n|   |-- index.js                     // 项目一些配置变量\n|   |-- prod.env.js                  // 生产环境变量\n|   |-- test.env.js                  // 测试环境变量\n|-- src                              // 源码目录\n|   |-- components                     // vue公共组件\n|   |-- store                          // vuex的状态管理\n|   |-- App.vue                        // 页面入口文件\n|   |-- main.js                        // 程序入口文件，加载各种公共组件\n|-- static                           // 静态文件，比如一些图片，json数据等\n|   |-- data                           // 群聊分析得到的数据用于数据可视化\n|-- .babelrc                         // ES6语法编译配置\n|-- .editorconfig                    // 定义代码格式\n|-- .gitignore                       // git上传需要忽略的文件格式\n|-- README.md                        // 项目说明\n|-- favicon.ico \n|-- index.html                       // 入口页面\n|-- package.json                     // 项目基本信息\n.\n```\n重要文件讲解：\npackage.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。\n\npackage.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写。\n```js\n\"scripts\": {\n    \"dev\": \"node build/dev-server.js\",\n    \"build\": \"node build/build.js\"\n},\n```\ndependencies字段和devDependencies字段\n- dependencies字段指项目运行时所依赖的模块；\n- devDependencies字段指定了项目开发时所依赖的模块；\n在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。package.json还有很多相关配置\n\n##### webpack相关配置\n我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。\n\ndev-server.js\n```js\n// 检查 Node 和 npm 版本\nrequire('./check-versions')()\n\n// 获取 config/index.js 的默认配置\nvar config = require('../config')\n\n// 如果 Node 的环境无法判断当前是 dev / product 环境\n// 使用 config.dev.env.NODE_ENV 作为当前的环境\n\nif (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n\n// 使用 NodeJS 自带的文件路径工具\nvar path = require('path')\n\n// 使用 express\nvar express = require('express')\n\n// 使用 webpack\nvar webpack = require('webpack')\n\n// 一个可以强制打开浏览器并跳转到指定 url 的插件\nvar opn = require('opn')\n\n// 使用 proxyTable\nvar proxyMiddleware = require('http-proxy-middleware')\n\n// 使用 dev 环境的 webpack 配置\nvar webpackConfig = require('./webpack.dev.conf')\n\n// default port where dev server listens for incoming traffic\n\n// 如果没有指定运行端口，使用 config.dev.port 作为运行端口\nvar port = process.env.PORT || config.dev.port\n\n// Define HTTP proxies to your custom API backend\n// https://github.com/chimurai/http-proxy-middleware\n\n// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\nvar proxyTable = config.dev.proxyTable\n\n// 使用 express 启动一个服务\nvar app = express()\n\n// 启动 webpack 进行编译\nvar compiler = webpack(webpackConfig)\n\n// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\nvar devMiddleware = require('webpack-dev-middleware')(compiler, {\n  publicPath: webpackConfig.output.publicPath,\n  stats: {\n    colors: true,\n    chunks: false\n  }\n})\n\n// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\nvar hotMiddleware = require('webpack-hot-middleware')(compiler)\n// force page reload when html-webpack-plugin template changes\ncompiler.plugin('compilation', function (compilation) {\n  compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n    hotMiddleware.publish({ action: 'reload' })\n    cb()\n  })\n})\n\n// proxy api requests\n// 将 proxyTable 中的请求配置挂在到启动的 express 服务上\nObject.keys(proxyTable).forEach(function (context) {\n  var options = proxyTable[context]\n  if (typeof options === 'string') {\n    options = { target: options }\n  }\n  app.use(proxyMiddleware(context, options))\n})\n\n// handle fallback for HTML5 history API\n// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\napp.use(require('connect-history-api-fallback')())\n\n// serve webpack bundle output\n// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\napp.use(devMiddleware)\n\n// enable hot-reload and state-preserving\n// compilation error display\n// 将 Hot-reload 挂在到 express 服务上\napp.use(hotMiddleware)\n\n// serve pure static assets\n// 拼接 static 文件夹的静态资源路径\nvar staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n// 为静态资源提供响应服务\napp.use(staticPath, express.static('./static'))\n\n// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\nmodule.exports = app.listen(port, function (err) {\n  if (err) {\n    console.log(err)\n    return\n  }\n  var uri = 'http://localhost:' + port\n  console.log('Listening at ' + uri + '\\n')\n\n  // when env is testing, don't need open it\n  // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n  if (process.env.NODE_ENV !== 'testing') {\n    opn(uri)\n  }\n})\n```\nwebpack.base.confg.js webpack的基础配置文件\n```js\n...\n...\nmodule.export = {\n    // 编译入口文件\n    entry: {},\n    // 编译输出路径\n    output: {},\n    // 一些解决方案配置\n    resolve: {},\n    resolveLoader: {},\n    module: {\n        // 各种不同类型文件加载器配置\n        loaders: {\n        ...\n        ...\n        // js文件用babel转码\n        {\n            test: /\\.js$/,\n            loader: 'babel',\n            include: projectRoot,\n            // 哪些文件不需要转码\n            exclude: /node_modules/\n        },\n        ...\n        ...\n        }\n    },\n    // vue文件一些相关配置\n    vue: {}\n}\n```\n##### .babelrc\nBabel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。\n```js\n{\n  //设定转码规则\n  \"presets\": [\n    [\"env\", { \"modules\": false }],\n    \"stage-2\"\n  ],\n  //转码用的插件\n  \"plugins\": [\"transform-runtime\"],\n  \"comments\": false,\n  //对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作\n  \"env\": {\n    \"test\": {\n      \"presets\": [\"env\", \"stage-2\"],\n      \"plugins\": [ \"istanbul\" ]\n    }\n  }\n}\n```\n##### .editorconfig\n该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。\n```js\nroot = true\n\n[*]    // 对所有文件应用下面的规则\ncharset = utf-8                    // 编码规则用utf-8\nindent_style = space               // 缩进用空格\nindent_size = 2                    // 缩进数量为2个空格\nend_of_line = lf                   // 换行符格式\ninsert_final_newline = true        // 是否在文件的最后插入一个空行\ntrim_trailing_whitespace = true    // 是否删除行尾的空格\n```\n这是比较重要的关于vue-cli的配置文件，当然还有很多其它文件这里就不多说了，你可以去百度了解下\n### 五、解读Vue-cli的模板\n我们通过两节课的讲解，你对vue-cli应该有了基本的了解，这节我们主要了解一下Vue-cli的模板操作，包括增加模板，修改模板，以及一个常规模板的基本结构。\n##### 1、npm run build 命令\n有小伙伴问我，如何把写好的Vue网页放到服务器上，那我就在这里讲解一下，主要的命令就是要用到npm run build 命令。我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。你在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 。\n\npackage.json的scripts 字段：\n```js\n\"scripts\": {\n    \"dev\": \"node build/dev-server.js\",\n    \"build\": \"node build/build.js\"\n  },\n```\n在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。\n\ndist文件夹下目录包括：\n- index.html主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。\n- static 静态资源文件夹：里边js、CSS和一些图片。\n\n##### 2、main.js解读\nmain.js是整个项目的入口文件,在src文件夹下：\n```js\nimport Vue from 'vue'      \nimport App from './App'\nimport router from './router'\n\nVue.config.productionTip = false   //生产环境提示，这里设置成了false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }\n})\n```\n通过代码可以看出这里引进了App的组件和的模板，它是通过 import App from ‘./App’这句代码引入的。 我们找到App.vue文件，打开查看。\n##### 3、app.vue文件\n```js\n<template>\n  <div id=\"app\">\n    <img src=\"./assets/logo.png\">\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'app'\n}\n</script>\n\n<style>\n#app {\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n```\napp.vue文件我们可以分成三部分解读，\n\n- <font color='red'>&lt;template&gt;</font><font color='red'>&lt;/template&gt;</font>标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和<font color='red'>&lt;router-view&gt;</font><font color='red'>&lt;/router-view&gt;</font>标签， <font color='red'>&lt;router-view&gt;</font>标签说明使用了路由机制。下一章我会讲到Vue-router。\n- <font color='red'>&lt;script&gt;</font><font color='red'>&lt;/script&gt;</font>标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。\n- <font color='red'>&lt;style&gt;</font><font color='red'>&lt;/style&gt;</font>标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用<font color='red'>&lt;style scoped&gt;</font><font color='red'>&lt;/style&gt;</font>来声明这些css样式只在本模板中起作用。\n##### 4、router/index.js 路由文件\n引文在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。下章我们就开始讲Vue-router。\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport Hello from '@/components/Hello'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'Hello',\n      component: Hello\n    }\n  ]\n})\n```\n我们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。\n\n##### 5、Hello.vue文件解读：\n这个文件就是我们在第一章看到的页面文件了。也是分为<font color='red'>&lt;template&gt;&lt;script&gt;&lt;style&gt;</font>三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。\n```js\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n    <h2>Essential Links</h2>\n    <ul>\n      <li><a href=\"https://vuejs.org\" target=\"_blank\">Core Docs</a></li>\n      <li><a href=\"https://forum.vuejs.org\" target=\"_blank\">Forum</a></li>\n      <li><a href=\"https://gitter.im/vuejs/vue\" target=\"_blank\">Gitter Chat</a></li>\n      <li><a href=\"https://twitter.com/vuejs\" target=\"_blank\">Twitter</a></li>\n      <br>\n      <li><a href=\"http://vuejs-templates.github.io/webpack/\" target=\"_blank\">Docs for This Template</a></li>\n    </ul>\n    <h2>Ecosystem</h2>\n    <ul>\n      <li><a href=\"http://router.vuejs.org/\" target=\"_blank\">vue-router</a></li>\n      <li><a href=\"http://vuex.vuejs.org/\" target=\"_blank\">vuex</a></li>\n      <li><a href=\"http://vue-loader.vuejs.org/\" target=\"_blank\">vue-loader</a></li>\n      <li><a href=\"https://github.com/vuejs/awesome-vue\" target=\"_blank\">awesome-vue</a></li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'hello',\n  data () {\n    return {\n      msg: 'Welcome to Your Vue.js App'\n    }\n  }\n}\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\nh1, h2 {\n  font-weight: normal;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n</style>\n```\n 这章只是带着你大概浏览和重点讲解了vue-cli的知识，如果你想完全弄明白vue-cli，我建议最好是有调理的阅读所有代码","slug":"Vue-cli脚手架","published":1,"updated":"2020-06-10T06:01:19.019Z","_id":"ck8r6c1670005imq6456qnr4a","layout":"post","photos":[],"link":"","content":"<p><img src alt></p>\n<h3 id=\"一、什么是vue-cli\"><a href=\"#一、什么是vue-cli\" class=\"headerlink\" title=\"一、什么是vue-cli?\"></a>一、什么是vue-cli?</h3><p>vue脚手架指的是vue-cli，它是一个专门为单页面应用快速搭建繁杂的脚手架，它可以轻松的创建新的应用程序而且可用于自动生成vue和webpack的项目模板。</p>\n<p>vue-cli是有Vue提供的一个官方cli，专门为单页面应用快速搭建繁杂的脚手架。它是用于自动生成vue.js+webpack的项目模板，是为现代前端工作流提供了 batteries-included</p>\n<h3 id=\"二、安装vue-cli\"><a href=\"#二、安装vue-cli\" class=\"headerlink\" title=\"二、安装vue-cli\"></a>二、安装vue-cli</h3><p>安装vue-cli的前提是你已经安装了npm，安装npm你可以直接下载node的安装包进行安装。你可以在命令行工具里输入npm -v 检测你是否安装了npm和版本情况。出现版本号说明你已经安装了npm和node。</p>\n<p>npm没有问题，接下来我们可以用npm 命令安装vue-cli了，在命令行输入下面的命令：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-cli -g</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>-g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue</li>\n<li>-V来进行查看 vue-cli的版本号。注意这里的V是大写的。</li>\n</ul>\n<h3 id=\"三、初始化项目\"><a href=\"#三、初始化项目\" class=\"headerlink\" title=\"三、初始化项目\"></a>三、初始化项目</h3><p>用vue init命令来初始化项目如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init &lt;template-name&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">project-name</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>init：表示我要用vue-cli来初始化项目</p>\n<p><font color=\"red\">&lt;template-name&gt;</font>：表示模板名称，vue-cli官方为我们提供了5种模板，</p>\n<ul>\n<li>webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。</li>\n<li>webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。</li>\n<li>browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。</li>\n<li>browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。<br>-simple-一个最简单的单页应用模板。</li>\n</ul>\n<p><font color=\"red\">&lt;project-name&gt;</font>：标识项目名称，这个你可以根据自己的项目来起名字。</p>\n<p>在实际开发中，一般我们都会使用webpack这个模板，那我们这里也安装这个模板，在命令行输入以下命令：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack vuecliTest</span><br></pre></td></tr></table></figure></p>\n<p>输入命令后，会询问我们几个简单的选项，我们根据自己的需要进行填写就可以了。</p>\n<ul>\n<li>Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了vueclitest</li>\n<li>Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。</li>\n<li>Author：作者，如果你有配置git的作者，他会读取。</li>\n<li>Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y</li>\n<li>Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。</li>\n<li>setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。</li>\n<li>Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。</li>\n</ul>\n<p>命令行出现上面的文字，说明我们已经初始化好了第一步。命令行提示我们现在可以作的三件事情。</p>\n<ul>\n<li>cd vuecliTest 进入我们的vue项目目录。</li>\n<li>npm install 安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。</li>\n<li>npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。</li>\n</ul>\n<h3 id=\"四、vue-cli结构\"><a href=\"#四、vue-cli结构\" class=\"headerlink\" title=\"四、vue-cli结构\"></a>四、vue-cli结构</h3><p>vue-cli脚手架工具就是为我们搭建了开发所需要的环境，为我们省去了很多精力。有必要对这个环境进行熟悉，我们就从项目的结构讲起。</p>\n<p>Ps：由于版本实时更新和你选择安装的不同（这里列出的是模板为webpack的目录结构），所以你看到的有可能和下边的有所差别。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">|-- build                            <span class=\"comment\">// 项目构建(webpack)相关代码</span></span><br><span class=\"line\">|   |-- build.js                     <span class=\"comment\">// 生产环境构建代码</span></span><br><span class=\"line\">|   |-- check-version.js             <span class=\"comment\">// 检查node、npm等版本</span></span><br><span class=\"line\">|   |-- dev-client.js                <span class=\"comment\">// 热重载相关</span></span><br><span class=\"line\">|   |-- dev-server.js                <span class=\"comment\">// 构建本地服务器</span></span><br><span class=\"line\">|   |-- utils.js                     <span class=\"comment\">// 构建工具相关</span></span><br><span class=\"line\">|   |-- webpack.base.conf.js         <span class=\"comment\">// webpack基础配置</span></span><br><span class=\"line\">|   |-- webpack.dev.conf.js          <span class=\"comment\">// webpack开发环境配置</span></span><br><span class=\"line\">|   |-- webpack.prod.conf.js         <span class=\"comment\">// webpack生产环境配置</span></span><br><span class=\"line\">|-- config                           <span class=\"comment\">// 项目开发环境配置</span></span><br><span class=\"line\">|   |-- dev.env.js                   <span class=\"comment\">// 开发环境变量</span></span><br><span class=\"line\">|   |-- index.js                     <span class=\"comment\">// 项目一些配置变量</span></span><br><span class=\"line\">|   |-- prod.env.js                  <span class=\"comment\">// 生产环境变量</span></span><br><span class=\"line\">|   |-- test.env.js                  <span class=\"comment\">// 测试环境变量</span></span><br><span class=\"line\">|-- src                              <span class=\"comment\">// 源码目录</span></span><br><span class=\"line\">|   |-- components                     <span class=\"comment\">// vue公共组件</span></span><br><span class=\"line\">|   |-- store                          <span class=\"comment\">// vuex的状态管理</span></span><br><span class=\"line\">|   |-- App.vue                        <span class=\"comment\">// 页面入口文件</span></span><br><span class=\"line\">|   |-- main.js                        <span class=\"comment\">// 程序入口文件，加载各种公共组件</span></span><br><span class=\"line\">|-- <span class=\"keyword\">static</span>                           <span class=\"comment\">// 静态文件，比如一些图片，json数据等</span></span><br><span class=\"line\">|   |-- data                           <span class=\"comment\">// 群聊分析得到的数据用于数据可视化</span></span><br><span class=\"line\">|-- .babelrc                         <span class=\"comment\">// ES6语法编译配置</span></span><br><span class=\"line\">|-- .editorconfig                    <span class=\"comment\">// 定义代码格式</span></span><br><span class=\"line\">|-- .gitignore                       <span class=\"comment\">// git上传需要忽略的文件格式</span></span><br><span class=\"line\">|-- README.md                        <span class=\"comment\">// 项目说明</span></span><br><span class=\"line\">|-- favicon.ico </span><br><span class=\"line\">|-- index.html                       <span class=\"comment\">// 入口页面</span></span><br><span class=\"line\">|-- package.json                     <span class=\"comment\">// 项目基本信息</span></span><br><span class=\"line\">.</span><br></pre></td></tr></table></figure></p>\n<p>重要文件讲解：<br>package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。</p>\n<p>package.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"node build/dev-server.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"node build/build.js\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>dependencies字段和devDependencies字段</p>\n<ul>\n<li>dependencies字段指项目运行时所依赖的模块；</li>\n<li>devDependencies字段指定了项目开发时所依赖的模块；<br>在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。package.json还有很多相关配置</li>\n</ul>\n<h5 id=\"webpack相关配置\"><a href=\"#webpack相关配置\" class=\"headerlink\" title=\"webpack相关配置\"></a>webpack相关配置</h5><p>我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。</p>\n<p>dev-server.js<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查 Node 和 npm 版本</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./check-versions'</span>)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 config/index.js 的默认配置</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'../config'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果 Node 的环境无法判断当前是 dev / product 环境</span></span><br><span class=\"line\"><span class=\"comment\">// 使用 config.dev.env.NODE_ENV 作为当前的环境</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!process.env.NODE_ENV) process.env.NODE_ENV = <span class=\"built_in\">JSON</span>.parse(config.dev.env.NODE_ENV)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 NodeJS 自带的文件路径工具</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 express</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 webpack</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个可以强制打开浏览器并跳转到指定 url 的插件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> opn = <span class=\"built_in\">require</span>(<span class=\"string\">'opn'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 proxyTable</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxyMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'http-proxy-middleware'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 dev 环境的 webpack 配置</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.dev.conf'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// default port where dev server listens for incoming traffic</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果没有指定运行端口，使用 config.dev.port 作为运行端口</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> port = process.env.PORT || config.dev.port</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define HTTP proxies to your custom API backend</span></span><br><span class=\"line\"><span class=\"comment\">// https://github.com/chimurai/http-proxy-middleware</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxyTable = config.dev.proxyTable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 express 启动一个服务</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 webpack 进行编译</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(webpackConfig)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> devMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)(compiler, &#123;</span><br><span class=\"line\">  publicPath: webpackConfig.output.publicPath,</span><br><span class=\"line\">  stats: &#123;</span><br><span class=\"line\">    colors: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    chunks: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hotMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)(compiler)</span><br><span class=\"line\"><span class=\"comment\">// force page reload when html-webpack-plugin template changes</span></span><br><span class=\"line\">compiler.plugin(<span class=\"string\">'compilation'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">compilation</span>) </span>&#123;</span><br><span class=\"line\">  compilation.plugin(<span class=\"string\">'html-webpack-plugin-after-emit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, cb</span>) </span>&#123;</span><br><span class=\"line\">    hotMiddleware.publish(&#123; <span class=\"attr\">action</span>: <span class=\"string\">'reload'</span> &#125;)</span><br><span class=\"line\">    cb()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// proxy api requests</span></span><br><span class=\"line\"><span class=\"comment\">// 将 proxyTable 中的请求配置挂在到启动的 express 服务上</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(proxyTable).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> options = proxyTable[context]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> options === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    options = &#123; <span class=\"attr\">target</span>: options &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  app.use(proxyMiddleware(context, options))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handle fallback for HTML5 history API</span></span><br><span class=\"line\"><span class=\"comment\">// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址</span></span><br><span class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'connect-history-api-fallback'</span>)())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// serve webpack bundle output</span></span><br><span class=\"line\"><span class=\"comment\">// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上</span></span><br><span class=\"line\">app.use(devMiddleware)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// enable hot-reload and state-preserving</span></span><br><span class=\"line\"><span class=\"comment\">// compilation error display</span></span><br><span class=\"line\"><span class=\"comment\">// 将 Hot-reload 挂在到 express 服务上</span></span><br><span class=\"line\">app.use(hotMiddleware)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// serve pure static assets</span></span><br><span class=\"line\"><span class=\"comment\">// 拼接 static 文件夹的静态资源路径</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)</span><br><span class=\"line\"><span class=\"comment\">// 为静态资源提供响应服务</span></span><br><span class=\"line\">app.use(staticPath, express.static(<span class=\"string\">'./static'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = app.listen(port, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> uri = <span class=\"string\">'http://localhost:'</span> + port</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listening at '</span> + uri + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// when env is testing, don't need open it</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果不是测试环境，自动打开浏览器并跳到我们的开发地址</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'testing'</span>) &#123;</span><br><span class=\"line\">    opn(uri)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>webpack.base.confg.js webpack的基础配置文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">module</span>.export = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 编译入口文件</span></span><br><span class=\"line\">    entry: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 编译输出路径</span></span><br><span class=\"line\">    output: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 一些解决方案配置</span></span><br><span class=\"line\">    resolve: &#123;&#125;,</span><br><span class=\"line\">    resolveLoader: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 各种不同类型文件加载器配置</span></span><br><span class=\"line\">        loaders: &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// js文件用babel转码</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">            loader: <span class=\"string\">'babel'</span>,</span><br><span class=\"line\">            include: projectRoot,</span><br><span class=\"line\">            <span class=\"comment\">// 哪些文件不需要转码</span></span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// vue文件一些相关配置</span></span><br><span class=\"line\">    vue: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"babelrc\"><a href=\"#babelrc\" class=\"headerlink\" title=\".babelrc\"></a>.babelrc</h5><p>Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">//设定转码规则</span></span><br><span class=\"line\">  <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"env\"</span>, &#123; <span class=\"string\">\"modules\"</span>: <span class=\"literal\">false</span> &#125;],</span><br><span class=\"line\">    <span class=\"string\">\"stage-2\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"comment\">//转码用的插件</span></span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [<span class=\"string\">\"transform-runtime\"</span>],</span><br><span class=\"line\">  <span class=\"string\">\"comments\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">//对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作</span></span><br><span class=\"line\">  <span class=\"string\">\"env\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"presets\"</span>: [<span class=\"string\">\"env\"</span>, <span class=\"string\">\"stage-2\"</span>],</span><br><span class=\"line\">      <span class=\"string\">\"plugins\"</span>: [ <span class=\"string\">\"istanbul\"</span> ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"editorconfig\"><a href=\"#editorconfig\" class=\"headerlink\" title=\".editorconfig\"></a>.editorconfig</h5><p>该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">[*]    <span class=\"comment\">// 对所有文件应用下面的规则</span></span><br><span class=\"line\">charset = utf<span class=\"number\">-8</span>                    <span class=\"comment\">// 编码规则用utf-8</span></span><br><span class=\"line\">indent_style = space               <span class=\"comment\">// 缩进用空格</span></span><br><span class=\"line\">indent_size = <span class=\"number\">2</span>                    <span class=\"comment\">// 缩进数量为2个空格</span></span><br><span class=\"line\">end_of_line = lf                   <span class=\"comment\">// 换行符格式</span></span><br><span class=\"line\">insert_final_newline = <span class=\"literal\">true</span>        <span class=\"comment\">// 是否在文件的最后插入一个空行</span></span><br><span class=\"line\">trim_trailing_whitespace = <span class=\"literal\">true</span>    <span class=\"comment\">// 是否删除行尾的空格</span></span><br></pre></td></tr></table></figure></p>\n<p>这是比较重要的关于vue-cli的配置文件，当然还有很多其它文件这里就不多说了，你可以去百度了解下</p>\n<h3 id=\"五、解读Vue-cli的模板\"><a href=\"#五、解读Vue-cli的模板\" class=\"headerlink\" title=\"五、解读Vue-cli的模板\"></a>五、解读Vue-cli的模板</h3><p>我们通过两节课的讲解，你对vue-cli应该有了基本的了解，这节我们主要了解一下Vue-cli的模板操作，包括增加模板，修改模板，以及一个常规模板的基本结构。</p>\n<h5 id=\"1、npm-run-build-命令\"><a href=\"#1、npm-run-build-命令\" class=\"headerlink\" title=\"1、npm run build 命令\"></a>1、npm run build 命令</h5><p>有小伙伴问我，如何把写好的Vue网页放到服务器上，那我就在这里讲解一下，主要的命令就是要用到npm run build 命令。我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。你在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 。</p>\n<p>package.json的scripts 字段：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"node build/dev-server.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"node build/build.js\"</span></span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。</p>\n<p>dist文件夹下目录包括：</p>\n<ul>\n<li>index.html主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。</li>\n<li>static 静态资源文件夹：里边js、CSS和一些图片。</li>\n</ul>\n<h5 id=\"2、main-js解读\"><a href=\"#2、main-js解读\" class=\"headerlink\" title=\"2、main.js解读\"></a>2、main.js解读</h5><p>main.js是整个项目的入口文件,在src文件夹下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>      </span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.productionTip = <span class=\"literal\">false</span>   <span class=\"comment\">//生产环境提示，这里设置成了false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* eslint-disable no-new */</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;App/&gt;'</span>,</span><br><span class=\"line\">  components: &#123; App &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>通过代码可以看出这里引进了App的组件和的模板，它是通过 import App from ‘./App’这句代码引入的。 我们找到App.vue文件，打开查看。</p>\n<h5 id=\"3、app-vue文件\"><a href=\"#3、app-vue文件\" class=\"headerlink\" title=\"3、app.vue文件\"></a>3、app.vue文件</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;img src=<span class=\"string\">\"./assets/logo.png\"</span>&gt;</span><br><span class=\"line\">    &lt;router-view&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span></span><br><span class=\"line\">  &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'app'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;style&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">#app &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  font-family: 'Avenir', Helvetica, Arial, sans-serif;</span></span><br><span class=\"line\"><span class=\"regexp\">  -webkit-font-smoothing: antialiased;</span></span><br><span class=\"line\"><span class=\"regexp\">  -moz-osx-font-smoothing: grayscale;</span></span><br><span class=\"line\"><span class=\"regexp\">  text-align: center;</span></span><br><span class=\"line\"><span class=\"regexp\">  color: #2c3e50;</span></span><br><span class=\"line\"><span class=\"regexp\">  margin-top: 60px;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>\n<p>app.vue文件我们可以分成三部分解读，</p>\n<ul>\n<li><font color=\"red\">&lt;template&gt;</font><font color=\"red\">&lt;/template&gt;</font>标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和<font color=\"red\">&lt;router-view&gt;</font><font color=\"red\">&lt;/router-view&gt;</font>标签， <font color=\"red\">&lt;router-view&gt;</font>标签说明使用了路由机制。下一章我会讲到Vue-router。</li>\n<li><font color=\"red\">&lt;script&gt;</font><font color=\"red\">&lt;/script&gt;</font>标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。</li>\n<li><font color=\"red\">&lt;style&gt;</font><font color=\"red\">&lt;/style&gt;</font>标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用<font color=\"red\">&lt;style scoped&gt;</font><font color=\"red\">&lt;/style&gt;</font>来声明这些css样式只在本模板中起作用。<h5 id=\"4、router-index-js-路由文件\"><a href=\"#4、router-index-js-路由文件\" class=\"headerlink\" title=\"4、router/index.js 路由文件\"></a>4、router/index.js 路由文件</h5>引文在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。下章我们就开始讲Vue-router。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,</span><br><span class=\"line\">      component: Hello</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。</p>\n<h5 id=\"5、Hello-vue文件解读：\"><a href=\"#5、Hello-vue文件解读：\" class=\"headerlink\" title=\"5、Hello.vue文件解读：\"></a>5、Hello.vue文件解读：</h5><p>这个文件就是我们在第一章看到的页面文件了。也是分为<font color=\"red\">&lt;template&gt;&lt;script&gt;&lt;style&gt;</font>三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"hello\"</span>&gt;</span><br><span class=\"line\">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;h2&gt;Essential Links&lt;/</span>h2&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://vuejs.org\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Core Docs<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://forum.vuejs.org\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Forum<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://gitter.im/vuejs/vue\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Gitter Chat<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://twitter.com/vuejs\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Twitter<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;br&gt;</span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://vuejs-templates.github.io/webpack/\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Docs for This Template<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;h2&gt;Ecosystem&lt;/</span>h2&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://router.vuejs.org/\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>vue-router<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://vuex.vuejs.org/\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>vuex<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://vue-loader.vuejs.org/\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>vue-loader<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://github.com/vuejs/awesome-vue\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>awesome-vue<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/template&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">export default &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  name: 'hello',</span></span><br><span class=\"line\"><span class=\"regexp\">  data () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      msg: 'Welcome to Your Vue.js App'</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Add <span class=\"string\">\"scoped\"</span> attribute to limit CSS to <span class=\"keyword\">this</span> component only --&gt;</span><br><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\">h1, h2 &#123;</span><br><span class=\"line\">  font-weight: normal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ul &#123;</span><br><span class=\"line\">  list-style-type: none;</span><br><span class=\"line\">  padding: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">li &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  margin: <span class=\"number\">0</span> <span class=\"number\">10</span>px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a &#123;</span><br><span class=\"line\">  color: #42b983;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/style&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p> 这章只是带着你大概浏览和重点讲解了vue-cli的知识，如果你想完全弄明白vue-cli，我建议最好是有调理的阅读所有代码</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src alt></p>\n<h3 id=\"一、什么是vue-cli\"><a href=\"#一、什么是vue-cli\" class=\"headerlink\" title=\"一、什么是vue-cli?\"></a>一、什么是vue-cli?</h3><p>vue脚手架指的是vue-cli，它是一个专门为单页面应用快速搭建繁杂的脚手架，它可以轻松的创建新的应用程序而且可用于自动生成vue和webpack的项目模板。</p>\n<p>vue-cli是有Vue提供的一个官方cli，专门为单页面应用快速搭建繁杂的脚手架。它是用于自动生成vue.js+webpack的项目模板，是为现代前端工作流提供了 batteries-included</p>\n<h3 id=\"二、安装vue-cli\"><a href=\"#二、安装vue-cli\" class=\"headerlink\" title=\"二、安装vue-cli\"></a>二、安装vue-cli</h3><p>安装vue-cli的前提是你已经安装了npm，安装npm你可以直接下载node的安装包进行安装。你可以在命令行工具里输入npm -v 检测你是否安装了npm和版本情况。出现版本号说明你已经安装了npm和node。</p>\n<p>npm没有问题，接下来我们可以用npm 命令安装vue-cli了，在命令行输入下面的命令：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-cli -g</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>-g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue</li>\n<li>-V来进行查看 vue-cli的版本号。注意这里的V是大写的。</li>\n</ul>\n<h3 id=\"三、初始化项目\"><a href=\"#三、初始化项目\" class=\"headerlink\" title=\"三、初始化项目\"></a>三、初始化项目</h3><p>用vue init命令来初始化项目如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init &lt;template-name&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">project-name</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>init：表示我要用vue-cli来初始化项目</p>\n<p><font color=\"red\">&lt;template-name&gt;</font>：表示模板名称，vue-cli官方为我们提供了5种模板，</p>\n<ul>\n<li>webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。</li>\n<li>webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。</li>\n<li>browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。</li>\n<li>browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。<br>-simple-一个最简单的单页应用模板。</li>\n</ul>\n<p><font color=\"red\">&lt;project-name&gt;</font>：标识项目名称，这个你可以根据自己的项目来起名字。</p>\n<p>在实际开发中，一般我们都会使用webpack这个模板，那我们这里也安装这个模板，在命令行输入以下命令：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack vuecliTest</span><br></pre></td></tr></table></figure></p>\n<p>输入命令后，会询问我们几个简单的选项，我们根据自己的需要进行填写就可以了。</p>\n<ul>\n<li>Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了vueclitest</li>\n<li>Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。</li>\n<li>Author：作者，如果你有配置git的作者，他会读取。</li>\n<li>Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y</li>\n<li>Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。</li>\n<li>setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。</li>\n<li>Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。</li>\n</ul>\n<p>命令行出现上面的文字，说明我们已经初始化好了第一步。命令行提示我们现在可以作的三件事情。</p>\n<ul>\n<li>cd vuecliTest 进入我们的vue项目目录。</li>\n<li>npm install 安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。</li>\n<li>npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。</li>\n</ul>\n<h3 id=\"四、vue-cli结构\"><a href=\"#四、vue-cli结构\" class=\"headerlink\" title=\"四、vue-cli结构\"></a>四、vue-cli结构</h3><p>vue-cli脚手架工具就是为我们搭建了开发所需要的环境，为我们省去了很多精力。有必要对这个环境进行熟悉，我们就从项目的结构讲起。</p>\n<p>Ps：由于版本实时更新和你选择安装的不同（这里列出的是模板为webpack的目录结构），所以你看到的有可能和下边的有所差别。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">|-- build                            <span class=\"comment\">// 项目构建(webpack)相关代码</span></span><br><span class=\"line\">|   |-- build.js                     <span class=\"comment\">// 生产环境构建代码</span></span><br><span class=\"line\">|   |-- check-version.js             <span class=\"comment\">// 检查node、npm等版本</span></span><br><span class=\"line\">|   |-- dev-client.js                <span class=\"comment\">// 热重载相关</span></span><br><span class=\"line\">|   |-- dev-server.js                <span class=\"comment\">// 构建本地服务器</span></span><br><span class=\"line\">|   |-- utils.js                     <span class=\"comment\">// 构建工具相关</span></span><br><span class=\"line\">|   |-- webpack.base.conf.js         <span class=\"comment\">// webpack基础配置</span></span><br><span class=\"line\">|   |-- webpack.dev.conf.js          <span class=\"comment\">// webpack开发环境配置</span></span><br><span class=\"line\">|   |-- webpack.prod.conf.js         <span class=\"comment\">// webpack生产环境配置</span></span><br><span class=\"line\">|-- config                           <span class=\"comment\">// 项目开发环境配置</span></span><br><span class=\"line\">|   |-- dev.env.js                   <span class=\"comment\">// 开发环境变量</span></span><br><span class=\"line\">|   |-- index.js                     <span class=\"comment\">// 项目一些配置变量</span></span><br><span class=\"line\">|   |-- prod.env.js                  <span class=\"comment\">// 生产环境变量</span></span><br><span class=\"line\">|   |-- test.env.js                  <span class=\"comment\">// 测试环境变量</span></span><br><span class=\"line\">|-- src                              <span class=\"comment\">// 源码目录</span></span><br><span class=\"line\">|   |-- components                     <span class=\"comment\">// vue公共组件</span></span><br><span class=\"line\">|   |-- store                          <span class=\"comment\">// vuex的状态管理</span></span><br><span class=\"line\">|   |-- App.vue                        <span class=\"comment\">// 页面入口文件</span></span><br><span class=\"line\">|   |-- main.js                        <span class=\"comment\">// 程序入口文件，加载各种公共组件</span></span><br><span class=\"line\">|-- <span class=\"keyword\">static</span>                           <span class=\"comment\">// 静态文件，比如一些图片，json数据等</span></span><br><span class=\"line\">|   |-- data                           <span class=\"comment\">// 群聊分析得到的数据用于数据可视化</span></span><br><span class=\"line\">|-- .babelrc                         <span class=\"comment\">// ES6语法编译配置</span></span><br><span class=\"line\">|-- .editorconfig                    <span class=\"comment\">// 定义代码格式</span></span><br><span class=\"line\">|-- .gitignore                       <span class=\"comment\">// git上传需要忽略的文件格式</span></span><br><span class=\"line\">|-- README.md                        <span class=\"comment\">// 项目说明</span></span><br><span class=\"line\">|-- favicon.ico </span><br><span class=\"line\">|-- index.html                       <span class=\"comment\">// 入口页面</span></span><br><span class=\"line\">|-- package.json                     <span class=\"comment\">// 项目基本信息</span></span><br><span class=\"line\">.</span><br></pre></td></tr></table></figure></p>\n<p>重要文件讲解：<br>package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。</p>\n<p>package.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"node build/dev-server.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"node build/build.js\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>dependencies字段和devDependencies字段</p>\n<ul>\n<li>dependencies字段指项目运行时所依赖的模块；</li>\n<li>devDependencies字段指定了项目开发时所依赖的模块；<br>在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。package.json还有很多相关配置</li>\n</ul>\n<h5 id=\"webpack相关配置\"><a href=\"#webpack相关配置\" class=\"headerlink\" title=\"webpack相关配置\"></a>webpack相关配置</h5><p>我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。</p>\n<p>dev-server.js<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查 Node 和 npm 版本</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./check-versions'</span>)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 config/index.js 的默认配置</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'../config'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果 Node 的环境无法判断当前是 dev / product 环境</span></span><br><span class=\"line\"><span class=\"comment\">// 使用 config.dev.env.NODE_ENV 作为当前的环境</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!process.env.NODE_ENV) process.env.NODE_ENV = <span class=\"built_in\">JSON</span>.parse(config.dev.env.NODE_ENV)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 NodeJS 自带的文件路径工具</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 express</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 webpack</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个可以强制打开浏览器并跳转到指定 url 的插件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> opn = <span class=\"built_in\">require</span>(<span class=\"string\">'opn'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 proxyTable</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxyMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'http-proxy-middleware'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 dev 环境的 webpack 配置</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.dev.conf'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// default port where dev server listens for incoming traffic</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果没有指定运行端口，使用 config.dev.port 作为运行端口</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> port = process.env.PORT || config.dev.port</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define HTTP proxies to your custom API backend</span></span><br><span class=\"line\"><span class=\"comment\">// https://github.com/chimurai/http-proxy-middleware</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> proxyTable = config.dev.proxyTable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 express 启动一个服务</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 webpack 进行编译</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(webpackConfig)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> devMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)(compiler, &#123;</span><br><span class=\"line\">  publicPath: webpackConfig.output.publicPath,</span><br><span class=\"line\">  stats: &#123;</span><br><span class=\"line\">    colors: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    chunks: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hotMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)(compiler)</span><br><span class=\"line\"><span class=\"comment\">// force page reload when html-webpack-plugin template changes</span></span><br><span class=\"line\">compiler.plugin(<span class=\"string\">'compilation'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">compilation</span>) </span>&#123;</span><br><span class=\"line\">  compilation.plugin(<span class=\"string\">'html-webpack-plugin-after-emit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, cb</span>) </span>&#123;</span><br><span class=\"line\">    hotMiddleware.publish(&#123; <span class=\"attr\">action</span>: <span class=\"string\">'reload'</span> &#125;)</span><br><span class=\"line\">    cb()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// proxy api requests</span></span><br><span class=\"line\"><span class=\"comment\">// 将 proxyTable 中的请求配置挂在到启动的 express 服务上</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(proxyTable).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> options = proxyTable[context]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> options === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    options = &#123; <span class=\"attr\">target</span>: options &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  app.use(proxyMiddleware(context, options))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handle fallback for HTML5 history API</span></span><br><span class=\"line\"><span class=\"comment\">// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址</span></span><br><span class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'connect-history-api-fallback'</span>)())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// serve webpack bundle output</span></span><br><span class=\"line\"><span class=\"comment\">// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上</span></span><br><span class=\"line\">app.use(devMiddleware)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// enable hot-reload and state-preserving</span></span><br><span class=\"line\"><span class=\"comment\">// compilation error display</span></span><br><span class=\"line\"><span class=\"comment\">// 将 Hot-reload 挂在到 express 服务上</span></span><br><span class=\"line\">app.use(hotMiddleware)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// serve pure static assets</span></span><br><span class=\"line\"><span class=\"comment\">// 拼接 static 文件夹的静态资源路径</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)</span><br><span class=\"line\"><span class=\"comment\">// 为静态资源提供响应服务</span></span><br><span class=\"line\">app.use(staticPath, express.static(<span class=\"string\">'./static'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = app.listen(port, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> uri = <span class=\"string\">'http://localhost:'</span> + port</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listening at '</span> + uri + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// when env is testing, don't need open it</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果不是测试环境，自动打开浏览器并跳到我们的开发地址</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'testing'</span>) &#123;</span><br><span class=\"line\">    opn(uri)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>webpack.base.confg.js webpack的基础配置文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">module</span>.export = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 编译入口文件</span></span><br><span class=\"line\">    entry: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 编译输出路径</span></span><br><span class=\"line\">    output: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 一些解决方案配置</span></span><br><span class=\"line\">    resolve: &#123;&#125;,</span><br><span class=\"line\">    resolveLoader: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 各种不同类型文件加载器配置</span></span><br><span class=\"line\">        loaders: &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// js文件用babel转码</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">            loader: <span class=\"string\">'babel'</span>,</span><br><span class=\"line\">            include: projectRoot,</span><br><span class=\"line\">            <span class=\"comment\">// 哪些文件不需要转码</span></span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// vue文件一些相关配置</span></span><br><span class=\"line\">    vue: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"babelrc\"><a href=\"#babelrc\" class=\"headerlink\" title=\".babelrc\"></a>.babelrc</h5><p>Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">//设定转码规则</span></span><br><span class=\"line\">  <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"env\"</span>, &#123; <span class=\"string\">\"modules\"</span>: <span class=\"literal\">false</span> &#125;],</span><br><span class=\"line\">    <span class=\"string\">\"stage-2\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"comment\">//转码用的插件</span></span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [<span class=\"string\">\"transform-runtime\"</span>],</span><br><span class=\"line\">  <span class=\"string\">\"comments\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">//对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作</span></span><br><span class=\"line\">  <span class=\"string\">\"env\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"test\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"presets\"</span>: [<span class=\"string\">\"env\"</span>, <span class=\"string\">\"stage-2\"</span>],</span><br><span class=\"line\">      <span class=\"string\">\"plugins\"</span>: [ <span class=\"string\">\"istanbul\"</span> ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"editorconfig\"><a href=\"#editorconfig\" class=\"headerlink\" title=\".editorconfig\"></a>.editorconfig</h5><p>该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">[*]    <span class=\"comment\">// 对所有文件应用下面的规则</span></span><br><span class=\"line\">charset = utf<span class=\"number\">-8</span>                    <span class=\"comment\">// 编码规则用utf-8</span></span><br><span class=\"line\">indent_style = space               <span class=\"comment\">// 缩进用空格</span></span><br><span class=\"line\">indent_size = <span class=\"number\">2</span>                    <span class=\"comment\">// 缩进数量为2个空格</span></span><br><span class=\"line\">end_of_line = lf                   <span class=\"comment\">// 换行符格式</span></span><br><span class=\"line\">insert_final_newline = <span class=\"literal\">true</span>        <span class=\"comment\">// 是否在文件的最后插入一个空行</span></span><br><span class=\"line\">trim_trailing_whitespace = <span class=\"literal\">true</span>    <span class=\"comment\">// 是否删除行尾的空格</span></span><br></pre></td></tr></table></figure></p>\n<p>这是比较重要的关于vue-cli的配置文件，当然还有很多其它文件这里就不多说了，你可以去百度了解下</p>\n<h3 id=\"五、解读Vue-cli的模板\"><a href=\"#五、解读Vue-cli的模板\" class=\"headerlink\" title=\"五、解读Vue-cli的模板\"></a>五、解读Vue-cli的模板</h3><p>我们通过两节课的讲解，你对vue-cli应该有了基本的了解，这节我们主要了解一下Vue-cli的模板操作，包括增加模板，修改模板，以及一个常规模板的基本结构。</p>\n<h5 id=\"1、npm-run-build-命令\"><a href=\"#1、npm-run-build-命令\" class=\"headerlink\" title=\"1、npm run build 命令\"></a>1、npm run build 命令</h5><p>有小伙伴问我，如何把写好的Vue网页放到服务器上，那我就在这里讲解一下，主要的命令就是要用到npm run build 命令。我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。你在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 。</p>\n<p>package.json的scripts 字段：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"node build/dev-server.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"node build/build.js\"</span></span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。</p>\n<p>dist文件夹下目录包括：</p>\n<ul>\n<li>index.html主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。</li>\n<li>static 静态资源文件夹：里边js、CSS和一些图片。</li>\n</ul>\n<h5 id=\"2、main-js解读\"><a href=\"#2、main-js解读\" class=\"headerlink\" title=\"2、main.js解读\"></a>2、main.js解读</h5><p>main.js是整个项目的入口文件,在src文件夹下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>      </span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.productionTip = <span class=\"literal\">false</span>   <span class=\"comment\">//生产环境提示，这里设置成了false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* eslint-disable no-new */</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;App/&gt;'</span>,</span><br><span class=\"line\">  components: &#123; App &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>通过代码可以看出这里引进了App的组件和的模板，它是通过 import App from ‘./App’这句代码引入的。 我们找到App.vue文件，打开查看。</p>\n<h5 id=\"3、app-vue文件\"><a href=\"#3、app-vue文件\" class=\"headerlink\" title=\"3、app.vue文件\"></a>3、app.vue文件</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;img src=<span class=\"string\">\"./assets/logo.png\"</span>&gt;</span><br><span class=\"line\">    &lt;router-view&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span></span><br><span class=\"line\">  &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'app'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;style&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">#app &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  font-family: 'Avenir', Helvetica, Arial, sans-serif;</span></span><br><span class=\"line\"><span class=\"regexp\">  -webkit-font-smoothing: antialiased;</span></span><br><span class=\"line\"><span class=\"regexp\">  -moz-osx-font-smoothing: grayscale;</span></span><br><span class=\"line\"><span class=\"regexp\">  text-align: center;</span></span><br><span class=\"line\"><span class=\"regexp\">  color: #2c3e50;</span></span><br><span class=\"line\"><span class=\"regexp\">  margin-top: 60px;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>\n<p>app.vue文件我们可以分成三部分解读，</p>\n<ul>\n<li><font color=\"red\">&lt;template&gt;</font><font color=\"red\">&lt;/template&gt;</font>标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和<font color=\"red\">&lt;router-view&gt;</font><font color=\"red\">&lt;/router-view&gt;</font>标签， <font color=\"red\">&lt;router-view&gt;</font>标签说明使用了路由机制。下一章我会讲到Vue-router。</li>\n<li><font color=\"red\">&lt;script&gt;</font><font color=\"red\">&lt;/script&gt;</font>标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。</li>\n<li><font color=\"red\">&lt;style&gt;</font><font color=\"red\">&lt;/style&gt;</font>标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用<font color=\"red\">&lt;style scoped&gt;</font><font color=\"red\">&lt;/style&gt;</font>来声明这些css样式只在本模板中起作用。<h5 id=\"4、router-index-js-路由文件\"><a href=\"#4、router-index-js-路由文件\" class=\"headerlink\" title=\"4、router/index.js 路由文件\"></a>4、router/index.js 路由文件</h5>引文在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。下章我们就开始讲Vue-router。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,</span><br><span class=\"line\">      component: Hello</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。</p>\n<h5 id=\"5、Hello-vue文件解读：\"><a href=\"#5、Hello-vue文件解读：\" class=\"headerlink\" title=\"5、Hello.vue文件解读：\"></a>5、Hello.vue文件解读：</h5><p>这个文件就是我们在第一章看到的页面文件了。也是分为<font color=\"red\">&lt;template&gt;&lt;script&gt;&lt;style&gt;</font>三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"hello\"</span>&gt;</span><br><span class=\"line\">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;h2&gt;Essential Links&lt;/</span>h2&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://vuejs.org\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Core Docs<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://forum.vuejs.org\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Forum<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://gitter.im/vuejs/vue\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Gitter Chat<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://twitter.com/vuejs\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Twitter<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;br&gt;</span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://vuejs-templates.github.io/webpack/\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>Docs for This Template<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;h2&gt;Ecosystem&lt;/</span>h2&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://router.vuejs.org/\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>vue-router<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://vuex.vuejs.org/\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>vuex<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://vue-loader.vuejs.org/\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>vue-loader<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">      &lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://github.com/vuejs/awesome-vue\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>awesome-vue<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/template&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">export default &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  name: 'hello',</span></span><br><span class=\"line\"><span class=\"regexp\">  data () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      msg: 'Welcome to Your Vue.js App'</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Add <span class=\"string\">\"scoped\"</span> attribute to limit CSS to <span class=\"keyword\">this</span> component only --&gt;</span><br><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\">h1, h2 &#123;</span><br><span class=\"line\">  font-weight: normal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ul &#123;</span><br><span class=\"line\">  list-style-type: none;</span><br><span class=\"line\">  padding: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">li &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  margin: <span class=\"number\">0</span> <span class=\"number\">10</span>px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a &#123;</span><br><span class=\"line\">  color: #42b983;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/style&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p> 这章只是带着你大概浏览和重点讲解了vue-cli的知识，如果你想完全弄明白vue-cli，我建议最好是有调理的阅读所有代码</p>\n"},{"title":"vue-router路由","comments":1,"date":"2020-01-07T16:00:00.000Z","author":"jun.zhou","_content":"\n\n![]()\n### 简介\n由于Vue在开发时对路由支持的不足，后来官方补充了vue-router插件，它在Vue的生态环境中非常重要，在实际开发中只要编写一个页面就会操作vue-router。要学习vue-router就要先知道这里的路由是什么？这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是我们WebApp的链接路径管理系统。\n有人会有疑虑，为什么我们不能像原来一样直接用&lt;a&gt;&lt;/a&gt;标签编写链接哪？因为我们用Vue作的都是单页应用，就相当于只有一个主的index.html页面，所以你写的&lt;a&gt;&lt;/a&gt;标签是不起作用的，你必须使用vue-router来进行管理。\n\n### 一、Vue-router入门\n##### 安装vue-router\nvue-router是一个插件包，所以我们还是需要用npm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。\n```js\nnpm install vue-router --save-dev\n```\n如果你安装很慢，也可以用cnpm进行安装，如果你在使用vue-cli中已经选择安装了vue-router，那这里不需要重复安装了。\n\n** 解读router/index.js文件**\n我们用vue-cli生产了我们的项目结构，你可以在src/router/index.js文件，这个文件就是路由的核心文件\n```js\nimport Vue from 'vue'   //引入Vue\nimport Router from 'vue-router'  //引入vue-router\nimport Hello from '@/components/Hello'  //引入根目录下的Hello.vue组件\n\nVue.use(Router)  //Vue全局使用Router\n\nexport default new Router({\n  routes: [              //配置路由，这里是个数组\n    {                    //每一个链接都是一个对象\n      path: '/',         //链接路径\n      name: 'Hello',     //路由名称，\n      component: Hello   //对应的组件模板\n    }\n  ]\n})\n```\n** 增加一个Hi的路由和页面 **\n对路由的核心文件熟悉后，我们试着增加一个路由配置，我们希望在地址栏输入 http://localhost:8080/#/hi 的时候出现一个新的页面\n\n然后我们看一下具体的操作步骤：\n- 在src/components目录下，新建 Hi.vue 文件。\n- 编写文件内容，和我们之前讲过的一样，文件要包括三个部分&lt;template&gt;&lt;script&gt;和&lt;style&gt;。文件很简单，只是打印一句话。\n```html\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'hi',\n  data () {\n    return {\n      msg: 'Hi, I am Jun'\n    }\n  }\n}\n</script>\n\n\n<style scoped>\n\n</style>\n```\n- 引入 Hi组件：我们在router/index.js文件的上边引入Hi组件\n```js\nimport Hi from '@/components/Hi'\n```\n- 增加路由配置：在router/index.js文件的routes[]数组中，新增加一个对象，代码如下。\n```js\n{\npath:'/hi',\nname:'Hi',\ncomponent:Hi\n}\n```\n通过上面的配置已经可以增加一个新的页面了。路由配置文件:\n```js\nimport Vue from 'vue'   //引入Vue\nimport Router from 'vue-router'  //引入vue-router\nimport Hello from '@/components/Hello'  //引入根目录下的Hello.vue组件\nimport Hi from '@/components/Hi' \n\nVue.use(Router)  //Vue全局使用Router\n\nexport default new Router({\n  routes: [              //配置路由，这里是个数组\n    {                    //每一个链接都是一个对象\n      path: '/',         //链接路径\n      name: 'Hello',     //路由名称，\n      component: Hello   //对应的组件模板\n    },{\n      path:'/hi',\n      name:'Hi',\n      component:Hi\n    }\n  ]\n})\n```\n** router-link制作导航 **\n现在通过在地址栏改变字符串地址，已经可以实现页面内容的变化了。这并不满足需求，我们需要的是在页面上有个像样的导航链接，我们只要点击就可以实现页面内容的变化。制作链接需要&lt;router-link&gt;标签，我们先来看一下它的语法。\n```html\n<router-link to=\"/\">[显示字段]</router-link>\n```\n- to：是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成 to=”/” ，\n- [显示字段] ：就是我们要显示给用户的导航名称，比如首页 新闻页。\n\n明白了router-link的基本语法，我们在 src/App.vue文件中的template里加入下面代码，实现导航。\n```html\n<p>导航 ：\n   <router-link to=\"/\">首页</router-link>\n   <router-link to=\"/hi\">Hi页面</router-link>\n</p>\n```\n现在我们访问页面，发现已经多出了导航。\n### 二、vue-router配置子路由\n我们上节初步了解Vue-router的初步知识，也学会了基本的跳转，那我们现在学习一下子菜单的路由方式，也叫子路由。子路由的情况一般用在一个页面有他的基础模版，然后它下面的页面都隶属于这个模版，只是部分改变样式。我们接着第一节的实例，在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。\n** 1、改造App.vue的导航代码 **\n我们需要先改造app.vue的导航代码，来实现基本的导航功能。我们用<router-link>标签增加了两个新的导航链接。\n\n** App.vue代码**\n```html\n<p>导航 ：\n      <router-link to=\"/\">首页</router-link> | \n      <router-link to=\"/hi\">Hi页面</router-link> |\n      <router-link to=\"/hi/hi1\">-Hi页面1</router-link> |\n      <router-link to=\"/hi/hi2\">-Hi页面2</router-link>\n</p>\n```\n这时候我们再访问主页的时候导航栏就发生了变化。多出了两个自导航：Hi页面1 和 Hi页面2\n** 2、改写components/Hi.vue页面 **\n\n把Hi.vue改成一个通用的模板，加入<router-view>标签，给子模板提供插入位置。“Hi页面1” 和 “Hi页面2” 都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入<router-view>标签。\n\n** components/Hi.vue,就是第5行的代码，其他代码不变。**\n```html\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n\n    <router-view class=\"aaa\"></router-view>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'hi',\n  data () {\n    return {\n      msg: 'Hi, I am Jun'\n    }\n  }\n}\n</script>\n<style scoped>\n\n</style>\n```\n* 3、在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue *\n\n新建的模板和Hi.vue没有太多的差别，知识改变了data中message的值，也就是输出的结果不太一样了。 Hi1.vue\n```html\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n  </div>\n</template>\n<script>\nexport default {\n  name: 'hi',\n  data () {\n    return {\n      msg: 'Hi, I am Hi1!'\n    }\n  }\n}\n</script>\n<style scoped>\n\n</style>\n```\nHi2.vue\n```html\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n  </div>\n</template>\n<script>\nexport default {\n  name: 'hi',\n  data () {\n    return {\n      msg: 'Hi, I am Hi2'\n    }\n  }\n}\n</script>\n<style scoped>\n</style>\n```\n4、修改router/index.js代码 我们现在导航有了，母模板和子模板也有了，只要改变我们的路由配置文件就可以了。子路由的写法是在原有的路由配置下加入children字段。\n```html\nchildren:[\n  {path:'/',component:xxx},\n  {path:'xx',component:xxx},\n]\n```\nchildren字段后边跟的是个数组，数组里和其他配置路由基本相同，需要配置path和component。具体看一下这个子路由的配置写法。\n```js\nimport Vue from 'vue'   \nimport Router from 'vue-router'  \nimport Hello from '@/components/Hello'  \nimport Hi from '@/components/Hi' \nimport Hi1 from '@/components/Hi1' \nimport Hi2 from '@/components/Hi2' \n\nVue.use(Router) \n\nexport default new Router({\n  routes: [             \n    {                    \n      path: '/',        \n      name: 'Hello',     \n      component: Hello   \n    },{\n      path:'/hi',\n      component:Hi,\n      children:[\n        {path:'/',component:Hi},\n        {path:'hi1',component:Hi1},\n        {path:'hi2',component:Hi2},\n      ]\n    }\n  ]\n})\n```\n需要注意的是，在配置路由文件前，需要先用import引入Hi1和Hi2。\n### 三、vue-router如何参数传递\n开发中，参数的传递是个最基本的业务需求。通过URL地址来传递参数是一个形式，这节我们就看看vue-router为我们提供了那些传递参数的功能。我们先想象一个基本需求，就是在我们点击导航菜单时，跳转页面上能显示出当前页面的路径，来告诉用户你想在所看的页面位置（类似于面包屑导航）。\n\n** 一、用name传递参数 ** \n前两节一直出现name的选项，但是我们都没有讲，这节我们讲name的一种作用，传递参数。接着上节的程序继续编写。\n\n两步完成用name传值并显示在模板里：\n\n- 在路由文件src/router/index.js里配置name属性\n```js\nroutes: [\n{\n  path: '/',\n  name: 'Hello',\n  component: Hello\n}\n]\n```\n- 模板里(src/App.vue)用$route.name的形势接收，比如直接在模板中显示：\n```html\n<p>{{ $route.name}}</p>\n```\n** 二、通过&lt;router-link&gt; 标签中的to传参 **\n\n也许你也会觉的上边的传参很不正规，也不方便，其实我们多数传参是不用name进行传参的，我们用&lt;router-link&gt;标签中的to属性进行传参，需要您注意的是这里的to要进行一个绑定，写成:to。先来看一下这种传参方法的基本语法：\n```html\n<router-link :to=\"{name:xxx,params:{key:value}}\">valueString</router-link>\n```\n这里的to前边是带冒号的，然后后边跟的是一个对象形势的字符串.\n\n- name：就是我们在路由配置文件中起的name值。\n- params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。\n了解基本的语法后，我们改造一下我们的src/App.vue里的&lt;router-link&gt;标签,我们把hi1页面的&lt;router-link&gt;进行修改。\n```html\n<router-link :to=\"{name:'hi1',params:{username:'jun'}}\">Hi页面1</router-link>\n```\n把src/reouter/index.js文件里给hi1配置的路由起个name,就叫hi1.\n```js\n{path:'/hi1',name:'hi1',component:Hi1},\n```\n最后在模板里(src/components/Hi1.vue)用$route.params.username进行接收.\n```js\n{{$route.params.username}}\n```\n*总结： * 今天我们学习了两种传参的方法，一般会使用第二种方法。我们通过学习也知道了name的用途，一种作用是传参，一种作用是在传参时起到名称作用。传参的操作在实际开发中是基本的需求，我们一定要掌握好啊。\n### 四、单页面多路由区域操作\n这节我们讲“单页面多路由区域操作”，实际需求是这样的，在一个页面里我们有2个以上&lt;router-view&gt;区域，我们通过配置路由的js文件，来操作这些区域的内容。例如我们在src/App.vue里加上两个&lt;router-view&gt;标签。我们用vue-cli建立了新的项目，并打开了src目录下的App.vue文件，在&lt;router-view&gt;下面新写了两行&lt;router-view&gt;标签,并加入了些CSS样式。\n```html\n<router-view ></router-view>\n<router-view name=\"left\" style=\"float:left;width:50%;background-color:#ccc;height:300px;\"></router-view>\n<router-view name=\"right\" style=\"float:right;width:50%;background-color:#c0c;height:300px;\"></router-view>\n```\n现在的页面中有了三个&lt;router-view&gt;标签，也就是说我们需要在路由里配置这三个区域，配置主要是在components字段里进行。\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport Hello from '@/components/Hello'\nimport Hi1 from '@/components/Hi1'\nimport Hi2 from '@/components/Hi2'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      components: {\n        default:Hello,\n        left:Hi1,\n        right:Hi2\n      }\n    },{\n      path: '/Hi',\n      components: {\n        default:Hello,\n        left:Hi2,\n        right:Hi1\n      }\n    }\n\n  ]\n})\n```\n上边的代码我们编写了两个路径，一个是默认的‘/’，另一个是’/Hi’.在两个路径下的components里面，我们对三个区域都定义了显示内容。 定义好后，我们需要在component文件夹下，新建Hi1.vue和Hi2.vue页面就可以了。\n** Hi1.vue **\n```html\n<template>\n    <div>\n        <h2>{{ msg }}</h2> \n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'hi1',\n  data () {\n    return {\n      msg: 'I am Hi1 page.'\n    }\n  }\n}\n</script>\n```\n** Hi2.vue **\n```html\n<template>\n    <div>\n        <h2>{{ msg }}</h2>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'hi2',\n  data () {\n    return {\n      msg: 'I am Hi2 page.'\n    }\n  }\n}\n</script>\n```\n最后在App.vue中配置我们的&lt;router-link&gt;就可以了\n```html\n<router-link to=\"/\">首页</router-link> | \n<router-link to=\"/hi\">Hi页面</router-link> |\n```\n### 五、vue-router 利用url传递参数\n我们在第3节虽然已经学会传递参数，但是我们这些老程序员的情怀还是利用url来传值，因为我们以前在前后端没有分开开发的时候，经常这样做。在实际开发也是有很多用URL传值的需求，比如我们在新闻列表中有很多新闻标题整齐的排列，我们需要点击每个新闻标题打开不同的新闻内容，这时在跳转路由时跟上新闻编号就十分实用。\n\n** :冒号的形式传递参数 ** 我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。 \n-. 在配置文件里以冒号的形式设置参数。我们在/src/router/index.js文件里配置路由。\n```js\n{\n    path:'/params/:newsId/:newsTitle',\n     component:Params\n}\n```\n我们需要传递参数是新闻ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。\n- 在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。\n```html\n<template>\n    <div>\n        <h2>{{ msg }}</h2>\n        <p>新闻ID：{{ $route.params.newsId}}</p>\n        <p>新闻标题：{{ $route.params.newsTitle}}</p>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'params',\n  data () {\n    return {\n      msg: 'params page'\n    }\n  }\n}\n</script>\n```\n在App.vue文件里加入我们的&lt;router-view&gt;标签。这时候我们可以直接利用url传值了。\n```html\n<router-link to=\"/params/198/jun website is very good\">params</router-link> |\n```\n我们已经实现了以url方式进行传值，这在实际开发中经常使用，必须完全了解。我希望你看完视频后或者学完文章后能多练习两边，并在实际项目中充分使用。\n\n** 正则表达式在URL传值中的应用 **\n\n上边的例子，我们传递了新闻编号，现在需求升级了，我们希望我们传递的新闻ID只能是数字的形式，这时候我们就需要在传递时有个基本的类型判断，vue是支持正则的。\n\n加入正则需要在路由配置文件里（/src/router/index.js）以圆括号的形式加入。\n```js\npath:'/params/:newsId(\\\\d+)/:newsTitle',\n```\n加入了正则，我们再传递数字之外的其他参数，params.vue组件就没有办法接收到。\n### 六、vue-router 的重定向-redirect\n开发中有时候我们虽然设置的路径不一致，但是我们希望跳转到同一个页面，或者说是打开同一个组件。这时候我们就用到了路由的重新定向redirect参数。\n\n** redirect基本重定向 **\n我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。\n```js\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      component: Hello\n    },{\n      path:'/params/:newsId(\\\\d+)/:newsTitle',\n      component:Params\n    },{\n      path:'/goback',\n      redirect:'/'\n    }\n\n  ]\n})\n```\n这里我们设置了goback路由，但是它并没有配置任何component（组件），而是直接redirect到path:’/’下了，这就是一个简单的重新定向。\n\n** 重定向时传递参数**\n\n我们已经学会了通过url来传递参数，那我们重定向时如果也需要传递参数怎么办？其实vue也已经为我们设置好了，我们只需要在ridirect后边的参数里复制重定向路径的path参数就可以了。可能你看的有点晕，我们来看一段代码：\n```js\n{\n  path:'/params/:newsId(\\\\d+)/:newsTitle',\n  component:Params\n},{\n  path:'/goParams/:newsId(\\\\d+)/:newsTitle',\n  redirect:'/params/:newsId(\\\\d+)/:newsTitle'\n}\n```\n已经有了一个params路由配置，我们在设置一个goParams的路由重定向，并传递了参数。这时候我们的路由参数就可以传递给params.vue组件了。参数接收方法和正常的路由接收方法一样。\n### 七、alias别名的使用\n上节学习了路由的重定向，我相信大家已经可以熟练使用redirect进行重定向了。使用alias别名的形式，我们也可以实现类似重定向的效果。\n\n1.首先我们在路由配置文件里（/src/router/index.js），给上节的Home路径起一个别名，jun。\n```js\n{\n    path: '/hi1',\n    component: Hi1,\n    alias:'/jun'\n }\n ```\n 2.配置我们的<router-link>，起过别名之后，可以直接使用<router-link>标签里的to属性，进行重新定向。\n ```html\n <router-link < to=\"/jun\">jun</router-link>\n```\n** redirect和alias的区别 **\n\nredirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。\nalias：URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了<router-view>中的内容。\n** 填个小坑： ** 别名请不要用在path为’/’中，如下代码的别名是不起作用的。\n```js\n{\n  path: '/',\n  component: Hello,\n  alias:'/home'\n}\n```\n### 八、路由的过渡动画\n在开发中有一种需求叫高端、大气、上档次。所以作为一个大前端有责任让你的程序开起来更酷炫。可以在页面切换时我们加入一些动画效果，提升我们程序的动效设计。这节课我们就学习一下路由的过渡动画效果制作。\n\n&lt;transition&gt;标签\n想让路由有过渡动画，需要在&lt;router-view&gt;标签的外部添加&lt;transition&gt;标签，标签还需要一个name属性。\n```html\n<transition name=\"fade\">\n  <router-view ></router-view>\n</transition>\n```\n我们在/src/App.vue文件里添加了&lt;transition&gt;标签，并给标签起了一个名字叫fade。\n\n** css过渡类名： ** 组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名：\n\n- fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。\n- fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。\n- fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。\n- fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。\n从上面四个类名可以看出，fade-enter-active和fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。\n\n那我们就在App.vue页面里加入四种CSS样式效果，并利用CSS3的transition属性控制动画的具体效果。代码如下：\n```css\n.fade-enter {\n  opacity:0;\n}\n.fade-leave{\n  opacity:1;\n}\n.fade-enter-active{\n  transition:opacity .5s;\n}\n.fade-leave-active{\n  opacity:0;\n  transition:opacity .5s;\n}\n```\n上边的代码设置了改变透明度的动画过渡效果，但是默认的mode模式in-out模式，这并不是我们想要的。下面我们学一下mode模式。\n\n** 过渡模式mode： **\n\n- in-out:新元素先进入过渡，完成之后当前元素过渡离开。\n- out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。\n\n### 九、mode的设置和404页面的处理\n在学习过渡效果的时候，我们学了mode的设置，但是在路由的属性中还有一个mode。这节课我们就学习一下另一个mode模式和404页面的设置。\n\n** mode的两个值 **\n\n- histroy:当你使用 history 模式时，URL 就像正常的 url，例如 http://www.justyouxx.top/，也好看！\n\n- hash:默认’hash’值，但是hash看起来就像无意义的字符排列，不太好看也不符合我们一般的网址浏览习惯。\n\n\n** 404页面的设置： **\n\n用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。vue-router也为我们提供了这样的机制.\n\n1.设置我们的路由配置文件（/src/router/index.js）：\n```js\n{\n   path:'*',\n   component:Error\n}\n```\n这里的path:’*’就是找不到页面时的配置，component是我们新建的一个Error.vue的文件。\n\n2.新建404页面：\n\n在/src/components/文件夹下新建一个Error.vue的文件。简单输入一些有关错误页面的内容。\n```html\n<template>\n    <div>\n        <h2>{{ msg }}</h2>\n    </div>\n</template>\n<script>\nexport default {\n  data () {\n    return {\n      msg: 'Error:404'\n    }\n  }\n}\n</script>\n```\n3.我们在用<router-link>瞎写一个标签的路径。\n```html\n<router-link to=\"/bbbbbb\">这是瞎写的</router-link> |\n```\n预览一下我们现在的结果，就已经实现404页面的效果。\n### 十、路由中的钩子\n我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节就介绍这两种钩子函数的写法。\n\n** 路由配置文件中的钩子函数 **\n\n我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。先来看一段具体的代码：\n```js\n{\n      path:'/params/:newsId(\\\\d+)/:newsTitle',\n      component:Params,\n      beforeEnter:(to,from,next)=>{\n        console.log('我进入了params模板');\n        console.log(to);\n        console.log(from);\n        next();\n},\n```\n我们在params路由里配置了bdforeEnter得钩子函数，函数我们采用了ES6的箭头函数，需要传递三个参数。我们并在箭头函数中打印了to和from函数。具体打印内容可以在控制台查看object。\n\n三个参数：\n\n- to:路由将要跳转的路径信息，信息是包含在对像里边的。\n- from:路径跳转前的路径信息，也是一个对象的形式。\n- next:路由的控制参数，常用的有next(true)和next(false)。\n\n** 写在模板中的钩子函数 ** 在配置文件中的钩子函数，只有一个钩子-beforeEnter，如果我们写在模板中就可以有两个钩子函数可以使用：\n\n- beforeRouteEnter：在路由进入前的钩子函数。\n- beforeRouteLeave：在路由离开前的钩子函数。\n```js\nexport default {\n  name: 'params',\n  data () {\n    return {\n      msg: 'params page'\n    }\n  },\n  beforeRouteEnter:(to,from,next)=>{\n    console.log(\"准备进入路由模板\");\n    next();\n  },\n  beforeRouteLeave: (to, from, next) => {\n    console.log(\"准备离开路由模板\");\n    next();\n  }\n}\n```\n这是我们写在params.vue模板里的路由钩子函数。它可以监控到路由的进入和路由的离开，也可以轻易的读出to和from的值。\n\n### 十一、编程式导航\n这是这篇文章的最后一节，前10节的导航都是用<router-link>标签或者直接操作地址栏的形式完成的，那如果在业务逻辑代码中需要跳转页面我们如何操作？这就是我们要说的编程式导航，顾名思义，就是在业务逻辑代码中实现导航。\n\n** this.$router.go(-1) 和 this.$router.go(1) **\n\n这两个编程式导航的意思是后退和前进，功能跟我们浏览器上的后退和前进按钮一样，这在业务逻辑中经常用到。比如条件不满足时，我们需要后退。\n\nrouter.go(-1)代表着后退，我们可以让我们的导航进行后退，并且我们的地址栏也是有所变化的。\n\n1.我们先在app.vue文件里加入一个按钮，按钮并绑定一个goback( )方法。\n```html\n<button @click=\"goback\">后退</button>\n```\n2.在我们的script模块中写入goback()方法，并使用this.$router.go(-1),进行后退操作。\n```js\n<script>\nexport default {\n  name: 'app',\n  methods:{\n    goback(){\n      this.$router.go(-1);\n    }\n  }\n}\n</script>\n```\n打开浏览器进行预览，这时我们的后退按钮就可以向以前的网页一样后退了。\n\nrouter.go(1):代表着前进，用法和后退一样，我在这里就不重复码字了。\n\nthis.$router.push(‘/xxx ‘)\n\n这个编程式导航都作用就是跳转，比如我们判断用户名和密码正确时，需要跳转到用户中心页面或者首页，都用到这个编程的方法来操作路由。\n\n我们设置一个按钮，点击按钮后回到站点首页。\n\n1.先编写一个按钮，在按钮上绑定goHome( )方法。\n```html\n<button @click=\"goHome\">回到首页</button>\n```\n2.在&lt;script&gt;模块里加入goHome方法，并用this.$router.push(‘/’)导航到首页\n```js\nexport default {\n  name: 'app',\n  methods:{\n    goback(){\n      this.$router.go(-1);\n    },\n    goHome(){\n      this.$router.push('/');\n    }\n  }\n}\n```","source":"_posts/2020-01-08-Vue-router路由.md","raw":"---\ntitle: vue-router路由\ncomments: true\ndate: 2020-01-08\ntags:\n- vue-router vue\ncategories:\n- WEB前端\nauthor: jun.zhou\n---\n\n\n![]()\n### 简介\n由于Vue在开发时对路由支持的不足，后来官方补充了vue-router插件，它在Vue的生态环境中非常重要，在实际开发中只要编写一个页面就会操作vue-router。要学习vue-router就要先知道这里的路由是什么？这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是我们WebApp的链接路径管理系统。\n有人会有疑虑，为什么我们不能像原来一样直接用&lt;a&gt;&lt;/a&gt;标签编写链接哪？因为我们用Vue作的都是单页应用，就相当于只有一个主的index.html页面，所以你写的&lt;a&gt;&lt;/a&gt;标签是不起作用的，你必须使用vue-router来进行管理。\n\n### 一、Vue-router入门\n##### 安装vue-router\nvue-router是一个插件包，所以我们还是需要用npm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。\n```js\nnpm install vue-router --save-dev\n```\n如果你安装很慢，也可以用cnpm进行安装，如果你在使用vue-cli中已经选择安装了vue-router，那这里不需要重复安装了。\n\n** 解读router/index.js文件**\n我们用vue-cli生产了我们的项目结构，你可以在src/router/index.js文件，这个文件就是路由的核心文件\n```js\nimport Vue from 'vue'   //引入Vue\nimport Router from 'vue-router'  //引入vue-router\nimport Hello from '@/components/Hello'  //引入根目录下的Hello.vue组件\n\nVue.use(Router)  //Vue全局使用Router\n\nexport default new Router({\n  routes: [              //配置路由，这里是个数组\n    {                    //每一个链接都是一个对象\n      path: '/',         //链接路径\n      name: 'Hello',     //路由名称，\n      component: Hello   //对应的组件模板\n    }\n  ]\n})\n```\n** 增加一个Hi的路由和页面 **\n对路由的核心文件熟悉后，我们试着增加一个路由配置，我们希望在地址栏输入 http://localhost:8080/#/hi 的时候出现一个新的页面\n\n然后我们看一下具体的操作步骤：\n- 在src/components目录下，新建 Hi.vue 文件。\n- 编写文件内容，和我们之前讲过的一样，文件要包括三个部分&lt;template&gt;&lt;script&gt;和&lt;style&gt;。文件很简单，只是打印一句话。\n```html\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'hi',\n  data () {\n    return {\n      msg: 'Hi, I am Jun'\n    }\n  }\n}\n</script>\n\n\n<style scoped>\n\n</style>\n```\n- 引入 Hi组件：我们在router/index.js文件的上边引入Hi组件\n```js\nimport Hi from '@/components/Hi'\n```\n- 增加路由配置：在router/index.js文件的routes[]数组中，新增加一个对象，代码如下。\n```js\n{\npath:'/hi',\nname:'Hi',\ncomponent:Hi\n}\n```\n通过上面的配置已经可以增加一个新的页面了。路由配置文件:\n```js\nimport Vue from 'vue'   //引入Vue\nimport Router from 'vue-router'  //引入vue-router\nimport Hello from '@/components/Hello'  //引入根目录下的Hello.vue组件\nimport Hi from '@/components/Hi' \n\nVue.use(Router)  //Vue全局使用Router\n\nexport default new Router({\n  routes: [              //配置路由，这里是个数组\n    {                    //每一个链接都是一个对象\n      path: '/',         //链接路径\n      name: 'Hello',     //路由名称，\n      component: Hello   //对应的组件模板\n    },{\n      path:'/hi',\n      name:'Hi',\n      component:Hi\n    }\n  ]\n})\n```\n** router-link制作导航 **\n现在通过在地址栏改变字符串地址，已经可以实现页面内容的变化了。这并不满足需求，我们需要的是在页面上有个像样的导航链接，我们只要点击就可以实现页面内容的变化。制作链接需要&lt;router-link&gt;标签，我们先来看一下它的语法。\n```html\n<router-link to=\"/\">[显示字段]</router-link>\n```\n- to：是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成 to=”/” ，\n- [显示字段] ：就是我们要显示给用户的导航名称，比如首页 新闻页。\n\n明白了router-link的基本语法，我们在 src/App.vue文件中的template里加入下面代码，实现导航。\n```html\n<p>导航 ：\n   <router-link to=\"/\">首页</router-link>\n   <router-link to=\"/hi\">Hi页面</router-link>\n</p>\n```\n现在我们访问页面，发现已经多出了导航。\n### 二、vue-router配置子路由\n我们上节初步了解Vue-router的初步知识，也学会了基本的跳转，那我们现在学习一下子菜单的路由方式，也叫子路由。子路由的情况一般用在一个页面有他的基础模版，然后它下面的页面都隶属于这个模版，只是部分改变样式。我们接着第一节的实例，在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。\n** 1、改造App.vue的导航代码 **\n我们需要先改造app.vue的导航代码，来实现基本的导航功能。我们用<router-link>标签增加了两个新的导航链接。\n\n** App.vue代码**\n```html\n<p>导航 ：\n      <router-link to=\"/\">首页</router-link> | \n      <router-link to=\"/hi\">Hi页面</router-link> |\n      <router-link to=\"/hi/hi1\">-Hi页面1</router-link> |\n      <router-link to=\"/hi/hi2\">-Hi页面2</router-link>\n</p>\n```\n这时候我们再访问主页的时候导航栏就发生了变化。多出了两个自导航：Hi页面1 和 Hi页面2\n** 2、改写components/Hi.vue页面 **\n\n把Hi.vue改成一个通用的模板，加入<router-view>标签，给子模板提供插入位置。“Hi页面1” 和 “Hi页面2” 都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入<router-view>标签。\n\n** components/Hi.vue,就是第5行的代码，其他代码不变。**\n```html\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n\n    <router-view class=\"aaa\"></router-view>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'hi',\n  data () {\n    return {\n      msg: 'Hi, I am Jun'\n    }\n  }\n}\n</script>\n<style scoped>\n\n</style>\n```\n* 3、在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue *\n\n新建的模板和Hi.vue没有太多的差别，知识改变了data中message的值，也就是输出的结果不太一样了。 Hi1.vue\n```html\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n  </div>\n</template>\n<script>\nexport default {\n  name: 'hi',\n  data () {\n    return {\n      msg: 'Hi, I am Hi1!'\n    }\n  }\n}\n</script>\n<style scoped>\n\n</style>\n```\nHi2.vue\n```html\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n  </div>\n</template>\n<script>\nexport default {\n  name: 'hi',\n  data () {\n    return {\n      msg: 'Hi, I am Hi2'\n    }\n  }\n}\n</script>\n<style scoped>\n</style>\n```\n4、修改router/index.js代码 我们现在导航有了，母模板和子模板也有了，只要改变我们的路由配置文件就可以了。子路由的写法是在原有的路由配置下加入children字段。\n```html\nchildren:[\n  {path:'/',component:xxx},\n  {path:'xx',component:xxx},\n]\n```\nchildren字段后边跟的是个数组，数组里和其他配置路由基本相同，需要配置path和component。具体看一下这个子路由的配置写法。\n```js\nimport Vue from 'vue'   \nimport Router from 'vue-router'  \nimport Hello from '@/components/Hello'  \nimport Hi from '@/components/Hi' \nimport Hi1 from '@/components/Hi1' \nimport Hi2 from '@/components/Hi2' \n\nVue.use(Router) \n\nexport default new Router({\n  routes: [             \n    {                    \n      path: '/',        \n      name: 'Hello',     \n      component: Hello   \n    },{\n      path:'/hi',\n      component:Hi,\n      children:[\n        {path:'/',component:Hi},\n        {path:'hi1',component:Hi1},\n        {path:'hi2',component:Hi2},\n      ]\n    }\n  ]\n})\n```\n需要注意的是，在配置路由文件前，需要先用import引入Hi1和Hi2。\n### 三、vue-router如何参数传递\n开发中，参数的传递是个最基本的业务需求。通过URL地址来传递参数是一个形式，这节我们就看看vue-router为我们提供了那些传递参数的功能。我们先想象一个基本需求，就是在我们点击导航菜单时，跳转页面上能显示出当前页面的路径，来告诉用户你想在所看的页面位置（类似于面包屑导航）。\n\n** 一、用name传递参数 ** \n前两节一直出现name的选项，但是我们都没有讲，这节我们讲name的一种作用，传递参数。接着上节的程序继续编写。\n\n两步完成用name传值并显示在模板里：\n\n- 在路由文件src/router/index.js里配置name属性\n```js\nroutes: [\n{\n  path: '/',\n  name: 'Hello',\n  component: Hello\n}\n]\n```\n- 模板里(src/App.vue)用$route.name的形势接收，比如直接在模板中显示：\n```html\n<p>{{ $route.name}}</p>\n```\n** 二、通过&lt;router-link&gt; 标签中的to传参 **\n\n也许你也会觉的上边的传参很不正规，也不方便，其实我们多数传参是不用name进行传参的，我们用&lt;router-link&gt;标签中的to属性进行传参，需要您注意的是这里的to要进行一个绑定，写成:to。先来看一下这种传参方法的基本语法：\n```html\n<router-link :to=\"{name:xxx,params:{key:value}}\">valueString</router-link>\n```\n这里的to前边是带冒号的，然后后边跟的是一个对象形势的字符串.\n\n- name：就是我们在路由配置文件中起的name值。\n- params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。\n了解基本的语法后，我们改造一下我们的src/App.vue里的&lt;router-link&gt;标签,我们把hi1页面的&lt;router-link&gt;进行修改。\n```html\n<router-link :to=\"{name:'hi1',params:{username:'jun'}}\">Hi页面1</router-link>\n```\n把src/reouter/index.js文件里给hi1配置的路由起个name,就叫hi1.\n```js\n{path:'/hi1',name:'hi1',component:Hi1},\n```\n最后在模板里(src/components/Hi1.vue)用$route.params.username进行接收.\n```js\n{{$route.params.username}}\n```\n*总结： * 今天我们学习了两种传参的方法，一般会使用第二种方法。我们通过学习也知道了name的用途，一种作用是传参，一种作用是在传参时起到名称作用。传参的操作在实际开发中是基本的需求，我们一定要掌握好啊。\n### 四、单页面多路由区域操作\n这节我们讲“单页面多路由区域操作”，实际需求是这样的，在一个页面里我们有2个以上&lt;router-view&gt;区域，我们通过配置路由的js文件，来操作这些区域的内容。例如我们在src/App.vue里加上两个&lt;router-view&gt;标签。我们用vue-cli建立了新的项目，并打开了src目录下的App.vue文件，在&lt;router-view&gt;下面新写了两行&lt;router-view&gt;标签,并加入了些CSS样式。\n```html\n<router-view ></router-view>\n<router-view name=\"left\" style=\"float:left;width:50%;background-color:#ccc;height:300px;\"></router-view>\n<router-view name=\"right\" style=\"float:right;width:50%;background-color:#c0c;height:300px;\"></router-view>\n```\n现在的页面中有了三个&lt;router-view&gt;标签，也就是说我们需要在路由里配置这三个区域，配置主要是在components字段里进行。\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport Hello from '@/components/Hello'\nimport Hi1 from '@/components/Hi1'\nimport Hi2 from '@/components/Hi2'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      components: {\n        default:Hello,\n        left:Hi1,\n        right:Hi2\n      }\n    },{\n      path: '/Hi',\n      components: {\n        default:Hello,\n        left:Hi2,\n        right:Hi1\n      }\n    }\n\n  ]\n})\n```\n上边的代码我们编写了两个路径，一个是默认的‘/’，另一个是’/Hi’.在两个路径下的components里面，我们对三个区域都定义了显示内容。 定义好后，我们需要在component文件夹下，新建Hi1.vue和Hi2.vue页面就可以了。\n** Hi1.vue **\n```html\n<template>\n    <div>\n        <h2>{{ msg }}</h2> \n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'hi1',\n  data () {\n    return {\n      msg: 'I am Hi1 page.'\n    }\n  }\n}\n</script>\n```\n** Hi2.vue **\n```html\n<template>\n    <div>\n        <h2>{{ msg }}</h2>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'hi2',\n  data () {\n    return {\n      msg: 'I am Hi2 page.'\n    }\n  }\n}\n</script>\n```\n最后在App.vue中配置我们的&lt;router-link&gt;就可以了\n```html\n<router-link to=\"/\">首页</router-link> | \n<router-link to=\"/hi\">Hi页面</router-link> |\n```\n### 五、vue-router 利用url传递参数\n我们在第3节虽然已经学会传递参数，但是我们这些老程序员的情怀还是利用url来传值，因为我们以前在前后端没有分开开发的时候，经常这样做。在实际开发也是有很多用URL传值的需求，比如我们在新闻列表中有很多新闻标题整齐的排列，我们需要点击每个新闻标题打开不同的新闻内容，这时在跳转路由时跟上新闻编号就十分实用。\n\n** :冒号的形式传递参数 ** 我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。 \n-. 在配置文件里以冒号的形式设置参数。我们在/src/router/index.js文件里配置路由。\n```js\n{\n    path:'/params/:newsId/:newsTitle',\n     component:Params\n}\n```\n我们需要传递参数是新闻ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。\n- 在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。\n```html\n<template>\n    <div>\n        <h2>{{ msg }}</h2>\n        <p>新闻ID：{{ $route.params.newsId}}</p>\n        <p>新闻标题：{{ $route.params.newsTitle}}</p>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'params',\n  data () {\n    return {\n      msg: 'params page'\n    }\n  }\n}\n</script>\n```\n在App.vue文件里加入我们的&lt;router-view&gt;标签。这时候我们可以直接利用url传值了。\n```html\n<router-link to=\"/params/198/jun website is very good\">params</router-link> |\n```\n我们已经实现了以url方式进行传值，这在实际开发中经常使用，必须完全了解。我希望你看完视频后或者学完文章后能多练习两边，并在实际项目中充分使用。\n\n** 正则表达式在URL传值中的应用 **\n\n上边的例子，我们传递了新闻编号，现在需求升级了，我们希望我们传递的新闻ID只能是数字的形式，这时候我们就需要在传递时有个基本的类型判断，vue是支持正则的。\n\n加入正则需要在路由配置文件里（/src/router/index.js）以圆括号的形式加入。\n```js\npath:'/params/:newsId(\\\\d+)/:newsTitle',\n```\n加入了正则，我们再传递数字之外的其他参数，params.vue组件就没有办法接收到。\n### 六、vue-router 的重定向-redirect\n开发中有时候我们虽然设置的路径不一致，但是我们希望跳转到同一个页面，或者说是打开同一个组件。这时候我们就用到了路由的重新定向redirect参数。\n\n** redirect基本重定向 **\n我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。\n```js\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      component: Hello\n    },{\n      path:'/params/:newsId(\\\\d+)/:newsTitle',\n      component:Params\n    },{\n      path:'/goback',\n      redirect:'/'\n    }\n\n  ]\n})\n```\n这里我们设置了goback路由，但是它并没有配置任何component（组件），而是直接redirect到path:’/’下了，这就是一个简单的重新定向。\n\n** 重定向时传递参数**\n\n我们已经学会了通过url来传递参数，那我们重定向时如果也需要传递参数怎么办？其实vue也已经为我们设置好了，我们只需要在ridirect后边的参数里复制重定向路径的path参数就可以了。可能你看的有点晕，我们来看一段代码：\n```js\n{\n  path:'/params/:newsId(\\\\d+)/:newsTitle',\n  component:Params\n},{\n  path:'/goParams/:newsId(\\\\d+)/:newsTitle',\n  redirect:'/params/:newsId(\\\\d+)/:newsTitle'\n}\n```\n已经有了一个params路由配置，我们在设置一个goParams的路由重定向，并传递了参数。这时候我们的路由参数就可以传递给params.vue组件了。参数接收方法和正常的路由接收方法一样。\n### 七、alias别名的使用\n上节学习了路由的重定向，我相信大家已经可以熟练使用redirect进行重定向了。使用alias别名的形式，我们也可以实现类似重定向的效果。\n\n1.首先我们在路由配置文件里（/src/router/index.js），给上节的Home路径起一个别名，jun。\n```js\n{\n    path: '/hi1',\n    component: Hi1,\n    alias:'/jun'\n }\n ```\n 2.配置我们的<router-link>，起过别名之后，可以直接使用<router-link>标签里的to属性，进行重新定向。\n ```html\n <router-link < to=\"/jun\">jun</router-link>\n```\n** redirect和alias的区别 **\n\nredirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。\nalias：URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了<router-view>中的内容。\n** 填个小坑： ** 别名请不要用在path为’/’中，如下代码的别名是不起作用的。\n```js\n{\n  path: '/',\n  component: Hello,\n  alias:'/home'\n}\n```\n### 八、路由的过渡动画\n在开发中有一种需求叫高端、大气、上档次。所以作为一个大前端有责任让你的程序开起来更酷炫。可以在页面切换时我们加入一些动画效果，提升我们程序的动效设计。这节课我们就学习一下路由的过渡动画效果制作。\n\n&lt;transition&gt;标签\n想让路由有过渡动画，需要在&lt;router-view&gt;标签的外部添加&lt;transition&gt;标签，标签还需要一个name属性。\n```html\n<transition name=\"fade\">\n  <router-view ></router-view>\n</transition>\n```\n我们在/src/App.vue文件里添加了&lt;transition&gt;标签，并给标签起了一个名字叫fade。\n\n** css过渡类名： ** 组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名：\n\n- fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。\n- fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。\n- fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。\n- fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。\n从上面四个类名可以看出，fade-enter-active和fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。\n\n那我们就在App.vue页面里加入四种CSS样式效果，并利用CSS3的transition属性控制动画的具体效果。代码如下：\n```css\n.fade-enter {\n  opacity:0;\n}\n.fade-leave{\n  opacity:1;\n}\n.fade-enter-active{\n  transition:opacity .5s;\n}\n.fade-leave-active{\n  opacity:0;\n  transition:opacity .5s;\n}\n```\n上边的代码设置了改变透明度的动画过渡效果，但是默认的mode模式in-out模式，这并不是我们想要的。下面我们学一下mode模式。\n\n** 过渡模式mode： **\n\n- in-out:新元素先进入过渡，完成之后当前元素过渡离开。\n- out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。\n\n### 九、mode的设置和404页面的处理\n在学习过渡效果的时候，我们学了mode的设置，但是在路由的属性中还有一个mode。这节课我们就学习一下另一个mode模式和404页面的设置。\n\n** mode的两个值 **\n\n- histroy:当你使用 history 模式时，URL 就像正常的 url，例如 http://www.justyouxx.top/，也好看！\n\n- hash:默认’hash’值，但是hash看起来就像无意义的字符排列，不太好看也不符合我们一般的网址浏览习惯。\n\n\n** 404页面的设置： **\n\n用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。vue-router也为我们提供了这样的机制.\n\n1.设置我们的路由配置文件（/src/router/index.js）：\n```js\n{\n   path:'*',\n   component:Error\n}\n```\n这里的path:’*’就是找不到页面时的配置，component是我们新建的一个Error.vue的文件。\n\n2.新建404页面：\n\n在/src/components/文件夹下新建一个Error.vue的文件。简单输入一些有关错误页面的内容。\n```html\n<template>\n    <div>\n        <h2>{{ msg }}</h2>\n    </div>\n</template>\n<script>\nexport default {\n  data () {\n    return {\n      msg: 'Error:404'\n    }\n  }\n}\n</script>\n```\n3.我们在用<router-link>瞎写一个标签的路径。\n```html\n<router-link to=\"/bbbbbb\">这是瞎写的</router-link> |\n```\n预览一下我们现在的结果，就已经实现404页面的效果。\n### 十、路由中的钩子\n我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节就介绍这两种钩子函数的写法。\n\n** 路由配置文件中的钩子函数 **\n\n我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。先来看一段具体的代码：\n```js\n{\n      path:'/params/:newsId(\\\\d+)/:newsTitle',\n      component:Params,\n      beforeEnter:(to,from,next)=>{\n        console.log('我进入了params模板');\n        console.log(to);\n        console.log(from);\n        next();\n},\n```\n我们在params路由里配置了bdforeEnter得钩子函数，函数我们采用了ES6的箭头函数，需要传递三个参数。我们并在箭头函数中打印了to和from函数。具体打印内容可以在控制台查看object。\n\n三个参数：\n\n- to:路由将要跳转的路径信息，信息是包含在对像里边的。\n- from:路径跳转前的路径信息，也是一个对象的形式。\n- next:路由的控制参数，常用的有next(true)和next(false)。\n\n** 写在模板中的钩子函数 ** 在配置文件中的钩子函数，只有一个钩子-beforeEnter，如果我们写在模板中就可以有两个钩子函数可以使用：\n\n- beforeRouteEnter：在路由进入前的钩子函数。\n- beforeRouteLeave：在路由离开前的钩子函数。\n```js\nexport default {\n  name: 'params',\n  data () {\n    return {\n      msg: 'params page'\n    }\n  },\n  beforeRouteEnter:(to,from,next)=>{\n    console.log(\"准备进入路由模板\");\n    next();\n  },\n  beforeRouteLeave: (to, from, next) => {\n    console.log(\"准备离开路由模板\");\n    next();\n  }\n}\n```\n这是我们写在params.vue模板里的路由钩子函数。它可以监控到路由的进入和路由的离开，也可以轻易的读出to和from的值。\n\n### 十一、编程式导航\n这是这篇文章的最后一节，前10节的导航都是用<router-link>标签或者直接操作地址栏的形式完成的，那如果在业务逻辑代码中需要跳转页面我们如何操作？这就是我们要说的编程式导航，顾名思义，就是在业务逻辑代码中实现导航。\n\n** this.$router.go(-1) 和 this.$router.go(1) **\n\n这两个编程式导航的意思是后退和前进，功能跟我们浏览器上的后退和前进按钮一样，这在业务逻辑中经常用到。比如条件不满足时，我们需要后退。\n\nrouter.go(-1)代表着后退，我们可以让我们的导航进行后退，并且我们的地址栏也是有所变化的。\n\n1.我们先在app.vue文件里加入一个按钮，按钮并绑定一个goback( )方法。\n```html\n<button @click=\"goback\">后退</button>\n```\n2.在我们的script模块中写入goback()方法，并使用this.$router.go(-1),进行后退操作。\n```js\n<script>\nexport default {\n  name: 'app',\n  methods:{\n    goback(){\n      this.$router.go(-1);\n    }\n  }\n}\n</script>\n```\n打开浏览器进行预览，这时我们的后退按钮就可以向以前的网页一样后退了。\n\nrouter.go(1):代表着前进，用法和后退一样，我在这里就不重复码字了。\n\nthis.$router.push(‘/xxx ‘)\n\n这个编程式导航都作用就是跳转，比如我们判断用户名和密码正确时，需要跳转到用户中心页面或者首页，都用到这个编程的方法来操作路由。\n\n我们设置一个按钮，点击按钮后回到站点首页。\n\n1.先编写一个按钮，在按钮上绑定goHome( )方法。\n```html\n<button @click=\"goHome\">回到首页</button>\n```\n2.在&lt;script&gt;模块里加入goHome方法，并用this.$router.push(‘/’)导航到首页\n```js\nexport default {\n  name: 'app',\n  methods:{\n    goback(){\n      this.$router.go(-1);\n    },\n    goHome(){\n      this.$router.push('/');\n    }\n  }\n}\n```","slug":"Vue-router路由","published":1,"updated":"2020-06-10T06:01:15.236Z","_id":"ck8r6c1690008imq6n38jg9m0","layout":"post","photos":[],"link":"","content":"<p><img src alt></p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>由于Vue在开发时对路由支持的不足，后来官方补充了vue-router插件，它在Vue的生态环境中非常重要，在实际开发中只要编写一个页面就会操作vue-router。要学习vue-router就要先知道这里的路由是什么？这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是我们WebApp的链接路径管理系统。<br>有人会有疑虑，为什么我们不能像原来一样直接用&lt;a&gt;&lt;/a&gt;标签编写链接哪？因为我们用Vue作的都是单页应用，就相当于只有一个主的index.html页面，所以你写的&lt;a&gt;&lt;/a&gt;标签是不起作用的，你必须使用vue-router来进行管理。</p>\n<h3 id=\"一、Vue-router入门\"><a href=\"#一、Vue-router入门\" class=\"headerlink\" title=\"一、Vue-router入门\"></a>一、Vue-router入门</h3><h5 id=\"安装vue-router\"><a href=\"#安装vue-router\" class=\"headerlink\" title=\"安装vue-router\"></a>安装vue-router</h5><p>vue-router是一个插件包，所以我们还是需要用npm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>如果你安装很慢，也可以用cnpm进行安装，如果你在使用vue-cli中已经选择安装了vue-router，那这里不需要重复安装了。</p>\n<p><strong> 解读router/index.js文件</strong><br>我们用vue-cli生产了我们的项目结构，你可以在src/router/index.js文件，这个文件就是路由的核心文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//引入Vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span>  <span class=\"comment\">//引入vue-router</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span>  <span class=\"comment\">//引入根目录下的Hello.vue组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)  <span class=\"comment\">//Vue全局使用Router</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [              <span class=\"comment\">//配置路由，这里是个数组</span></span><br><span class=\"line\">    &#123;                    <span class=\"comment\">//每一个链接都是一个对象</span></span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,         <span class=\"comment\">//链接路径</span></span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,     <span class=\"comment\">//路由名称，</span></span><br><span class=\"line\">      component: Hello   <span class=\"comment\">//对应的组件模板</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> 增加一个Hi的路由和页面 </strong><br>对路由的核心文件熟悉后，我们试着增加一个路由配置，我们希望在地址栏输入 <a href=\"http://localhost:8080/#/hi\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/#/hi</a> 的时候出现一个新的页面</p>\n<p>然后我们看一下具体的操作步骤：</p>\n<ul>\n<li>在src/components目录下，新建 Hi.vue 文件。</li>\n<li><p>编写文件内容，和我们之前讲过的一样，文件要包括三个部分&lt;template&gt;&lt;script&gt;和&lt;style&gt;。文件很简单，只是打印一句话。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Hi, I am Jun'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入 Hi组件：我们在router/index.js文件的上边引入Hi组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Hi <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>增加路由配置：在router/index.js文件的routes[]数组中，新增加一个对象，代码如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">path:<span class=\"string\">'/hi'</span>,</span><br><span class=\"line\">name:<span class=\"string\">'Hi'</span>,</span><br><span class=\"line\">component:Hi</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通过上面的配置已经可以增加一个新的页面了。路由配置文件:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//引入Vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span>  <span class=\"comment\">//引入vue-router</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span>  <span class=\"comment\">//引入根目录下的Hello.vue组件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi'</span> </span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)  <span class=\"comment\">//Vue全局使用Router</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [              <span class=\"comment\">//配置路由，这里是个数组</span></span><br><span class=\"line\">    &#123;                    <span class=\"comment\">//每一个链接都是一个对象</span></span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,         <span class=\"comment\">//链接路径</span></span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,     <span class=\"comment\">//路由名称，</span></span><br><span class=\"line\">      component: Hello   <span class=\"comment\">//对应的组件模板</span></span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/hi'</span>,</span><br><span class=\"line\">      name:<span class=\"string\">'Hi'</span>,</span><br><span class=\"line\">      component:Hi</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> router-link制作导航 </strong><br>现在通过在地址栏改变字符串地址，已经可以实现页面内容的变化了。这并不满足需求，我们需要的是在页面上有个像样的导航链接，我们只要点击就可以实现页面内容的变化。制作链接需要&lt;router-link&gt;标签，我们先来看一下它的语法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>[显示字段]<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>to：是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成 to=”/” ，</li>\n<li>[显示字段] ：就是我们要显示给用户的导航名称，比如首页 新闻页。</li>\n</ul>\n<p>明白了router-link的基本语法，我们在 src/App.vue文件中的template里加入下面代码，实现导航。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>导航 ：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi\"</span>&gt;</span>Hi页面<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>现在我们访问页面，发现已经多出了导航。</p>\n<h3 id=\"二、vue-router配置子路由\"><a href=\"#二、vue-router配置子路由\" class=\"headerlink\" title=\"二、vue-router配置子路由\"></a>二、vue-router配置子路由</h3><p>我们上节初步了解Vue-router的初步知识，也学会了基本的跳转，那我们现在学习一下子菜单的路由方式，也叫子路由。子路由的情况一般用在一个页面有他的基础模版，然后它下面的页面都隶属于这个模版，只是部分改变样式。我们接着第一节的实例，在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。<br><strong> 1、改造App.vue的导航代码 </strong><br>我们需要先改造app.vue的导航代码，来实现基本的导航功能。我们用<router-link>标签增加了两个新的导航链接。</router-link></p>\n<p><strong> App.vue代码</strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>导航 ：</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> | </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi\"</span>&gt;</span>Hi页面<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi/hi1\"</span>&gt;</span>-Hi页面1<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi/hi2\"</span>&gt;</span>-Hi页面2<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候我们再访问主页的时候导航栏就发生了变化。多出了两个自导航：Hi页面1 和 Hi页面2<br><strong> 2、改写components/Hi.vue页面 </strong></p>\n<p>把Hi.vue改成一个通用的模板，加入<router-view>标签，给子模板提供插入位置。“Hi页面1” 和 “Hi页面2” 都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入<router-view>标签。</router-view></router-view></p>\n<p><strong> components/Hi.vue,就是第5行的代码，其他代码不变。</strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aaa\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Hi, I am Jun'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>3、在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue *</li>\n</ul>\n<p>新建的模板和Hi.vue没有太多的差别，知识改变了data中message的值，也就是输出的结果不太一样了。 Hi1.vue<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Hi, I am Hi1!'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Hi2.vue<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Hi, I am Hi2'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>4、修改router/index.js代码 我们现在导航有了，母模板和子模板也有了，只要改变我们的路由配置文件就可以了。子路由的写法是在原有的路由配置下加入children字段。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">children:[</span><br><span class=\"line\">  &#123;path:'/',component:xxx&#125;,</span><br><span class=\"line\">  &#123;path:'xx',component:xxx&#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>children字段后边跟的是个数组，数组里和其他配置路由基本相同，需要配置path和component。具体看一下这个子路由的配置写法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   </span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span>  </span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span>  </span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi'</span> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi1 <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi1'</span> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi2 <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi2'</span> </span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [             </span><br><span class=\"line\">    &#123;                    </span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,        </span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,     </span><br><span class=\"line\">      component: Hello   </span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/hi'</span>,</span><br><span class=\"line\">      component:Hi,</span><br><span class=\"line\">      children:[</span><br><span class=\"line\">        &#123;<span class=\"attr\">path</span>:<span class=\"string\">'/'</span>,<span class=\"attr\">component</span>:Hi&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">path</span>:<span class=\"string\">'hi1'</span>,<span class=\"attr\">component</span>:Hi1&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">path</span>:<span class=\"string\">'hi2'</span>,<span class=\"attr\">component</span>:Hi2&#125;,</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，在配置路由文件前，需要先用import引入Hi1和Hi2。</p>\n<h3 id=\"三、vue-router如何参数传递\"><a href=\"#三、vue-router如何参数传递\" class=\"headerlink\" title=\"三、vue-router如何参数传递\"></a>三、vue-router如何参数传递</h3><p>开发中，参数的传递是个最基本的业务需求。通过URL地址来传递参数是一个形式，这节我们就看看vue-router为我们提供了那些传递参数的功能。我们先想象一个基本需求，就是在我们点击导航菜单时，跳转页面上能显示出当前页面的路径，来告诉用户你想在所看的页面位置（类似于面包屑导航）。</p>\n<p><strong> 一、用name传递参数 </strong><br>前两节一直出现name的选项，但是我们都没有讲，这节我们讲name的一种作用，传递参数。接着上节的程序继续编写。</p>\n<p>两步完成用name传值并显示在模板里：</p>\n<ul>\n<li><p>在路由文件src/router/index.js里配置name属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes: [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'Hello'</span>,</span><br><span class=\"line\">  component: Hello</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模板里(src/App.vue)用$route.name的形势接收，比如直接在模板中显示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; $route.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong> 二、通过&lt;router-link&gt; 标签中的to传参 </strong></p>\n<p>也许你也会觉的上边的传参很不正规，也不方便，其实我们多数传参是不用name进行传参的，我们用&lt;router-link&gt;标签中的to属性进行传参，需要您注意的是这里的to要进行一个绑定，写成:to。先来看一下这种传参方法的基本语法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123;name:xxx,params:&#123;key:value&#125;&#125;\"</span>&gt;</span>valueString<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这里的to前边是带冒号的，然后后边跟的是一个对象形势的字符串.</p>\n<ul>\n<li>name：就是我们在路由配置文件中起的name值。</li>\n<li>params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。<br>了解基本的语法后，我们改造一下我们的src/App.vue里的&lt;router-link&gt;标签,我们把hi1页面的&lt;router-link&gt;进行修改。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123;name:'hi1',params:&#123;username:'jun'&#125;&#125;\"</span>&gt;</span>Hi页面1<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>把src/reouter/index.js文件里给hi1配置的路由起个name,就叫hi1.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"attr\">path</span>:<span class=\"string\">'/hi1'</span>,<span class=\"attr\">name</span>:<span class=\"string\">'hi1'</span>,<span class=\"attr\">component</span>:Hi1&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>最后在模板里(src/components/Hi1.vue)用$route.params.username进行接收.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;$route.params.username&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>总结： </em> 今天我们学习了两种传参的方法，一般会使用第二种方法。我们通过学习也知道了name的用途，一种作用是传参，一种作用是在传参时起到名称作用。传参的操作在实际开发中是基本的需求，我们一定要掌握好啊。</p>\n<h3 id=\"四、单页面多路由区域操作\"><a href=\"#四、单页面多路由区域操作\" class=\"headerlink\" title=\"四、单页面多路由区域操作\"></a>四、单页面多路由区域操作</h3><p>这节我们讲“单页面多路由区域操作”，实际需求是这样的，在一个页面里我们有2个以上&lt;router-view&gt;区域，我们通过配置路由的js文件，来操作这些区域的内容。例如我们在src/App.vue里加上两个&lt;router-view&gt;标签。我们用vue-cli建立了新的项目，并打开了src目录下的App.vue文件，在&lt;router-view&gt;下面新写了两行&lt;router-view&gt;标签,并加入了些CSS样式。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-view</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">name</span>=<span class=\"string\">\"left\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"float:left;width:50%;background-color:#ccc;height:300px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">name</span>=<span class=\"string\">\"right\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"float:right;width:50%;background-color:#c0c;height:300px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>现在的页面中有了三个&lt;router-view&gt;标签，也就是说我们需要在路由里配置这三个区域，配置主要是在components字段里进行。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi1 <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi2 <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi2'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:Hello,</span><br><span class=\"line\">        left:Hi1,</span><br><span class=\"line\">        right:Hi2</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/Hi'</span>,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:Hello,</span><br><span class=\"line\">        left:Hi2,</span><br><span class=\"line\">        right:Hi1</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上边的代码我们编写了两个路径，一个是默认的‘/’，另一个是’/Hi’.在两个路径下的components里面，我们对三个区域都定义了显示内容。 定义好后，我们需要在component文件夹下，新建Hi1.vue和Hi2.vue页面就可以了。<br><strong> Hi1.vue </strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi1'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'I am Hi1 page.'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong> Hi2.vue </strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi2'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'I am Hi2 page.'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>最后在App.vue中配置我们的&lt;router-link&gt;就可以了<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> | </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi\"</span>&gt;</span>Hi页面<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、vue-router-利用url传递参数\"><a href=\"#五、vue-router-利用url传递参数\" class=\"headerlink\" title=\"五、vue-router 利用url传递参数\"></a>五、vue-router 利用url传递参数</h3><p>我们在第3节虽然已经学会传递参数，但是我们这些老程序员的情怀还是利用url来传值，因为我们以前在前后端没有分开开发的时候，经常这样做。在实际开发也是有很多用URL传值的需求，比如我们在新闻列表中有很多新闻标题整齐的排列，我们需要点击每个新闻标题打开不同的新闻内容，这时在跳转路由时跟上新闻编号就十分实用。</p>\n<p><strong> :冒号的形式传递参数 </strong> 我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。<br>-. 在配置文件里以冒号的形式设置参数。我们在/src/router/index.js文件里配置路由。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path:<span class=\"string\">'/params/:newsId/:newsTitle'</span>,</span><br><span class=\"line\">     component:Params</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们需要传递参数是新闻ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。</p>\n<ul>\n<li>在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>新闻ID：&#123;&#123; $route.params.newsId&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>新闻标题：&#123;&#123; $route.params.newsTitle&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'params'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'params page'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在App.vue文件里加入我们的&lt;router-view&gt;标签。这时候我们可以直接利用url传值了。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/params/198/jun website is very good\"</span>&gt;</span>params<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br></pre></td></tr></table></figure></p>\n<p>我们已经实现了以url方式进行传值，这在实际开发中经常使用，必须完全了解。我希望你看完视频后或者学完文章后能多练习两边，并在实际项目中充分使用。</p>\n<p><strong> 正则表达式在URL传值中的应用 </strong></p>\n<p>上边的例子，我们传递了新闻编号，现在需求升级了，我们希望我们传递的新闻ID只能是数字的形式，这时候我们就需要在传递时有个基本的类型判断，vue是支持正则的。</p>\n<p>加入正则需要在路由配置文件里（/src/router/index.js）以圆括号的形式加入。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span>,</span><br></pre></td></tr></table></figure></p>\n<p>加入了正则，我们再传递数字之外的其他参数，params.vue组件就没有办法接收到。</p>\n<h3 id=\"六、vue-router-的重定向-redirect\"><a href=\"#六、vue-router-的重定向-redirect\" class=\"headerlink\" title=\"六、vue-router 的重定向-redirect\"></a>六、vue-router 的重定向-redirect</h3><p>开发中有时候我们虽然设置的路径不一致，但是我们希望跳转到同一个页面，或者说是打开同一个组件。这时候我们就用到了路由的重新定向redirect参数。</p>\n<p><strong> redirect基本重定向 </strong><br>我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">      component: Hello</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span>,</span><br><span class=\"line\">      component:Params</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/goback'</span>,</span><br><span class=\"line\">      redirect:<span class=\"string\">'/'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这里我们设置了goback路由，但是它并没有配置任何component（组件），而是直接redirect到path:’/’下了，这就是一个简单的重新定向。</p>\n<p><strong> 重定向时传递参数</strong></p>\n<p>我们已经学会了通过url来传递参数，那我们重定向时如果也需要传递参数怎么办？其实vue也已经为我们设置好了，我们只需要在ridirect后边的参数里复制重定向路径的path参数就可以了。可能你看的有点晕，我们来看一段代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  path:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span>,</span><br><span class=\"line\">  component:Params</span><br><span class=\"line\">&#125;,&#123;</span><br><span class=\"line\">  path:<span class=\"string\">'/goParams/:newsId(\\\\d+)/:newsTitle'</span>,</span><br><span class=\"line\">  redirect:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>已经有了一个params路由配置，我们在设置一个goParams的路由重定向，并传递了参数。这时候我们的路由参数就可以传递给params.vue组件了。参数接收方法和正常的路由接收方法一样。</p>\n<h3 id=\"七、alias别名的使用\"><a href=\"#七、alias别名的使用\" class=\"headerlink\" title=\"七、alias别名的使用\"></a>七、alias别名的使用</h3><p>上节学习了路由的重定向，我相信大家已经可以熟练使用redirect进行重定向了。使用alias别名的形式，我们也可以实现类似重定向的效果。</p>\n<p>1.首先我们在路由配置文件里（/src/router/index.js），给上节的Home路径起一个别名，jun。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path: <span class=\"string\">'/hi1'</span>,</span><br><span class=\"line\">    component: Hi1,</span><br><span class=\"line\">    alias:<span class=\"string\">'/jun'</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p> 2.配置我们的<router-link>，起过别名之后，可以直接使用<router-link>标签里的to属性，进行重新定向。<br> <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link &lt; to=\"/jun\"&gt;jun&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></router-link></router-link></p>\n<p><strong> redirect和alias的区别 </strong></p>\n<p>redirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。<br>alias：URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了<router-view>中的内容。<br><strong> 填个小坑： </strong> 别名请不要用在path为’/’中，如下代码的别名是不起作用的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">  component: Hello,</span><br><span class=\"line\">  alias:<span class=\"string\">'/home'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></router-view></p>\n<h3 id=\"八、路由的过渡动画\"><a href=\"#八、路由的过渡动画\" class=\"headerlink\" title=\"八、路由的过渡动画\"></a>八、路由的过渡动画</h3><p>在开发中有一种需求叫高端、大气、上档次。所以作为一个大前端有责任让你的程序开起来更酷炫。可以在页面切换时我们加入一些动画效果，提升我们程序的动效设计。这节课我们就学习一下路由的过渡动画效果制作。</p>\n<p>&lt;transition&gt;标签<br>想让路由有过渡动画，需要在&lt;router-view&gt;标签的外部添加&lt;transition&gt;标签，标签还需要一个name属性。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">router-view</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>我们在/src/App.vue文件里添加了&lt;transition&gt;标签，并给标签起了一个名字叫fade。</p>\n<p><strong> css过渡类名： </strong> 组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名：</p>\n<ul>\n<li>fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。</li>\n<li>fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。</li>\n<li>fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。</li>\n<li>fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。<br>从上面四个类名可以看出，fade-enter-active和fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。</li>\n</ul>\n<p>那我们就在App.vue页面里加入四种CSS样式效果，并利用CSS3的transition属性控制动画的具体效果。代码如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.fade-enter</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.fade-leave</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.fade-enter-active</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>:opacity .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.fade-leave-active</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>:opacity .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上边的代码设置了改变透明度的动画过渡效果，但是默认的mode模式in-out模式，这并不是我们想要的。下面我们学一下mode模式。</p>\n<p><strong> 过渡模式mode： </strong></p>\n<ul>\n<li>in-out:新元素先进入过渡，完成之后当前元素过渡离开。</li>\n<li>out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。</li>\n</ul>\n<h3 id=\"九、mode的设置和404页面的处理\"><a href=\"#九、mode的设置和404页面的处理\" class=\"headerlink\" title=\"九、mode的设置和404页面的处理\"></a>九、mode的设置和404页面的处理</h3><p>在学习过渡效果的时候，我们学了mode的设置，但是在路由的属性中还有一个mode。这节课我们就学习一下另一个mode模式和404页面的设置。</p>\n<p><strong> mode的两个值 </strong></p>\n<ul>\n<li><p>histroy:当你使用 history 模式时，URL 就像正常的 url，例如 <a href=\"http://www.justyouxx.top/，也好看！\">http://www.justyouxx.top/，也好看！</a></p>\n</li>\n<li><p>hash:默认’hash’值，但是hash看起来就像无意义的字符排列，不太好看也不符合我们一般的网址浏览习惯。</p>\n</li>\n</ul>\n<p><strong> 404页面的设置： </strong></p>\n<p>用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。vue-router也为我们提供了这样的机制.</p>\n<p>1.设置我们的路由配置文件（/src/router/index.js）：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   path:<span class=\"string\">'*'</span>,</span><br><span class=\"line\">   component:<span class=\"built_in\">Error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的path:’*’就是找不到页面时的配置，component是我们新建的一个Error.vue的文件。</p>\n<p>2.新建404页面：</p>\n<p>在/src/components/文件夹下新建一个Error.vue的文件。简单输入一些有关错误页面的内容。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Error:404'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>3.我们在用<router-link>瞎写一个标签的路径。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bbbbbb\"</span>&gt;</span>这是瞎写的<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br></pre></td></tr></table></figure></router-link></p>\n<p>预览一下我们现在的结果，就已经实现404页面的效果。</p>\n<h3 id=\"十、路由中的钩子\"><a href=\"#十、路由中的钩子\" class=\"headerlink\" title=\"十、路由中的钩子\"></a>十、路由中的钩子</h3><p>我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节就介绍这两种钩子函数的写法。</p>\n<p><strong> 路由配置文件中的钩子函数 </strong></p>\n<p>我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。先来看一段具体的代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span>,</span><br><span class=\"line\">      component:Params,</span><br><span class=\"line\">      beforeEnter:<span class=\"function\">(<span class=\"params\">to,<span class=\"keyword\">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'我进入了params模板'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(to);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">from</span>);</span><br><span class=\"line\">        next();</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>我们在params路由里配置了bdforeEnter得钩子函数，函数我们采用了ES6的箭头函数，需要传递三个参数。我们并在箭头函数中打印了to和from函数。具体打印内容可以在控制台查看object。</p>\n<p>三个参数：</p>\n<ul>\n<li>to:路由将要跳转的路径信息，信息是包含在对像里边的。</li>\n<li>from:路径跳转前的路径信息，也是一个对象的形式。</li>\n<li>next:路由的控制参数，常用的有next(true)和next(false)。</li>\n</ul>\n<p><strong> 写在模板中的钩子函数 </strong> 在配置文件中的钩子函数，只有一个钩子-beforeEnter，如果我们写在模板中就可以有两个钩子函数可以使用：</p>\n<ul>\n<li>beforeRouteEnter：在路由进入前的钩子函数。</li>\n<li>beforeRouteLeave：在路由离开前的钩子函数。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'params'</span>,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      msg: <span class=\"string\">'params page'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteEnter:<span class=\"function\">(<span class=\"params\">to,<span class=\"keyword\">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"准备进入路由模板\"</span>);</span><br><span class=\"line\">    next();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteLeave: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"准备离开路由模板\"</span>);</span><br><span class=\"line\">    next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这是我们写在params.vue模板里的路由钩子函数。它可以监控到路由的进入和路由的离开，也可以轻易的读出to和from的值。</p>\n<h3 id=\"十一、编程式导航\"><a href=\"#十一、编程式导航\" class=\"headerlink\" title=\"十一、编程式导航\"></a>十一、编程式导航</h3><p>这是这篇文章的最后一节，前10节的导航都是用<router-link>标签或者直接操作地址栏的形式完成的，那如果在业务逻辑代码中需要跳转页面我们如何操作？这就是我们要说的编程式导航，顾名思义，就是在业务逻辑代码中实现导航。</router-link></p>\n<p><strong> this.$router.go(-1) 和 this.$router.go(1) </strong></p>\n<p>这两个编程式导航的意思是后退和前进，功能跟我们浏览器上的后退和前进按钮一样，这在业务逻辑中经常用到。比如条件不满足时，我们需要后退。</p>\n<p>router.go(-1)代表着后退，我们可以让我们的导航进行后退，并且我们的地址栏也是有所变化的。</p>\n<p>1.我们先在app.vue文件里加入一个按钮，按钮并绑定一个goback( )方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"goback\"</span>&gt;</span>后退<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>2.在我们的script模块中写入goback()方法，并使用this.$router.go(-1),进行后退操作。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'app'</span>,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    goback()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$router.go(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>打开浏览器进行预览，这时我们的后退按钮就可以向以前的网页一样后退了。</p>\n<p>router.go(1):代表着前进，用法和后退一样，我在这里就不重复码字了。</p>\n<p>this.$router.push(‘/xxx ‘)</p>\n<p>这个编程式导航都作用就是跳转，比如我们判断用户名和密码正确时，需要跳转到用户中心页面或者首页，都用到这个编程的方法来操作路由。</p>\n<p>我们设置一个按钮，点击按钮后回到站点首页。</p>\n<p>1.先编写一个按钮，在按钮上绑定goHome( )方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"goHome\"</span>&gt;</span>回到首页<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>2.在&lt;script&gt;模块里加入goHome方法，并用this.$router.push(‘/’)导航到首页<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'app'</span>,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    goback()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$router.go(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    goHome()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src alt></p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>由于Vue在开发时对路由支持的不足，后来官方补充了vue-router插件，它在Vue的生态环境中非常重要，在实际开发中只要编写一个页面就会操作vue-router。要学习vue-router就要先知道这里的路由是什么？这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是我们WebApp的链接路径管理系统。<br>有人会有疑虑，为什么我们不能像原来一样直接用&lt;a&gt;&lt;/a&gt;标签编写链接哪？因为我们用Vue作的都是单页应用，就相当于只有一个主的index.html页面，所以你写的&lt;a&gt;&lt;/a&gt;标签是不起作用的，你必须使用vue-router来进行管理。</p>\n<h3 id=\"一、Vue-router入门\"><a href=\"#一、Vue-router入门\" class=\"headerlink\" title=\"一、Vue-router入门\"></a>一、Vue-router入门</h3><h5 id=\"安装vue-router\"><a href=\"#安装vue-router\" class=\"headerlink\" title=\"安装vue-router\"></a>安装vue-router</h5><p>vue-router是一个插件包，所以我们还是需要用npm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>如果你安装很慢，也可以用cnpm进行安装，如果你在使用vue-cli中已经选择安装了vue-router，那这里不需要重复安装了。</p>\n<p><strong> 解读router/index.js文件</strong><br>我们用vue-cli生产了我们的项目结构，你可以在src/router/index.js文件，这个文件就是路由的核心文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//引入Vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span>  <span class=\"comment\">//引入vue-router</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span>  <span class=\"comment\">//引入根目录下的Hello.vue组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)  <span class=\"comment\">//Vue全局使用Router</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [              <span class=\"comment\">//配置路由，这里是个数组</span></span><br><span class=\"line\">    &#123;                    <span class=\"comment\">//每一个链接都是一个对象</span></span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,         <span class=\"comment\">//链接路径</span></span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,     <span class=\"comment\">//路由名称，</span></span><br><span class=\"line\">      component: Hello   <span class=\"comment\">//对应的组件模板</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> 增加一个Hi的路由和页面 </strong><br>对路由的核心文件熟悉后，我们试着增加一个路由配置，我们希望在地址栏输入 <a href=\"http://localhost:8080/#/hi\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/#/hi</a> 的时候出现一个新的页面</p>\n<p>然后我们看一下具体的操作步骤：</p>\n<ul>\n<li>在src/components目录下，新建 Hi.vue 文件。</li>\n<li><p>编写文件内容，和我们之前讲过的一样，文件要包括三个部分&lt;template&gt;&lt;script&gt;和&lt;style&gt;。文件很简单，只是打印一句话。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Hi, I am Jun'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入 Hi组件：我们在router/index.js文件的上边引入Hi组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Hi <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>增加路由配置：在router/index.js文件的routes[]数组中，新增加一个对象，代码如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">path:<span class=\"string\">'/hi'</span>,</span><br><span class=\"line\">name:<span class=\"string\">'Hi'</span>,</span><br><span class=\"line\">component:Hi</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通过上面的配置已经可以增加一个新的页面了。路由配置文件:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   <span class=\"comment\">//引入Vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span>  <span class=\"comment\">//引入vue-router</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span>  <span class=\"comment\">//引入根目录下的Hello.vue组件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi'</span> </span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)  <span class=\"comment\">//Vue全局使用Router</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [              <span class=\"comment\">//配置路由，这里是个数组</span></span><br><span class=\"line\">    &#123;                    <span class=\"comment\">//每一个链接都是一个对象</span></span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,         <span class=\"comment\">//链接路径</span></span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,     <span class=\"comment\">//路由名称，</span></span><br><span class=\"line\">      component: Hello   <span class=\"comment\">//对应的组件模板</span></span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/hi'</span>,</span><br><span class=\"line\">      name:<span class=\"string\">'Hi'</span>,</span><br><span class=\"line\">      component:Hi</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong> router-link制作导航 </strong><br>现在通过在地址栏改变字符串地址，已经可以实现页面内容的变化了。这并不满足需求，我们需要的是在页面上有个像样的导航链接，我们只要点击就可以实现页面内容的变化。制作链接需要&lt;router-link&gt;标签，我们先来看一下它的语法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>[显示字段]<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>to：是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成 to=”/” ，</li>\n<li>[显示字段] ：就是我们要显示给用户的导航名称，比如首页 新闻页。</li>\n</ul>\n<p>明白了router-link的基本语法，我们在 src/App.vue文件中的template里加入下面代码，实现导航。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>导航 ：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi\"</span>&gt;</span>Hi页面<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>现在我们访问页面，发现已经多出了导航。</p>\n<h3 id=\"二、vue-router配置子路由\"><a href=\"#二、vue-router配置子路由\" class=\"headerlink\" title=\"二、vue-router配置子路由\"></a>二、vue-router配置子路由</h3><p>我们上节初步了解Vue-router的初步知识，也学会了基本的跳转，那我们现在学习一下子菜单的路由方式，也叫子路由。子路由的情况一般用在一个页面有他的基础模版，然后它下面的页面都隶属于这个模版，只是部分改变样式。我们接着第一节的实例，在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。<br><strong> 1、改造App.vue的导航代码 </strong><br>我们需要先改造app.vue的导航代码，来实现基本的导航功能。我们用<router-link>标签增加了两个新的导航链接。</router-link></p>\n<p><strong> App.vue代码</strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>导航 ：</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> | </span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi\"</span>&gt;</span>Hi页面<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi/hi1\"</span>&gt;</span>-Hi页面1<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi/hi2\"</span>&gt;</span>-Hi页面2<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候我们再访问主页的时候导航栏就发生了变化。多出了两个自导航：Hi页面1 和 Hi页面2<br><strong> 2、改写components/Hi.vue页面 </strong></p>\n<p>把Hi.vue改成一个通用的模板，加入<router-view>标签，给子模板提供插入位置。“Hi页面1” 和 “Hi页面2” 都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入<router-view>标签。</router-view></router-view></p>\n<p><strong> components/Hi.vue,就是第5行的代码，其他代码不变。</strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aaa\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Hi, I am Jun'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>3、在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue *</li>\n</ul>\n<p>新建的模板和Hi.vue没有太多的差别，知识改变了data中message的值，也就是输出的结果不太一样了。 Hi1.vue<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Hi, I am Hi1!'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Hi2.vue<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Hi, I am Hi2'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>4、修改router/index.js代码 我们现在导航有了，母模板和子模板也有了，只要改变我们的路由配置文件就可以了。子路由的写法是在原有的路由配置下加入children字段。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">children:[</span><br><span class=\"line\">  &#123;path:'/',component:xxx&#125;,</span><br><span class=\"line\">  &#123;path:'xx',component:xxx&#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>children字段后边跟的是个数组，数组里和其他配置路由基本相同，需要配置path和component。具体看一下这个子路由的配置写法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>   </span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span>  </span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span>  </span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi'</span> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi1 <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi1'</span> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi2 <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi2'</span> </span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [             </span><br><span class=\"line\">    &#123;                    </span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,        </span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,     </span><br><span class=\"line\">      component: Hello   </span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/hi'</span>,</span><br><span class=\"line\">      component:Hi,</span><br><span class=\"line\">      children:[</span><br><span class=\"line\">        &#123;<span class=\"attr\">path</span>:<span class=\"string\">'/'</span>,<span class=\"attr\">component</span>:Hi&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">path</span>:<span class=\"string\">'hi1'</span>,<span class=\"attr\">component</span>:Hi1&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">path</span>:<span class=\"string\">'hi2'</span>,<span class=\"attr\">component</span>:Hi2&#125;,</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，在配置路由文件前，需要先用import引入Hi1和Hi2。</p>\n<h3 id=\"三、vue-router如何参数传递\"><a href=\"#三、vue-router如何参数传递\" class=\"headerlink\" title=\"三、vue-router如何参数传递\"></a>三、vue-router如何参数传递</h3><p>开发中，参数的传递是个最基本的业务需求。通过URL地址来传递参数是一个形式，这节我们就看看vue-router为我们提供了那些传递参数的功能。我们先想象一个基本需求，就是在我们点击导航菜单时，跳转页面上能显示出当前页面的路径，来告诉用户你想在所看的页面位置（类似于面包屑导航）。</p>\n<p><strong> 一、用name传递参数 </strong><br>前两节一直出现name的选项，但是我们都没有讲，这节我们讲name的一种作用，传递参数。接着上节的程序继续编写。</p>\n<p>两步完成用name传值并显示在模板里：</p>\n<ul>\n<li><p>在路由文件src/router/index.js里配置name属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes: [</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'Hello'</span>,</span><br><span class=\"line\">  component: Hello</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模板里(src/App.vue)用$route.name的形势接收，比如直接在模板中显示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; $route.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong> 二、通过&lt;router-link&gt; 标签中的to传参 </strong></p>\n<p>也许你也会觉的上边的传参很不正规，也不方便，其实我们多数传参是不用name进行传参的，我们用&lt;router-link&gt;标签中的to属性进行传参，需要您注意的是这里的to要进行一个绑定，写成:to。先来看一下这种传参方法的基本语法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123;name:xxx,params:&#123;key:value&#125;&#125;\"</span>&gt;</span>valueString<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这里的to前边是带冒号的，然后后边跟的是一个对象形势的字符串.</p>\n<ul>\n<li>name：就是我们在路由配置文件中起的name值。</li>\n<li>params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。<br>了解基本的语法后，我们改造一下我们的src/App.vue里的&lt;router-link&gt;标签,我们把hi1页面的&lt;router-link&gt;进行修改。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123;name:'hi1',params:&#123;username:'jun'&#125;&#125;\"</span>&gt;</span>Hi页面1<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>把src/reouter/index.js文件里给hi1配置的路由起个name,就叫hi1.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"attr\">path</span>:<span class=\"string\">'/hi1'</span>,<span class=\"attr\">name</span>:<span class=\"string\">'hi1'</span>,<span class=\"attr\">component</span>:Hi1&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>最后在模板里(src/components/Hi1.vue)用$route.params.username进行接收.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;$route.params.username&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>总结： </em> 今天我们学习了两种传参的方法，一般会使用第二种方法。我们通过学习也知道了name的用途，一种作用是传参，一种作用是在传参时起到名称作用。传参的操作在实际开发中是基本的需求，我们一定要掌握好啊。</p>\n<h3 id=\"四、单页面多路由区域操作\"><a href=\"#四、单页面多路由区域操作\" class=\"headerlink\" title=\"四、单页面多路由区域操作\"></a>四、单页面多路由区域操作</h3><p>这节我们讲“单页面多路由区域操作”，实际需求是这样的，在一个页面里我们有2个以上&lt;router-view&gt;区域，我们通过配置路由的js文件，来操作这些区域的内容。例如我们在src/App.vue里加上两个&lt;router-view&gt;标签。我们用vue-cli建立了新的项目，并打开了src目录下的App.vue文件，在&lt;router-view&gt;下面新写了两行&lt;router-view&gt;标签,并加入了些CSS样式。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-view</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">name</span>=<span class=\"string\">\"left\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"float:left;width:50%;background-color:#ccc;height:300px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">name</span>=<span class=\"string\">\"right\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"float:right;width:50%;background-color:#c0c;height:300px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>现在的页面中有了三个&lt;router-view&gt;标签，也就是说我们需要在路由里配置这三个区域，配置主要是在components字段里进行。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hello'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi1 <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi1'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hi2 <span class=\"keyword\">from</span> <span class=\"string\">'@/components/Hi2'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:Hello,</span><br><span class=\"line\">        left:Hi1,</span><br><span class=\"line\">        right:Hi2</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/Hi'</span>,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:Hello,</span><br><span class=\"line\">        left:Hi2,</span><br><span class=\"line\">        right:Hi1</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上边的代码我们编写了两个路径，一个是默认的‘/’，另一个是’/Hi’.在两个路径下的components里面，我们对三个区域都定义了显示内容。 定义好后，我们需要在component文件夹下，新建Hi1.vue和Hi2.vue页面就可以了。<br><strong> Hi1.vue </strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi1'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'I am Hi1 page.'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong> Hi2.vue </strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'hi2'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'I am Hi2 page.'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>最后在App.vue中配置我们的&lt;router-link&gt;就可以了<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> | </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/hi\"</span>&gt;</span>Hi页面<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、vue-router-利用url传递参数\"><a href=\"#五、vue-router-利用url传递参数\" class=\"headerlink\" title=\"五、vue-router 利用url传递参数\"></a>五、vue-router 利用url传递参数</h3><p>我们在第3节虽然已经学会传递参数，但是我们这些老程序员的情怀还是利用url来传值，因为我们以前在前后端没有分开开发的时候，经常这样做。在实际开发也是有很多用URL传值的需求，比如我们在新闻列表中有很多新闻标题整齐的排列，我们需要点击每个新闻标题打开不同的新闻内容，这时在跳转路由时跟上新闻编号就十分实用。</p>\n<p><strong> :冒号的形式传递参数 </strong> 我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。<br>-. 在配置文件里以冒号的形式设置参数。我们在/src/router/index.js文件里配置路由。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path:<span class=\"string\">'/params/:newsId/:newsTitle'</span>,</span><br><span class=\"line\">     component:Params</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们需要传递参数是新闻ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。</p>\n<ul>\n<li>在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>新闻ID：&#123;&#123; $route.params.newsId&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>新闻标题：&#123;&#123; $route.params.newsTitle&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  name: <span class=\"string\">'params'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'params page'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在App.vue文件里加入我们的&lt;router-view&gt;标签。这时候我们可以直接利用url传值了。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/params/198/jun website is very good\"</span>&gt;</span>params<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br></pre></td></tr></table></figure></p>\n<p>我们已经实现了以url方式进行传值，这在实际开发中经常使用，必须完全了解。我希望你看完视频后或者学完文章后能多练习两边，并在实际项目中充分使用。</p>\n<p><strong> 正则表达式在URL传值中的应用 </strong></p>\n<p>上边的例子，我们传递了新闻编号，现在需求升级了，我们希望我们传递的新闻ID只能是数字的形式，这时候我们就需要在传递时有个基本的类型判断，vue是支持正则的。</p>\n<p>加入正则需要在路由配置文件里（/src/router/index.js）以圆括号的形式加入。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span>,</span><br></pre></td></tr></table></figure></p>\n<p>加入了正则，我们再传递数字之外的其他参数，params.vue组件就没有办法接收到。</p>\n<h3 id=\"六、vue-router-的重定向-redirect\"><a href=\"#六、vue-router-的重定向-redirect\" class=\"headerlink\" title=\"六、vue-router 的重定向-redirect\"></a>六、vue-router 的重定向-redirect</h3><p>开发中有时候我们虽然设置的路径不一致，但是我们希望跳转到同一个页面，或者说是打开同一个组件。这时候我们就用到了路由的重新定向redirect参数。</p>\n<p><strong> redirect基本重定向 </strong><br>我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">      component: Hello</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span>,</span><br><span class=\"line\">      component:Params</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/goback'</span>,</span><br><span class=\"line\">      redirect:<span class=\"string\">'/'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这里我们设置了goback路由，但是它并没有配置任何component（组件），而是直接redirect到path:’/’下了，这就是一个简单的重新定向。</p>\n<p><strong> 重定向时传递参数</strong></p>\n<p>我们已经学会了通过url来传递参数，那我们重定向时如果也需要传递参数怎么办？其实vue也已经为我们设置好了，我们只需要在ridirect后边的参数里复制重定向路径的path参数就可以了。可能你看的有点晕，我们来看一段代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  path:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span>,</span><br><span class=\"line\">  component:Params</span><br><span class=\"line\">&#125;,&#123;</span><br><span class=\"line\">  path:<span class=\"string\">'/goParams/:newsId(\\\\d+)/:newsTitle'</span>,</span><br><span class=\"line\">  redirect:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>已经有了一个params路由配置，我们在设置一个goParams的路由重定向，并传递了参数。这时候我们的路由参数就可以传递给params.vue组件了。参数接收方法和正常的路由接收方法一样。</p>\n<h3 id=\"七、alias别名的使用\"><a href=\"#七、alias别名的使用\" class=\"headerlink\" title=\"七、alias别名的使用\"></a>七、alias别名的使用</h3><p>上节学习了路由的重定向，我相信大家已经可以熟练使用redirect进行重定向了。使用alias别名的形式，我们也可以实现类似重定向的效果。</p>\n<p>1.首先我们在路由配置文件里（/src/router/index.js），给上节的Home路径起一个别名，jun。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path: <span class=\"string\">'/hi1'</span>,</span><br><span class=\"line\">    component: Hi1,</span><br><span class=\"line\">    alias:<span class=\"string\">'/jun'</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p> 2.配置我们的<router-link>，起过别名之后，可以直接使用<router-link>标签里的to属性，进行重新定向。<br> <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link &lt; to=\"/jun\"&gt;jun&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></router-link></router-link></p>\n<p><strong> redirect和alias的区别 </strong></p>\n<p>redirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。<br>alias：URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了<router-view>中的内容。<br><strong> 填个小坑： </strong> 别名请不要用在path为’/’中，如下代码的别名是不起作用的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">  component: Hello,</span><br><span class=\"line\">  alias:<span class=\"string\">'/home'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></router-view></p>\n<h3 id=\"八、路由的过渡动画\"><a href=\"#八、路由的过渡动画\" class=\"headerlink\" title=\"八、路由的过渡动画\"></a>八、路由的过渡动画</h3><p>在开发中有一种需求叫高端、大气、上档次。所以作为一个大前端有责任让你的程序开起来更酷炫。可以在页面切换时我们加入一些动画效果，提升我们程序的动效设计。这节课我们就学习一下路由的过渡动画效果制作。</p>\n<p>&lt;transition&gt;标签<br>想让路由有过渡动画，需要在&lt;router-view&gt;标签的外部添加&lt;transition&gt;标签，标签还需要一个name属性。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">router-view</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>我们在/src/App.vue文件里添加了&lt;transition&gt;标签，并给标签起了一个名字叫fade。</p>\n<p><strong> css过渡类名： </strong> 组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名：</p>\n<ul>\n<li>fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。</li>\n<li>fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。</li>\n<li>fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。</li>\n<li>fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。<br>从上面四个类名可以看出，fade-enter-active和fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。</li>\n</ul>\n<p>那我们就在App.vue页面里加入四种CSS样式效果，并利用CSS3的transition属性控制动画的具体效果。代码如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.fade-enter</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.fade-leave</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.fade-enter-active</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>:opacity .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.fade-leave-active</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>:opacity .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上边的代码设置了改变透明度的动画过渡效果，但是默认的mode模式in-out模式，这并不是我们想要的。下面我们学一下mode模式。</p>\n<p><strong> 过渡模式mode： </strong></p>\n<ul>\n<li>in-out:新元素先进入过渡，完成之后当前元素过渡离开。</li>\n<li>out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。</li>\n</ul>\n<h3 id=\"九、mode的设置和404页面的处理\"><a href=\"#九、mode的设置和404页面的处理\" class=\"headerlink\" title=\"九、mode的设置和404页面的处理\"></a>九、mode的设置和404页面的处理</h3><p>在学习过渡效果的时候，我们学了mode的设置，但是在路由的属性中还有一个mode。这节课我们就学习一下另一个mode模式和404页面的设置。</p>\n<p><strong> mode的两个值 </strong></p>\n<ul>\n<li><p>histroy:当你使用 history 模式时，URL 就像正常的 url，例如 <a href=\"http://www.justyouxx.top/，也好看！\">http://www.justyouxx.top/，也好看！</a></p>\n</li>\n<li><p>hash:默认’hash’值，但是hash看起来就像无意义的字符排列，不太好看也不符合我们一般的网址浏览习惯。</p>\n</li>\n</ul>\n<p><strong> 404页面的设置： </strong></p>\n<p>用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。vue-router也为我们提供了这样的机制.</p>\n<p>1.设置我们的路由配置文件（/src/router/index.js）：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   path:<span class=\"string\">'*'</span>,</span><br><span class=\"line\">   component:<span class=\"built_in\">Error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的path:’*’就是找不到页面时的配置，component是我们新建的一个Error.vue的文件。</p>\n<p>2.新建404页面：</p>\n<p>在/src/components/文件夹下新建一个Error.vue的文件。简单输入一些有关错误页面的内容。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      msg: <span class=\"string\">'Error:404'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>3.我们在用<router-link>瞎写一个标签的路径。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bbbbbb\"</span>&gt;</span>这是瞎写的<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span> |</span><br></pre></td></tr></table></figure></router-link></p>\n<p>预览一下我们现在的结果，就已经实现404页面的效果。</p>\n<h3 id=\"十、路由中的钩子\"><a href=\"#十、路由中的钩子\" class=\"headerlink\" title=\"十、路由中的钩子\"></a>十、路由中的钩子</h3><p>我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节就介绍这两种钩子函数的写法。</p>\n<p><strong> 路由配置文件中的钩子函数 </strong></p>\n<p>我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。先来看一段具体的代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">      path:<span class=\"string\">'/params/:newsId(\\\\d+)/:newsTitle'</span>,</span><br><span class=\"line\">      component:Params,</span><br><span class=\"line\">      beforeEnter:<span class=\"function\">(<span class=\"params\">to,<span class=\"keyword\">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'我进入了params模板'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(to);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">from</span>);</span><br><span class=\"line\">        next();</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>我们在params路由里配置了bdforeEnter得钩子函数，函数我们采用了ES6的箭头函数，需要传递三个参数。我们并在箭头函数中打印了to和from函数。具体打印内容可以在控制台查看object。</p>\n<p>三个参数：</p>\n<ul>\n<li>to:路由将要跳转的路径信息，信息是包含在对像里边的。</li>\n<li>from:路径跳转前的路径信息，也是一个对象的形式。</li>\n<li>next:路由的控制参数，常用的有next(true)和next(false)。</li>\n</ul>\n<p><strong> 写在模板中的钩子函数 </strong> 在配置文件中的钩子函数，只有一个钩子-beforeEnter，如果我们写在模板中就可以有两个钩子函数可以使用：</p>\n<ul>\n<li>beforeRouteEnter：在路由进入前的钩子函数。</li>\n<li>beforeRouteLeave：在路由离开前的钩子函数。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'params'</span>,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      msg: <span class=\"string\">'params page'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteEnter:<span class=\"function\">(<span class=\"params\">to,<span class=\"keyword\">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"准备进入路由模板\"</span>);</span><br><span class=\"line\">    next();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteLeave: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"准备离开路由模板\"</span>);</span><br><span class=\"line\">    next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这是我们写在params.vue模板里的路由钩子函数。它可以监控到路由的进入和路由的离开，也可以轻易的读出to和from的值。</p>\n<h3 id=\"十一、编程式导航\"><a href=\"#十一、编程式导航\" class=\"headerlink\" title=\"十一、编程式导航\"></a>十一、编程式导航</h3><p>这是这篇文章的最后一节，前10节的导航都是用<router-link>标签或者直接操作地址栏的形式完成的，那如果在业务逻辑代码中需要跳转页面我们如何操作？这就是我们要说的编程式导航，顾名思义，就是在业务逻辑代码中实现导航。</router-link></p>\n<p><strong> this.$router.go(-1) 和 this.$router.go(1) </strong></p>\n<p>这两个编程式导航的意思是后退和前进，功能跟我们浏览器上的后退和前进按钮一样，这在业务逻辑中经常用到。比如条件不满足时，我们需要后退。</p>\n<p>router.go(-1)代表着后退，我们可以让我们的导航进行后退，并且我们的地址栏也是有所变化的。</p>\n<p>1.我们先在app.vue文件里加入一个按钮，按钮并绑定一个goback( )方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"goback\"</span>&gt;</span>后退<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>2.在我们的script模块中写入goback()方法，并使用this.$router.go(-1),进行后退操作。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'app'</span>,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    goback()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$router.go(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>打开浏览器进行预览，这时我们的后退按钮就可以向以前的网页一样后退了。</p>\n<p>router.go(1):代表着前进，用法和后退一样，我在这里就不重复码字了。</p>\n<p>this.$router.push(‘/xxx ‘)</p>\n<p>这个编程式导航都作用就是跳转，比如我们判断用户名和密码正确时，需要跳转到用户中心页面或者首页，都用到这个编程的方法来操作路由。</p>\n<p>我们设置一个按钮，点击按钮后回到站点首页。</p>\n<p>1.先编写一个按钮，在按钮上绑定goHome( )方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"goHome\"</span>&gt;</span>回到首页<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>2.在&lt;script&gt;模块里加入goHome方法，并用this.$router.push(‘/’)导航到首页<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'app'</span>,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    goback()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$router.go(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    goHome()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjxfsbp440000hgq5mam9n8h1","category_id":"cjxfsbp4b0002hgq5pfywnjis","_id":"cjxfsbp4j000bhgq50md4zxau"},{"post_id":"cjxfsbp490001hgq59tu9glg6","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"cjxfsbp4q000ghgq507gi7149"},{"post_id":"cjxfsbp4i000ahgq58qd16amy","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"cjxfsbp4r000ihgq5t32k1ysj"},{"post_id":"cjxfsbp4d0004hgq51v2pm6fi","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"cjxfsbp4r000khgq509lwymsq"},{"post_id":"cjxfsbp4e0005hgq5kods3x24","category_id":"cjxfsbp4p000fhgq5nph4kfza","_id":"cjxfsbp4s000phgq54d70nnbi"},{"post_id":"cjxfsbp4h0009hgq569lsne3l","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"cjxftk8x1001qhgq5lq91zl9h"},{"post_id":"cjxfsbp4l000ehgq51qcgfn9h","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"cjxftkaxu001rhgq5dcpkkaze"},{"post_id":"cjypnrl860000ryq5u8w4tbwa","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"cjypnrl8h0002ryq5hbef84v4"},{"post_id":"ck2yl0qbf0000h6q6w8l3mao0","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qbz0006h6q624lu6igt"},{"post_id":"ck2yl0qbj0001h6q6tj3p6ktd","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qc00008h6q66oqie1v8"},{"post_id":"ck2yl0qbl0003h6q66qt9tom5","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qc3000ch6q6rccocuc7"},{"post_id":"ck2yl0qc00007h6q6tf470ta0","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qc5000gh6q6yu0t9znv"},{"post_id":"ck2yl0qc2000ah6q6mxz6ahdo","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qc6000kh6q6pr7lx11g"},{"post_id":"ck2yl0qc3000dh6q6c9o2jtc6","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qc7000nh6q6itux16bb"},{"post_id":"ck2yl0qby0005h6q6v1ybrp1z","category_id":"ck2yl0qc10009h6q6xk3j7f7f","_id":"ck2yl0qc9000rh6q661azbkcl"},{"post_id":"ck2yl0qc4000fh6q6d0n36ewm","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qca000uh6q6hod2341y"},{"post_id":"ck2yl0qc6000jh6q6ehkwz4vt","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qcb000yh6q6ahhtr3dm"},{"post_id":"ck2yl0qc7000mh6q683g7gwqa","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qcc0011h6q6od0f0lre"},{"post_id":"ck2yl0qc8000qh6q65uno84ka","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qcd0013h6q6488oheyv"},{"post_id":"ck2yl0qc9000th6q6m434kggm","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qce0016h6q6loc9929m"},{"post_id":"ck2yl0qcb000xh6q6a08qkhf5","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qce0018h6q6zouaq81l"},{"post_id":"ck2yl0qcc0010h6q6b67cdrs6","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck2yl0qcf001ah6q6hnbe4hnx"},{"post_id":"ck4249z8200004aq64yty071v","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck4249za300024aq6db5gtt0f"},{"post_id":"ck4249zag00044aq61xceapmh","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck4249zai00064aq6mtav3n2p"},{"post_id":"ck562y5rm0000khq6vxm5a885","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck562y5rx0004khq61105gvt2"},{"post_id":"ck562y5rs0001khq67re0qiol","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck562y5s20006khq67akdm7t8"},{"post_id":"ck562y5rw0002khq6orwd3ojh","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck562y5s30007khq6u6fcf7lg"},{"post_id":"ck8r6c15h0000imq6a8igkejv","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck8r6c1680006imq6nxdcvhe7"},{"post_id":"ck8r6c15o0001imq6ixxwvdn4","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck8r6c16a0009imq6pav7h4s5"},{"post_id":"ck8r6c15v0003imq6t36tasyi","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck8r6c16e000bimq62gfp3jit"},{"post_id":"ck8r6c1670005imq6456qnr4a","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck8r6c16f000dimq6xlnvlhnx"},{"post_id":"ck8r6c1690008imq6n38jg9m0","category_id":"cjxfsbp4g0007hgq5ql78yiyz","_id":"ck8r6c16l000eimq6bpc18hay"}],"PostTag":[{"post_id":"cjxfsbp440000hgq5mam9n8h1","tag_id":"cjxfsbp4c0003hgq56n8xempg","_id":"cjxfsbp4r000jhgq5w6e80nsi"},{"post_id":"cjxfsbp440000hgq5mam9n8h1","tag_id":"cjxfsbp4g0008hgq5h47l5ps7","_id":"cjxfsbp4r000lhgq5waz5lrp0"},{"post_id":"cjxfsbp440000hgq5mam9n8h1","tag_id":"cjxfsbp4j000dhgq51f2qj3nv","_id":"cjxfsbp4s000ohgq5uaq7r593"},{"post_id":"cjxfsbp490001hgq59tu9glg6","tag_id":"cjxfsbp4q000hhgq5wtst7eie","_id":"cjxfsbp4t000vhgq5v13a4pxb"},{"post_id":"cjxfsbp490001hgq59tu9glg6","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"cjxfsbp4t000whgq57qvfw8z8"},{"post_id":"cjxfsbp490001hgq59tu9glg6","tag_id":"cjxfsbp4s000qhgq5nobvh4v0","_id":"cjxfsbp4u000yhgq5jn6703ss"},{"post_id":"cjxfsbp490001hgq59tu9glg6","tag_id":"cjxfsbp4s000shgq528i9ohle","_id":"cjxfsbp4u000zhgq5q0ge84m3"},{"post_id":"cjxfsbp490001hgq59tu9glg6","tag_id":"cjxfsbp4t000thgq5pl5ps5n0","_id":"cjxfsbp4u0011hgq58uyqaqwj"},{"post_id":"cjxfsbp4d0004hgq51v2pm6fi","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"cjxfsbp4u0012hgq5wmad7obb"},{"post_id":"cjxfsbp4e0005hgq5kods3x24","tag_id":"cjxfsbp4t000xhgq5a3xsjupx","_id":"cjxfsbp4v0016hgq5586td8vw"},{"post_id":"cjxfsbp4e0005hgq5kods3x24","tag_id":"cjxfsbp4u0010hgq5uyqr73c8","_id":"cjxfsbp4v0017hgq53ic9c8w3"},{"post_id":"cjxfsbp4e0005hgq5kods3x24","tag_id":"cjxfsbp4u0013hgq5ujfknc1p","_id":"cjxfsbp4w0019hgq5crne81r7"},{"post_id":"cjxfsbp4e0005hgq5kods3x24","tag_id":"cjxfsbp4v0014hgq5yfnm0wmh","_id":"cjxfsbp4w001ahgq5q2yub8w5"},{"post_id":"cjxfsbp4i000ahgq58qd16amy","tag_id":"cjxfsbp4v0018hgq5ur2xxhcr","_id":"cjxfsbp4w001dhgq5vv1h8lg6"},{"post_id":"cjxfsbp4i000ahgq58qd16amy","tag_id":"cjxfsbp4s000qhgq5nobvh4v0","_id":"cjxfsbp4x001ehgq5be1kd568"},{"post_id":"cjxfsbp4l000ehgq51qcgfn9h","tag_id":"cjxfsbp4s000shgq528i9ohle","_id":"cjxfsrawg001ihgq5l96zswt3"},{"post_id":"cjxfsbp4l000ehgq51qcgfn9h","tag_id":"cjxfsrawf001hhgq5luoqz5cc","_id":"cjxfsrawg001jhgq59n266pvo"},{"post_id":"cjxfsbp4h0009hgq569lsne3l","tag_id":"cjxfsbp4v0015hgq5rhvdcgkr","_id":"cjxftihqh001nhgq5np8957rv"},{"post_id":"cjxfsbp4h0009hgq569lsne3l","tag_id":"cjxftihqh001mhgq5inrloq3a","_id":"cjxftihqi001ohgq5i8t1voac"},{"post_id":"cjypnrl860000ryq5u8w4tbwa","tag_id":"cjypnrl8b0001ryq57fm9rfhw","_id":"cjypnrl8i0004ryq548kmo2xo"},{"post_id":"cjypnrl860000ryq5u8w4tbwa","tag_id":"cjypnrl8h0003ryq5cbbifosn","_id":"cjypnrl8i0005ryq5rxjbzk62"},{"post_id":"ck2yl0qbf0000h6q6w8l3mao0","tag_id":"cjxfsbp4v0015hgq5rhvdcgkr","_id":"ck2yl0qbl0002h6q6ua6sxp0l"},{"post_id":"ck2yl0qc2000ah6q6mxz6ahdo","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck2yl0qc4000eh6q66yqiasua"},{"post_id":"ck2yl0qc3000dh6q6c9o2jtc6","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck2yl0qc6000ih6q6tctdlne7"},{"post_id":"ck2yl0qbj0001h6q6tj3p6ktd","tag_id":"ck2yl0qbm0004h6q61bhfj4v1","_id":"ck2yl0qc7000lh6q6if8awaak"},{"post_id":"ck2yl0qbj0001h6q6tj3p6ktd","tag_id":"ck2yl0qc2000bh6q6l711l18k","_id":"ck2yl0qc8000ph6q6am0qsqy7"},{"post_id":"ck2yl0qbj0001h6q6tj3p6ktd","tag_id":"cjxfsbp4t000thgq5pl5ps5n0","_id":"ck2yl0qc9000sh6q692xa9sdi"},{"post_id":"ck2yl0qc4000fh6q6d0n36ewm","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck2yl0qca000vh6q6yexpysnz"},{"post_id":"ck2yl0qbl0003h6q66qt9tom5","tag_id":"ck2yl0qc5000hh6q618t2rcs5","_id":"ck2yl0qcc000zh6q6pm8myja9"},{"post_id":"ck2yl0qc7000mh6q683g7gwqa","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck2yl0qcd0012h6q64mf47ffv"},{"post_id":"ck2yl0qc8000qh6q65uno84ka","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck2yl0qce0015h6q6pfzm7oy7"},{"post_id":"ck2yl0qc9000th6q6m434kggm","tag_id":"ck2yl0qc5000hh6q618t2rcs5","_id":"ck2yl0qce0017h6q6xih3vb84"},{"post_id":"ck2yl0qby0005h6q6v1ybrp1z","tag_id":"ck2yl0qc8000oh6q629rsqwez","_id":"ck2yl0qcf001bh6q6byhev8ih"},{"post_id":"ck2yl0qby0005h6q6v1ybrp1z","tag_id":"ck2yl0qca000wh6q65u3hrd7y","_id":"ck2yl0qcf001ch6q612zqls7d"},{"post_id":"ck2yl0qby0005h6q6v1ybrp1z","tag_id":"ck2yl0qcd0014h6q69lq9r403","_id":"ck2yl0qcf001eh6q64mmchnh5"},{"post_id":"ck2yl0qc00007h6q6tf470ta0","tag_id":"ck2yl0qce0019h6q6cl56a0n6","_id":"ck2yl0qcf001fh6q6a29uo24q"},{"post_id":"ck2yl0qc00007h6q6tf470ta0","tag_id":"cjxfsbp4s000qhgq5nobvh4v0","_id":"ck2yl0qcg001hh6q639rkdlob"},{"post_id":"ck2yl0qc00007h6q6tf470ta0","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck2yl0qcg001ih6q6tzrpq9z8"},{"post_id":"ck2yl0qc6000jh6q6ehkwz4vt","tag_id":"ck2yl0qcf001dh6q6n2f64rik","_id":"ck2yl0qcg001kh6q66n4cyn6q"},{"post_id":"ck2yl0qc6000jh6q6ehkwz4vt","tag_id":"cjxfsbp4s000qhgq5nobvh4v0","_id":"ck2yl0qcg001lh6q6y5w0pby2"},{"post_id":"ck2yl0qc6000jh6q6ehkwz4vt","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck2yl0qch001mh6q613hcrqlp"},{"post_id":"ck2yl0qcb000xh6q6a08qkhf5","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck2yl0qch001nh6q6pytfkpnw"},{"post_id":"ck2yl0qcb000xh6q6a08qkhf5","tag_id":"cjxfsbp4t000thgq5pl5ps5n0","_id":"ck2yl0qch001oh6q67rhampdf"},{"post_id":"ck2yl0qcb000xh6q6a08qkhf5","tag_id":"ck2yl0qcf001gh6q6ik4105ou","_id":"ck2yl0qch001ph6q6opk6h213"},{"post_id":"ck2yl0qcc0010h6q6b67cdrs6","tag_id":"ck2yl0qcg001jh6q6e5jl0ra3","_id":"ck2yl0qch001qh6q6bwo9s6j7"},{"post_id":"ck4249z8200004aq64yty071v","tag_id":"ck4249z9v00014aq6qqw97d2u","_id":"ck4249za400034aq6hjyku4bx"},{"post_id":"ck4249zag00044aq61xceapmh","tag_id":"ck4249zai00054aq68txe31rz","_id":"ck4249zai00074aq6ijcqh53z"},{"post_id":"ck562y5rs0001khq67re0qiol","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck562y5rx0003khq6mypi3uyb"},{"post_id":"ck562y5rw0002khq6orwd3ojh","tag_id":"ck562y5ry0005khq60kcsgcq5","_id":"ck562y5s30008khq6ers9apde"},{"post_id":"ck8r6c15h0000imq6a8igkejv","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck8r6c15u0002imq66hy9ie86"},{"post_id":"ck8r6c15v0003imq6t36tasyi","tag_id":"cjxfsbp4s000nhgq53t32dh2u","_id":"ck8r6c1690007imq6n8qjo4oe"},{"post_id":"ck8r6c15o0001imq6ixxwvdn4","tag_id":"ck8r6c15x0004imq603t1hkkx","_id":"ck8r6c16f000cimq64trvugnr"},{"post_id":"ck8r6c1670005imq6456qnr4a","tag_id":"ck8r6c16b000aimq6pc7kil2o","_id":"ck8r6c16m000gimq6p8ecw2xk"},{"post_id":"ck8r6c1690008imq6n38jg9m0","tag_id":"ck8r6c16l000fimq6dzq58dof","_id":"ck8r6c16m000himq6rhe4qt4c"}],"Tag":[{"name":"java","_id":"cjxfsbp4c0003hgq56n8xempg"},{"name":"avtiviti","_id":"cjxfsbp4g0008hgq5h47l5ps7"},{"name":"工作流","_id":"cjxfsbp4j000dhgq51f2qj3nv"},{"name":"hexo","_id":"cjxfsbp4q000hhgq5wtst7eie"},{"name":"js","_id":"cjxfsbp4s000nhgq53t32dh2u"},{"name":"html","_id":"cjxfsbp4s000qhgq5nobvh4v0"},{"name":"css","_id":"cjxfsbp4s000shgq528i9ohle"},{"name":"node","_id":"cjxfsbp4t000thgq5pl5ps5n0"},{"name":"asterrisk","_id":"cjxfsbp4t000xhgq5a3xsjupx"},{"name":"语音","_id":"cjxfsbp4u0010hgq5uyqr73c8"},{"name":"通信","_id":"cjxfsbp4u0013hgq5ujfknc1p"},{"name":"C语言","_id":"cjxfsbp4v0014hgq5yfnm0wmh"},{"name":"react","_id":"cjxfsbp4v0015hgq5rhvdcgkr"},{"name":"markdown","_id":"cjxfsbp4v0018hgq5ur2xxhcr"},{"name":"动画","_id":"cjxfsrawf001hhgq5luoqz5cc"},{"name":"antd","_id":"cjxftihqh001mhgq5inrloq3a"},{"name":"sass","_id":"cjypnrl8b0001ryq57fm9rfhw"},{"name":"compass","_id":"cjypnrl8h0003ryq5cbbifosn"},{"name":"npm","_id":"ck2yl0qbm0004h6q61bhfj4v1"},{"name":"web","_id":"ck2yl0qc2000bh6q6l711l18k"},{"name":"es6","_id":"ck2yl0qc5000hh6q618t2rcs5"},{"name":"flutter","_id":"ck2yl0qc8000oh6q629rsqwez"},{"name":"app","_id":"ck2yl0qca000wh6q65u3hrd7y"},{"name":"跨平台","_id":"ck2yl0qcd0014h6q69lq9r403"},{"name":"svg","_id":"ck2yl0qce0019h6q6cl56a0n6"},{"name":"jsdoc","_id":"ck2yl0qcf001dh6q6n2f64rik"},{"name":"mongodb","_id":"ck2yl0qcf001gh6q6ik4105ou"},{"name":"vue","_id":"ck2yl0qcg001jh6q6e5jl0ra3"},{"name":"react hooks","_id":"ck4249z9v00014aq6qqw97d2u"},{"name":"vue vuex","_id":"ck4249zai00054aq68txe31rz"},{"name":"websocket","_id":"ck562y5ry0005khq60kcsgcq5"},{"name":"react hoc html js","_id":"ck8r6c15x0004imq603t1hkkx"},{"name":"vue-cli vue","_id":"ck8r6c16b000aimq6pc7kil2o"},{"name":"vue-router vue","_id":"ck8r6c16l000fimq6dzq58dof"}]}}