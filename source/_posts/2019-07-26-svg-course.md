---
title: SVG入门介绍
comments: true
date: 2019-07-26 11:21:54
tags:
- svg
- html
- js
categories:
- WEB前端
author: jun.zhou
---

# SVG入门介绍

![SVG](https://img.fengjr.com/image/2019/07/25/2c9c7fc330d25bde7ca74245c3bc5669.png)
## SVG的简介

> SVG（英文：Scalable Vector Graphics）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式，SVG由W3C制定，是一个开放标准。

SVG推出于1999年，由一组加入W3C的公司启动开发，与之前1998年提交给W3C的标准（PGML、VML）构成竞争。SVG从这两个格式吸取了经验。

SVG允许3种图形对象类型：矢量图形、栅格图像以及文本。

### 优点
- 图像文件可读，易于修改和编辑（理论上如此，但实际上却是因为各种不同的SVG档编辑器而可能存储成不易解读的SVG文件）
- 与现有技术可以互动融合。例如，SVG技术本身的动态部分（包括时序控制和动画）就是基于SMIL标准。另外，SVG文件还可嵌入JavaScript（严格地说，应该是ECMAScript）脚本来控制SVG对象
- SVG图形格式可以方便的创建文字索引，从而实现基于内容的图像搜索
- SVG图形格式支持多种滤镜和特殊效果，在不改变图像内容的前提下可以实现位图格式中类似文字阴影的效果。
- SVG图形格式可以用来动态生成图形。例如，可用SVG动态生成具有交互功能的地图，嵌入网页中，并显示给终端用户。

### 缺点

- 由于原始的SVG档是遵从XML语法，导致数据采用未压缩的方式存放，因此相较于其他的矢量图形格式，同样的文件内容会比其他的文件格式稍大。Adobe因此使用gzip压缩开发出压缩的SVG档格式，附文件名为 .svgz， 但此种文件格式除了Adobe旗下的软件以外，未被广泛支持使用。
- 旧版的SVG Viewer无法正确显示出使用新版SVG格式的矢量图形。
- 只能做2维图形，没法做动画

## SVG的语法

目前所有的浏览器都支持SVG，但各浏览器是有差异的，因此很可能你制作了一个SVG，并且用一个工具调试正常后，却在另一个浏览器种无法显示，这是因为不同的浏览器支持的SVG标准的程度不同。

使用SVG，你需要掌握，有几个重点要记住：

- SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同）
- SVG里的属性值必须用引号引起来，就算是数值也必须这样做。

### SVG的标签

svg的代码都放在顶层标签`<svg>`中，下面是一个例子

```HTMl
<svg version="1.1"
     baseProfile="full"
     width="300" height="300"
     viewBox="50 50 50 50"
     xmlns="http://www.w3.org/2000/svg">
  <circle id="mycircle" cx="50" cy="50" r="50" />
</svg>
```

**width**：SVG图形占据页面的宽度，除了相对单位，也可以使用绝对单位，不指定默认为 300px。

**height**：SVG图形占据页面的高度，除了相对单位，也可以使用绝对单位，不指定默认为 150px。

[**baseProfile**](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/baseProfile)：特性描述了作者认为正确渲染内容所需要的最小的 SVG 语言概述。这个特性不会说明任何处理限制，可以把它看作是元数据。 比如，这个特性的值可以被编辑工具用来在用户的修改超出所指定的基准概述范围时发出警告。

**version**：该version属性用于指示SVG文档符合的规范。它只允许在根`<svg>`元素上。它纯粹是建议性的，对渲染或处理没有影响，只有两个有效的选择是当前`1.0`和`1.1`。

**xmlns**：表明`<svg>`标签和它的字标签都属于 http://www.w3.org/2000/svg 这个命名空间，这个声明只需要在根结点声明一次即可，命名空间仅仅是一些字符串，并不是链接到某一个地址。

**viewBox**：属性的值有四个数字，分别是左上角的横坐标和纵坐标、视口的宽度和高度。上面代码中，SVG 图像是150像素宽 x 50像素高，viewBox属性指定视口从(50, 50)这个点开始。所以，实际看到的是右下角的部分，视口必须适配所在的空间，上面代码中，视口大小是50 * 50，SVG图像是300 * 300，所以视口会去适配SVG的大小，意味着放大了6倍。

下面我依次介绍一下SVG中几种基本图形的用法：

### 矩形

**rect**元素可以在屏幕上绘制一个矩形，只需要六个基本属性就可以控制它在屏幕上的位置和形状。

```HTML
<rect x="60" y="10" rx="10" ry="10" width="30" height="30"/>
```

**x**：矩形左上角的X位置

**y**：矩形左上角的Y位置

**width**：矩形的宽度

**height**：矩形的高度

**rx**：圆角X方位的半径

**ry**：圆角Y方位的半径

### 圆形

**circle**元素可以在屏幕上绘制一个圆形，只需要三个基本属就可以设置圆形。

```HTML
<circle cx="25" cy="75" r="20"/>
```

**cx**：圆心X的位置

**cy**：圆心Y的位置

**r**：圆的半径

### 椭圆

ellipse 是circle元素更通用的形式，可以缩放圆的X半径和Y半径

```HTML
<ellipse cx="75" cy="75" rx="20" ry="5"/>
```
**rx**：椭圆的X半径

**ry**：椭圆的Y半径

**cx**：椭圆中心的X位置

**cy**：椭圆中心的Y位置

### 直线

line 是用来绘制直线的，它取两个点的位置作为属性，指定这条线的起点和终点的位置。

```HTML
<line x1="10" x2="50" y1="110" y2="150"/>
```
**x1**：起点的X位置

**y1**：起点的Y位置

**x2**：终点的X位置

**y2**：终点的Y位置

### 折线

polyline 是一组连接在一起的直线，因为它可以有很多的点，折线的所有点位置都放在一个points属性中：

```HTMl
<polyline points="60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145"/>
```

**points**：点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。

### 多边形

polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形

```HTMl
    <polygon points="50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180"/>
```

**points**：点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。

### 路径

path可能是SVG中最常见的形状。你可以用path元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形，以及一些其他的形状，例如贝塞尔曲线、2次曲线等曲线。


```HTML
<path d="M 20 230 Q 40 205, 50 230 T 90 230"/>
```

**d**：一个点集数列以及其它关于如何绘制路径的信息。

由于path非常强大也非常的复杂，接下来我们重点学习一下path。

path命令有两种表达方式：
- 大写字母：表示采用绝对定位
- 小写字母：表示采用相对定位，（例如，从上一个点的位置，向上移动10px等）

#### 直线命令

`<path>`元素里有5个画直线的命令，顾名思义，直线命令就是在两个点之间画直线。首先是“Move to”命令，M，它需要两个参数，分别是需要移动到的点的x轴和y轴的坐标。假设，你的画笔当前位于一个点，在使用M命令移动画笔后，只会移动画笔，但不会在两点之间画线。因为M命令仅仅是移动画笔，但不画线。所以M命令经常出现在路径的开始处，用来指明从何处开始画。

##### M

```
M x y
```

```
m dx dy
```

能够真正画线的命令有三个

##### L

L 表示的是 line to，有两个参数x和y，分别表示下一个点的x轴和y轴坐标，L将会在当前位置和新位置之间画一条线段

```
L x y (or l dx dy)
```

##### H
H 表示绘制水平线，只有一个参数x，表示移动到x轴上该点位置的水平线。

```
H x (or h dx)
```

##### V
V 表示绘制垂直线，只有一个参数y，表示移动到y轴上该点位置的垂直线。

```
V y (or v dy)
```

##### Z

Z表示一个闭合路径的命令，会从当前点画一条直线到起点，经常放在路径的最后，Z命令不区分大小写。


```
Z（or z）
```

下面为总结的一个例子：

```HTML
<path d="M10 10 L 90 10 V 90 H 10 Z" fill="transparent" stroke="black" stroke-width="5"  />
```

#### 曲线命令

SVG绘制平滑曲线的命令有三个，两个用来绘制贝塞尔曲线，另外一个用来绘制弧形或者说圆的一部分。

##### 贝塞尔曲线

我们从稍微复杂一点的三次贝塞尔曲线C入手，三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数：


```
C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)
```

这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。如果你熟悉代数或者微积分的话，会更容易理解控制点，控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程。

![image](https://img.fengjr.com/image/2019/07/25/a74c83f52a7b4be5ebe036b6a3e7a2bd.png)


你可以将若干个贝塞尔曲线连起来，从而创建出一条很长的平滑曲线。通常情况下，一个点某一侧的控制点是它另一侧的控制点的对称（以保持斜率不变）。这样，你可以使用一个简写的贝塞尔曲线命令S，如下所示：

```
S x2 y2, x y (or s dx2 dy2, dx dy)
```

S命令可以用来创建与前面一样的贝塞尔曲线，但是，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或S命令，那当前点将作为第一个控制点。


另一种可用的贝塞尔曲线是二次贝塞尔曲线Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。


```
Q x1 y1, x y (or q dx1 dy1, dx dy)
```
![image](https://img.fengjr.com/image/2019/07/25/5be989240c91dc86dc13102e23ced681.png)

就像三次贝塞尔曲线有一个S命令，二次贝塞尔曲线有一个差不多的T命令，可以通过更简短的参数，延长二次贝塞尔曲线。


```
T x y (or t dx dy)
```

和之前一样，快捷命令T会通过前一个控制点，推断出一个新的控制点。这意味着，在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。

##### 弧形

弧形命令A是另一个创建SVG曲线的命令。基本上，弧形可以视为圆形或椭圆形的一部分。假设，已知椭圆形的长轴半径和短轴半径，并且已知两个点（在椭圆上），根据半径和两点，可以画出两个椭圆，在每个椭圆上根据两点都可以画出两种弧形。所以，仅仅根据半径和两点，可以画出四种弧形。为了保证创建的弧形唯一，A命令需要用到比较多的参数：


```
A rx ry x-axis-rotation large-arc-flag sweep-flag x y
a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy
```

**rx**：椭圆弧的x轴半径
**ry**：椭圆弧的y轴半径
**x-axis-rotation**：椭圆弧的旋转角度
**large-arc-flag**：椭圆弧的角度大小，决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。
**sweep-flag**：椭圆弧的弧线方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧
**x**：椭圆弧的终点x坐标
**y**：椭圆弧终点y坐标

示例图片：

![image](https://img.fengjr.com/image/2019/07/26/2c526c035064a6ad18f39fb5a0f875ee.png)

代码：

```HTML
<svg width="325px" height="325px" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M80 80
           A 45 45, 0, 0, 0, 125 125
           L 125 80 Z" fill="green"/>
  <path d="M230 80
           A 45 45, 0, 1, 0, 275 125
           L 275 80 Z" fill="red"/>
  <path d="M80 230
           A 45 45, 0, 0, 1, 125 275
           L 125 230 Z" fill="purple"/>
  <path d="M230 230
           A 45 45, 0, 1, 1, 275 275
           L 275 230 Z" fill="blue"/>
</svg>
```

## SVG的属性

上面的例子我们可以看到，标签中很多写了fill和stroke属性的，这些是什么意思呢？

### fill

fill 属性设置对象内部的颜色，还有一个fill-opacity可以控制填充色的不透明度，浏览器也支持rgba属性来设置同样效果，但是有些浏览器不支持。

### stroke

除了颜色属性，stroke可以进行描边，stroke有以下几个属性：

**stroke**：用来设置边框的颜色

**stroke-width**：用来设置边框的宽度，描边是以路径为中心绘制的。

**stroke-linecap**：用来绘制边框终点的形状，它有三个值：

- `butt`用直边结束线段，它是常规做法，线段边界90度垂直于描边的方向、贯穿它的终点。
- `square`的效果差不多，但是会稍微超出实际路径的范围，超出的大小由stroke-width控制。
- `round`表示边框的终点是圆角，圆角的半径也是由stroke-width控制的。用直线结束线段

![image](https://img.fengjr.com/image/2019/07/26/24c5fd2f693d1b91746dd7ba1c5ad0b7.png)


**stroke-linejoin**：用来控制两条描边线段之间用什么方式连接。它有
三个值：
- `miter` 默认值，表示用方形画笔在连接出形成尖角。
- `round` 表示用圆角连接，实现平滑效果。
- `bevel` 连接处会形成一个斜接。

![image](https://img.fengjr.com/image/2019/07/26/7f6908d0b8cb0b4c8c1d5809e8f5d80a.png)

**stroke-dasharray**：可以将虚线应用在描边上。


```HTML
<svg width="200" height="150" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <path d="M 10 75 Q 50 10 100 75 T 190 75" stroke="black"
    stroke-linecap="round" stroke-dasharray="5,10,5" fill="none"/>
  <path d="M 10 75 L 190 75" stroke="red"
    stroke-linecap="round" stroke-width="1" stroke-dasharray="5,5" fill="none"/>
</svg>
```

stroke-dasharray属性的参数，是一组用逗号分割的数字组成的数列。注意，和path不一样，这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度。所以在上面的例子里，第二个路径会先做5个像素单位的填色，紧接着是5个空白单位，然后又是5个单位的填色。如果你想要更复杂的虚线模式，你可以定义更多的数字。第一个例子指定了3个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染5个填色单位，10个空白单位，5个填色单位，然后回头以这3个数字做一次循环，但是这次是创建5个空白单位，10个填色单位，5个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复。

**fill-rule**：可以将虚线应用在描边于定义如何给图形重叠的区域上色。

**stroke-dashoffset**：定义虚线开始的位置。
